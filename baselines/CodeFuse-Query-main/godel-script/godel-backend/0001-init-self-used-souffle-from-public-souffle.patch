From 5ef4e439424421214071cf8b9bb5b413534fe582 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=81=95=E5=B1=B1?= <lihaokun.lhk@antgroup.com>
Date: Fri, 13 Dec 2024 18:02:01 +0800
Subject: [PATCH] init self used souffle from public souffle

---
 CMakeLists.txt                                |   29 +-
 README.md                                     |    6 +-
 choco-packages.config                         |    5 +-
 cmake/SouffleTests.cmake                      |   54 +-
 cmake/common.py                               |    1 -
 cmake/redirect.py                             |    4 -
 debian/changelog                              |   33 -
 debian/souffle.bash-completion                |    2 +-
 sh/checkStyle.sh                              |    4 +-
 sh/check_os.sh                                |    2 +-
 src/CMakeLists.txt                            |  104 +-
 src/DynamicLibrary.cpp                        |   84 +
 src/ExtraConfig.h                             |   36 +
 src/FunctorOps.cpp                            |    4 -
 src/FunctorOps.h                              |    5 -
 src/Global.cpp                                |    6 +-
 src/Global.h                                  |   11 +-
 src/GraphUtils.h                              |   76 +-
 src/LogStatement.h                            |   31 +-
 src/MainEntry.cpp                             |   17 +
 src/RelationTag.h                             |    2 +
 src/TranslationUnitBase.h                     |   22 +-
 src/ast/Aggregator.cpp                        |   29 +-
 src/ast/Aggregator.h                          |   27 +-
 src/ast/AlgebraicDataType.cpp                 |    7 +-
 src/ast/AlgebraicDataType.h                   |    2 -
 src/ast/AliasType.cpp                         |    6 +-
 src/ast/AliasType.h                           |    2 -
 src/ast/Argument.h                            |    5 -
 src/ast/Atom.cpp                              |    7 +-
 src/ast/Atom.h                                |    2 -
 src/ast/Attribute.cpp                         |   22 +-
 src/ast/Attribute.h                           |    8 -
 src/ast/BinaryConstraint.cpp                  |    7 +-
 src/ast/BinaryConstraint.h                    |    2 -
 src/ast/BooleanConstraint.cpp                 |    6 +-
 src/ast/BooleanConstraint.h                   |    2 -
 src/ast/BranchInit.cpp                        |    5 +-
 src/ast/BranchInit.h                          |    2 -
 src/ast/BranchType.cpp                        |   11 +-
 src/ast/BranchType.h                          |    4 -
 src/ast/Clause.cpp                            |   27 +-
 src/ast/Clause.h                              |    8 -
 src/ast/Component.cpp                         |   19 -
 src/ast/Component.h                           |   40 +-
 src/ast/ComponentInit.cpp                     |    9 +-
 src/ast/ComponentInit.h                       |    2 -
 src/ast/ComponentType.cpp                     |    6 +-
 src/ast/ComponentType.h                       |    2 -
 src/ast/Constant.cpp                          |   11 +-
 src/ast/Constant.h                            |    4 +-
 src/ast/Constraint.h                          |    9 -
 src/ast/Counter.cpp                           |   10 -
 src/ast/Counter.h                             |    6 -
 src/ast/Directive.cpp                         |    7 +-
 src/ast/Directive.h                           |    2 -
 src/ast/ExecutionOrder.cpp                    |    6 +-
 src/ast/ExecutionOrder.h                      |    2 -
 src/ast/ExecutionPlan.cpp                     |    7 -
 src/ast/ExecutionPlan.h                       |    4 -
 src/ast/FunctionalConstraint.cpp              |    9 +-
 src/ast/FunctionalConstraint.h                |    2 -
 src/ast/Functor.h                             |    6 -
 src/ast/FunctorDeclaration.cpp                |   13 +-
 src/ast/FunctorDeclaration.h                  |    2 -
 src/ast/IntrinsicFunctor.cpp                  |    6 +-
 src/ast/IntrinsicFunctor.h                    |    7 +-
 src/ast/Literal.h                             |    9 -
 src/ast/Negation.cpp                          |    7 +-
 src/ast/Negation.h                            |    2 -
 src/ast/NilConstant.cpp                       |    6 +-
 src/ast/NilConstant.h                         |    2 -
 src/ast/Node.cpp                              |  194 +-
 src/ast/Node.h                                |  191 +-
 src/ast/NumericConstant.cpp                   |   11 +-
 src/ast/NumericConstant.h                     |    2 -
 src/ast/Pragma.cpp                            |    6 +-
 src/ast/Pragma.h                              |    2 -
 src/ast/Program.cpp                           |   52 +-
 src/ast/Program.h                             |   61 +-
 src/ast/QualifiedName.cpp                     |  156 +-
 src/ast/QualifiedName.h                       |  136 +-
 src/ast/RecordInit.cpp                        |    7 +-
 src/ast/RecordInit.h                          |    2 -
 src/ast/RecordType.cpp                        |    7 +-
 src/ast/RecordType.h                          |    2 -
 src/ast/Relation.cpp                          |   20 +-
 src/ast/Relation.h                            |   50 +-
 src/ast/StringConstant.cpp                    |    6 +-
 src/ast/StringConstant.h                      |    3 -
 src/ast/SubsetType.cpp                        |    7 +-
 src/ast/SubsetType.h                          |    2 -
 src/ast/SubsumptiveClause.cpp                 |   12 +-
 src/ast/SubsumptiveClause.h                   |    2 -
 src/ast/Term.cpp                              |    9 +-
 src/ast/Term.h                                |   15 +-
 src/ast/TranslationUnit.cpp                   |    8 +-
 src/ast/TranslationUnit.h                     |    3 +-
 src/ast/Type.cpp                              |   10 +-
 src/ast/Type.h                                |    4 +-
 src/ast/TypeCast.cpp                          |    7 +-
 src/ast/TypeCast.h                            |    2 -
 src/ast/UnionType.cpp                         |    7 +-
 src/ast/UnionType.h                           |    2 -
 src/ast/UnnamedVariable.cpp                   |   10 -
 src/ast/UnnamedVariable.h                     |    6 -
 src/ast/UserDefinedFunctor.cpp                |    9 +-
 src/ast/UserDefinedFunctor.h                  |    2 -
 src/ast/Variable.cpp                          |    8 +-
 src/ast/Variable.h                            |    2 -
 src/ast/analysis/Aggregate.cpp                |   12 +-
 src/ast/analysis/ClauseNormalisation.cpp      |   11 +-
 src/ast/analysis/ComponentLookup.cpp          |    6 +-
 src/ast/analysis/ComponentLookup.h            |    2 +-
 src/ast/analysis/Constraint.h                 |   37 +-
 src/ast/analysis/ConstraintSystem.h           |   50 +-
 src/ast/analysis/Functor.cpp                  |   10 -
 src/ast/analysis/Functor.h                    |    3 -
 src/ast/analysis/Ground.cpp                   |   35 +-
 src/ast/analysis/Ground.h                     |    3 +-
 src/ast/analysis/IOType.h                     |    8 +-
 src/ast/analysis/PrecedenceGraph.cpp          |    8 -
 src/ast/analysis/PrecedenceGraph.h            |   12 +-
 src/ast/analysis/ProfileUse.cpp               |   15 +-
 src/ast/analysis/ProfileUse.h                 |    4 +-
 src/ast/analysis/RecursiveClauses.cpp         |   99 +-
 src/ast/analysis/RecursiveClauses.h           |    3 +
 src/ast/analysis/RedundantRelations.cpp       |    4 +-
 src/ast/analysis/RedundantRelations.h         |    4 +-
 src/ast/analysis/RelationSchedule.cpp         |   50 +-
 src/ast/analysis/RelationSchedule.h           |   18 +-
 src/ast/analysis/SCCGraph.cpp                 |    3 +-
 src/ast/analysis/SCCGraph.h                   |   39 +-
 .../analysis/TopologicallySortedSCCGraph.cpp  |  140 +-
 .../analysis/TopologicallySortedSCCGraph.h    |   29 +-
 src/ast/analysis/UniqueKeys.cpp               |  581 ++++++
 src/ast/analysis/UniqueKeys.h                 |   79 +
 .../typesystem/PolymorphicObjects.cpp         |    2 +-
 .../analysis/typesystem/PolymorphicObjects.h  |    4 +-
 src/ast/analysis/typesystem/SumTypeBranches.h |    2 +-
 src/ast/analysis/typesystem/Type.cpp          |   82 +-
 src/ast/analysis/typesystem/Type.h            |   31 +-
 .../typesystem/TypeConstrainsAnalysis.cpp     |   24 +-
 .../typesystem/TypeConstrainsAnalysis.h       |    4 +-
 .../analysis/typesystem/TypeConstraints.cpp   |    8 -
 src/ast/analysis/typesystem/TypeConstraints.h |    9 -
 .../analysis/typesystem/TypeEnvironment.cpp   |   26 +-
 src/ast/analysis/typesystem/TypeEnvironment.h |    8 +-
 src/ast/analysis/typesystem/TypeSystem.cpp    |   18 +-
 src/ast/analysis/typesystem/TypeSystem.h      |  107 +-
 src/ast/tests/CMakeLists.txt                  |    1 -
 src/ast/tests/ast_print_test.cpp              |   35 +-
 src/ast/tests/ast_program_test.cpp            |   54 +-
 src/ast/tests/ast_transformers_test.cpp       |   98 +-
 src/ast/tests/ast_utils_test.cpp              |   44 +-
 src/ast/tests/type_system_test.cpp            |   80 +-
 .../AddNullariesToAtomlessAggregates.cpp      |    5 +-
 src/ast/transform/ComponentChecker.cpp        |    9 +-
 src/ast/transform/ComponentInstantiation.cpp  |   66 +-
 src/ast/transform/DebugReporter.cpp           |   13 +-
 src/ast/transform/ExecutionPlanChecker.cpp    |   21 +-
 src/ast/transform/IOAttributes.h              |    4 +-
 src/ast/transform/IODefaults.h                |   15 +-
 src/ast/transform/InlineRelations.cpp         |   59 +-
 src/ast/transform/InlineRelations.h           |    4 +-
 src/ast/transform/MagicSet.cpp                |   80 +-
 src/ast/transform/MagicSet.h                  |   25 +-
 .../MaterializeAggregationQueries.cpp         |   74 +-
 .../MaterializeSingletonAggregation.cpp       |    4 +-
 src/ast/transform/Meta.cpp                    |   10 +-
 src/ast/transform/MinimiseProgram.cpp         |    2 +-
 src/ast/transform/PartitionBodyLiterals.cpp   |    4 +-
 src/ast/transform/PragmaChecker.cpp           |   11 +-
 src/ast/transform/PragmaChecker.h             |    5 +-
 src/ast/transform/ReduceExistentials.cpp      |   22 +-
 src/ast/transform/RemoveEmptyRelations.cpp    |    5 +-
 src/ast/transform/RemoveRedundantSums.cpp     |    6 +-
 src/ast/transform/RemoveRelationCopies.cpp    |    6 +-
 src/ast/transform/ResolveAliases.cpp          |   31 +-
 src/ast/transform/SemanticChecker.cpp         |  325 +--
 .../SimplifyAggregateTargetExpression.cpp     |    8 +-
 src/ast/transform/TypeChecker.cpp             |   39 +-
 src/ast/utility/BindingStore.cpp              |    1 +
 src/ast/utility/SipsMetric.cpp                |  797 ++++++++
 src/ast/utility/SipsMetric.h                  |  221 ++
 src/ast/utility/Utils.cpp                     |    6 +-
 src/ast/utility/Utils.h                       |    6 +-
 src/ast/utility/Visitor.h                     |   12 +-
 src/ast2ram/ClauseTranslator.h                |    7 +-
 src/ast2ram/provenance/ClauseTranslator.cpp   |    2 +-
 src/ast2ram/provenance/UnitTranslator.cpp     |   38 +-
 src/ast2ram/provenance/UnitTranslator.h       |    4 +-
 src/ast2ram/seminaive/ClauseTranslator.cpp    |  196 +-
 src/ast2ram/seminaive/ClauseTranslator.h      |    4 +-
 src/ast2ram/seminaive/UnitTranslator.cpp      |  404 +---
 src/ast2ram/seminaive/UnitTranslator.h        |   39 +-
 src/ast2ram/seminaive/ValueTranslator.cpp     |    6 -
 src/ast2ram/seminaive/ValueTranslator.h       |    2 -
 src/ast2ram/utility/TranslatorContext.cpp     |  119 +-
 src/ast2ram/utility/TranslatorContext.h       |   55 +-
 src/ast2ram/utility/Utils.cpp                 |   67 +-
 src/ast2ram/utility/Utils.h                   |   10 +-
 src/include/souffle/CompiledOptions.h         |   14 +-
 src/include/souffle/CompiledSouffle.h         |  332 ++-
 src/include/souffle/RamTypes.h                |    3 -
 src/include/souffle/RecordTable.h             |    6 -
 src/include/souffle/SignalHandler.h           |   24 +-
 src/include/souffle/SouffleInterface.h        |    2 -
 src/include/souffle/datastructure/BTree.h     |   34 +-
 .../souffle/datastructure/BTreeDelete.h       |   49 +-
 src/include/souffle/datastructure/BTreeUtil.h |    6 +-
 .../datastructure/ConcurrentFlyweight.h       |   13 +-
 .../ConcurrentInsertOnlyHashMap.h             |   28 +-
 .../datastructure/EquivalenceRelation.h       |   16 +-
 src/include/souffle/datastructure/PiggyList.h |    4 -
 .../souffle/datastructure/RecordTableImpl.h   |   36 -
 src/include/souffle/io/IOSystem.h             |    1 +
 src/include/souffle/io/ReadStream.h           |    6 +-
 src/include/souffle/io/ReadStreamCSV.h        |   58 +-
 src/include/souffle/io/ReadStreamSQLite.h     |   26 +-
 src/include/souffle/io/SerialisationStream.h  |    2 +-
 src/include/souffle/io/WriteStream.h          |    2 +-
 src/include/souffle/io/WriteStreamSQLite.h    |   50 +-
 src/include/souffle/profile/Cell.h            |   16 +-
 src/include/souffle/profile/CellInterface.h   |    2 +-
 src/include/souffle/profile/Cli.h             |   17 +-
 src/include/souffle/profile/EventProcessor.h  |   32 +-
 src/include/souffle/profile/OutputProcessor.h |   37 +-
 src/include/souffle/profile/ProfileEvent.h    |    8 +-
 src/include/souffle/profile/ProgramRun.h      |    4 +-
 src/include/souffle/profile/Reader.h          |   34 +-
 src/include/souffle/profile/Relation.h        |   18 +-
 src/include/souffle/profile/Tui.h             |   99 +-
 src/include/souffle/profile/UserInputReader.h |   12 -
 src/include/souffle/profile/htmlJsMain.h      |   36 +-
 src/include/souffle/utility/ContainerUtil.h   |    8 +-
 src/include/souffle/utility/DynamicCasting.h  |  128 +-
 src/include/souffle/utility/EvaluatorUtil.h   |    4 +-
 src/include/souffle/utility/FileUtil.h        |   14 +-
 src/include/souffle/utility/FunctionalUtil.h  |    6 +-
 src/include/souffle/utility/MiscUtil.h        |   48 +-
 src/include/souffle/utility/StreamUtil.h      |   14 -
 src/include/souffle/utility/StringUtil.h      |   23 -
 src/include/souffle/utility/SubProcess.h      |   18 +-
 src/include/souffle/utility/Types.h           |   15 -
 src/include/souffle/utility/Visitor.h         |    7 +-
 src/include/souffle/utility/json11.h          |   12 +-
 src/interpreter/BTreeDeleteIndex.cpp          |   18 +-
 src/interpreter/BTreeIndex.cpp                |   19 +-
 src/interpreter/Context.h                     |    9 -
 src/interpreter/Engine.cpp                    |  620 +++---
 src/interpreter/Engine.h                      |   45 +-
 src/interpreter/EqrelIndex.cpp                |    3 +-
 src/interpreter/Generator.cpp                 |  144 +-
 src/interpreter/Generator.h                   |   14 +-
 src/interpreter/Index.h                       |   32 +-
 src/interpreter/Node.h                        |  122 +-
 src/interpreter/ProvenanceIndex.cpp           |   19 +-
 src/interpreter/Relation.h                    |   43 +-
 src/interpreter/Util.h                        |  283 +--
 .../tests/interpreter_relation_test.cpp       |   18 +-
 src/interpreter/tests/ram_arithmetic_test.cpp |    9 +-
 src/interpreter/tests/ram_relation_test.cpp   |   63 +-
 src/main.cpp                                  |  985 +++++++++
 src/parser/Helper.h                           |  163 ++
 src/parser/ParserDriver.cpp                   |  232 +--
 src/parser/ParserDriver.h                     |   54 +-
 src/parser/ParserUtils.cpp                    |  154 +-
 src/parser/ParserUtils.h                      |   80 +-
 src/parser/SrcLocation.cpp                    |   47 +-
 src/parser/SrcLocation.h                      |   74 +-
 src/parser/parser.yy                          |  807 ++------
 src/parser/scanner.ll                         |  238 +--
 src/ram/AbstractAggregate.h                   |   39 +-
 src/ram/AbstractConditional.h                 |   17 +-
 src/ram/AbstractExistenceCheck.h              |   16 +-
 src/ram/AbstractOperator.h                    |   19 +-
 src/ram/Aggregate.h                           |   25 +-
 src/ram/AutoIncrement.h                       |    6 -
 src/ram/BinRelationStatement.h                |   13 +-
 src/ram/Break.h                               |    6 +-
 src/ram/Call.h                                |    6 +-
 src/ram/Clear.h                               |    6 +-
 src/ram/Condition.h                           |   12 -
 src/ram/Conjunction.h                         |    7 +-
 src/ram/Constraint.h                          |    6 +-
 src/ram/CountUniqueKeys.h                     |  107 +
 src/ram/DebugInfo.h                           |    7 +-
 src/ram/EmptinessCheck.h                      |    6 +-
 src/ram/Erase.h                               |    8 +-
 src/ram/ExistenceCheck.h                      |    7 +-
 src/ram/Exit.h                                |    6 +-
 src/ram/Expression.h                          |   13 -
 src/ram/False.h                               |    6 -
 src/ram/Filter.h                              |    6 +-
 src/ram/FloatConstant.h                       |    6 +-
 src/ram/GuardedInsert.h                       |    6 +-
 src/ram/IO.h                                  |    6 +-
 src/ram/IfExists.h                            |   17 +-
 src/ram/IndexAggregate.h                      |   23 +-
 src/ram/IndexIfExists.h                       |   25 +-
 src/ram/IndexOperation.h                      |   27 +-
 src/ram/IndexScan.h                           |   20 +-
 src/ram/Insert.h                              |   17 +-
 src/ram/IntrinsicOperator.h                   |    9 +-
 src/ram/ListStatement.h                       |   21 +-
 src/ram/LogRelationTimer.h                    |    7 +-
 src/ram/LogSize.h                             |    7 +-
 src/ram/LogTimer.h                            |    7 +-
 src/ram/Loop.h                                |    6 +-
 src/ram/MergeExtend.h                         |    7 +-
 src/ram/Negation.h                            |    6 +-
 src/ram/NestedIntrinsicOperator.h             |   11 +-
 src/ram/NestedOperation.h                     |   16 +-
 src/ram/Node.cpp                              |    6 +-
 src/ram/Node.h                                |  155 +-
 src/ram/NumericConstant.h                     |    9 +-
 src/ram/Operation.h                           |    9 -
 src/ram/PackRecord.h                          |   10 +-
 src/ram/Parallel.h                            |   10 +-
 src/ram/ParallelAggregate.h                   |   13 +-
 src/ram/ParallelIfExists.h                    |    6 +-
 src/ram/ParallelIndexAggregate.h              |   12 +-
 src/ram/ParallelIndexIfExists.h               |    8 +-
 src/ram/ParallelIndexScan.h                   |    7 +-
 src/ram/ParallelScan.h                        |    6 +-
 src/ram/Program.h                             |    9 +-
 src/ram/ProvenanceExistenceCheck.h            |    6 +-
 src/ram/Query.h                               |    6 +-
 src/ram/Relation.h                            |   26 +-
 src/ram/RelationOperation.h                   |   11 +-
 src/ram/RelationSize.h                        |    6 +-
 src/ram/RelationStatement.h                   |   11 +-
 src/ram/Scan.h                                |   15 +-
 src/ram/Sequence.h                            |   11 +-
 src/ram/SignedConstant.h                      |    6 +-
 src/ram/Statement.h                           |    9 -
 src/ram/StringConstant.h                      |    8 +-
 src/ram/SubroutineArgument.h                  |    6 +-
 src/ram/SubroutineReturn.h                    |   10 +-
 src/ram/Swap.h                                |    6 +-
 src/ram/TranslationUnit.cpp                   |    3 +-
 src/ram/True.h                                |    6 -
 src/ram/TupleElement.h                        |    7 +-
 src/ram/TupleOperation.h                      |   12 +-
 src/ram/UndefValue.h                          |    6 -
 src/ram/UnpackRecord.h                        |    7 +-
 src/ram/UnsignedConstant.h                    |    6 +-
 src/ram/UserDefinedOperator.h                 |   18 +-
 src/ram/analysis/Complexity.cpp               |   16 +-
 src/ram/analysis/Index.cpp                    |   12 +-
 src/ram/analysis/Index.h                      |    8 +-
 src/ram/analysis/Level.cpp                    |    5 -
 src/ram/transform/MakeIndex.cpp               |   50 +-
 src/ram/transform/MakeIndex.h                 |   13 +-
 src/ram/transform/Parallel.cpp                |   20 +-
 src/ram/transform/ReorderConditions.cpp       |    7 +-
 src/ram/transform/Transformer.cpp             |    4 +-
 src/ram/utility/Visitor.h                     |   14 +-
 src/reports/DebugReport.cpp                   |  270 +--
 src/reports/DebugReport.h                     |   22 +-
 src/reports/ErrorReport.h                     |   69 +-
 src/souffle-compile.template.py               |   30 +-
 src/souffle_prof.cpp                          |    4 +-
 src/synthesiser/Relation.cpp                  | 1053 +++++-----
 src/synthesiser/Relation.h                    |   26 +-
 src/synthesiser/Synthesiser.cpp               | 1780 ++++++++---------
 src/synthesiser/Synthesiser.h                 |   47 +-
 src/tests/graph_utils_test.cpp                |    1 -
 src/tests/record_table_test.cpp               |   21 -
 src/tests/visitor_test.cpp                    |   12 +-
 tests/CMakeLists.txt                          |    2 -
 tests/evaluation/CMakeLists.txt               |   14 +-
 tests/example/CMakeLists.txt                  |    2 +-
 tests/interface/CMakeLists.txt                |    9 -
 tests/interface/functors/CMakeLists.txt       |    6 -
 tests/interface/functors/functors.dl          |    9 +-
 tests/interface/insert_print/driver.cpp       |    2 +-
 tests/profile/CMakeLists.txt                  |    2 -
 tests/provenance/CMakeLists.txt               |    9 +-
 tests/scheduler/CMakeLists.txt                |    3 +-
 tests/semantic/CMakeLists.txt                 |   48 +-
 tests/semantic/agg_checks/agg_checks.err      |   17 +-
 .../bad_functor_types/bad_functor_types.err   |    8 +-
 .../comp_params_inheritance.err               |    6 +-
 tests/semantic/comp_types/comp_types.err      |   38 +-
 .../semantic/execution_plan/execution_plan.dl |   25 -
 .../execution_plan/execution_plan.err         |   17 +-
 tests/semantic/fact_plus/fact_plus.err        |    3 +
 .../semantic/fact_variable/fact_variable.err  |    3 +
 tests/semantic/leq/leq.dl                     |    2 +-
 tests/semantic/load10/load10.err              |    8 +
 tests/semantic/load10/oFloat.csv              |    2 +
 tests/semantic/load10/oSigned.csv             |    3 +
 tests/semantic/load3/load3.out                |    1 +
 tests/semantic/load4/load4.out                |    1 +
 tests/semantic/plan1/plan1.err                |    2 +-
 .../rule_typecompat/rule_typecompat.err       |   99 +-
 tests/semantic/strconv/A.csv                  |    8 +-
 tests/semantic/strconv/strconv.dl             |    6 -
 tests/semantic/subsumption/subsumption.err    |    2 +-
 .../subsumption_multiple_rules.dl             |    2 +
 tests/semantic/union_types/union_types.err    |   23 +-
 tests/semantic/var_single/var_single.err      |    3 +
 tests/syntactic/CMakeLists.txt                |   82 +-
 .../dot_identifiers/dot_identifiers.dl        |    2 -
 tests/syntactic/qualifiers4/qualifiers4.err   |    2 +-
 tests/syntactic/syntax1/syntax1.err           |    2 +-
 tests/syntactic/syntax10/syntax10.err         |    2 +-
 tests/syntactic/syntax5/syntax5.err           |    2 +-
 tests/syntactic/syntax6/syntax6.err           |    2 +-
 tests/syntactic/syntax8/syntax8.err           |    2 +-
 412 files changed, 7824 insertions(+), 9542 deletions(-)
 create mode 100644 src/DynamicLibrary.cpp
 create mode 100644 src/ExtraConfig.h
 create mode 100644 src/MainEntry.cpp
 create mode 100644 src/ast/analysis/UniqueKeys.cpp
 create mode 100644 src/ast/analysis/UniqueKeys.h
 create mode 100644 src/ast/utility/SipsMetric.cpp
 create mode 100644 src/ast/utility/SipsMetric.h
 create mode 100644 src/main.cpp
 create mode 100644 src/parser/Helper.h
 create mode 100644 src/ram/CountUniqueKeys.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 5ab514d..1204593 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,10 +6,6 @@
 
 cmake_minimum_required(VERSION 3.15)
 
-set(CMAKE_CXX_STANDARD 17)
-set(CMAKE_CXX_STANDARD_REQUIRED ON)
-set(CMAKE_CXX_EXTENSIONS OFF)
-
 include(CMakeDependentOption)
 
 option(SOUFFLE_GIT "Enable/Disable git completion" ON)
@@ -34,7 +30,7 @@ if (SOUFFLE_GIT)
     else()
         string(REGEX REPLACE "\n$" "" PACKAGE_VERSION "${GIT_PACKAGE_VERSION}")
         message(STATUS "Building souffle version ${PACKAGE_VERSION}")
-
+    
         # SOUFFLE_VERSION only includes the major/minor triplet
         string(REGEX REPLACE "-.*$" "" SOUFFLE_VERSION "${PACKAGE_VERSION}")
 
@@ -143,15 +139,6 @@ if (WIN32)
   SET( CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE "${OUTPUT_DIRECTORY}")
 endif ()
 
-
-if(EMSCRIPTEN)
-  set(SOUFFLE_USE_SQLITE off)
-  set(SOUFFLE_USE_OPENMP off)
-  set(SOUFFLE_USE_ZLIB off)
-  set(SOUFFLE_USE_LIBFFI off)
-  set(SOUFFLE_USE_CURSES off)
-  set(SOUFFLE_ENABLE_TESTING off)
-endif ()
 # --------------------------------------------------
 # curses libraries for Provenance information
 # --------------------------------------------------
@@ -202,7 +189,7 @@ if (CMAKE_HOST_SYSTEM_NAME MATCHES "Darwin")
             OUTPUT_VARIABLE BREW_BISON_PREFIX
             OUTPUT_STRIP_TRAILING_WHITESPACE
     )
-    if (BREW_BISON EQUAL 0 AND EXISTS "${BREW_BISON_PREFIX}")
+    if (NOT DEFINED BISON_EXECUTABLE AND BREW_BISON EQUAL 0 AND EXISTS "${BREW_BISON_PREFIX}")
         message(STATUS "Found Bison keg installed by Homebrew at ${BREW_BISON_PREFIX}")
         set(BISON_EXECUTABLE "${BREW_BISON_PREFIX}/bin/bison")
     endif()
@@ -213,13 +200,13 @@ if (CMAKE_HOST_SYSTEM_NAME MATCHES "Darwin")
             OUTPUT_VARIABLE BREW_FLEX_PREFIX
             OUTPUT_STRIP_TRAILING_WHITESPACE
     )
-    if (BREW_FLEX EQUAL 0 AND EXISTS "${BREW_FLEX_PREFIX}")
+    if (NOT DEFINED FLEX_EXECUTABLE AND BREW_FLEX EQUAL 0 AND EXISTS "${BREW_FLEX_PREFIX}")
         message(STATUS "Found Flex keg installed by Homebrew at ${BREW_FLEX_PREFIX}")
         set(FLEX_EXECUTABLE "${BREW_FLEX_PREFIX}/bin/flex")
     endif()
 endif()
 find_package(FLEX REQUIRED)
-find_package(BISON "3.2" REQUIRED)
+find_package(BISON "3.0.4" REQUIRED)
 
 # --------------------------------------------------
 # mcpp
@@ -319,7 +306,7 @@ if (SOUFFLE_GENERATE_DOXYGEN)
 
     add_custom_target(doxygen
         COMMAND ${DOXYGEN_EXECUTABLE} ${DOXYGEN_CFG}
-        WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
+        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
         COMMENT "Generating API documentation with Doxygen")
 endif()
 
@@ -391,7 +378,7 @@ IF (SOUFFLE_BASH_COMPLETION)
     endif()
 
     install(
-        FILES "${PROJECT_SOURCE_DIR}/debian/souffle.bash-completion"
+        FILES "${CMAKE_CURRENT_SOURCE_DIR}/debian/souffle.bash-completion"
         DESTINATION ${BASH_COMPLETION_COMPLETIONSDIR}
         RENAME "souffle"
     )
@@ -402,7 +389,7 @@ if (NOT WIN32)
 # --------------------------------------------------
 # CPack configuration
 # --------------------------------------------------
-execute_process(COMMAND bash "${PROJECT_SOURCE_DIR}/sh/check_os.sh"
+execute_process(COMMAND bash "${CMAKE_CURRENT_SOURCE_DIR}/sh/check_os.sh"
                 RESULT_VARIABLE CHECK_OS_RESULT
                 OUTPUT_VARIABLE CHECK_OS_OUTPUT)
 
@@ -414,7 +401,7 @@ SET(CPACK_PACKAGE_DESCRIPTION_SUMMARY "A Datalog Compiler")
 SET(CPACK_THREADS 0)
 
 # Make sure changelog, bash-completion and other important files in debian directory also packaged
-SET(CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA "${PROJECT_SOURCE_DIR}/debian/changelog" "${PROJECT_SOURCE_DIR}/debian/souffle.bash-completion" "${PROJECT_SOURCE_DIR}/debian/copyright")
+SET(CPACK_DEBIAN_PACKAGE_CONTROL_EXTRA "${CMAKE_CURRENT_SOURCE_DIR}/debian/changelog" "${CMAKE_CURRENT_SOURCE_DIR}/debian/souffle.bash-completion" "${CMAKE_CURRENT_SOURCE_DIR}/debian/copyright")
 
 # --------------------------------------------------
 # CPack configuration 
diff --git a/README.md b/README.md
index 05af771..aca3a69 100644
--- a/README.md
+++ b/README.md
@@ -5,8 +5,8 @@ The Soufflé language is similar to Datalog (but has terms known as records), an
 domain-specific language for analysis problems.
 
 [![License: UPL](https://img.shields.io/badge/License-UPL--1.0-blue.svg)](https://github.com/souffle-lang/souffle/blob/master/LICENSE)
-[![CI-Tests](https://github.com/souffle-lang/souffle/actions/workflows/CI-Tests.yml/badge.svg?event=push)](https://github.com/souffle-lang/souffle/actions/workflows/CI-Tests.yml)
-[![MSVC-CI-Tests](https://github.com/souffle-lang/souffle/actions/workflows/VS-CI-Tests.yml/badge.svg?event=push)](https://github.com/souffle-lang/souffle/actions/workflows/VS-CI-Tests.yml)
+[![CI-Tests](https://github.com/souffle-lang/souffle/actions/workflows/CI-Tests.yml/badge.svg)](https://github.com/souffle-lang/souffle/actions/workflows/CI-Tests.yml)
+[![MSVC-CI-Tests](https://github.com/souffle-lang/souffle/actions/workflows/VS-CI-Tests.yml/badge.svg)](https://github.com/souffle-lang/souffle/actions/workflows/VS-CI-Tests.yml)
 [![codecov](https://codecov.io/gh/souffle-lang/souffle/branch/master/graph/badge.svg)](https://codecov.io/gh/souffle-lang/souffle)
 
 ## Features of Soufflé
@@ -46,7 +46,7 @@ domain-specific language for analysis problems.
 
 Use git to obtain the source code of Soufflé.
 
-    $ git clone https://github.com/souffle-lang/souffle.git
+    $ git clone git://github.com/souffle-lang/souffle.git
 
 Build instructions can be found [here](https://souffle-lang.github.io/build).
 
diff --git a/choco-packages.config b/choco-packages.config
index 9c8d432..aebe6bf 100644
--- a/choco-packages.config
+++ b/choco-packages.config
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <packages>
   <package id="winflexbison3"/>
-  <!-- must use the same version of sqlite as in vcpkg.json -->
-  <package id="sqlite" version="3.40.1"/>
-  <package id="cmake" version="3.25.1"/>
+  <package id="sqlite"/>
+  <package id="cmake" version="3.21.3"/>
 </packages>
diff --git a/cmake/SouffleTests.cmake b/cmake/SouffleTests.cmake
index 2162f9b..148e344 100644
--- a/cmake/SouffleTests.cmake
+++ b/cmake/SouffleTests.cmake
@@ -63,14 +63,6 @@ function(SOUFFLE_RUN_INTEGRATION_TEST)
       FIXTURES_SETUP ${PARAM_FIXTURE_NAME}_run_souffle
       FIXTURES_REQUIRED ${PARAM_FIXTURE_NAME}_setup)
 
-    if (WIN32)
-      string(REPLACE ";" "\\;" escaped_path "$ENV{PATH}")
-      cmake_path(GET CMAKE_CXX_COMPILER PARENT_PATH CL_DIR)
-      set_tests_properties(${PARAM_QUALIFIED_TEST_NAME}_run_souffle PROPERTIES
-        ENVIRONMENT "PATH=${CL_DIR}\\;$<SHELL_PATH:$<TARGET_FILE_DIR:souffle>>\\;${escaped_path}"
-      )
-    endif()
-
     if (PARAM_NEGATIVE)
       #Mark the souffle run as "will fail" for negative tests
       set_tests_properties(${PARAM_QUALIFIED_TEST_NAME}_run_souffle PROPERTIES WILL_FAIL TRUE)
@@ -91,21 +83,12 @@ function(SOUFFLE_COMPARE_STD_OUTPUTS)
       COMMAND
         ${Python3_EXECUTABLE} "${PROJECT_SOURCE_DIR}/cmake/check_std_outputs.py"
         "${PARAM_TEST_NAME}"
-        "${PARAM_EXTRA_DATA}"
-    )
+        "${PARAM_EXTRA_DATA}")
 
     set_tests_properties(${PARAM_QUALIFIED_TEST_NAME}_compare_std_outputs PROPERTIES
-      WORKING_DIRECTORY "${PARAM_OUTPUT_DIR}"
-      LABELS "${PARAM_TEST_LABELS}"
-      FIXTURES_REQUIRED ${PARAM_RUN_AFTER_FIXTURE}
-    )
-
-    if (WIN32)
-      string(REPLACE ";" "\\;" escaped_path "$ENV{PATH}")
-      set_tests_properties(${PARAM_QUALIFIED_TEST_NAME}_compare_std_outputs PROPERTIES
-        ENVIRONMENT "$<SHELL_PATH:$<TARGET_FILE_DIR:souffle>>\\;${escaped_path}"
-      )
-    endif()
+                         WORKING_DIRECTORY "${PARAM_OUTPUT_DIR}"
+                         LABELS "${PARAM_TEST_LABELS}"
+                         FIXTURES_REQUIRED ${PARAM_RUN_AFTER_FIXTURE})
 endfunction()
 
 function(SOUFFLE_COMPARE_CSV)
@@ -151,8 +134,6 @@ function(SOUFFLE_RUN_TEST_HELPER)
 #PARAM_FUNCTORS - with -L for finding functor library in the testsuite
 #PARAM_NEGATIVE - should it fail or not
 #PARAM_MULTI_TEST - used to distinguish "multi-tests", sort of left over from automake
-#PARAM_NO_PROCESSOR - should the C preprocessor be disabled or not
-#PARAM_INCLUDE_DIRS - list of include directory paths, relative to the test input directory
 #Basically, the same test dir has multiple sets of facts / outputs
 #We should just get rid of this and make multiple tests
 #It also means we need to use slightly different naming for tests
@@ -161,9 +142,9 @@ function(SOUFFLE_RUN_TEST_HELPER)
 #Usually just "facts" but can be different when running multi - tests
     cmake_parse_arguments(
         PARAM
-        "COMPILED;COMPILED_SPLITTED;FUNCTORS;NEGATIVE;MULTI_TEST;NO_PREPROCESSOR;OUTPUT_STDOUT" # Options
+        "COMPILED;FUNCTORS;NEGATIVE;MULTI_TEST;NO_PREPROCESSOR" # Options
         "TEST_NAME;CATEGORY;FACTS_DIR_NAME;EXTRA_DATA" #Single valued options
-        "INCLUDE_DIRS" # Multi-valued options
+        ""
         ${ARGV}
     )
 
@@ -173,10 +154,6 @@ function(SOUFFLE_RUN_TEST_HELPER)
         list(APPEND EXTRA_FLAGS "-c")
         set(EXEC_STYLE "compiled")
         set(SHORT_EXEC_STYLE "_c")
-    elseif(PARAM_COMPILED_SPLITTED)
-        list(APPEND EXTRA_FLAGS "-C")
-        set(EXEC_STYLE "compiled-splitted")
-        set(SHORT_EXEC_STYLE "_C")
     else()
         set(EXEC_STYLE "interpreted")
         set(SHORT_EXEC_STYLE "")
@@ -205,13 +182,6 @@ function(SOUFFLE_RUN_TEST_HELPER)
     set(INPUT_DIR "${CMAKE_CURRENT_SOURCE_DIR}/${PARAM_TEST_NAME}")
     set(FACTS_DIR "${INPUT_DIR}/${PARAM_FACTS_DIR_NAME}")
 
-    if (PARAM_INCLUDE_DIRS)
-      ## generate -I include directory options
-      list(TRANSFORM PARAM_INCLUDE_DIRS PREPEND "${INPUT_DIR}/")
-      list(TRANSFORM PARAM_INCLUDE_DIRS PREPEND "-I")
-      list(APPEND EXTRA_FLAGS ${PARAM_INCLUDE_DIRS})
-    endif()
-
     if (PARAM_MULTI_TEST)
         set(DATA_CHECK_DIR "${INPUT_DIR}/${PARAM_FACTS_DIR_NAME}")
         set(MT_EXTRA_SUFFIX "_${PARAM_FACTS_DIR_NAME}")
@@ -243,11 +213,7 @@ function(SOUFFLE_RUN_TEST_HELPER)
                                        FIXTURE_NAME ${FIXTURE_NAME}
                                        TEST_LABELS ${TEST_LABELS})
 
-    if(PARAM_OUTPUT_STDOUT)
-      set(SOUFFLE_PARAMS "-D-" "-F" "${FACTS_DIR}")
-    else()
-      set(SOUFFLE_PARAMS "-D" "." "-F" "${FACTS_DIR}")
-    endif()
+    set(SOUFFLE_PARAMS "-D" "." "-F" "${FACTS_DIR}")
     list(PREPEND SOUFFLE_PARAMS ${EXTRA_FLAGS})
 
     if (OPENMP_FOUND)
@@ -348,12 +314,6 @@ endfunction()
 function(SOUFFLE_POSITIVE_TEST TEST_NAME CATEGORY)
     souffle_run_test(TEST_NAME ${TEST_NAME}
                      CATEGORY ${CATEGORY})
-    if (${ARGN} MATCHES "COMPILED_SPLITTED")
-        souffle_run_test_helper(
-            TEST_NAME ${TEST_NAME}
-            CATEGORY ${CATEGORY}
-            COMPILED_SPLITTED)
-    endif()
 endfunction()
 
 # A helper to make it easier to specify the category positionally
diff --git a/cmake/common.py b/cmake/common.py
index 28fe8f1..9e999d0 100644
--- a/cmake/common.py
+++ b/cmake/common.py
@@ -45,7 +45,6 @@ def compare_files(expected_file, actual_file):
 
     if actual_lines != expected_lines:
         os.sys.stdout.writelines(difflib.unified_diff(open(expected_file).readlines(), open(actual_file).readlines(), fromfile=expected_file, tofile=actual_file))
-        os.sys.stdout.write("\n")
         os.sys.exit("Found output difference, expected file:'{}', actual file:'{}".format(expected_file, actual_file))
 
     return True
diff --git a/cmake/redirect.py b/cmake/redirect.py
index 6e83a1d..d1b703e 100644
--- a/cmake/redirect.py
+++ b/cmake/redirect.py
@@ -41,8 +41,4 @@ if stdout:
 if stderr:
     stderr.close()
 
-if status.returncode != 0 and args.err_file:
-    with open(args.err_file, "r") as f:
-        os.sys.stderr.write(f.read())
-
 os.sys.exit(status.returncode)
diff --git a/debian/changelog b/debian/changelog
index 97c45fd..87595ff 100644
--- a/debian/changelog
+++ b/debian/changelog
@@ -1,36 +1,3 @@
-souffle (2.4.1) stable; urgency=low
- * Remove escapes in arch build (XiaowenHu96)
- * fix windows CI (quentin)
- * Fix subsumption (julienhenry)
- * remove -Werror from CMakeLists.txt (ammkrn)
- * Provide way to debug delta relations and expose iteration counter (julienhenry)
- * fix "variable only occurs once" checker (quentin)
- * fix bad source location for END token (quentin)
- * Fix generated code for eqrel when emitting statistics (fangyi-zhou)
- * do not consider debug_delta relations as empty (julienhenry)
- * Fix auto-scheduler profile mismatch (fangyi-zhou)
- * fixes souffleprof and enable build on Windows (quentin)
- * Enabling souffle-lang/souffle GitHub dependency graph with vcpk (#2427) (quentin)
- * fix sqlite reading of empty values (dbueno)
- * symbol concatenation with binary `+` (quentin)
-
- -- Quentin Sabah <quentin.sabah@gmail.com>  Web, 11 Oct 2023 11:00:00 +0100
-
-souffle (2.4) stable; urgency=low
- * New option --generate-many to split the generated C++ Code into multiple files (julienhenry)
- * Purge input and intermediate relations (adamjseitz)
- * Emscripten Build (philzook58)
- * Improved parallel load balance in the interpreter (quentin)
- * User defined aggregate (julienhenry)
- * Improved loading of CSV (strRM, bmeck)
- * Configurable warnings (langston-barrett)
- * Performance improvements for regex matching (strRM)
- * Expose main driver interface (quentin)
- * Allow linking against multiple compiled Souffle programs (ruricolist, quentin)
- * Misc fixes and refactoring (adamjseitz, ruricolist, quentin, b-scholz, mingodad, bmeck, strRM, fgauthie, julienhenry, SamArch27, luc-tielen, XiaowenHu96, Gueckmooh)
-
- -- Quentin Sabah <quentin.sabah@gmail.com>  Sat, 18 Feb 2023 11:00:00 +0100
-
 souffle (2.3) stable; urgency=low
  * Auto-scheduler for rules (SamArch27)
  * Better scheduling heuristic (julienhenry)
diff --git a/debian/souffle.bash-completion b/debian/souffle.bash-completion
index 5b6b2f0..a849194 100644
--- a/debian/souffle.bash-completion
+++ b/debian/souffle.bash-completion
@@ -35,7 +35,7 @@ _souffle()
             return
             ;;
         --disable-transformers)
-            COMPREPLY=( $(compgen -W "AstComponentChecker AstExecutionPlanChecker AstPragmaChecker AstSemanticChecker AstUserDefinedFunctorsTransformer ComponentInstantiationTransformer FoldAnonymousRecords GroundedTermsChecker InlineRelationsTransformer MagicSetTransformer MaterializeAggregationQueriesTransformer MaterializeSingletonAggregationTransformer MetaTransformer MinimiseProgramTransformer NameUnnamedVariablesTransformer NormaliseConstraintsTransformer PartitionBodyLiteralsTransformer PolymorphicObjectsTransformer ProvenanceTransformer ReduceExistentialsTransformer RemoveBooleanConstraintsTransformer RemoveEmptyRelationsTransformer RemoveRedundantRelationsTransformer RemoveRedundantSumsTransformer RemoveRelationCopiesTransformer RemoveTypecastsTransformer ReorderLiteralsTransformer ReplaceSingletonVariablesTransformer ResolveAliasesTransformer ResolveAnonymousRecordAliases SimplifyConstantBinaryConstraintsTransformer UniqueAggregationVariablesTransformer" -- "$cur" ) )
+            COMPREPLY=( $(compgen -W "AstComponentChecker AstExecutionPlanChecker AstPragmaChecker AstSemanticChecker AstUserDefinedFunctorsTransformer ComponentInstantiationTransformer FoldAnonymousRecords GroundedTermsChecker InlineRelationsTransformer MagicSetTransformer MaterializeAggregationQueriesTransformer MaterializeSingletonAggregationTransformer MetaTransformer MinimiseProgramTransformer NameUnnamedVariablesTransformer NormaliseConstraintsTransformer PartitionBodyLiteralsTransformer PolymorphicObjectsTransformer ProvenanceTransformer ReduceExistentialsTransformer RemoveBooleanConstraintsTransformer RemoveEmptyRelationsTransformer RemoveRedundantRelationsTransformer RemoveRedundantSumsTransformer RemoveRelationCopiesTransformer RemoveTypecastsTransformer ReorderLiteralsTransformer ReplaceSingletonVariablesTransformer ResolveAliasesTransformer ResolveAnonymousRecordAliases UniqueAggregationVariablesTransformer" -- "$cur" ) )
             return
             ;;
     esac
diff --git a/sh/checkStyle.sh b/sh/checkStyle.sh
index 6c46809..c6ca15e 100755
--- a/sh/checkStyle.sh
+++ b/sh/checkStyle.sh
@@ -16,7 +16,7 @@ cd "$(git rev-parse --show-toplevel)"
 
 # Find all changed files in the diff
 for f in $(git diff --name-only --diff-filter=ACMRTUXB $1); do
-  if echo "$f" | grep -E -q "[.](cpp|h)$"; then
+  if echo "$f" | egrep -q "[.](cpp|h)$"; then
     $CLANGFORMAT -style=file "$f" -i
     d=$(git diff --minimal --color=always --ws-error-highlight=all $f) || true
     if [ -n "$d" ]; then
@@ -27,7 +27,7 @@ for f in $(git diff --name-only --diff-filter=ACMRTUXB $1); do
       echo
       fail=1
     fi
-  elif echo "$f" | grep -E -q "[.](dl)$"; then
+  elif echo "$f" | egrep -q "[.](dl)$"; then
     sed -i 's/[ \t]*$//' "$f" || true
     d=$(git diff --minimal --color=always --ws-error-highlight=all $f) || true
     if [ -n "$d" ]; then
diff --git a/sh/check_os.sh b/sh/check_os.sh
index 5b0f8a3..b8eb63a 100755
--- a/sh/check_os.sh
+++ b/sh/check_os.sh
@@ -11,7 +11,7 @@ fi
 ID=$(grep -G "^ID_LIKE=" $file | tr a-z A-Z)
 
 #Fedora is special and has no ID_LIKE
-if [ -z "$ID" ]; then
+if [ -z $ID ]; then
     ID=$(grep -G "^ID=" $file | tr a-z A-Z)
 fi
 
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index c2ce37b..5c07576 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -8,12 +8,7 @@
 set(SOUFFLE_SOURCES
     FunctorOps.cpp
     Global.cpp
-    GraphUtils.cpp
-    MainDriver.cpp
-    ast/Annotation.cpp
     ast/Aggregator.cpp
-    ast/IntrinsicAggregator.cpp
-    ast/UserDefinedAggregator.cpp
     ast/AlgebraicDataType.cpp
     ast/AliasType.cpp
     ast/Atom.cpp
@@ -35,8 +30,6 @@ set(SOUFFLE_SOURCES
     ast/FunctorDeclaration.cpp
     ast/FunctionalConstraint.cpp
     ast/IntrinsicFunctor.cpp
-    ast/IterationCounter.cpp
-    ast/Lattice.cpp
     ast/Negation.cpp
     ast/NilConstant.cpp
     ast/Node.cpp
@@ -50,7 +43,6 @@ set(SOUFFLE_SOURCES
     ast/StringConstant.cpp
     ast/SubsetType.cpp
     ast/Term.cpp
-    ast/TokenTree.cpp
     ast/TranslationUnit.cpp
     ast/Type.cpp
     ast/TypeCast.cpp
@@ -69,7 +61,7 @@ set(SOUFFLE_SOURCES
     ast/analysis/RecursiveClauses.cpp
     ast/analysis/RedundantRelations.cpp
     ast/analysis/RelationSchedule.cpp
-    ast/analysis/JoinSize.cpp
+    ast/analysis/UniqueKeys.cpp
     ast/analysis/SCCGraph.cpp
     ast/analysis/TopologicallySortedSCCGraph.cpp
     ast/analysis/typesystem/PolymorphicObjects.cpp
@@ -84,14 +76,12 @@ set(SOUFFLE_SOURCES
     ast/transform/ComponentChecker.cpp
     ast/transform/ComponentInstantiation.cpp
     ast/transform/DebugReporter.cpp
-    ast/transform/DebugDeltaRelation.cpp
     ast/transform/ExecutionPlanChecker.cpp
     ast/transform/ExpandEqrels.cpp
     ast/transform/FoldAnonymousRecords.cpp
     ast/transform/GroundedTermsChecker.cpp
     ast/transform/GroundWitnesses.cpp
     ast/transform/InlineRelations.cpp
-    ast/transform/InsertLatticeOperations.cpp
     ast/transform/MagicSet.cpp
     ast/transform/MaterializeAggregationQueries.cpp
     ast/transform/MaterializeSingletonAggregation.cpp
@@ -111,15 +101,13 @@ set(SOUFFLE_SOURCES
     ast/transform/ResolveAliases.cpp
     ast/transform/ResolveAnonymousRecordAliases.cpp
     ast/transform/SemanticChecker.cpp
-    ast/transform/SimplifyConstantBinaryConstraints.cpp
     ast/transform/SubsumptionQualifier.cpp
     ast/transform/SimplifyAggregateTargetExpression.cpp
     ast/transform/Transformer.cpp
     ast/transform/TypeChecker.cpp
     ast/transform/UniqueAggregationVariables.cpp
     ast/utility/BindingStore.cpp
-    ast2ram/utility/SipsMetric.cpp
-    ast2ram/utility/SipGraph.cpp
+    ast/utility/SipsMetric.cpp
     ast/utility/Utils.cpp
     ast2ram/provenance/ClauseTranslator.cpp
     ast2ram/provenance/ConstraintTranslator.cpp
@@ -144,7 +132,6 @@ set(SOUFFLE_SOURCES
     parser/ParserDriver.cpp
     parser/ParserUtils.cpp
     parser/SrcLocation.cpp
-    parser/VirtualFileSystem.cpp
     ram/Node.cpp
     ram/TranslationUnit.cpp
     ram/analysis/Complexity.cpp
@@ -165,12 +152,10 @@ set(SOUFFLE_SOURCES
     ram/transform/Transformer.cpp
     ram/transform/TupleId.cpp
     ram/utility/NodeMapper.cpp
-    reports/ErrorReport.cpp
     reports/DebugReport.cpp
     synthesiser/Synthesiser.cpp
     synthesiser/Relation.cpp
-    synthesiser/Utils.cpp
-    synthesiser/GenDb.cpp
+    main.cpp
 )
 
 # --------------------------------------------------
@@ -182,7 +167,7 @@ flex_target(scanner parser/scanner.ll ${CMAKE_CURRENT_BINARY_DIR}/parser/scanner
   COMPILE_FLAGS "${SCANNER_COMPILE_FLAGS} -d")
 
 bison_target(parser parser/parser.yy ${CMAKE_CURRENT_BINARY_DIR}/parser/parser.cc
-             COMPILE_FLAGS "-Wall -Wno-error=deprecated -Wno-error=other -v -d")
+             COMPILE_FLAGS "-Wall -Werror -Wno-error=deprecated -Wno-error=other -v -d")
 add_flex_bison_dependency(scanner parser)
 
 
@@ -191,15 +176,10 @@ if (MSVC)
              COMPILE_FLAGS "/wd4005 /wd4996")
   set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/parser/parser.cc PROPERTIES
              COMPILE_FLAGS "/wd4005 /wd26819")
-elseif (EMSCRIPTEN)
-  set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/parser/parser.cc PROPERTIES
-             COMPILE_FLAGS "-Wno-error=unused-but-set-variable")
 else ()
   # OSX compiler doesn't recognise `(void)var;` ideom
   set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/parser/scanner.cc PROPERTIES
              COMPILE_FLAGS "-Wno-error=unused-parameter")
-  set_source_files_properties(${CMAKE_CURRENT_BINARY_DIR}/parser/parser.cc PROPERTIES
-             COMPILE_FLAGS "-Wno-error=unused-but-set-variable")
 endif ()
 
 # --------------------------------------------------
@@ -211,6 +191,10 @@ add_library(libsouffle STATIC
             ${BISON_parser_OUTPUTS}
             )
 
+add_library(libsouffle-shared SHARED DynamicLibrary.cpp)
+target_link_libraries(libsouffle-shared libsouffle)
+set_target_properties(libsouffle-shared PROPERTIES OUTPUT_NAME "souffle")
+
 # Make most of the attributes public.  Note that that's strictly not "correct" but
 # this library is not going to be installed and it makes it easier to build
 # the other targets in this project.  It encapsulates things nicely.
@@ -232,15 +216,12 @@ target_compile_features(libsouffle PUBLIC cxx_std_17)
 target_compile_features(compiled PUBLIC cxx_std_17)
 
 set_target_properties(libsouffle PROPERTIES CXX_EXTENSIONS OFF)
-set_target_properties(libsouffle PROPERTIES POSITION_INDEPENDENT_CODE ON)
-
 set_target_properties(compiled PROPERTIES CXX_EXTENSIONS OFF)
-set_target_properties(compiled PROPERTIES POSITION_INDEPENDENT_CODE ON)
 
 if (NOT MSVC)
-  target_compile_options(libsouffle PUBLIC -Wall -Wextra -fwrapv)
+  target_compile_options(libsouffle PUBLIC -Wall -Wextra -fwrapv -fPIC)
 else ()
-  target_compile_options(libsouffle PUBLIC /W3)
+  target_compile_options(libsouffle PUBLIC /W3 /WX)
 endif ()
 
 target_compile_options(compiled PUBLIC "")
@@ -330,36 +311,24 @@ set_target_properties(libsouffle PROPERTIES OUTPUT_NAME "souffle")
 # Souffle binary
 # --------------------------------------------------
 add_executable(souffle
-               souffle.cpp)
+               MainEntry.cpp)
 target_link_libraries(souffle libsouffle)
 install(TARGETS souffle DESTINATION bin)
 
-if (EMSCRIPTEN)
-target_link_libraries(souffle -sMODULARIZE=1
-                      -s'EXPORTED_RUNTIME_METHODS=["FS"]' -sEXPORT_NAME="SOUFFLE")
-endif()
-
 # Copy the dlls in the same directory as Souffle so that they will
 # be immediately found by the operating system.
 
 if (SOUFFLE_USE_SQLITE)
-  add_custom_command(TARGET souffle POST_BUILD
-    COMMAND ${CMAKE_COMMAND} -E copy_if_different
-    ${SQLite3_LIBRARY}
-    $<TARGET_FILE_DIR:souffle>)
-  if (WIN32)
-    cmake_path(GET SQLite3_LIBRARY PARENT_PATH SQLite3_LIBRARY_DIR)
-    add_custom_command(TARGET souffle POST_BUILD
-      COMMAND ${CMAKE_COMMAND} -E copy_if_different
-      ${SQLite3_LIBRARY_DIR}/../bin/sqlite3.dll
-      $<TARGET_FILE_DIR:souffle>)
-  endif ()
+add_custom_command(TARGET souffle POST_BUILD
+  COMMAND ${CMAKE_COMMAND} -E copy_if_different
+  ${SQLite3_LIBRARY} ${ZLIB_LIBRARY_RELEASE}
+  $<TARGET_FILE_DIR:souffle>)
 endif ()
 
 if (SOUFFLE_USE_ZLIB)
 add_custom_command(TARGET souffle POST_BUILD
   COMMAND ${CMAKE_COMMAND} -E copy_if_different
-  ${ZLIB_LIBRARY_RELEASE}
+  ${SQLite3_LIBRARY} ${ZLIB_LIBRARY_RELEASE}
   $<TARGET_FILE_DIR:souffle>)
 endif ()
 
@@ -374,21 +343,18 @@ endif ()
 # Souffle's profiler binary
 # --------------------------------------------------
 
+if (NOT WIN32)
+  add_executable(souffleprof
+    souffle_prof.cpp)
+  target_include_directories(souffleprof PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include)
+  install(TARGETS souffleprof DESTINATION bin)
 
-add_executable(souffleprof
-  souffle_prof.cpp)
-target_include_directories(souffleprof PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/include)
-install(TARGETS souffleprof DESTINATION bin)
-
-# Set C++ standard to C++17
-target_compile_features(souffleprof
-  PUBLIC cxx_std_17)
+  # Set C++ standard to C++17
+  target_compile_features(souffleprof
+    PUBLIC cxx_std_17)
+endif()
 
 if (MSVC)
-  target_compile_options(libsouffle PUBLIC /Zc:__cplusplus)
-  target_compile_options(compiled PUBLIC /Zc:__cplusplus)
-  target_compile_options(souffleprof PUBLIC /Zc:__cplusplus)
-
   target_compile_options(libsouffle PUBLIC /bigobj)
   target_compile_options(compiled PUBLIC /bigobj)
 
@@ -413,27 +379,15 @@ if (MSVC)
 
   target_compile_options(libsouffle PUBLIC /Zc:preprocessor)
   target_compile_options(compiled PUBLIC /Zc:preprocessor)
-  target_compile_options(souffleprof PUBLIC /Zc:preprocessor)
 
   target_compile_options(libsouffle PUBLIC /EHsc)
   target_compile_options(compiled PUBLIC /EHsc)
-  target_compile_options(souffleprof PUBLIC /EHsc)
 
   target_compile_definitions(libsouffle PUBLIC USE_CUSTOM_GETOPTLONG)
   target_compile_definitions(compiled PUBLIC USE_CUSTOM_GETOPTLONG)
-  target_compile_definitions(souffleprof PUBLIC USE_CUSTOM_GETOPTLONG)
 endif (MSVC)
 
-if (APPLE)
-  if ("${CMAKE_HOST_SYSTEM_PROCESSOR}" STREQUAL "arm64")
-    # work around a known issue with xcode15 linker
-    # c++ exceptions handling is broken otherwise
-    set(CMAKE_CXX_LINK_FLAGS "${CMAKE_CXX_LINK_FLAGS} -Wl,-ld_classic")
-    target_link_options(libsouffle PUBLIC "-ld_classic")
-    target_link_options(compiled PUBLIC "-ld_classic")
-    target_link_options(souffleprof PUBLIC "-ld_classic")
-  endif()
-endif()
+
 
 # --------------------------------------------------
 # Substitutions for souffle-compile.py
@@ -449,7 +403,6 @@ set(SOUFFLE_COMPILED_DEBUG_CXX_FLAGS ${CMAKE_CXX_FLAGS_DEBUG})
 get_target_property(SOUFFLE_COMPILED_DEFS compiled COMPILE_DEFINITIONS)
 get_target_property(SOUFFLE_COMPILED_OPTS compiled COMPILE_OPTIONS)
 get_target_property(SOUFFLE_COMPILED_INCS compiled INCLUDE_DIRECTORIES)
-get_property(SOUFFLE_COMPILED_LINK_OPTS TARGET compiled PROPERTY LINK_OPTIONS)
 
 set(SOUFFLE_COMPILED_LIBS "")
 set(SOUFFLE_COMPILED_RPATHS "")
@@ -537,10 +490,7 @@ endif ()
 
 list(JOIN SOUFFLE_COMPILED_OPTS " " SOUFFLE_COMPILED_CXX_OPTIONS)
 
-list(JOIN SOUFFLE_COMPILED_LIBS " " SOUFFLE_COMPILED_LINK_OPTIONS1)
-list(JOIN SOUFFLE_COMPILED_LINK_OPTS " " SOUFFLE_COMPILED_LINK_OPTIONS2)
-set(SOUFFLE_COMPILED_LINK_OPTIONS "")
-string(APPEND SOUFFLE_COMPILED_LINK_OPTIONS " ${SOUFFLE_COMPILED_LINK_OPTIONS1}" " ${SOUFFLE_COMPILED_LINK_OPTIONS2}")
+list(JOIN SOUFFLE_COMPILED_LIBS " " SOUFFLE_COMPILED_LINK_OPTIONS)
 
 if (CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
   set(SOUFFLE_COMPILED_LINK_OPTIONS "/link ${SOUFFLE_COMPILED_LINK_OPTIONS}")
diff --git a/src/DynamicLibrary.cpp b/src/DynamicLibrary.cpp
new file mode 100644
index 0000000..28be988
--- /dev/null
+++ b/src/DynamicLibrary.cpp
@@ -0,0 +1,84 @@
+// Copyright (c), 2016-present, Sourcebrella, Inc Ltd - All rights reserved.
+// Unauthorized copying, using, modifying of this file, via any medium is strictly prohibited.
+// Proprietary and confidential.
+//
+// Alipay.com Inc.
+// Copyright (c) 2004 All Rights Reserved.
+//
+// Author: 冰莲 (lyn249877@antfin.com)
+// File Description:
+// Creation Date: 2022-01-28
+// Modification History:
+
+#include <iostream>
+#include <vector>
+
+#include "ExtraConfig.h"
+
+extern ExtraConfig extraConfig;
+namespace souffle { int main(int argc, char **argv); }
+
+// This function is a C API for foreign functions.
+extern "C" int souffle_main(int argc, char **argv) {
+    try {
+        return souffle::main(argc, argv);
+    } catch (std::exception &e) {
+        std::cerr << "Exception Occur: " << e.what() << std::endl;
+        return 1;
+    }
+}
+
+// Soufflé 定制化入口，与 Gödel 互通
+// program_path         : 程序路径，对应 argv[0]，Soufflé 会根据这个路径搜索库或者头文件
+// query_file           : Query 文件的路径
+// query_content        : 【可空】Query 的内容，开启后不再从 query_file 中读取内容
+// fact_search_path     : 【可空】Fact 文件搜索路径
+// library_search_path  : 【可空】库搜索路径
+// library_name         : 【可空】库名
+// enable_warning       : 开启警告，非 0 为开，0 为关
+// verbose              : 开启 Verbose 信息
+// extra_args           : 【可空】额外参数，以 nullptr 结尾的数组
+
+extern "C" int souffle_entry(
+        const char *program_path,
+        const char *query_file,
+        const char *query_content,
+        const char *fact_search_path,
+        const char *library_search_path,
+        const char *library_name,
+        int enable_warning,
+        int verbose,
+        const char *extra_args[]) {
+    std::vector<const char *> args;
+    args.push_back(program_path);
+    args.push_back(query_file);
+    if (query_content != nullptr) {
+        extraConfig.setContent(query_content);
+    }
+    args.push_back("--no-preprocessor");
+    if (fact_search_path) {
+        args.push_back("-F");
+        args.push_back(fact_search_path);
+    }
+    if (library_search_path) {
+        args.push_back("-L");
+        args.push_back(library_search_path);
+    }
+    if (library_name) {
+        args.push_back("-l");
+        args.push_back(library_name);
+    }
+    if (!enable_warning) {
+        args.push_back("-w");
+    }
+    if (verbose) {
+        args.push_back("-v");
+    }
+    if (extra_args) {
+        for (const char **parg = extra_args; *parg != nullptr; ++parg) {
+            args.push_back(*parg);
+        }
+    }
+
+    return souffle_main(args.size(), const_cast<char**>(args.data()));
+}
diff --git a/src/ExtraConfig.h b/src/ExtraConfig.h
new file mode 100644
index 0000000..961a3aa
--- /dev/null
+++ b/src/ExtraConfig.h
@@ -0,0 +1,36 @@
+// Copyright (c), 2016-present, Sourcebrella, Inc Ltd - All rights reserved.
+// Unauthorized copying, using, modifying of this file, via any medium is strictly prohibited.
+// Proprietary and confidential.
+//
+// Alipay.com Inc.
+// Copyright (c) 2004 All Rights Reserved.
+//
+// Author: 冰莲 (lyn249877@antfin.com)
+// File Description:
+// Creation Date: 2022-01-28
+// Modification History:
+
+#pragma once
+
+#ifndef GODEL_EXTRACONFIG_H
+#define GODEL_EXTRACONFIG_H
+#include <memory>
+#include <string>
+
+// 针对嵌入 Gödel 的 Soufflé 程序进行的额外配置
+struct ExtraConfig
+{
+private:
+    std::unique_ptr<std::string> content; // 解析的 Soufflé 代码内容，非 nullptr 时表示直接解析内容而不是从文件读取
+
+public:
+    const std::unique_ptr<std::string>& getContent() const {
+        return content;
+    }
+
+    void setContent(const std::string &message) {
+        this->content = std::make_unique<std::string>(message);
+    }
+};
+
+#endif //GODEL_EXTRACONFIG_H
diff --git a/src/FunctorOps.cpp b/src/FunctorOps.cpp
index 394357b..178dcd8 100644
--- a/src/FunctorOps.cpp
+++ b/src/FunctorOps.cpp
@@ -48,7 +48,6 @@ char const* functorOpNameLegacy(FunctorOp op) {
         /** Binary Functor Operators */
         case FunctorOp::ADD:
         case FunctorOp::FADD:
-        case FunctorOp::SSADD:
         case FunctorOp::UADD: return "+";
         case FunctorOp::SUB:
         case FunctorOp::USUB:
@@ -224,9 +223,6 @@ const std::vector<IntrinsicFunctorInfo> FUNCTOR_INTRINSICS = {
         VARIADIC(CAT, Symbol),
         OP_1(STRLEN, Symbol, Signed),
         OP_3(SUBSTR, Symbol, Signed, Signed, Symbol, false),
-
-        {functorOpNameSymbol(FOp::SSADD), {TAttr::Symbol, TAttr::Symbol}, TAttr::Symbol, FOp::SSADD, false,
-                false},
 };
 
 template <typename F>
diff --git a/src/FunctorOps.h b/src/FunctorOps.h
index 6caebcc..2ad9895 100644
--- a/src/FunctorOps.h
+++ b/src/FunctorOps.h
@@ -101,7 +101,6 @@ enum class FunctorOp {
     FMIN,                // min of two floats
     SMAX,                // max of two symbols
     SMIN,                // min of two symbols
-    SSADD,               // string-string concatenation
 
     // Produces values within a numeric range. Format is `range(bgn, endExcl, step = 1)`.
     // e.g. `range(0, 5)` produces the sequence `0, 1, 2, 3, 4`.
@@ -165,8 +164,4 @@ bool isInfixFunctorOp(FunctorOp op);
 
 FunctorOp getMinOp(const std::string& type);
 FunctorOp getMaxOp(const std::string& type);
-
-/// Indicate if a functor can yield multiple results
-bool isFunctorMultiResult(FunctorOp op);
-
 }  // end of namespace souffle
diff --git a/src/Global.cpp b/src/Global.cpp
index 68f673a..f843690 100644
--- a/src/Global.cpp
+++ b/src/Global.cpp
@@ -182,7 +182,7 @@ void MainConfig::processArgs(int argc, char** argv, const std::string& header, c
         while ((c = getopt_long(argc, argv, shortNames.c_str(), longNames.get(), nullptr)) != -1) {
             // case for the unknown option
             if (c == '?') {
-                std::cerr << help();
+                std::cerr << Global::config().help();
                 throw std::runtime_error("Error: Unknown command line option.");
             }
             // obtain an iterator to the option in the table referenced by the current short name
@@ -217,11 +217,11 @@ void MainConfig::processArgs(int argc, char** argv, const std::string& header, c
     }
 
     // obtain the name of the datalog file, and store it in the option with the empty key
-    if (argc > 1 && !has("help") && !has("version")) {
+    if (argc > 1 && !Global::config().has("help") && !Global::config().has("version")) {
         std::string filename = "";
         // ensure that the optind is less than the total number of arguments
         if (argc > 1 && optind >= argc) {
-            std::cerr << help();
+            std::cerr << Global::config().help();
             throw std::runtime_error("Error: Missing source file path.");
         }
 
diff --git a/src/Global.h b/src/Global.h
index 5e63334..866fd61 100644
--- a/src/Global.h
+++ b/src/Global.h
@@ -104,21 +104,18 @@ private:
  * used to isolate all globals. */
 class Global {
 public:
-    Global() = default;
     /* Deleted copy constructor. */
     Global(const Global&) = delete;
     /* Deleted assignment operator. */
     Global& operator=(const Global&) = delete;
     /* Obtain the global configuration. */
-    MainConfig& config() {
-        return _config;
-    }
-
-    const MainConfig& config() const {
+    static MainConfig& config() {
+        static MainConfig _config;
         return _config;
     }
 
 private:
-    MainConfig _config;
+    /* Private empty constructor, there is only one global instance. */
+    Global() = default;
 };
 }  // namespace souffle
diff --git a/src/GraphUtils.h b/src/GraphUtils.h
index 104fe2b..aab91cf 100644
--- a/src/GraphUtils.h
+++ b/src/GraphUtils.h
@@ -13,14 +13,84 @@
  * A simple utility graph for conducting simple, graph-based operations.
  *
  ***********************************************************************/
+
 #pragma once
 
+#include "souffle/datastructure/Graph.h"
+#include "souffle/utility/FileUtil.h"
+#include <functional>
+#include <map>
 #include <ostream>
+#include <set>
 #include <string>
+#include <utility>
 #include <vector>
 
 namespace souffle {
-std::string toBase64(const std::string& data);
-std::string convertDotToSVG(const std::string& dotSpec);
-void printHTMLGraph(std::ostream& out, const std::string& dotSpec, const std::string& id);
+
+inline std::string toBase64(const std::string& data) {
+    static const std::vector<char> table = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
+            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
+            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',
+            'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'};
+    std::string result;
+    std::string tmp = data;
+    unsigned int padding = 0;
+    if (data.size() % 3 == 2) {
+        padding = 1;
+    } else if (data.size() % 3 == 1) {
+        padding = 2;
+    }
+
+    for (unsigned int i = 0; i < padding; i++) {
+        tmp.push_back(0);
+    }
+    for (unsigned int i = 0; i < tmp.size(); i += 3) {
+        auto c1 = static_cast<unsigned char>(tmp[i]);
+        auto c2 = static_cast<unsigned char>(tmp[i + 1]);
+        auto c3 = static_cast<unsigned char>(tmp[i + 2]);
+        unsigned char index1 = c1 >> 2;
+        unsigned char index2 = ((c1 & 0x03) << 4) | (c2 >> 4);
+        unsigned char index3 = ((c2 & 0x0F) << 2) | (c3 >> 6);
+        unsigned char index4 = c3 & 0x3F;
+
+        result.push_back(table[index1]);
+        result.push_back(table[index2]);
+        result.push_back(table[index3]);
+        result.push_back(table[index4]);
+    }
+    if (padding == 1) {
+        result[result.size() - 1] = '=';
+    } else if (padding == 2) {
+        result[result.size() - 1] = '=';
+        result[result.size() - 2] = '=';
+    }
+    return result;
+}
+
+inline std::string convertDotToSVG(const std::string& dotSpec) {
+    // Check if dot is present
+    std::string cmd = which("dot");
+    if (!isExecutable(cmd)) {
+        return "";
+    }
+
+    TempFileStream dotFile;
+    dotFile << dotSpec;
+    dotFile.flush();
+    return execStdOut("dot -Tsvg < " + dotFile.getFileName()).str();
+}
+
+inline void printHTMLGraph(std::ostream& out, const std::string& dotSpec, const std::string& id) {
+    std::string data = convertDotToSVG(dotSpec);
+
+    if (data.find("<svg") != std::string::npos) {
+        out << "<img alt='graph image' src='data:image/svg+xml;base64," << toBase64(data) << "'><br/>\n";
+    } else {
+        out << "<div class='" << id << "-source"
+            << "'>\n<pre>" << dotSpec << "</pre>\n";
+        out << "</div>\n";
+    }
+}
+
 }  // end of namespace souffle
diff --git a/src/LogStatement.h b/src/LogStatement.h
index 1a84c08..498d9d8 100644
--- a/src/LogStatement.h
+++ b/src/LogStatement.h
@@ -21,26 +21,19 @@
 namespace souffle {
 
 class LogStatement {
-private:
-    static std::string str(const SrcLocation& loc) {
-        return loc.getReportedPath() + " [" + std::to_string(loc.start.line) + ":" +
-               std::to_string(loc.start.column) + "-" + std::to_string(loc.end.line) + ":" +
-               std::to_string(loc.end.column) + "]";
-    }
-
 public:
     static const std::string tNonrecursiveRelation(
             const std::string& relationName, const SrcLocation& srcLocation) {
         const char* messageType = "@t-nonrecursive-relation";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";";
         return line.str();
     }
     static const std::string tRelationLoadTime(
             const std::string& relationName, const SrcLocation& srcLocation) {
         const char* messageType = "@t-relation-loadtime";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";loadtime;";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";loadtime;";
         return line.str();
     }
 
@@ -48,7 +41,7 @@ public:
             const std::string& relationName, const SrcLocation& srcLocation) {
         const char* messageType = "@t-relation-savetime";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";savetime;";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";savetime;";
         return line.str();
     }
 
@@ -56,7 +49,7 @@ public:
             const std::string& relationName, const SrcLocation& srcLocation) {
         const char* messageType = "@n-nonrecursive-relation";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";";
         return line.str();
     }
 
@@ -64,7 +57,7 @@ public:
             const std::string& relationName, const SrcLocation& srcLocation, const std::string& datalogText) {
         const char* messageType = "@t-nonrecursive-rule";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";" << datalogText << ";";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";" << datalogText << ";";
         return line.str();
     }
 
@@ -72,7 +65,7 @@ public:
             const std::string& relationName, const SrcLocation& srcLocation, const std::string& datalogText) {
         const char* messageType = "@n-nonrecursive-rule";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";" << datalogText << ";";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";" << datalogText << ";";
         return line.str();
     }
 
@@ -80,7 +73,7 @@ public:
             const SrcLocation& srcLocation, const std::string& datalogText) {
         const char* messageType = "@t-recursive-rule";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << version << ";" << str(srcLocation) << ";"
+        line << messageType << ";" << relationName << ";" << version << ";" << srcLocation << ";"
              << datalogText << ";";
         return line.str();
     }
@@ -89,7 +82,7 @@ public:
             const SrcLocation& srcLocation, const std::string& datalogText) {
         const char* messageType = "@n-recursive-rule";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << version << ";" << str(srcLocation) << ";"
+        line << messageType << ";" << relationName << ";" << version << ";" << srcLocation << ";"
              << datalogText << ";";
         return line.str();
     }
@@ -98,7 +91,7 @@ public:
             const std::string& relationName, const SrcLocation& srcLocation) {
         const char* messageType = "@t-recursive-relation";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";";
         return line.str();
     }
 
@@ -106,7 +99,7 @@ public:
             const std::string& relationName, const SrcLocation& srcLocation) {
         const char* messageType = "@n-recursive-relation";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";";
         return line.str();
     }
 
@@ -114,7 +107,7 @@ public:
             const std::string& relationName, const SrcLocation& srcLocation) {
         const char* messageType = "@c-recursive-relation";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";";
         return line.str();
     }
 
@@ -124,7 +117,7 @@ public:
         // messages are ignored
         const char* messageType = "#p-proof-counter";
         std::stringstream line;
-        line << messageType << ";" << relationName << ";" << str(srcLocation) << ";" << datalogText << ";";
+        line << messageType << ";" << relationName << ";" << srcLocation << ";" << datalogText << ";";
         // TODO (#590): the additional semicolon is added to maintain backwards compatibility and should
         // eventually be removed
         line << ";";
diff --git a/src/MainEntry.cpp b/src/MainEntry.cpp
new file mode 100644
index 0000000..a5a6416
--- /dev/null
+++ b/src/MainEntry.cpp
@@ -0,0 +1,17 @@
+// Copyright (c), 2016-present, Sourcebrella, Inc Ltd - All rights reserved.
+// Unauthorized copying, using, modifying of this file, via any medium is strictly prohibited.
+// Proprietary and confidential.
+//
+// Alipay.com Inc.
+// Copyright (c) 2004 All Rights Reserved.
+//
+// Author: 冰莲 (lyn249877@antfin.com)
+// File Description:
+// Creation Date: 2021-09-15
+// Modification History:
+
+namespace souffle { int main(int argc, char **argv); }
+
+int main(int argc, char** argv) {
+    return souffle::main(argc, argv);
+}
diff --git a/src/RelationTag.h b/src/RelationTag.h
index c6d51ca..5a85097 100644
--- a/src/RelationTag.h
+++ b/src/RelationTag.h
@@ -58,6 +58,7 @@ enum class RelationRepresentation {
     BTREE,         // use btree data-structure
     BTREE_DELETE,  // use btree_delete data-structure
     EQREL,         // use union data-structure
+    PROVENANCE,    // use custom btree data-structure with provenance extras
     INFO,          // info relation for provenance
 };
 
@@ -167,6 +168,7 @@ inline std::ostream& operator<<(std::ostream& os, RelationRepresentation represe
         case RelationRepresentation::BTREE_DELETE: return os << "btree_delete";
         case RelationRepresentation::BRIE: return os << "brie";
         case RelationRepresentation::EQREL: return os << "eqrel";
+        case RelationRepresentation::PROVENANCE: return os << "provenance";
         case RelationRepresentation::INFO: return os << "info";
         case RelationRepresentation::DEFAULT: return os;
     }
diff --git a/src/TranslationUnitBase.h b/src/TranslationUnitBase.h
index b4dcc14..e97ebec 100644
--- a/src/TranslationUnitBase.h
+++ b/src/TranslationUnitBase.h
@@ -16,13 +16,11 @@
 
 #pragma once
 
-#include "Global.h"
 #include "reports/DebugReport.h"
 #include "reports/ErrorReport.h"
 #include "souffle/utility/DynamicCasting.h"
 #include "souffle/utility/Types.h"
 #include <cassert>
-#include <cstring>
 #include <map>
 #include <memory>
 #include <ostream>
@@ -50,14 +48,9 @@ public:
         return name_as_cstr_literal;
     }
 
-    /** @brief Print the analysis result in textual format */
+    /** @brief Print the analysis result in HTML format */
     virtual void print(std::ostream& /* os */) const {}
 
-    /** @brief Print the analysis result in HTML format (or fallback to textual format) */
-    virtual void printHTML(std::ostream& os) const {
-        print(os);
-    }
-
 private:
     char const* const name_as_cstr_literal;
 };
@@ -79,8 +72,8 @@ struct TranslationUnitBase {
         virtual void run(Impl const&) = 0;
     };
 
-    TranslationUnitBase(Global& g, Own<Program> prog, ErrorReport& e, DebugReport& d)
-            : glb(g), program(std::move(prog)), errorReport(e), debugReport(d) {
+    TranslationUnitBase(Own<Program> prog, ErrorReport& e, DebugReport& d)
+            : program(std::move(prog)), errorReport(e), debugReport(d) {
         assert(program != nullptr && "program is a null-pointer");
     }
 
@@ -94,7 +87,7 @@ struct TranslationUnitBase {
             it = analyses.insert({A::name, mk<A>()}).first;
 
             auto& analysis = *it->second;
-            assert((std::strcmp(analysis.getName(), A::name) == 0) && "must be same pointer");
+            assert(analysis.getName() == A::name && "must be same pointer");
             analysis.run(static_cast<Impl const&>(*this));
             logAnalysis(analysis);
         }
@@ -116,11 +109,6 @@ struct TranslationUnitBase {
         analyses.clear();
     }
 
-    /** @brief Get the global configuration */
-    Global& global() const {
-        return glb;
-    }
-
     /** @brief Get the RAM Program of the translation unit  */
     Program& getProgram() const {
         return *program;
@@ -145,8 +133,6 @@ protected:
     //       Using `std::string` appears to suppress the issue (bug?).
     mutable std::map<std::string, Own<Analysis>> analyses;
 
-    Global& glb;
-
     /* RAM program */
     Own<Program> program;
 
diff --git a/src/ast/Aggregator.cpp b/src/ast/Aggregator.cpp
index 981ea55..acc6f25 100644
--- a/src/ast/Aggregator.cpp
+++ b/src/ast/Aggregator.cpp
@@ -16,23 +16,21 @@
 #include <utility>
 
 namespace souffle::ast {
-Aggregator::Aggregator(NodeKind kind, Own<Argument> expr, VecOwn<Literal> body, SrcLocation loc)
-        : Argument(kind, std::move(loc)), targetExpression(std::move(expr)), body(std::move(body)) {
+Aggregator::Aggregator(AggregateOp baseOperator, Own<Argument> expr, VecOwn<Literal> body, SrcLocation loc)
+        : Argument(std::move(loc)), baseOperator(baseOperator), targetExpression(std::move(expr)),
+          body(std::move(body)) {
     // NOTE: targetExpression can be nullptr - it's used e.g. when aggregator
     // has no parameters, such as count: { body }
     assert(allValidPtrs(this->body));
-    assert(kind >= NK_Aggregator && kind < NK_LastAggregator);
 }
 
 std::vector<Literal*> Aggregator::getBodyLiterals() const {
     return toPtrVector(body);
 }
 
-VecOwn<Literal> Aggregator::setBodyLiterals(VecOwn<Literal> bodyLiterals) {
+void Aggregator::setBodyLiterals(VecOwn<Literal> bodyLiterals) {
     assert(allValidPtrs(body));
-    auto oldBody = std::move(body);
     body = std::move(bodyLiterals);
-    return oldBody;
 }
 
 void Aggregator::apply(const NodeMapper& map) {
@@ -43,9 +41,22 @@ void Aggregator::apply(const NodeMapper& map) {
     mapAll(body, map);
 }
 
-bool Aggregator::classof(const Node* n) {
-    const NodeKind kind = n->getKind();
-    return (kind >= NK_Aggregator && kind < NK_LastAggregator);
+void Aggregator::print(std::ostream& os) const {
+    os << baseOperator;
+    if (targetExpression) {
+        os << " " << *targetExpression;
+    }
+    os << " : { " << join(body) << " }";
+}
+
+bool Aggregator::equal(const Node& node) const {
+    const auto& other = asAssert<Aggregator>(node);
+    return baseOperator == other.baseOperator && equal_ptr(targetExpression, other.targetExpression) &&
+           equal_targets(body, other.body);
+}
+
+Aggregator* Aggregator::cloning() const {
+    return new Aggregator(baseOperator, clone(targetExpression), clone(body), getSrcLoc());
 }
 
 Node::NodeVec Aggregator::getChildren() const {
diff --git a/src/ast/Aggregator.h b/src/ast/Aggregator.h
index 54f58c5..4e07556 100644
--- a/src/ast/Aggregator.h
+++ b/src/ast/Aggregator.h
@@ -38,7 +38,13 @@ namespace souffle::ast {
  */
 class Aggregator : public Argument {
 public:
-    Aggregator(NodeKind Kind, Own<Argument> expr = {}, VecOwn<Literal> body = {}, SrcLocation loc = {});
+    Aggregator(AggregateOp baseOperator, Own<Argument> expr = {}, VecOwn<Literal> body = {},
+            SrcLocation loc = {});
+
+    /** Return the (base type) operator of the aggregator */
+    AggregateOp getBaseOperator() const {
+        return baseOperator;
+    }
 
     /** Return target expression */
     const Argument* getTargetExpression() const {
@@ -52,18 +58,25 @@ public:
     /** Return body literals */
     std::vector<Literal*> getBodyLiterals() const;
 
-    /** Set body literals, returns previous body literals */
-    VecOwn<Literal> setBodyLiterals(VecOwn<Literal> bodyLiterals);
+    /** Set body literals */
+    void setBodyLiterals(VecOwn<Literal> bodyLiterals);
 
     void apply(const NodeMapper& map) override;
 
-    virtual std::string getBaseOperatorName() const = 0;
-
-    static bool classof(const Node*);
-
 protected:
+    void print(std::ostream& os) const override;
+
     NodeVec getChildren() const override;
 
+private:
+    bool equal(const Node& node) const override;
+
+    Aggregator* cloning() const override;
+
+private:
+    /** Aggregate (base type) operator */
+    AggregateOp baseOperator;
+
     /** Aggregate expression */
     Own<Argument> targetExpression;
 
diff --git a/src/ast/AlgebraicDataType.cpp b/src/ast/AlgebraicDataType.cpp
index 716c94d..77d678d 100644
--- a/src/ast/AlgebraicDataType.cpp
+++ b/src/ast/AlgebraicDataType.cpp
@@ -16,7 +16,7 @@
 namespace souffle::ast {
 
 AlgebraicDataType::AlgebraicDataType(QualifiedName name, VecOwn<BranchType> branches, SrcLocation loc)
-        : Type(NK_AlgebraicDataType, std::move(name), std::move(loc)), branches(std::move(branches)) {
+        : Type(std::move(name), std::move(loc)), branches(std::move(branches)) {
     assert(!this->branches.empty());
     assert(allValidPtrs(this->branches));
 }
@@ -31,7 +31,6 @@ Node::NodeVec AlgebraicDataType::getChildren() const {
 }
 
 void AlgebraicDataType::print(std::ostream& os) const {
-    printAnnotations(os);
     os << tfm::format(".type %s = %s", getQualifiedName(), join(branches, " | "));
 }
 
@@ -44,8 +43,4 @@ AlgebraicDataType* AlgebraicDataType::cloning() const {
     return new AlgebraicDataType(getQualifiedName(), clone(branches), getSrcLoc());
 }
 
-bool AlgebraicDataType::classof(const Node* n) {
-    return n->getKind() == NK_AlgebraicDataType;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/AlgebraicDataType.h b/src/ast/AlgebraicDataType.h
index fb63b0c..c6e73d3 100644
--- a/src/ast/AlgebraicDataType.h
+++ b/src/ast/AlgebraicDataType.h
@@ -44,8 +44,6 @@ public:
 
     std::vector<BranchType*> getBranches() const;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/AliasType.cpp b/src/ast/AliasType.cpp
index f60dea5..e5e43ea 100644
--- a/src/ast/AliasType.cpp
+++ b/src/ast/AliasType.cpp
@@ -14,7 +14,7 @@
 namespace souffle::ast {
 
 AliasType::AliasType(QualifiedName name, QualifiedName aliasTypeName, SrcLocation loc)
-        : Type(NK_AliasType, std::move(name), std::move(loc)), aliasType(std::move(aliasTypeName)) {}
+        : Type(std::move(name), std::move(loc)), aliasType(std::move(aliasTypeName)) {}
 
 void AliasType::print(std::ostream& os) const {
     os << ".type " << getQualifiedName() << " = " << getAliasType();
@@ -29,8 +29,4 @@ AliasType* AliasType::cloning() const {
     return new AliasType(getQualifiedName(), getAliasType(), getSrcLoc());
 }
 
-bool AliasType::classof(const Node* n) {
-    return n->getKind() == NK_AliasType;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/AliasType.h b/src/ast/AliasType.h
index 9813667..4b79965 100644
--- a/src/ast/AliasType.h
+++ b/src/ast/AliasType.h
@@ -44,8 +44,6 @@ public:
         aliasType = type;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Argument.h b/src/ast/Argument.h
index b202230..cb8b259 100644
--- a/src/ast/Argument.h
+++ b/src/ast/Argument.h
@@ -27,11 +27,6 @@ namespace souffle::ast {
 class Argument : public Node {
 public:
     using Node::Node;
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Argument && kind < NK_LastArgument);
-    }
 };
 
 }  // namespace souffle::ast
diff --git a/src/ast/Atom.cpp b/src/ast/Atom.cpp
index f6505a0..7fe72ab 100644
--- a/src/ast/Atom.cpp
+++ b/src/ast/Atom.cpp
@@ -26,7 +26,7 @@ namespace souffle::ast {
  * e.g., parent(x,y), !parent(x,y), ...
  */
 Atom::Atom(QualifiedName name, VecOwn<Argument> args, SrcLocation loc)
-        : Literal(NK_Atom, std::move(loc)), name(std::move(name)), arguments(std::move(args)) {
+        : Literal(std::move(loc)), name(std::move(name)), arguments(std::move(args)) {
     assert(allValidPtrs(arguments));
 }
 
@@ -53,7 +53,6 @@ Node::NodeVec Atom::getChildren() const {
 }
 
 void Atom::print(std::ostream& os) const {
-    printAnnotations(os);
     os << getQualifiedName() << "(" << join(arguments) << ")";
 }
 
@@ -66,8 +65,4 @@ Atom* Atom::cloning() const {
     return new Atom(name, clone(arguments), getSrcLoc());
 }
 
-bool Atom::classof(const Node* n) {
-    return n->getKind() == NK_Atom;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Atom.h b/src/ast/Atom.h
index 9e52a32..795f5dd 100644
--- a/src/ast/Atom.h
+++ b/src/ast/Atom.h
@@ -60,8 +60,6 @@ public:
 
     void apply(const NodeMapper& map) override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Attribute.cpp b/src/ast/Attribute.cpp
index 6a8a4bd..a06fdab 100644
--- a/src/ast/Attribute.cpp
+++ b/src/ast/Attribute.cpp
@@ -14,39 +14,23 @@
 namespace souffle::ast {
 
 Attribute::Attribute(std::string n, QualifiedName t, SrcLocation loc)
-        : Node(NK_Attribute, std::move(loc)), name(std::move(n)), typeName(std::move(t)), isLattice(false) {}
-
-Attribute::Attribute(std::string n, QualifiedName t, bool isLattice, SrcLocation loc)
-        : Node(NK_Attribute, std::move(loc)), name(std::move(n)), typeName(std::move(t)),
-          isLattice(isLattice) {}
+        : Node(std::move(loc)), name(std::move(n)), typeName(std::move(t)) {}
 
 void Attribute::setTypeName(QualifiedName name) {
     typeName = std::move(name);
 }
 
 void Attribute::print(std::ostream& os) const {
-    printAnnotations(os);
     os << name << ":" << typeName;
-    if (isLattice) {
-        os << "<>";
-    }
 }
 
 bool Attribute::equal(const Node& node) const {
     const auto& other = asAssert<Attribute>(node);
-    return name == other.name && typeName == other.typeName && isLattice == other.isLattice;
+    return name == other.name && typeName == other.typeName;
 }
 
 Attribute* Attribute::cloning() const {
-    return new Attribute(name, typeName, isLattice, getSrcLoc());
-}
-
-bool Attribute::classof(const Node* n) {
-    return n->getKind() == NK_Attribute;
-}
-
-bool Attribute::getIsLattice() const {
-    return isLattice;
+    return new Attribute(name, typeName, getSrcLoc());
 }
 
 }  // namespace souffle::ast
diff --git a/src/ast/Attribute.h b/src/ast/Attribute.h
index 3d41fa1..ecea916 100644
--- a/src/ast/Attribute.h
+++ b/src/ast/Attribute.h
@@ -35,7 +35,6 @@ namespace souffle::ast {
 class Attribute : public Node {
 public:
     Attribute(std::string n, QualifiedName t, SrcLocation loc = {});
-    Attribute(std::string n, QualifiedName t, bool isLattice, SrcLocation loc = {});
 
     /** Return attribute name */
     const std::string& getName() const {
@@ -50,10 +49,6 @@ public:
     /** Set type name */
     void setTypeName(QualifiedName name);
 
-    bool getIsLattice() const;
-
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
@@ -68,9 +63,6 @@ private:
 
     /** Type name */
     QualifiedName typeName;
-
-    /** Is lattice element */
-    bool isLattice;
 };
 
 }  // namespace souffle::ast
diff --git a/src/ast/BinaryConstraint.cpp b/src/ast/BinaryConstraint.cpp
index 4f0cc8f..0104815 100644
--- a/src/ast/BinaryConstraint.cpp
+++ b/src/ast/BinaryConstraint.cpp
@@ -15,8 +15,7 @@
 namespace souffle::ast {
 
 BinaryConstraint::BinaryConstraint(BinaryConstraintOp o, Own<Argument> ls, Own<Argument> rs, SrcLocation loc)
-        : Constraint(NK_BinaryConstraint, std::move(loc)), operation(o), lhs(std::move(ls)),
-          rhs(std::move(rs)) {
+        : Constraint(std::move(loc)), operation(o), lhs(std::move(ls)), rhs(std::move(rs)) {
     assert(lhs != nullptr);
     assert(rhs != nullptr);
 }
@@ -47,8 +46,4 @@ BinaryConstraint* BinaryConstraint::cloning() const {
     return new BinaryConstraint(operation, clone(lhs), clone(rhs), getSrcLoc());
 }
 
-bool BinaryConstraint::classof(const Node* n) {
-    return n->getKind() == NK_BinaryConstraint;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/BinaryConstraint.h b/src/ast/BinaryConstraint.h
index 3a02814..911fbf7 100644
--- a/src/ast/BinaryConstraint.h
+++ b/src/ast/BinaryConstraint.h
@@ -61,8 +61,6 @@ public:
 
     void apply(const NodeMapper& map) override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/BooleanConstraint.cpp b/src/ast/BooleanConstraint.cpp
index 1dba292..0a8251e 100644
--- a/src/ast/BooleanConstraint.cpp
+++ b/src/ast/BooleanConstraint.cpp
@@ -24,7 +24,7 @@ namespace souffle::ast {
  * Boolean constraint representing either the 'true' or the 'false' value
  */
 BooleanConstraint::BooleanConstraint(bool truthValue, SrcLocation loc)
-        : Constraint(NK_BooleanConstraint, std::move(loc)), truthValue(truthValue) {}
+        : Constraint(std::move(loc)), truthValue(truthValue) {}
 
 void BooleanConstraint::print(std::ostream& os) const {
     os << (truthValue ? "true" : "false");
@@ -39,8 +39,4 @@ BooleanConstraint* BooleanConstraint::cloning() const {
     return new BooleanConstraint(truthValue, getSrcLoc());
 }
 
-bool BooleanConstraint::classof(const Node* n) {
-    return n->getKind() == NK_BooleanConstraint;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/BooleanConstraint.h b/src/ast/BooleanConstraint.h
index f4f6b23..f6ac7cf 100644
--- a/src/ast/BooleanConstraint.h
+++ b/src/ast/BooleanConstraint.h
@@ -45,8 +45,6 @@ public:
         truthValue = value;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/BranchInit.cpp b/src/ast/BranchInit.cpp
index 7a0a9c5..6813df7 100644
--- a/src/ast/BranchInit.cpp
+++ b/src/ast/BranchInit.cpp
@@ -18,7 +18,7 @@
 namespace souffle::ast {
 
 BranchInit::BranchInit(QualifiedName name, VecOwn<Argument> args, SrcLocation loc)
-        : Term(NK_BranchInit, std::move(args), std::move(loc)), name(std::move(name)) {}
+        : Term(std::move(args), std::move(loc)), name(std::move(name)) {}
 
 void BranchInit::print(std::ostream& os) const {
     os << tfm::format("$%s(%s)", name, join(args, ", "));
@@ -33,7 +33,4 @@ BranchInit* BranchInit::cloning() const {
     return new BranchInit(name, clone(args), getSrcLoc());
 }
 
-bool BranchInit::classof(const Node* n) {
-    return n->getKind() == NK_BranchInit;
-}
 }  // namespace souffle::ast
diff --git a/src/ast/BranchInit.h b/src/ast/BranchInit.h
index 9585b73..c948fea 100644
--- a/src/ast/BranchInit.h
+++ b/src/ast/BranchInit.h
@@ -49,8 +49,6 @@ public:
         this->name = name;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/BranchType.cpp b/src/ast/BranchType.cpp
index cb73677..1237314 100644
--- a/src/ast/BranchType.cpp
+++ b/src/ast/BranchType.cpp
@@ -16,7 +16,7 @@
 namespace souffle::ast {
 
 BranchType::BranchType(QualifiedName name, VecOwn<Attribute> fields, SrcLocation loc)
-        : Node(NK_BranchType, std::move(loc)), name(std::move(name)), fields(std::move(fields)) {
+        : Node(std::move(loc)), name(std::move(name)), fields(std::move(fields)) {
     assert(allValidPtrs(this->fields));
 }
 
@@ -25,7 +25,6 @@ std::vector<Attribute*> BranchType::getFields() {
 }
 
 void BranchType::print(std::ostream& os) const {
-    printAnnotations(os);
     os << tfm::format("%s {%s}", name, join(fields, ", "));
 }
 
@@ -37,12 +36,4 @@ void BranchType::setFieldType(std::size_t idx, QualifiedName type) {
     fields.at(idx)->setTypeName(std::move(type));
 }
 
-bool BranchType::classof(const Node* n) {
-    return n->getKind() == NK_BranchType;
-}
-
-bool BranchType::equal(const Node& /* other */) const {
-    return false;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/BranchType.h b/src/ast/BranchType.h
index a69e4c9..ab86de5 100644
--- a/src/ast/BranchType.h
+++ b/src/ast/BranchType.h
@@ -58,14 +58,10 @@ public:
     /** Set field type */
     void setFieldType(std::size_t idx, QualifiedName type);
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
 private:
-    bool equal(const Node& /* other */) const override;
-
     BranchType* cloning() const override;
 
 private:
diff --git a/src/ast/Clause.cpp b/src/ast/Clause.cpp
index e682bac..818fa6b 100644
--- a/src/ast/Clause.cpp
+++ b/src/ast/Clause.cpp
@@ -17,19 +17,14 @@
 
 namespace souffle::ast {
 
-Clause::Clause(
-        NodeKind kind, Own<Atom> head, VecOwn<Literal> bodyLiterals, Own<ExecutionPlan> plan, SrcLocation loc)
-        : Node(kind, std::move(loc)), head(std::move(head)), bodyLiterals(std::move(bodyLiterals)),
+Clause::Clause(Own<Atom> head, VecOwn<Literal> bodyLiterals, Own<ExecutionPlan> plan, SrcLocation loc)
+        : Node(std::move(loc)), head(std::move(head)), bodyLiterals(std::move(bodyLiterals)),
           plan(std::move(plan)) {
     assert(this->head != nullptr);
     assert(allValidPtrs(this->bodyLiterals));
-    assert(kind >= NK_Clause && kind < NK_LastClause);
     // Execution plan can be null
 }
 
-Clause::Clause(Own<Atom> head, VecOwn<Literal> bodyLiterals, Own<ExecutionPlan> plan, SrcLocation loc)
-        : Clause(NK_Clause, std::move(head), std::move(bodyLiterals), std::move(plan), std::move(loc)) {}
-
 Clause::Clause(Own<Atom> head, SrcLocation loc) : Clause(std::move(head), {}, {}, std::move(loc)) {}
 
 Clause::Clause(QualifiedName name, SrcLocation loc) : Clause(mk<Atom>(name), std::move(loc)) {}
@@ -74,7 +69,6 @@ Node::NodeVec Clause::getChildren() const {
 }
 
 void Clause::print(std::ostream& os) const {
-    printAnnotations(os);
     os << *head;
     if (!bodyLiterals.empty()) {
         os << " :- \n   " << join(bodyLiterals, ",\n   ");
@@ -85,14 +79,6 @@ void Clause::print(std::ostream& os) const {
     }
 }
 
-void Clause::printForDebugInfo(std::ostream& os) const {
-    os << *head;
-    if (!bodyLiterals.empty()) {
-        os << " :- \n   " << join(bodyLiterals, ",\n   ");
-    }
-    os << ".";
-}
-
 bool Clause::equal(const Node& node) const {
     const auto& other = asAssert<Clause>(node);
     return equal_ptr(head, other.head) && equal_targets(bodyLiterals, other.bodyLiterals) &&
@@ -100,8 +86,7 @@ bool Clause::equal(const Node& node) const {
 }
 
 Clause* Clause::cloning() const {
-    auto* cl = new Clause(clone(head), clone(bodyLiterals), clone(plan), getSrcLoc());
-    return cl;
+    return new Clause(clone(head), clone(bodyLiterals), clone(plan), getSrcLoc());
 }
 
 Clause* Clause::cloneHead() const {
@@ -109,13 +94,7 @@ Clause* Clause::cloneHead() const {
     if (getExecutionPlan() != nullptr) {
         myClone->setExecutionPlan(clone(getExecutionPlan()));
     }
-    myClone->setAnnotationsFrom(*this);
     return myClone;
 }
 
-bool Clause::classof(const Node* n) {
-    const NodeKind kind = n->getKind();
-    return (kind >= NK_Clause && kind < NK_LastClause);
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Clause.h b/src/ast/Clause.h
index b7b1eb7..5533335 100644
--- a/src/ast/Clause.h
+++ b/src/ast/Clause.h
@@ -37,9 +37,6 @@ namespace souffle::ast {
  */
 class Clause : public Node {
 public:
-    Clause(NodeKind kind, Own<Atom> head, VecOwn<Literal> bodyLiterals, Own<ExecutionPlan> plan = {},
-            SrcLocation loc = {});
-
     Clause(Own<Atom> head, VecOwn<Literal> bodyLiterals, Own<ExecutionPlan> plan = {}, SrcLocation loc = {});
 
     Clause(Own<Atom> head, SrcLocation loc = {});
@@ -84,11 +81,6 @@ public:
 
     void apply(const NodeMapper& map) override;
 
-    /** Print this clause for `ram::DebugInfo` without annotations */
-    void printForDebugInfo(std::ostream& os) const;
-
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Component.cpp b/src/ast/Component.cpp
index 43a9cca..97129a0 100644
--- a/src/ast/Component.cpp
+++ b/src/ast/Component.cpp
@@ -16,9 +16,6 @@
 #include <utility>
 
 namespace souffle::ast {
-
-Component::Component(SrcLocation loc) : Node(NK_Component, loc) {}
-
 void Component::setComponentType(Own<ComponentType> other) {
     assert(other != nullptr);
     componentType = std::move(other);
@@ -42,15 +39,6 @@ std::vector<Type*> Component::getTypes() const {
     return toPtrVector(types);
 }
 
-void Component::addLattice(Own<Lattice> t) {
-    assert(t != nullptr);
-    lattices.push_back(std::move(t));
-}
-
-std::vector<Lattice*> Component::getLattices() const {
-    return toPtrVector(lattices);
-}
-
 void Component::copyBaseComponents(const Component& other) {
     baseComponents = clone(other.baseComponents);
 }
@@ -130,7 +118,6 @@ void Component::print(std::ostream& os) const {
         os << prefix << join(xs, sep) << "\n";
     };
 
-    printAnnotations(os);
     os << ".comp " << *componentType << " ";
     show(baseComponents, ",", ": ");
     os << "{\n";
@@ -159,7 +146,6 @@ bool Component::equal(const Node& node) const {
             equal_targets(relations, other.relations) &&
             equal_targets(clauses, other.clauses) &&
             equal_targets(directives, other.directives) &&
-            equal_targets(lattices, other.lattices) &&
             overrideRules != other.overrideRules);
            // clang-format off
 }
@@ -174,13 +160,8 @@ Component* Component::cloning() const {
     res->relations = clone(relations);
     res->clauses = clone(clauses);
     res->directives = clone(directives);
-    res->lattices = clone(lattices);
     res->overrideRules = overrideRules;
     return res;
 }
 
-bool Component::classof(const Node* n) {
-    return n->getKind() == NK_Component;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Component.h b/src/ast/Component.h
index bd3fb0f..99befb8 100644
--- a/src/ast/Component.h
+++ b/src/ast/Component.h
@@ -20,8 +20,6 @@
 #include "ast/ComponentInit.h"
 #include "ast/ComponentType.h"
 #include "ast/Directive.h"
-#include "ast/ItemContainer.h"
-#include "ast/Lattice.h"
 #include "ast/Node.h"
 #include "ast/Relation.h"
 #include "ast/Type.h"
@@ -44,10 +42,8 @@ namespace souffle::ast {
  *
  * Component consists of type declaration, relations, rules, etc.
  */
-class Component : public Node, public ItemContainer {
+class Component : public Node {
 public:
-    Component(SrcLocation loc = {});
-
     /** Get component type */
     const ComponentType* getComponentType() const {
         return componentType.get();
@@ -63,48 +59,43 @@ public:
     void addBaseComponent(Own<ComponentType> component);
 
     /** Add type */
-    void addType(Own<Type> t) override;
+    void addType(Own<Type> t);
 
     /** Get types */
-    std::vector<Type*> getTypes() const override;
-
-    /** Add lattice */
-    void addLattice(Own<Lattice> lat) override;
-
-    std::vector<Lattice*> getLattices() const override;
+    std::vector<Type*> getTypes() const;
 
     /** Copy base components */
     void copyBaseComponents(const Component& other);
 
     /** Add relation */
-    void addRelation(Own<Relation> r) override;
+    void addRelation(Own<Relation> r);
 
     /** Get relations */
-    std::vector<Relation*> getRelations() const override;
+    std::vector<Relation*> getRelations() const;
 
     /** Add clause */
-    void addClause(Own<Clause> c) override;
+    void addClause(Own<Clause> c);
 
     /** Get clauses */
-    std::vector<Clause*> getClauses() const override;
+    std::vector<Clause*> getClauses() const;
 
     /** Add directive */
-    void addDirective(Own<Directive> directive) override;
+    void addDirective(Own<Directive> directive);
 
     /** Get directive statements */
-    std::vector<Directive*> getDirectives() const override;
+    std::vector<Directive*> getDirectives() const;
 
     /** Add components */
-    void addComponent(Own<Component> c) override;
+    void addComponent(Own<Component> c);
 
     /** Get components */
-    std::vector<Component*> getComponents() const override;
+    std::vector<Component*> getComponents() const;
 
     /** Add instantiation */
-    void addInstantiation(Own<ComponentInit> i) override;
+    void addInstantiation(Own<ComponentInit> i);
 
     /** Get instantiation */
-    std::vector<ComponentInit*> getInstantiations() const override;
+    std::vector<ComponentInit*> getInstantiations() const;
 
     /** Add override */
     void addOverride(const std::string& name) {
@@ -118,8 +109,6 @@ public:
 
     void apply(const NodeMapper& mapper) override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
@@ -140,9 +129,6 @@ private:
     /** Types declarations */
     VecOwn<Type> types;
 
-    /** Types declarations */
-    VecOwn<Lattice> lattices;
-
     /** Relations */
     VecOwn<Relation> relations;
 
diff --git a/src/ast/ComponentInit.cpp b/src/ast/ComponentInit.cpp
index 2bfd92a..0406977 100644
--- a/src/ast/ComponentInit.cpp
+++ b/src/ast/ComponentInit.cpp
@@ -15,8 +15,7 @@
 namespace souffle::ast {
 
 ComponentInit::ComponentInit(std::string name, Own<ComponentType> type, SrcLocation loc)
-        : Node(NK_ComponentInit, std::move(loc)), instanceName(std::move(name)),
-          componentType(std::move(type)) {
+        : Node(std::move(loc)), instanceName(std::move(name)), componentType(std::move(type)) {
     assert(componentType);
 }
 
@@ -38,7 +37,6 @@ Node::NodeVec ComponentInit::getChildren() const {
 }
 
 void ComponentInit::print(std::ostream& os) const {
-    printAnnotations(os);
     os << ".init " << instanceName << " = " << *componentType;
 }
 
@@ -50,9 +48,4 @@ bool ComponentInit::equal(const Node& node) const {
 ComponentInit* ComponentInit::cloning() const {
     return new ComponentInit(instanceName, clone(componentType), getSrcLoc());
 }
-
-bool ComponentInit::classof(const Node* n) {
-    return n->getKind() == NK_ComponentInit;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/ComponentInit.h b/src/ast/ComponentInit.h
index af3e5c9..8a6fbaf 100644
--- a/src/ast/ComponentInit.h
+++ b/src/ast/ComponentInit.h
@@ -55,8 +55,6 @@ public:
 
     void apply(const NodeMapper& mapper) override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/ComponentType.cpp b/src/ast/ComponentType.cpp
index f831517..07236e4 100644
--- a/src/ast/ComponentType.cpp
+++ b/src/ast/ComponentType.cpp
@@ -15,7 +15,7 @@
 namespace souffle::ast {
 
 ComponentType::ComponentType(std::string name, std::vector<QualifiedName> params, SrcLocation loc)
-        : Node(NK_ComponentType, std::move(loc)), name(std::move(name)), typeParams(std::move(params)) {}
+        : Node(std::move(loc)), name(std::move(name)), typeParams(std::move(params)) {}
 
 void ComponentType::print(std::ostream& os) const {
     os << name;
@@ -33,8 +33,4 @@ ComponentType* ComponentType::cloning() const {
     return new ComponentType(name, typeParams, getSrcLoc());
 }
 
-bool ComponentType::classof(const Node* n) {
-    return n->getKind() == NK_ComponentType;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/ComponentType.h b/src/ast/ComponentType.h
index 4d7e45b..92ff83b 100644
--- a/src/ast/ComponentType.h
+++ b/src/ast/ComponentType.h
@@ -56,8 +56,6 @@ public:
         typeParams = params;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Constant.cpp b/src/ast/Constant.cpp
index 04e7e1d..f3fbd0d 100644
--- a/src/ast/Constant.cpp
+++ b/src/ast/Constant.cpp
@@ -12,10 +12,8 @@
 #include <utility>
 
 namespace souffle::ast {
-Constant::Constant(NodeKind kind, std::string value, SrcLocation loc)
-        : Argument(kind, std::move(loc)), constant(std::move(value)) {
-    assert(kind >= NK_Constant && kind < NK_LastConstant);
-};
+Constant::Constant(std::string value, SrcLocation loc)
+        : Argument(std::move(loc)), constant(std::move(value)){};
 
 void Constant::print(std::ostream& os) const {
     os << getConstant();
@@ -26,9 +24,4 @@ bool Constant::equal(const Node& node) const {
     return constant == other.constant;
 }
 
-bool Constant::classof(const Node* n) {
-    const NodeKind kind = n->getKind();
-    return (kind >= NK_Constant && kind < NK_LastConstant);
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Constant.h b/src/ast/Constant.h
index 80bef18..47f291f 100644
--- a/src/ast/Constant.h
+++ b/src/ast/Constant.h
@@ -34,10 +34,8 @@ public:
         return constant;
     }
 
-    static bool classof(const Node*);
-
 protected:
-    Constant(NodeKind kind, std::string value, SrcLocation loc = {});
+    Constant(std::string value, SrcLocation loc = {});
 
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Constraint.h b/src/ast/Constraint.h
index 0b0bb91..fe7b2cc 100644
--- a/src/ast/Constraint.h
+++ b/src/ast/Constraint.h
@@ -27,15 +27,6 @@ namespace souffle::ast {
 class Constraint : public Literal {
 public:
     using Literal::Literal;
-
-    Constraint(NodeKind kind, SrcLocation loc = {}) : Literal(kind, loc) {
-        assert(kind >= NK_Constraint && kind < NK_LastConstraint);
-    }
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Constraint && kind < NK_LastConstraint);
-    }
 };
 
 }  // namespace souffle::ast
diff --git a/src/ast/Counter.cpp b/src/ast/Counter.cpp
index 0f2fd91..a372e9a 100644
--- a/src/ast/Counter.cpp
+++ b/src/ast/Counter.cpp
@@ -11,8 +11,6 @@
 
 namespace souffle::ast {
 
-Counter::Counter(SrcLocation loc) : Argument(NK_Counter, std::move(loc)) {}
-
 void Counter::print(std::ostream& os) const {
     os << "$";
 }
@@ -21,12 +19,4 @@ Counter* Counter::cloning() const {
     return new Counter(getSrcLoc());
 }
 
-bool Counter::classof(const Node* n) {
-    return n->getKind() == NK_Counter;
-}
-
-bool Counter::equal(const Node&) const {
-    return true;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Counter.h b/src/ast/Counter.h
index 0f5551d..aaac742 100644
--- a/src/ast/Counter.h
+++ b/src/ast/Counter.h
@@ -29,16 +29,10 @@ class Counter : public Argument {
 public:
     using Argument::Argument;
 
-    Counter(SrcLocation = {});
-
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
 private:
-    bool equal(const Node&) const override;
-
     Counter* cloning() const override;
 };
 
diff --git a/src/ast/Directive.cpp b/src/ast/Directive.cpp
index bc3cba7..693faac 100644
--- a/src/ast/Directive.cpp
+++ b/src/ast/Directive.cpp
@@ -26,7 +26,7 @@ std::ostream& operator<<(std::ostream& os, DirectiveType e) {
 }
 
 Directive::Directive(DirectiveType type, QualifiedName name, SrcLocation loc)
-        : Node(NK_Directive, std::move(loc)), type(type), name(std::move(name)) {}
+        : Node(std::move(loc)), type(type), name(std::move(name)) {}
 
 void Directive::setQualifiedName(QualifiedName name) {
     this->name = std::move(name);
@@ -37,7 +37,6 @@ void Directive::addParameter(const std::string& key, std::string value) {
 }
 
 void Directive::print(std::ostream& os) const {
-    printAnnotations(os);
     os << "." << type << " " << name;
     if (!parameters.empty()) {
         os << "(" << join(parameters, ",", [](std::ostream& out, const auto& arg) {
@@ -57,8 +56,4 @@ Directive* Directive::cloning() const {
     return res;
 }
 
-bool Directive::classof(const Node* n) {
-    return n->getKind() == NK_Directive;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Directive.h b/src/ast/Directive.h
index 360d0a3..94c03a6 100644
--- a/src/ast/Directive.h
+++ b/src/ast/Directive.h
@@ -75,8 +75,6 @@ public:
         return parameters;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/ExecutionOrder.cpp b/src/ast/ExecutionOrder.cpp
index 188a53f..3a3a1bd 100644
--- a/src/ast/ExecutionOrder.cpp
+++ b/src/ast/ExecutionOrder.cpp
@@ -15,7 +15,7 @@
 namespace souffle::ast {
 
 ExecutionOrder::ExecutionOrder(ExecOrder order, SrcLocation loc)
-        : Node(NK_ExecutionOrder, std::move(loc)), order(std::move(order)) {}
+        : Node(std::move(loc)), order(std::move(order)) {}
 
 void ExecutionOrder::print(std::ostream& out) const {
     out << "(" << join(order) << ")";
@@ -30,8 +30,4 @@ ExecutionOrder* ExecutionOrder::cloning() const {
     return new ExecutionOrder(order, getSrcLoc());
 }
 
-bool ExecutionOrder::classof(const Node* n) {
-    return n->getKind() == NK_ExecutionOrder;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/ExecutionOrder.h b/src/ast/ExecutionOrder.h
index 31829c5..d5173d0 100644
--- a/src/ast/ExecutionOrder.h
+++ b/src/ast/ExecutionOrder.h
@@ -39,8 +39,6 @@ public:
         return order;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& out) const override;
 
diff --git a/src/ast/ExecutionPlan.cpp b/src/ast/ExecutionPlan.cpp
index 219effe..0a888c8 100644
--- a/src/ast/ExecutionPlan.cpp
+++ b/src/ast/ExecutionPlan.cpp
@@ -16,8 +16,6 @@
 
 namespace souffle::ast {
 
-ExecutionPlan::ExecutionPlan(SrcLocation loc) : Node(NK_ExecutionPlan, std::move(loc)) {}
-
 /** Set execution order for a given rule version */
 void ExecutionPlan::setOrderFor(std::size_t version, Own<ExecutionOrder> plan) {
     assert(plan != nullptr);
@@ -64,9 +62,4 @@ ExecutionPlan* ExecutionPlan::cloning() const {
     }
     return res.release();
 }
-
-bool ExecutionPlan::classof(const Node* n) {
-    return n->getKind() == NK_ExecutionPlan;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/ExecutionPlan.h b/src/ast/ExecutionPlan.h
index 5ad3830..7350608 100644
--- a/src/ast/ExecutionPlan.h
+++ b/src/ast/ExecutionPlan.h
@@ -39,8 +39,6 @@ class ExecutionPlan : public Node {
 public:
     using Node::Node;
 
-    ExecutionPlan(SrcLocation = {});
-
     /** Set execution order for a given rule version */
     void setOrderFor(std::size_t version, Own<ExecutionOrder> plan);
 
@@ -51,8 +49,6 @@ public:
 
     NodeVec getChildren() const override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& out) const override;
 
diff --git a/src/ast/FunctionalConstraint.cpp b/src/ast/FunctionalConstraint.cpp
index 3872014..e50328a 100644
--- a/src/ast/FunctionalConstraint.cpp
+++ b/src/ast/FunctionalConstraint.cpp
@@ -18,12 +18,11 @@
 namespace souffle::ast {
 
 FunctionalConstraint::FunctionalConstraint(VecOwn<Variable> keys, SrcLocation loc)
-        : Constraint(NK_FunctionalConstraint, std::move(loc)), keys(std::move(keys)) {
+        : Constraint(std::move(loc)), keys(std::move(keys)) {
     assert(allValidPtrs(this->keys));
 }
 
-FunctionalConstraint::FunctionalConstraint(Own<Variable> key, SrcLocation loc)
-        : Constraint(NK_FunctionalConstraint, std::move(loc)) {
+FunctionalConstraint::FunctionalConstraint(Own<Variable> key, SrcLocation loc) : Constraint(std::move(loc)) {
     assert(key != nullptr);
     keys.push_back(std::move(key));
 }
@@ -70,8 +69,4 @@ FunctionalConstraint* FunctionalConstraint::cloning() const {
     return new FunctionalConstraint(clone(keys), getSrcLoc());
 }
 
-bool FunctionalConstraint::classof(const Node* n) {
-    return n->getKind() == NK_FunctionalConstraint;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/FunctionalConstraint.h b/src/ast/FunctionalConstraint.h
index be60d7e..758f2ef 100644
--- a/src/ast/FunctionalConstraint.h
+++ b/src/ast/FunctionalConstraint.h
@@ -56,8 +56,6 @@ public:
 
     bool equivalentConstraint(const FunctionalConstraint& other) const;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Functor.h b/src/ast/Functor.h
index e9cd81d..9bafe2b 100644
--- a/src/ast/Functor.h
+++ b/src/ast/Functor.h
@@ -28,12 +28,6 @@ namespace souffle::ast {
 class Functor : public Term {
 protected:
     using Term::Term;
-
-    Functor(NodeKind kind, SrcLocation loc = {}) : Term(kind, loc) {
-        assert(kind > NK_FirstFunctor && kind < NK_LastFunctor);
-    }
-
-    static bool classof(const Node*);
 };
 
 }  // namespace souffle::ast
diff --git a/src/ast/FunctorDeclaration.cpp b/src/ast/FunctorDeclaration.cpp
index 7a38072..380f5c3 100644
--- a/src/ast/FunctorDeclaration.cpp
+++ b/src/ast/FunctorDeclaration.cpp
@@ -20,7 +20,7 @@ namespace souffle::ast {
 
 FunctorDeclaration::FunctorDeclaration(
         std::string name, VecOwn<Attribute> params, Own<Attribute> returnType, bool stateful, SrcLocation loc)
-        : Node(NK_FunctorDeclaration, std::move(loc)), name(std::move(name)), params(std::move(params)),
+        : Node(std::move(loc)), name(std::move(name)), params(std::move(params)),
           returnType(std::move(returnType)), stateful(stateful) {
     assert(this->name.length() > 0 && "functor name is empty");
     assert(allValidPtrs(this->params));
@@ -28,8 +28,11 @@ FunctorDeclaration::FunctorDeclaration(
 }
 
 void FunctorDeclaration::print(std::ostream& out) const {
-    printAnnotations(out);
-    tfm::format(out, ".functor %s(%s): %s", name, join(params, ","), returnType->getTypeName());
+    auto convert = [&](Own<Attribute> const& attr) {
+        return attr->getName() + ": " + attr->getTypeName().toString();
+    };
+
+    tfm::format(out, ".functor %s(%s): %s", name, join(map(params, convert), ","), returnType->getTypeName());
     if (stateful) {
         out << " stateful";
     }
@@ -45,8 +48,4 @@ FunctorDeclaration* FunctorDeclaration::cloning() const {
     return new FunctorDeclaration(name, clone(params), clone(returnType), stateful, getSrcLoc());
 }
 
-bool FunctorDeclaration::classof(const Node* n) {
-    return n->getKind() == NK_FunctorDeclaration;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/FunctorDeclaration.h b/src/ast/FunctorDeclaration.h
index e8ac183..f65f68c 100644
--- a/src/ast/FunctorDeclaration.h
+++ b/src/ast/FunctorDeclaration.h
@@ -64,8 +64,6 @@ public:
         return stateful;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& out) const override;
 
diff --git a/src/ast/IntrinsicFunctor.cpp b/src/ast/IntrinsicFunctor.cpp
index 96feb84..19f6298 100644
--- a/src/ast/IntrinsicFunctor.cpp
+++ b/src/ast/IntrinsicFunctor.cpp
@@ -16,7 +16,7 @@
 namespace souffle::ast {
 
 IntrinsicFunctor::IntrinsicFunctor(std::string op, VecOwn<Argument> args, SrcLocation loc)
-        : Functor(NK_IntrinsicFunctor, std::move(args), std::move(loc)), function(std::move(op)) {}
+        : Functor(std::move(args), std::move(loc)), function(std::move(op)) {}
 
 void IntrinsicFunctor::print(std::ostream& os) const {
     if (isInfixFunctorOp(function)) {
@@ -41,8 +41,4 @@ IntrinsicFunctor* IntrinsicFunctor::cloning() const {
     return new IntrinsicFunctor(function, clone(args), getSrcLoc());
 }
 
-bool IntrinsicFunctor::classof(const Node* n) {
-    return n->getKind() == NK_IntrinsicFunctor;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/IntrinsicFunctor.h b/src/ast/IntrinsicFunctor.h
index 7df8498..bf562ae 100644
--- a/src/ast/IntrinsicFunctor.h
+++ b/src/ast/IntrinsicFunctor.h
@@ -34,12 +34,11 @@ class IntrinsicFunctor : public Functor {
 public:
     template <typename... Operands>
     IntrinsicFunctor(std::string op, Operands&&... operands)
-            : Functor(NK_IntrinsicFunctor, std::forward<Operands>(operands)...), function(std::move(op)) {}
+            : Functor(std::forward<Operands>(operands)...), function(std::move(op)) {}
 
     template <typename... Operands>
     IntrinsicFunctor(SrcLocation loc, std::string op, Operands&&... operands)
-            : Functor(NK_IntrinsicFunctor, std::move(loc), std::forward<Operands>(operands)...),
-              function(std::move(op)) {}
+            : Functor(std::move(loc), std::forward<Operands>(operands)...), function(std::move(op)) {}
 
     IntrinsicFunctor(std::string op, VecOwn<Argument> args, SrcLocation loc = {});
 
@@ -53,8 +52,6 @@ public:
         function = std::move(functor);
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Literal.h b/src/ast/Literal.h
index 758b077..b7aea67 100644
--- a/src/ast/Literal.h
+++ b/src/ast/Literal.h
@@ -30,15 +30,6 @@ namespace souffle::ast {
 class Literal : public Node {
 public:
     using Node::Node;
-
-    explicit Literal(NodeKind kind, SrcLocation loc = {}) : Node(kind, loc) {
-        assert(kind >= NK_Literal && kind < NK_LastLiteral);
-    }
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Literal && kind < NK_LastLiteral);
-    }
 };
 
 }  // namespace souffle::ast
diff --git a/src/ast/Negation.cpp b/src/ast/Negation.cpp
index 5e29a02..ca702f9 100644
--- a/src/ast/Negation.cpp
+++ b/src/ast/Negation.cpp
@@ -14,8 +14,7 @@
 
 namespace souffle::ast {
 
-Negation::Negation(Own<Atom> atom, SrcLocation loc)
-        : Literal(NK_Negation, std::move(loc)), atom(std::move(atom)) {
+Negation::Negation(Own<Atom> atom, SrcLocation loc) : Literal(std::move(loc)), atom(std::move(atom)) {
     assert(this->atom != nullptr);
 }
 
@@ -40,8 +39,4 @@ Negation* Negation::cloning() const {
     return new Negation(clone(atom), getSrcLoc());
 }
 
-bool Negation::classof(const Node* n) {
-    return n->getKind() == NK_Negation;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Negation.h b/src/ast/Negation.h
index 5fe14d0..b87a036 100644
--- a/src/ast/Negation.h
+++ b/src/ast/Negation.h
@@ -43,8 +43,6 @@ public:
 
     void apply(const NodeMapper& map) override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/NilConstant.cpp b/src/ast/NilConstant.cpp
index 87a3e96..ca2ad5e 100644
--- a/src/ast/NilConstant.cpp
+++ b/src/ast/NilConstant.cpp
@@ -10,14 +10,10 @@
 
 namespace souffle::ast {
 
-NilConstant::NilConstant(SrcLocation loc) : Constant(NK_NilConstant, "nil", std::move(loc)) {}
+NilConstant::NilConstant(SrcLocation loc) : Constant("nil", std::move(loc)) {}
 
 NilConstant* NilConstant::cloning() const {
     return new NilConstant(getSrcLoc());
 }
 
-bool NilConstant::classof(const Node* n) {
-    return n->getKind() == NK_NilConstant;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/NilConstant.h b/src/ast/NilConstant.h
index 701d8d9..ebb9659 100644
--- a/src/ast/NilConstant.h
+++ b/src/ast/NilConstant.h
@@ -31,8 +31,6 @@ class NilConstant : public Constant {
 public:
     NilConstant(SrcLocation loc = {});
 
-    static bool classof(const Node*);
-
 private:
     NilConstant* cloning() const override;
 };
diff --git a/src/ast/Node.cpp b/src/ast/Node.cpp
index 18acab4..9fc128b 100644
--- a/src/ast/Node.cpp
+++ b/src/ast/Node.cpp
@@ -6,12 +6,11 @@
  * - <souffle root>/licenses/SOUFFLE-UPL.txt
  */
 #include "ast/Node.h"
-
-#include <algorithm>
+#include <typeinfo>
 #include <utility>
 
 namespace souffle::ast {
-Node::Node(NodeKind kind, SrcLocation loc) : Kind(kind), location(std::move(loc)) {}
+Node::Node(SrcLocation loc) : location(std::move(loc)) {}
 
 /** Set source location for the Node */
 void Node::setSrcLoc(SrcLocation l) {
@@ -23,25 +22,11 @@ bool Node::operator==(const Node& other) const {
         return true;
     }
 
-    if constexpr (/* we ignore annotations in equality test */ false) {
-        const bool has_annotes = ((bool)annotations) == true && !annotations->empty();
-        const bool other_has_annotes = ((bool)other.annotations) == true && !other.annotations->empty();
-        if (has_annotes != other_has_annotes) {
-            return false;
-        }
-
-        if (has_annotes && (*annotations != *(other.annotations))) {
-            return false;
-        }
-    }
-
-    return this->Kind == other.Kind && equal(other);
+    return typeid(*this) == typeid(*&other) && equal(other);
 }
 
 Own<Node> Node::cloneImpl() const {
-    auto Res = Own<Node>(cloning());
-    Res->setAnnotationsFrom(*this);
-    return Res;
+    return Own<Node>(cloning());
 }
 
 /** Apply the mapper to all child nodes */
@@ -60,176 +45,13 @@ std::ostream& operator<<(std::ostream& out, const Node& node) {
     return out;
 }
 
-// bool Node::equal(const Node& other) const {
-//     return this == &other;
-// }
+bool Node::equal(const Node&) const {
+    // FIXME: Change to this == &other?
+    return true;
+}
 
 Node::NodeVec Node::getChildren() const {
     return {};
 }
 
-Node::NodeKind Node::getKind() const {
-    return Kind;
-}
-
-const SrcLocation& Node::getSrcLoc() const {
-    return location;
-}
-
-std::string Node::extloc() const {
-    return location.extloc();
-}
-
-bool Node::operator!=(const Node& other) const {
-    return !(*this == other);
-}
-
-AnnotationList& Node::ensureAnnotations() {
-    if (!annotations) {
-        annotations = std::make_unique<AnnotationList>();
-    }
-    return *annotations;
-}
-
-void Node::addAnnotation(Annotation annote) {
-    ensureAnnotations().emplace_back(std::move(annote));
-}
-
-void Node::addAnnotations(AnnotationList annotes) {
-    auto& annotations = ensureAnnotations();
-    annotations.splice(annotations.end(), annotes);
-}
-
-void Node::prependAnnotation(Annotation annote) {
-    ensureAnnotations().emplace_front(std::move(annote));
-}
-
-void Node::prependAnnotations(AnnotationList annotes) {
-    auto& annotations = ensureAnnotations();
-    annotations.splice(annotations.begin(), annotes);
-}
-
-void Node::setAnnotationsFrom(const Node& other) {
-    if (other.annotations && !other.annotations->empty()) {
-        annotations = std::make_unique<AnnotationList>(*other.annotations);
-    } else {
-        annotations.release();
-    }
-}
-
-void Node::setAnnotations(AnnotationList annotes) {
-    if (!annotes.empty()) {
-        annotations = std::make_unique<AnnotationList>(std::move(annotes));
-    } else {
-        annotations.release();
-    }
-}
-
-void Node::setAnnotations(std::unique_ptr<AnnotationList> annotes) {
-    if (annotes && !annotes->empty()) {
-        annotations = std::move(annotes);
-    } else {
-        annotations.release();
-    }
-}
-
-void Node::stealAnnotationsFrom(Node& other) {
-    annotations = std::move(other.annotations);
-}
-
-void Node::eachAnnotation(const std::function<void(const Annotation&)>& f) const {
-    if (!annotations) {
-        return;
-    }
-
-    for (const auto& annote : *annotations) {
-        f(annote);
-    }
-}
-
-void Node::eachAnnotation(
-        const QualifiedName& label, const std::function<void(const TokenStream&)>& f) const {
-    if (!annotations) {
-        return;
-    }
-
-    for (const auto& annote : *annotations) {
-        if (annote.getLabel() == label) {
-            f(annote.getTokens());
-        }
-    }
-}
-
-void Node::eachAnnotation(const QualifiedName& label, const std::function<void(const Annotation&)>& f) const {
-    if (!annotations) {
-        return;
-    }
-
-    for (const auto& annote : *annotations) {
-        if (annote.getLabel() == label) {
-            f(annote);
-        }
-    }
-}
-
-void Node::eachAnnotation(const std::function<void(const QualifiedName&, const TokenStream&)>& f) const {
-    if (!annotations) {
-        return;
-    }
-
-    for (const auto& annote : *annotations) {
-        f(annote.getLabel(), annote.getTokens());
-    }
-}
-
-std::size_t Node::countAnnotations(const QualifiedName& label) const {
-    if (!annotations) {
-        return 0;
-    }
-
-    return std::count_if(annotations->cbegin(), annotations->cend(),
-            [&](const Annotation& a) -> bool { return a.getLabel() == label; });
-}
-
-const Annotation& Node::getAnnotation(const QualifiedName& label) const {
-    if (!annotations) {
-        throw std::out_of_range("No such annotation");
-    }
-
-    auto it = std::find_if(annotations->cbegin(), annotations->cend(),
-            [&](const Annotation& a) -> bool { return a.getLabel() == label; });
-    if (it == annotations->cend()) {
-        throw std::out_of_range("No such annotation");
-    }
-
-    return *it;
-}
-
-AnnotationList* Node::getAnnotations() {
-    if (annotations) {
-        return annotations.get();
-    } else {
-        return nullptr;
-    }
-}
-
-const AnnotationList* Node::getAnnotations() const {
-    if (annotations) {
-        return annotations.get();
-    } else {
-        return nullptr;
-    }
-}
-
-/// print annotations of this node, except documentation
-void Node::printAnnotations(std::ostream& os) const {
-    eachAnnotation([&](const Annotation& annotation) {
-        if (annotation.getKind() == Annotation::Kind::DocComment) {
-            return;
-        }
-        annotation.printAsOuter(os);
-        os << "\n";
-    });
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Node.h b/src/ast/Node.h
index bd215d8..570f850 100644
--- a/src/ast/Node.h
+++ b/src/ast/Node.h
@@ -16,18 +16,13 @@
 
 #pragma once
 
-#include "Annotation.h"
-#include "QualifiedName.h"
-#include "TokenTree.h"
 #include "parser/SrcLocation.h"
 #include "souffle/utility/Iteration.h"
 #include "souffle/utility/NodeMapperFwd.h"
 #include "souffle/utility/Types.h"
 #include "souffle/utility/VisitorFwd.h"
-
 #include <functional>
 #include <iosfwd>
-#include <list>
 #include <string>
 #include <vector>
 
@@ -57,129 +52,32 @@ struct ConstCaster {
  */
 class Node {
 public:
-    /// LLVM-style RTTI
-    ///
-    /// Each class under the ast::Node hierarchy must appear here and must implement
-    /// `static bool classof(const Node*)`.
-    ///
-    /// When class T is final, we must provide a single enum:
-    ///
-    ///   ...
-    ///   NK_T,
-    ///   ...
-    ///
-    /// When class T is non-final, we must provide enums like this:
-    ///
-    ///   NK_T,
-    ///     NK_Child1,
-    ///     ...
-    ///     NK_ChildN,
-    ///   NK_LastT
-    ///
-    ///
-    // clang-format off
-    enum NodeKind {
-        NK_NONE,
-        NK_Argument,
-            NK_Constant,
-                NK_NilConstant,
-                NK_NumericConstant,
-                NK_StringConstant,
-            NK_LastConstant,
-
-            NK_Counter,
-            NK_ExecutionOrder,
-            NK_ExecutionPlan,
-            NK_IterationCounter,
-
-            NK_Aggregator,
-                NK_IntrinsicAggregator,
-                NK_UserDefinedAggregator,
-            NK_LastAggregator,
-
-            NK_Term,
-                NK_BranchInit,
-                NK_FirstFunctor,
-                    NK_IntrinsicFunctor,
-                    NK_UserDefinedFunctor,
-                NK_LastFunctor,
-                NK_RecordInit,
-            NK_LastTerm,
-
-            NK_UnnamedVariable,
-            NK_Variable,
-            NK_TypeCast,
-        NK_LastArgument,
-
-        NK_Attribute,
-        NK_BranchType,
-        NK_Clause,
-          NK_SubsumptiveClause,
-        NK_LastClause,
-        NK_Component,
-        NK_ComponentInit,
-        NK_ComponentType,
-        NK_Directive,
-        NK_FunctorDeclaration,
-        NK_Lattice,
-
-        NK_Literal,
-            NK_Atom,
-
-            NK_Constraint,
-                NK_BinaryConstraint,
-                NK_BooleanConstraint,
-                NK_FunctionalConstraint,
-            NK_LastConstraint,
-
-            NK_Negation,
-        NK_LastLiteral,
-
-        NK_Pragma,
-        NK_Program,
-        NK_Relation,
-
-        NK_Type,
-            NK_AlgebraicDataType,
-            NK_AliasType,
-            NK_RecordType,
-            NK_SubsetType,
-            NK_UnionType,
-        NK_LastType,
-    };
-    // clang-format on
-private:
-    const NodeKind Kind;
-
-public:
-    explicit Node(NodeKind K, SrcLocation loc = {});
+    Node(SrcLocation loc = {});
     virtual ~Node() = default;
     // Make sure we don't accidentally copy/slice
     Node(Node const&) = delete;
     Node& operator=(Node const&) = delete;
 
-    NodeKind getKind() const;
-
     /** Return source location of the Node */
-    const SrcLocation& getSrcLoc() const;
+    const SrcLocation& getSrcLoc() const {
+        return location;
+    }
 
     /** Set source location for the Node */
     void setSrcLoc(SrcLocation l);
 
     /** Return source location of the syntactic element */
-    std::string extloc() const;
+    std::string extloc() const {
+        return location.extloc();
+    }
 
-    /** Equivalence check for two AST nodes
-     *
-     * Annotations are ignored.
-     */
+    /** Equivalence check for two AST nodes */
     bool operator==(const Node& other) const;
 
-    /** Inequality check for two AST nodes
-     *
-     * Annotations are ignored.
-     */
-    bool operator!=(const Node& other) const;
+    /** Inequality check for two AST nodes */
+    bool operator!=(const Node& other) const {
+        return !(*this == other);
+    }
 
     /** Create a clone (i.e. deep copy) of this node */
     Own<Node> cloneImpl() const;
@@ -200,63 +98,6 @@ public:
     using ChildNodes = OwningTransformRange<NodeVec, detail::ConstCaster>;
     ChildNodes getChildNodes();
 
-    /** Add an annotation to this object. */
-    void addAnnotation(Annotation);
-
-    /** Add a list of annotations to this object. */
-    void addAnnotations(AnnotationList);
-
-    void prependAnnotation(Annotation);
-
-    void prependAnnotations(AnnotationList);
-
-    /** Reset annotations using annotations from the other object */
-    void setAnnotationsFrom(const Node& other);
-
-    /** Reset annotations using the given list */
-    void setAnnotations(AnnotationList);
-
-    /** Reset annotations using the given list */
-    void setAnnotations(std::unique_ptr<AnnotationList>);
-
-    /// Replace this node annotations with annotations stollen from other node.
-    void stealAnnotationsFrom(Node& other);
-
-    /** Enumerate annotations attached to this object */
-    void eachAnnotation(const std::function<void(const Annotation&)>& f) const;
-
-    /** Enumerate annotations attached to this object that have the given annotation */
-    void eachAnnotation(const QualifiedName& label, const std::function<void(const TokenStream&)>& f) const;
-
-    /** Enumerate annotations attached to this object that have the given annotation */
-    void eachAnnotation(const QualifiedName& label, const std::function<void(const Annotation&)>& f) const;
-
-    /** Enumerate annotations attached to this object */
-    void eachAnnotation(const std::function<void(const QualifiedName&, const TokenStream&)>& f) const;
-
-    /** Return the number of attached annotations that have the given label */
-    std::size_t countAnnotations(const QualifiedName& label) const;
-
-    /** Return a pointer to the list of annotations or nullptr */
-    AnnotationList* getAnnotations();
-
-    /** Return a pointer to the list of annotations or nullptr */
-    const AnnotationList* getAnnotations() const;
-
-    /**
-     * Return the first attached annotation that have the given label.
-     *
-     * Throws an exception if no such annotation exists.
-     */
-    const Annotation& getAnnotation(const QualifiedName& label) const;
-
-    /**
-     * Print annotations, except doc comments
-     *
-     * Inner annotations are printed like outer annotations
-     */
-    void printAnnotations(std::ostream& os) const;
-
     /** Print node onto an output stream */
     friend std::ostream& operator<<(std::ostream& out, const Node& node);
 
@@ -268,19 +109,13 @@ protected:
 
 private:
     /** Abstract equality check for two AST nodes */
-    virtual bool equal(const Node& /* other */) const = 0;
+    virtual bool equal(const Node& /* other */) const;
 
     virtual Node* cloning() const = 0;
 
-    /** Ensure that this node has an annotations list and return it by reference. */
-    AnnotationList& ensureAnnotations();
-
 private:
     /** Source location of a syntactic element */
     SrcLocation location;
-
-    /** The attached annotations */
-    std::unique_ptr<AnnotationList> annotations;
 };
 
 }  // namespace souffle::ast
diff --git a/src/ast/NumericConstant.cpp b/src/ast/NumericConstant.cpp
index ff6513a..802efbb 100644
--- a/src/ast/NumericConstant.cpp
+++ b/src/ast/NumericConstant.cpp
@@ -13,14 +13,13 @@
 
 namespace souffle::ast {
 
-NumericConstant::NumericConstant(RamSigned value)
-        : Constant(NK_NumericConstant, std::to_string(value)), fixedType(Type::Int) {}
+NumericConstant::NumericConstant(RamSigned value) : Constant(std::to_string(value)), fixedType(Type::Int) {}
 
 NumericConstant::NumericConstant(std::string constant, SrcLocation loc)
-        : Constant(NK_NumericConstant, std::move(constant), std::move(loc)) {}
+        : Constant(std::move(constant), std::move(loc)) {}
 
 NumericConstant::NumericConstant(std::string constant, std::optional<Type> fixedType, SrcLocation loc)
-        : Constant(NK_NumericConstant, std::move(constant), std::move(loc)), fixedType(fixedType) {}
+        : Constant(std::move(constant), std::move(loc)), fixedType(fixedType) {}
 
 bool NumericConstant::equal(const Node& node) const {
     const auto& other = asAssert<NumericConstant>(node);
@@ -31,8 +30,4 @@ NumericConstant* NumericConstant::cloning() const {
     return new NumericConstant(getConstant(), getFixedType(), getSrcLoc());
 }
 
-bool NumericConstant::classof(const Node* n) {
-    return n->getKind() == NK_NumericConstant;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/NumericConstant.h b/src/ast/NumericConstant.h
index 1f38f25..bf9751e 100644
--- a/src/ast/NumericConstant.h
+++ b/src/ast/NumericConstant.h
@@ -45,8 +45,6 @@ public:
         return fixedType;
     }
 
-    static bool classof(const Node*);
-
 private:
     bool equal(const Node& node) const override;
 
diff --git a/src/ast/Pragma.cpp b/src/ast/Pragma.cpp
index 0426890..4e6cae9 100644
--- a/src/ast/Pragma.cpp
+++ b/src/ast/Pragma.cpp
@@ -14,7 +14,7 @@
 namespace souffle::ast {
 
 Pragma::Pragma(std::string key, std::string value, SrcLocation loc)
-        : Node(NK_Pragma, std::move(loc)), key(std::move(key)), value(std::move(value)) {}
+        : Node(std::move(loc)), key(std::move(key)), value(std::move(value)) {}
 
 void Pragma::print(std::ostream& os) const {
     os << ".pragma " << key << " " << value << "\n";
@@ -29,8 +29,4 @@ Pragma* Pragma::cloning() const {
     return new Pragma(key, value, getSrcLoc());
 }
 
-bool Pragma::classof(const Node* n) {
-    return n->getKind() == NK_Pragma;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Pragma.h b/src/ast/Pragma.h
index 989b1f5..b9340a2 100644
--- a/src/ast/Pragma.h
+++ b/src/ast/Pragma.h
@@ -37,8 +37,6 @@ public:
         return std::make_pair(key, value);
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Program.cpp b/src/ast/Program.cpp
index 4cda12e..d67db8f 100644
--- a/src/ast/Program.cpp
+++ b/src/ast/Program.cpp
@@ -110,8 +110,6 @@ namespace souffle::ast {
 
 using souffle::clone;
 
-Program::Program() : Node(NK_Program) {}
-
 Program::RelationInfo clone(Program::RelationInfo const& x) {
     return {clone(x.decls), clone(x.clauses), clone(x.directives)};
 }
@@ -120,10 +118,6 @@ std::vector<Type*> Program::getTypes() const {
     return toPtrVector(types);
 }
 
-std::vector<Lattice*> Program::getLattices() const {
-    return toPtrVector(lattices);
-}
-
 std::vector<Relation*> Program::getRelations() const {
     return toPtrVector(relations, &RelationInfo::decls);
 }
@@ -237,15 +231,6 @@ void Program::addType(Own<Type> type) {
     types.push_back(std::move(type));
 }
 
-void Program::addLattice(Own<Lattice> lattice) {
-    assert(lattice != nullptr);
-    [[maybe_unused]] auto* existingLattice = getIf(getLattices(), [&](const Lattice* current) {
-        return current->getQualifiedName() == lattice->getQualifiedName();
-    });
-    assert(existingLattice == nullptr && "Redefinition of lattice!");
-    lattices.push_back(std::move(lattice));
-}
-
 void Program::addPragma(Own<Pragma> pragma) {
     assert(pragma && "NULL pragma");
     pragmas.push_back(std::move(pragma));
@@ -259,7 +244,7 @@ void Program::addFunctorDeclaration(Own<FunctorDeclaration> f) {
     functors.push_back(std::move(f));
 }
 
-std::vector<ComponentInit*> Program::getInstantiations() const {
+std::vector<ComponentInit*> Program::getComponentInstantiations() const {
     return toPtrVector(instantiations);
 }
 
@@ -274,7 +259,6 @@ void Program::apply(const NodeMapper& map) {
     mapAll(instantiations, map);
     mapAll(functors, map);
     mapAll(types, map);
-    mapAll(lattices, map);
     mapAll(relations, &RelationInfo::decls, map);
     mapAll(relations, &RelationInfo::clauses, map);
     mapAll(relations, &RelationInfo::directives, map);
@@ -287,7 +271,6 @@ Node::NodeVec Program::getChildren() const {
     append(res, makePtrRange(instantiations));
     append(res, makePtrRange(functors));
     append(res, makePtrRange(types));
-    append(res, makePtrRange(lattices));
     append(res, relations, &RelationInfo::decls);
     append(res, relations, &RelationInfo::clauses);
     append(res, relations, &RelationInfo::directives);
@@ -303,13 +286,28 @@ void Program::print(std::ostream& os) const {
     show(components);
     show(instantiations);
     show(types);
-    show(lattices);
     show(functors);
     show(getRelations());
     show(getClauses(), "\n\n");
     show(getDirectives(), "\n\n");
 }
 
+bool Program::equal(const Node& node) const {
+    const auto& other = asAssert<Program>(node);
+    // clang-format off
+    return equal_targets(pragmas, other.pragmas) &&
+           equal_targets(components, other.components) &&
+           equal_targets(instantiations, other.instantiations) &&
+           equal_targets(functors, other.functors) &&
+           equal_targets(types, other.types) &&
+           equal_targets_map(relations, other.relations, [](auto& a, auto& b) {
+                return  equal_targets(a.decls     , b.decls     ) &&
+                        equal_targets(a.clauses   , b.clauses   ) &&
+                        equal_targets(a.directives, b.directives);
+           });
+    // clang-format on
+}
+
 void Program::addComponent(Own<Component> component) {
     assert(component && "NULL component");
     components.push_back(std::move(component));
@@ -326,25 +324,9 @@ Program* Program::cloning() const {
     res->components = clone(components);
     res->instantiations = clone(instantiations);
     res->types = clone(types);
-    res->lattices = clone(lattices);
     res->functors = clone(functors);
     res->relations = clone(relations);
     return res;
 }
 
-bool Program::classof(const Node* n) {
-    return n->getKind() == NK_Program;
-}
-
-bool Program::equal(const Node& node) const {
-    const auto& other = asAssert<Program>(node);
-    // strict ordered comparisons of vectors
-    return equal_targets(types, other.types) && equal_targets(lattices, other.lattices) &&
-           equal_targets(functors, other.functors) && equal_targets(components, other.components) &&
-           equal_targets(instantiations, other.instantiations) && equal_targets(pragmas, other.pragmas) &&
-           equal_targets(getClauses(), other.getClauses()) &&
-           equal_targets(getRelations(), other.getRelations()) &&
-           equal_targets(getDirectives(), other.getDirectives());
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Program.h b/src/ast/Program.h
index 598b827..1316f0d 100644
--- a/src/ast/Program.h
+++ b/src/ast/Program.h
@@ -16,13 +16,11 @@
 
 #pragma once
 
-#include "Global.h"
 #include "ast/Clause.h"
 #include "ast/Component.h"
 #include "ast/ComponentInit.h"
 #include "ast/Directive.h"
 #include "ast/FunctorDeclaration.h"
-#include "ast/ItemContainer.h"
 #include "ast/Node.h"
 #include "ast/Pragma.h"
 #include "ast/QualifiedName.h"
@@ -60,7 +58,7 @@ namespace souffle::ast {
  * @class Program
  * @brief The program class consists of relations, clauses and types.
  */
-class Program : public Node, public ItemContainer {
+class Program : public Node {
 public:
     // Requirements for storing top-level nodes:
     // 1) remove-by-identity needs to be at least `O(lg n)`
@@ -87,9 +85,7 @@ public:
         VecOwn<Directive> directives;
     };
 
-    using RelationInfoMap = OrderedQualifiedNameMap<RelationInfo>;
-
-    Program();
+    using RelationInfoMap = std::map<QualifiedName, RelationInfo>;
 
     RelationInfoMap& getRelationInfo() {
         return relations;
@@ -110,13 +106,10 @@ public:
     }
 
     /** Return types */
-    std::vector<Type*> getTypes() const override;
-
-    /** Return lattices */
-    std::vector<Lattice*> getLattices() const override;
+    std::vector<Type*> getTypes() const;
 
     /** Return relations */
-    std::vector<Relation*> getRelations() const override;
+    std::vector<Relation*> getRelations() const;
 
     /** Returns the first `Relation` declartion for a given name, if any */
     Relation* getRelation(QualifiedName const&) const;
@@ -132,7 +125,7 @@ public:
     std::vector<Relation*> getRelationAll(QualifiedName const&) const;
 
     /** Return clauses */
-    std::vector<Clause*> getClauses() const override;
+    std::vector<Clause*> getClauses() const;
 
     /** Return clauses for a given relation */
     std::vector<Clause*> getClauses(QualifiedName const&) const;
@@ -146,7 +139,7 @@ public:
     std::vector<FunctorDeclaration*> getFunctorDeclarations() const;
 
     /** Return relation directives */
-    std::vector<Directive*> getDirectives() const override;
+    std::vector<Directive*> getDirectives() const;
 
     /** Return relation directives for a relation */
     std::vector<Directive*> getDirectives(QualifiedName const&) const;
@@ -157,7 +150,7 @@ public:
     }
 
     /** Add relation directive */
-    void addDirective(Own<Directive> directive) override;
+    void addDirective(Own<Directive> directive);
 
     /** Return pragma directives */
     const VecOwn<Pragma>& getPragmaDirectives() const {
@@ -165,7 +158,7 @@ public:
     }
 
     /* Add relation */
-    void addRelation(Own<Relation> relation) override;
+    void addRelation(Own<Relation> relation);
 
     /**
      * Remove a relation entirely, including the declaration(s), clauses, and directives.
@@ -181,16 +174,13 @@ public:
     void removeRelation(Relation const&);
 
     /** Add a clause */
-    void addClause(Own<Clause> clause) override;
+    void addClause(Own<Clause> clause);
 
     // Common case helper.
     void addClauses(VecOwn<Clause> clauses);
 
     /** Add a type declaration */
-    void addType(Own<Type> type) override;
-
-    /** Add a lattice declaration */
-    void addLattice(Own<Lattice> lattice) override;
+    void addType(Own<Type> type);
 
     /**
      * Remove a clause by identity. The clause must be owned by the program.
@@ -213,28 +203,16 @@ public:
     void removeDirective(const Directive&);
 
     /** Return components */
-    std::vector<Component*> getComponents() const override;
+    std::vector<Component*> getComponents() const;
 
     /** Return component instantiation */
-    std::vector<ComponentInit*> getInstantiations() const override;
-
-    void addPragma(Own<Pragma> pragma);
-
-    void addFunctorDeclaration(Own<FunctorDeclaration> functor);
-
-    /** Add component */
-    void addComponent(Own<Component> component) override;
-
-    /** Add component instantiation */
-    void addInstantiation(Own<ComponentInit> instantiation) override;
+    std::vector<ComponentInit*> getComponentInstantiations() const;
 
     /** Remove components and components' instantiations */
     void clearComponents();
 
     void apply(const NodeMapper& map) override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
@@ -242,8 +220,18 @@ protected:
 
     friend class souffle::ParserDriver;
 
+    void addPragma(Own<Pragma> pragma);
+
+    void addFunctorDeclaration(Own<FunctorDeclaration> functor);
+
+    /** Add component */
+    void addComponent(Own<Component> component);
+
+    /** Add component instantiation */
+    void addInstantiation(Own<ComponentInit> instantiation);
+
 private:
-    bool equal(const Node&) const override;
+    bool equal(const Node& node) const override;
 
     Program* cloning() const override;
 
@@ -251,9 +239,6 @@ private:
     /** Program types  */
     VecOwn<Type> types;
 
-    /** Program lattices */
-    VecOwn<Lattice> lattices;
-
     /** Program relation declartions, clauses, and directives */
     RelationInfoMap relations;
 
diff --git a/src/ast/QualifiedName.cpp b/src/ast/QualifiedName.cpp
index 38d71f3..192c90a 100644
--- a/src/ast/QualifiedName.cpp
+++ b/src/ast/QualifiedName.cpp
@@ -8,165 +8,47 @@
 
 #include "ast/QualifiedName.h"
 #include "souffle/utility/StreamUtil.h"
-#include "souffle/utility/StringUtil.h"
-
 #include <algorithm>
-#include <cassert>
-#include <deque>
-#include <map>
 #include <ostream>
 #include <sstream>
-#include <unordered_map>
 #include <utility>
 
 namespace souffle::ast {
 
-/// Container of qualified names, provides interning by associating a unique
-/// numerical index to each qualified name.
-struct QNInterner {
-public:
-    explicit QNInterner() {
-        qualifiedNames.emplace_back(QualifiedNameData{{}, ""});
-        qualifiedNameToIndex.emplace("", 0);
-    }
-
-    /// Return the qualified name object for the given string.
-    ///
-    /// Each `.` character is treated as a separator.
-    QualifiedName intern(std::string_view qn) {
-        const auto It = qualifiedNameToIndex.find(qn);
-        if (It != qualifiedNameToIndex.end()) {
-            return QualifiedName{It->second};
-        }
-
-        const uint32_t index = static_cast<uint32_t>(qualifiedNames.size());
-
-        QualifiedNameData qndata{splitString(qn, '.'), std::string{qn}};
-        qualifiedNames.emplace_back(std::move(qndata));
-        qualifiedNameToIndex.emplace(qualifiedNames.back().qualified, index);
-
-        return QualifiedName{index};
-    }
-
-    /// Return the qualified name data object from the given index.
-    const QualifiedNameData& at(uint32_t index) {
-        return qualifiedNames.at(index);
-    }
-
-private:
-    /// Store the qualified name data of interned qualified names.
-    std::deque<QualifiedNameData> qualifiedNames;
-
-    /// Mapping from a qualified name string representation to its index in
-    /// `qualifiedNames`.
-    std::unordered_map<std::string_view, uint32_t> qualifiedNameToIndex;
-};
-
-namespace {
-/// The default qualified name interner instance.
-QNInterner Interner;
-}  // namespace
-
-QualifiedName::QualifiedName() : index(0) {}
-QualifiedName::QualifiedName(uint32_t idx) : index(idx) {}
-
-const QualifiedNameData& QualifiedName::data() const {
-    return Interner.at(index);
+QualifiedName::QualifiedName() {}
+QualifiedName::QualifiedName(std::string name) {
+    qualifiers.emplace_back(std::move(name));
 }
+QualifiedName::QualifiedName(const char* name) : QualifiedName(std::string(name)) {}
+QualifiedName::QualifiedName(std::vector<std::string> qualifiers) : qualifiers(std::move(qualifiers)) {}
 
-bool QualifiedName::operator==(const QualifiedName& other) const {
-    return index == other.index;
+void QualifiedName::append(std::string name) {
+    qualifiers.push_back(std::move(name));
 }
 
-bool QualifiedName::operator!=(const QualifiedName& other) const {
-    return index != other.index;
-}
-
-void QualifiedName::append(const std::string& segment) {
-    assert(segment.find('.') == std::string::npos);
-    *this = Interner.intern(data().qualified + "." + segment);
-}
-
-void QualifiedName::prepend(const std::string& segment) {
-    assert(segment.find('.') == std::string::npos);
-    *this = Interner.intern(segment + "." + data().qualified);
-}
-
-void QualifiedName::append(const QualifiedName& rhs) {
-    if (rhs.empty()) {
-        return;
-    }
-    if (empty()) {
-        index = rhs.index;
-        return;
-    }
-    *this = Interner.intern(toString() + "." + rhs.toString());
+void QualifiedName::prepend(std::string name) {
+    qualifiers.insert(qualifiers.begin(), std::move(name));
 }
 
 /** convert to a string separated by fullstop */
-const std::string& QualifiedName::toString() const {
-    return data().qualified;
+std::string QualifiedName::toString() const {
+    std::stringstream ss;
+    print(ss);
+    return ss.str();
 }
 
-QualifiedName QualifiedName::fromString(std::string_view qname) {
-    return Interner.intern(qname);
-}
-
-bool QualifiedName::lexicalLess(const QualifiedName& other) const {
-    if (index == other.index) {
-        return false;
-    }
-    return data().lexicalLess(other.data());
+bool QualifiedName::operator<(const QualifiedName& other) const {
+    return std::lexicographical_compare(
+            qualifiers.begin(), qualifiers.end(), other.qualifiers.begin(), other.qualifiers.end());
 }
 
 void QualifiedName::print(std::ostream& out) const {
-    out << toString();
+    out << join(qualifiers, ".");
 }
 
-std::ostream& operator<<(std::ostream& out, const QualifiedName& qn) {
-    out << qn.toString();
+std::ostream& operator<<(std::ostream& out, const QualifiedName& id) {
+    id.print(out);
     return out;
 }
 
-const std::vector<std::string>& QualifiedName::getQualifiers() const {
-    return data().segments;
-}
-
-uint32_t QualifiedName::getIndex() const {
-    return index;
-}
-
-bool QualifiedName::empty() const {
-    return index == 0;
-}
-
-QualifiedName QualifiedName::head() const {
-    if (empty()) {
-        return QualifiedName();
-    }
-    return fromString(data().segments.front());
-}
-
-QualifiedName QualifiedName::tail() const {
-    const QualifiedNameData& qdata = data();
-    if (qdata.segments.size() < 2) {
-        return QualifiedName();
-    } else {
-        std::stringstream ss;
-        ss << join(qdata.segments.begin() + 1, qdata.segments.end(), "");
-        return fromString(ss.str());
-    }
-}
-
-bool QualifiedNameData::lexicalLess(const QualifiedNameData& other) const {
-    return std::lexicographical_compare(
-            segments.begin(), segments.end(), other.segments.begin(), other.segments.end());
-}
-
-QualifiedName operator+(const std::string& head, const QualifiedName& tail) {
-    QualifiedName res = tail;
-    res.prepend(head);
-    return res;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/QualifiedName.h b/src/ast/QualifiedName.h
index 9692dfe..85f5e81 100644
--- a/src/ast/QualifiedName.h
+++ b/src/ast/QualifiedName.h
@@ -16,151 +16,71 @@
 
 #pragma once
 
-#include <cstdint>
 #include <iosfwd>
-#include <map>
-#include <set>
 #include <string>
-#include <unordered_map>
-#include <unordered_set>
 #include <vector>
 
 namespace souffle::ast {
 
-struct QualifiedNameData {
-    using Segment = std::string;
-    std::vector<Segment> segments;
-
-    /// the whole qualified name with segments glued with dot
-    std::string qualified;
-
-    bool lexicalLess(const QualifiedNameData& other) const;
-};
-
-struct QNInterner;
-
 /**
+ * @class QualifiedName
  * @brief Qualified Name class defines fully/partially qualified names
  * to identify objects in components.
  */
 class QualifiedName {
-private:
-    friend struct QNInterner;
-    explicit QualifiedName(uint32_t);
-
 public:
-    /** Build a QualifiedName from a dot-separated qualified name */
-    static QualifiedName fromString(std::string_view qualname);
-
-    /// The empty qualified name
     QualifiedName();
-
+    QualifiedName(std::string name);
+    QualifiedName(const char* name);
+    QualifiedName(std::vector<std::string> qualifiers);
     QualifiedName(const QualifiedName&) = default;
     QualifiedName(QualifiedName&&) = default;
     QualifiedName& operator=(const QualifiedName&) = default;
     QualifiedName& operator=(QualifiedName&&) = default;
 
-    const QualifiedNameData& data() const;
+    /** append qualifiers */
+    void append(std::string name);
 
-    /** append one qualifier */
-    void append(const std::string& name);
-
-    /** append another qualified name */
-    void append(const QualifiedName& name);
-
-    /** prepend one qualifier */
-    void prepend(const std::string& name);
+    /** prepend qualifiers */
+    void prepend(std::string name);
 
     /** check for emptiness */
-    bool empty() const;
+    bool empty() const {
+        return qualifiers.empty();
+    }
 
     /** get qualifiers */
-    const std::vector<std::string>& getQualifiers() const;
+    const std::vector<std::string>& getQualifiers() const {
+        return qualifiers;
+    }
 
     /** convert to a string separated by fullstop */
-    const std::string& toString() const;
-
-    QualifiedName head() const;
+    std::string toString() const;
 
-    QualifiedName tail() const;
-
-    bool operator==(const QualifiedName& other) const;
+    bool operator==(const QualifiedName& other) const {
+        return qualifiers == other.qualifiers;
+    }
 
-    bool operator!=(const QualifiedName& other) const;
+    bool operator!=(const QualifiedName& other) const {
+        return !(*this == other);
+    }
 
-    /// Lexicographic less comparison.
-    ///
-    /// We don't offer `operator<` because it's a costly operation
-    /// that should only be used when ordering is required.
-    ///
-    /// See type definitions of containers below.
-    bool lexicalLess(const QualifiedName& other) const;
+    bool operator<(const QualifiedName& other) const;
 
     /** print qualified name */
     void print(std::ostream& out) const;
 
     friend std::ostream& operator<<(std::ostream& out, const QualifiedName& id);
 
-    /// Return the unique identifier of the interned qualified name.
-    uint32_t getIndex() const;
-
 private:
-    /// index of this qualified name in the qualified-name interner
-    uint32_t index;
+    /* array of name qualifiers */
+    std::vector<std::string> qualifiers;
 };
 
-/// Return the qualified name by the adding prefix segment in head of the qualified name.
-QualifiedName operator+(const std::string& head, const QualifiedName& tail);
-
-struct OrderedQualifiedNameLess {
-    bool operator()(const QualifiedName& lhs, const QualifiedName& rhs) const {
-        return lhs.lexicalLess(rhs);
-    }
-};
-
-struct UnorderedQualifiedNameLess {
-    bool operator()(const QualifiedName& lhs, const QualifiedName& rhs) const {
-        return lhs.getIndex() < rhs.getIndex();
-    }
-};
-
-struct QualifiedNameHash {
-    std::size_t operator()(const QualifiedName& qn) const {
-        return static_cast<std::size_t>(qn.getIndex());
-    }
-};
-
-/// a map from qualified name to T where qualified name keys are ordered in
-/// lexicographic order.
-template <typename T>
-using OrderedQualifiedNameMap = std::map<QualifiedName, T, OrderedQualifiedNameLess>;
-
-/// a map from qualified name to T where qualified name keys are not ordered in
-/// any deterministic order.
-template <typename T>
-using UnorderedQualifiedNameMap = std::unordered_map<QualifiedName, T, QualifiedNameHash>;
-
-/// a multi-map from qualified name to T where qualified name keys are not ordered in
-/// any deterministic order.
-template <typename T>
-using UnorderedQualifiedNameMultimap = std::unordered_multimap<QualifiedName, T, QualifiedNameHash>;
-
-/// an ordered set of qualified name ordered in lexicographic order.
-using OrderedQualifiedNameSet = std::set<QualifiedName, OrderedQualifiedNameLess>;
-
-/// an unordered set of qualified name.
-using UnorderedQualifiedNameSet = std::unordered_set<QualifiedName, QualifiedNameHash>;
-
-template <typename Container>
-OrderedQualifiedNameSet orderedQualifiedNameSet(const Container& cont) {
-    return OrderedQualifiedNameSet(cont.cbegin(), cont.cend());
+inline QualifiedName operator+(const std::string& name, const QualifiedName& id) {
+    QualifiedName res = id;
+    res.prepend(name);
+    return res;
 }
 
 }  // namespace souffle::ast
-
-template <>
-struct std::hash<souffle::ast::QualifiedName> {
-    std::size_t operator()(const souffle::ast::QualifiedName& qn) const noexcept {
-        return static_cast<std::size_t>(qn.getIndex());
-    }
-};
diff --git a/src/ast/RecordInit.cpp b/src/ast/RecordInit.cpp
index f3ee050..2881b62 100644
--- a/src/ast/RecordInit.cpp
+++ b/src/ast/RecordInit.cpp
@@ -14,7 +14,7 @@
 
 namespace souffle::ast {
 RecordInit::RecordInit(VecOwn<Argument> operands, SrcLocation loc)
-        : Term(NK_RecordInit, std::move(operands), std::move(loc)) {}
+        : Term(std::move(operands), std::move(loc)) {}
 
 void RecordInit::print(std::ostream& os) const {
     os << "[" << join(args) << "]";
@@ -23,9 +23,4 @@ void RecordInit::print(std::ostream& os) const {
 RecordInit* RecordInit::cloning() const {
     return new RecordInit(clone(args), getSrcLoc());
 }
-
-bool RecordInit::classof(const Node* n) {
-    return n->getKind() == NK_RecordInit;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/RecordInit.h b/src/ast/RecordInit.h
index 648eb4d..c9196ba 100644
--- a/src/ast/RecordInit.h
+++ b/src/ast/RecordInit.h
@@ -32,8 +32,6 @@ class RecordInit : public Term {
 public:
     RecordInit(VecOwn<Argument> operands = {}, SrcLocation loc = {});
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/RecordType.cpp b/src/ast/RecordType.cpp
index de31aa2..6ee5cda 100644
--- a/src/ast/RecordType.cpp
+++ b/src/ast/RecordType.cpp
@@ -17,7 +17,7 @@
 
 namespace souffle::ast {
 RecordType::RecordType(QualifiedName name, VecOwn<Attribute> fields, SrcLocation loc)
-        : Type(NK_RecordType, std::move(name), std::move(loc)), fields(std::move(fields)) {
+        : Type(std::move(name), std::move(loc)), fields(std::move(fields)) {
     assert(allValidPtrs(this->fields));
 }
 
@@ -34,7 +34,6 @@ void RecordType::setFieldType(std::size_t idx, QualifiedName type) {
 }
 
 void RecordType::print(std::ostream& os) const {
-    printAnnotations(os);
     os << tfm::format(".type %s = [%s]", getQualifiedName(), join(fields, ", "));
 }
 
@@ -47,8 +46,4 @@ RecordType* RecordType::cloning() const {
     return new RecordType(getQualifiedName(), clone(fields), getSrcLoc());
 }
 
-bool RecordType::classof(const Node* n) {
-    return n->getKind() == NK_RecordType;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/RecordType.h b/src/ast/RecordType.h
index 01e7b59..cfdc405 100644
--- a/src/ast/RecordType.h
+++ b/src/ast/RecordType.h
@@ -45,8 +45,6 @@ public:
     /** Set field type */
     void setFieldType(std::size_t idx, QualifiedName type);
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Relation.cpp b/src/ast/Relation.cpp
index 010960d..8f790c8 100644
--- a/src/ast/Relation.cpp
+++ b/src/ast/Relation.cpp
@@ -17,10 +17,7 @@
 
 namespace souffle::ast {
 
-Relation::Relation(SrcLocation loc) : Node(NK_Relation, loc) {}
-
-Relation::Relation(QualifiedName name, SrcLocation loc)
-        : Node(NK_Relation, std::move(loc)), name(std::move(name)) {}
+Relation::Relation(QualifiedName name, SrcLocation loc) : Node(std::move(loc)), name(std::move(name)) {}
 
 void Relation::setQualifiedName(QualifiedName n) {
     name = std::move(n);
@@ -53,25 +50,17 @@ void Relation::apply(const NodeMapper& map) {
     mapAll(attributes, map);
 }
 
-bool Relation::classof(const Node* n) {
-    return n->getKind() == NK_Relation;
-}
-
 Node::NodeVec Relation::getChildren() const {
     auto rn = makePtrRange(attributes);
     return {rn.begin(), rn.end()};
 }
 
 void Relation::print(std::ostream& os) const {
-    printAnnotations(os);
     os << ".decl " << getQualifiedName() << "(" << join(attributes, ", ") << ")" << join(qualifiers, " ")
        << " " << representation;
     if (!functionalDependencies.empty()) {
         os << " choice-domain " << join(functionalDependencies, ", ");
     }
-    if (isDeltaDebug) {
-        os << " delta_debug(" << isDeltaDebug.value() << ")";
-    }
 }
 
 bool Relation::equal(const Node& node) const {
@@ -79,7 +68,7 @@ bool Relation::equal(const Node& node) const {
     return name == other.name && equal_targets(attributes, other.attributes) &&
            qualifiers == other.qualifiers &&
            equal_targets(functionalDependencies, other.functionalDependencies) &&
-           representation == other.representation && isDeltaDebug == other.isDeltaDebug;
+           representation == other.representation;
 }
 
 Relation* Relation::cloning() const {
@@ -88,12 +77,7 @@ Relation* Relation::cloning() const {
     res->qualifiers = qualifiers;
     res->functionalDependencies = clone(functionalDependencies);
     res->representation = representation;
-    res->isDeltaDebug = isDeltaDebug;
     return res;
 }
 
-RelationSet orderedRelationSet(const UnorderedRelationSet& cont) {
-    return RelationSet(cont.cbegin(), cont.cend());
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Relation.h b/src/ast/Relation.h
index 978e2b3..9a0ae21 100644
--- a/src/ast/Relation.h
+++ b/src/ast/Relation.h
@@ -35,7 +35,7 @@ namespace souffle::ast {
  */
 class Relation : public Node {
 public:
-    Relation(SrcLocation loc = {});
+    Relation() = default;
     Relation(QualifiedName name, SrcLocation loc = {});
 
     /** Get qualified relation name */
@@ -54,15 +54,6 @@ public:
         return attributes.size();
     }
 
-    /** Return the arity of this relation */
-    std::size_t getAuxiliaryArity() const {
-        std::size_t arity = 0;
-        for (const auto& a : attributes) {
-            arity += a->getIsLattice() ? 1 : 0;
-        }
-        return arity;
-    }
-
     /** Set relation attributes */
     void setAttributes(VecOwn<Attribute> attrs);
 
@@ -106,16 +97,6 @@ public:
 
     void apply(const NodeMapper& map) override;
 
-    void setIsDeltaDebug(QualifiedName rel) {
-        isDeltaDebug = rel;
-    }
-
-    std::optional<QualifiedName> getIsDeltaDebug() const {
-        return isDeltaDebug;
-    }
-
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
@@ -141,8 +122,6 @@ private:
 
     /** Datastructure to use for this relation */
     RelationRepresentation representation{RelationRepresentation::DEFAULT};
-
-    std::optional<QualifiedName> isDeltaDebug;
 };
 
 /**
@@ -155,16 +134,7 @@ private:
 struct NameComparison {
     bool operator()(const Relation* x, const Relation* y) const {
         if (x != nullptr && y != nullptr) {
-            return x->getQualifiedName().lexicalLess(y->getQualifiedName());
-        }
-        return y != nullptr;
-    }
-};
-
-struct UnorderedNameComparison {
-    bool operator()(const Relation* x, const Relation* y) const {
-        if (x != nullptr && y != nullptr) {
-            return x->getQualifiedName().getIndex() < y->getQualifiedName().getIndex();
+            return x->getQualifiedName() < y->getQualifiedName();
         }
         return y != nullptr;
     }
@@ -172,21 +142,5 @@ struct UnorderedNameComparison {
 
 /** Relation set */
 using RelationSet = std::set<const Relation*, NameComparison>;
-using UnorderedRelationSet = std::set<const Relation*, UnorderedNameComparison>;
-
-/// Return an unordered set of relations corresponding to the given relations.
-template <typename Container>
-UnorderedRelationSet unorderedRelationSet(const Container& cont) {
-    return UnorderedRelationSet(cont.cbegin(), cont.cend());
-}
-
-/// Return an unordered set of relations corresponding to the given relations.
-template <typename Container>
-UnorderedRelationSet unorderedRelationSet(Container& cont) {
-    return UnorderedRelationSet(cont.begin(), cont.end());
-}
-
-/// Return an ordered set of relations corresponding to the given relations.
-RelationSet orderedRelationSet(const UnorderedRelationSet& cont);
 
 }  // namespace souffle::ast
diff --git a/src/ast/StringConstant.cpp b/src/ast/StringConstant.cpp
index 4c829c8..a056286 100644
--- a/src/ast/StringConstant.cpp
+++ b/src/ast/StringConstant.cpp
@@ -13,7 +13,7 @@
 namespace souffle::ast {
 
 StringConstant::StringConstant(std::string value, SrcLocation loc)
-        : Constant(NK_StringConstant, std::move(value), std::move(loc)) {}
+        : Constant(std::move(value), std::move(loc)) {}
 
 void StringConstant::print(std::ostream& os) const {
     os << "\"" << getConstant() << "\"";
@@ -23,8 +23,4 @@ StringConstant* StringConstant::cloning() const {
     return new StringConstant(getConstant(), getSrcLoc());
 }
 
-bool StringConstant::classof(const Node* n) {
-    return n->getKind() == NK_StringConstant;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/StringConstant.h b/src/ast/StringConstant.h
index 4209c52..d62d1db 100644
--- a/src/ast/StringConstant.h
+++ b/src/ast/StringConstant.h
@@ -30,9 +30,6 @@ namespace souffle::ast {
 class StringConstant : public Constant {
 public:
     explicit StringConstant(std::string value, SrcLocation loc = {});
-
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/SubsetType.cpp b/src/ast/SubsetType.cpp
index b74ff62..e3e6e32 100644
--- a/src/ast/SubsetType.cpp
+++ b/src/ast/SubsetType.cpp
@@ -14,10 +14,9 @@
 namespace souffle::ast {
 
 SubsetType::SubsetType(QualifiedName name, QualifiedName baseTypeName, SrcLocation loc)
-        : Type(NK_SubsetType, std::move(name), std::move(loc)), baseType(std::move(baseTypeName)) {}
+        : Type(std::move(name), std::move(loc)), baseType(std::move(baseTypeName)) {}
 
 void SubsetType::print(std::ostream& os) const {
-    printAnnotations(os);
     os << ".type " << getQualifiedName() << " <: " << getBaseType();
 }
 
@@ -30,8 +29,4 @@ SubsetType* SubsetType::cloning() const {
     return new SubsetType(getQualifiedName(), getBaseType(), getSrcLoc());
 }
 
-bool SubsetType::classof(const Node* n) {
-    return n->getKind() == NK_SubsetType;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/SubsetType.h b/src/ast/SubsetType.h
index f1e5d8a..7a816af 100644
--- a/src/ast/SubsetType.h
+++ b/src/ast/SubsetType.h
@@ -44,8 +44,6 @@ public:
         baseType = type;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/SubsumptiveClause.cpp b/src/ast/SubsumptiveClause.cpp
index f85214d..d09bcf2 100644
--- a/src/ast/SubsumptiveClause.cpp
+++ b/src/ast/SubsumptiveClause.cpp
@@ -19,8 +19,7 @@ namespace souffle::ast {
 
 SubsumptiveClause::SubsumptiveClause(
         Own<Atom> head, VecOwn<Literal> bodyLiterals, Own<ExecutionPlan> plan, SrcLocation loc)
-        : Clause(NK_SubsumptiveClause, std::move(head), std::move(bodyLiterals), std::move(plan),
-                  std::move(loc)) {}
+        : Clause(std::move(head), std::move(bodyLiterals), std::move(plan), std::move(loc)) {}
 
 SubsumptiveClause::SubsumptiveClause(Own<Atom> head, SrcLocation loc)
         : SubsumptiveClause(std::move(head), {}, {}, std::move(loc)) {}
@@ -34,7 +33,6 @@ void SubsumptiveClause::addToBodyFront(Own<Literal> literal) {
 }
 
 void SubsumptiveClause::print(std::ostream& os) const {
-    printAnnotations(os);
     os << *bodyLiterals[0];
     os << " <= ";
     os << *bodyLiterals[1];
@@ -52,8 +50,7 @@ void SubsumptiveClause::print(std::ostream& os) const {
 }
 
 SubsumptiveClause* SubsumptiveClause::cloning() const {
-    auto cl = new SubsumptiveClause(clone(head), clone(bodyLiterals), clone(plan), getSrcLoc());
-    return cl;
+    return new SubsumptiveClause(clone(head), clone(bodyLiterals), clone(plan), getSrcLoc());
 }
 
 Clause* SubsumptiveClause::cloneHead() const {
@@ -61,12 +58,7 @@ Clause* SubsumptiveClause::cloneHead() const {
     if (getExecutionPlan() != nullptr) {
         myClone->setExecutionPlan(clone(getExecutionPlan()));
     }
-    myClone->setAnnotationsFrom(*this);
     return myClone;
 }
 
-bool SubsumptiveClause::classof(const Node* n) {
-    return n->getKind() == NK_SubsumptiveClause;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/SubsumptiveClause.h b/src/ast/SubsumptiveClause.h
index 5c38f4f..06c8230 100644
--- a/src/ast/SubsumptiveClause.h
+++ b/src/ast/SubsumptiveClause.h
@@ -49,8 +49,6 @@ public:
 
     Clause* cloneHead() const override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Term.cpp b/src/ast/Term.cpp
index 87abbf7..2b60396 100644
--- a/src/ast/Term.cpp
+++ b/src/ast/Term.cpp
@@ -14,10 +14,8 @@
 
 namespace souffle::ast {
 
-Term::Term(NodeKind kind, VecOwn<Argument> operands, SrcLocation loc)
-        : Argument(kind, std::move(loc)), args(std::move(operands)) {
+Term::Term(VecOwn<Argument> operands, SrcLocation loc) : Argument(std::move(loc)), args(std::move(operands)) {
     assert(allValidPtrs(args));
-    assert(kind >= NK_Term && kind < NK_LastTerm);
 }
 
 std::vector<Argument*> Term::getArguments() const {
@@ -45,9 +43,4 @@ bool Term::equal(const Node& node) const {
     return equal_targets(args, other.args);
 }
 
-bool Term::classof(const Node* n) {
-    const NodeKind kind = n->getKind();
-    return (kind >= NK_Term && kind < NK_LastTerm);
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Term.h b/src/ast/Term.h
index 25c35f6..d289605 100644
--- a/src/ast/Term.h
+++ b/src/ast/Term.h
@@ -32,13 +32,13 @@ namespace souffle::ast {
 class Term : public Argument {
 protected:
     template <typename... Operands>
-    Term(NodeKind kind, Operands&&... operands) : Term(kind, {}, std::forward<Operands>(operands)...) {}
+    Term(Operands&&... operands) : Term({}, std::forward<Operands>(operands)...) {}
 
     template <typename... Operands>
-    Term(NodeKind kind, SrcLocation loc, Operands&&... operands)
-            : Term(kind, asVec(std::forward<Operands>(operands)...), std::move(loc)) {}
+    Term(SrcLocation loc, Operands&&... operands)
+            : Term(asVec(std::forward<Operands>(operands)...), std::move(loc)) {}
 
-    Term(NodeKind kind, VecOwn<Argument> operands, SrcLocation loc = {});
+    Term(VecOwn<Argument> operands, SrcLocation loc = {});
 
 public:
     /** Get arguments */
@@ -51,15 +51,16 @@ public:
 
     bool equal(const Node& node) const override;
 
-    static bool classof(const Node*);
-
 private:
     NodeVec getChildren() const override;
 
     template <typename... Operands>
     static VecOwn<Argument> asVec(Operands... ops) {
+        Own<Argument> ary[] = {std::move(ops)...};
         VecOwn<Argument> xs;
-        (xs.emplace_back(std::move(std::forward<Operands>(ops))), ...);
+        for (auto&& x : ary) {
+            xs.push_back(std::move(x));
+        }
         return xs;
     }
 
diff --git a/src/ast/TranslationUnit.cpp b/src/ast/TranslationUnit.cpp
index 77a3c5f..a2975b6 100644
--- a/src/ast/TranslationUnit.cpp
+++ b/src/ast/TranslationUnit.cpp
@@ -8,7 +8,6 @@
 
 #include "ast/TranslationUnit.h"
 #include "Global.h"
-#include "ast/Program.h"
 #include "ast/analysis/PrecedenceGraph.h"
 #include "ast/analysis/SCCGraph.h"
 #include "reports/DebugReport.h"
@@ -18,13 +17,14 @@ namespace souffle::ast {
 
 /** get analysis: analysis is generated on the fly if not present */
 void TranslationUnit::logAnalysis(Analysis& analysis) const {
-    if (!global().config().has("debug-report")) return;
+    if (!Global::config().has("debug-report")) return;
 
     std::string name = analysis.getName();
     if (as<analysis::PrecedenceGraphAnalysis>(analysis) || as<analysis::SCCGraphAnalysis>(analysis)) {
-        debugReport.addSection(DebugReportSection(name, "Ast Analysis [" + name + "]", {}, toHtml(analysis)));
+        debugReport.addSection(
+                DebugReportSection(name, "Ast Analysis [" + name + "]", {}, toString(analysis)));
     } else {
-        debugReport.addSection(name, "Ast Analysis [" + name + "]", toHtml(analysis));
+        debugReport.addSection(name, "Ast Analysis [" + name + "]", toString(analysis));
     }
 }
 
diff --git a/src/ast/TranslationUnit.h b/src/ast/TranslationUnit.h
index 21e21ca..d3aeea7 100644
--- a/src/ast/TranslationUnit.h
+++ b/src/ast/TranslationUnit.h
@@ -16,11 +16,12 @@
 
 #pragma once
 
-#include "Program.h"
 #include "TranslationUnitBase.h"
 
 namespace souffle::ast {
 
+class Program;
+
 /**
  * @class TranslationUnit
  * @brief Translation unit class for the translation pipeline
diff --git a/src/ast/Type.cpp b/src/ast/Type.cpp
index 6ddc07a..2ec7f34 100644
--- a/src/ast/Type.cpp
+++ b/src/ast/Type.cpp
@@ -11,18 +11,10 @@
 
 namespace souffle::ast {
 
-Type::Type(NodeKind kind, QualifiedName name, SrcLocation loc)
-        : Node(kind, std::move(loc)), name(std::move(name)) {
-    assert(kind > NK_Type && kind < NK_LastType);
-}
+Type::Type(QualifiedName name, SrcLocation loc) : Node(std::move(loc)), name(std::move(name)) {}
 
 void Type::setQualifiedName(QualifiedName name) {
     this->name = std::move(name);
 }
 
-bool Type::classof(const Node* n) {
-    const NodeKind kind = n->getKind();
-    return (kind >= NK_Type && kind < NK_LastType);
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Type.h b/src/ast/Type.h
index 066241c..24c82a3 100644
--- a/src/ast/Type.h
+++ b/src/ast/Type.h
@@ -28,7 +28,7 @@ namespace souffle::ast {
  */
 class Type : public Node {
 public:
-    Type(NodeKind kind, QualifiedName name = {}, SrcLocation loc = {});
+    Type(QualifiedName name = {}, SrcLocation loc = {});
 
     /** Return type name */
     const QualifiedName& getQualifiedName() const {
@@ -38,8 +38,6 @@ public:
     /** Set type name */
     void setQualifiedName(QualifiedName name);
 
-    static bool classof(const Node*);
-
 private:
     /** type name */
     QualifiedName name;
diff --git a/src/ast/TypeCast.cpp b/src/ast/TypeCast.cpp
index 9e96528..a87d248 100644
--- a/src/ast/TypeCast.cpp
+++ b/src/ast/TypeCast.cpp
@@ -17,7 +17,7 @@
 namespace souffle::ast {
 
 TypeCast::TypeCast(Own<Argument> value, QualifiedName type, SrcLocation loc)
-        : Argument(NK_TypeCast, std::move(loc)), value(std::move(value)), type(std::move(type)) {
+        : Argument(std::move(loc)), value(std::move(value)), type(std::move(type)) {
     assert(this->value != nullptr);
 }
 
@@ -47,9 +47,4 @@ bool TypeCast::equal(const Node& node) const {
 TypeCast* TypeCast::cloning() const {
     return new TypeCast(clone(value), type, getSrcLoc());
 }
-
-bool TypeCast::classof(const Node* n) {
-    return n->getKind() == NK_TypeCast;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/TypeCast.h b/src/ast/TypeCast.h
index eb51699..18fe62a 100644
--- a/src/ast/TypeCast.h
+++ b/src/ast/TypeCast.h
@@ -47,8 +47,6 @@ public:
 
     void apply(const NodeMapper& map) override;
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/UnionType.cpp b/src/ast/UnionType.cpp
index a57dd6a..971b90f 100644
--- a/src/ast/UnionType.cpp
+++ b/src/ast/UnionType.cpp
@@ -14,7 +14,7 @@
 
 namespace souffle::ast {
 UnionType::UnionType(QualifiedName name, std::vector<QualifiedName> types, SrcLocation loc)
-        : Type(NK_UnionType, std::move(name), std::move(loc)), types(std::move(types)) {}
+        : Type(std::move(name), std::move(loc)), types(std::move(types)) {}
 
 void UnionType::add(QualifiedName type) {
     types.push_back(std::move(type));
@@ -25,7 +25,6 @@ void UnionType::setType(std::size_t idx, QualifiedName type) {
 }
 
 void UnionType::print(std::ostream& os) const {
-    printAnnotations(os);
     os << ".type " << getQualifiedName() << " = " << join(types, " | ");
 }
 
@@ -38,8 +37,4 @@ UnionType* UnionType::cloning() const {
     return new UnionType(getQualifiedName(), types, getSrcLoc());
 }
 
-bool UnionType::classof(const Node* n) {
-    return n->getKind() == NK_UnionType;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/UnionType.h b/src/ast/UnionType.h
index e652eec..c19b890 100644
--- a/src/ast/UnionType.h
+++ b/src/ast/UnionType.h
@@ -55,8 +55,6 @@ public:
     /** Set type */
     void setType(std::size_t idx, QualifiedName type);
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/UnnamedVariable.cpp b/src/ast/UnnamedVariable.cpp
index 3edc2f0..d3cd866 100644
--- a/src/ast/UnnamedVariable.cpp
+++ b/src/ast/UnnamedVariable.cpp
@@ -11,8 +11,6 @@
 
 namespace souffle::ast {
 
-UnnamedVariable::UnnamedVariable(SrcLocation loc) : Argument(NK_UnnamedVariable, loc) {}
-
 void UnnamedVariable::print(std::ostream& os) const {
     os << "_";
 }
@@ -21,12 +19,4 @@ UnnamedVariable* UnnamedVariable::cloning() const {
     return new UnnamedVariable(getSrcLoc());
 }
 
-bool UnnamedVariable::classof(const Node* n) {
-    return n->getKind() == NK_UnnamedVariable;
-}
-
-bool UnnamedVariable::equal(const Node&) const {
-    return true;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/UnnamedVariable.h b/src/ast/UnnamedVariable.h
index 5786470..c2794d1 100644
--- a/src/ast/UnnamedVariable.h
+++ b/src/ast/UnnamedVariable.h
@@ -29,16 +29,10 @@ class UnnamedVariable : public Argument {
 public:
     using Argument::Argument;
 
-    UnnamedVariable(SrcLocation loc = {});
-
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
 private:
-    bool equal(const Node&) const override;
-
     UnnamedVariable* cloning() const override;
 };
 
diff --git a/src/ast/UserDefinedFunctor.cpp b/src/ast/UserDefinedFunctor.cpp
index c6b58bf..1ab3e12 100644
--- a/src/ast/UserDefinedFunctor.cpp
+++ b/src/ast/UserDefinedFunctor.cpp
@@ -16,11 +16,10 @@
 
 namespace souffle::ast {
 
-UserDefinedFunctor::UserDefinedFunctor(std::string name)
-        : Functor(NK_UserDefinedFunctor, {}, {}), name(std::move(name)) {}
+UserDefinedFunctor::UserDefinedFunctor(std::string name) : Functor({}, {}), name(std::move(name)){};
 
 UserDefinedFunctor::UserDefinedFunctor(std::string name, VecOwn<Argument> args, SrcLocation loc)
-        : Functor(NK_UserDefinedFunctor, std::move(args), std::move(loc)), name(std::move(name)) {}
+        : Functor(std::move(args), std::move(loc)), name(std::move(name)) {}
 
 void UserDefinedFunctor::print(std::ostream& os) const {
     os << '@' << name << "(" << join(args) << ")";
@@ -35,8 +34,4 @@ UserDefinedFunctor* UserDefinedFunctor::cloning() const {
     return new UserDefinedFunctor(name, clone(args), getSrcLoc());
 }
 
-bool UserDefinedFunctor::classof(const Node* n) {
-    return n->getKind() == NK_UserDefinedFunctor;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/UserDefinedFunctor.h b/src/ast/UserDefinedFunctor.h
index 950454a..17acbd5 100644
--- a/src/ast/UserDefinedFunctor.h
+++ b/src/ast/UserDefinedFunctor.h
@@ -40,8 +40,6 @@ public:
         return name;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/Variable.cpp b/src/ast/Variable.cpp
index 0e870c2..2e51e83 100644
--- a/src/ast/Variable.cpp
+++ b/src/ast/Variable.cpp
@@ -12,8 +12,7 @@
 #include <utility>
 
 namespace souffle::ast {
-Variable::Variable(std::string name, SrcLocation loc)
-        : Argument(NK_Variable, std::move(loc)), name(std::move(name)) {}
+Variable::Variable(std::string name, SrcLocation loc) : Argument(std::move(loc)), name(std::move(name)) {}
 
 void Variable::setName(std::string name) {
     this->name = std::move(name);
@@ -31,9 +30,4 @@ bool Variable::equal(const Node& node) const {
 Variable* Variable::cloning() const {
     return new Variable(name, getSrcLoc());
 }
-
-bool Variable::classof(const Node* n) {
-    return n->getKind() == NK_Variable;
-}
-
 }  // namespace souffle::ast
diff --git a/src/ast/Variable.h b/src/ast/Variable.h
index 4ef1900..6173647 100644
--- a/src/ast/Variable.h
+++ b/src/ast/Variable.h
@@ -39,8 +39,6 @@ public:
         return name;
     }
 
-    static bool classof(const Node*);
-
 protected:
     void print(std::ostream& os) const override;
 
diff --git a/src/ast/analysis/Aggregate.cpp b/src/ast/analysis/Aggregate.cpp
index c6741e0..ffe6b47 100644
--- a/src/ast/analysis/Aggregate.cpp
+++ b/src/ast/analysis/Aggregate.cpp
@@ -95,7 +95,7 @@ std::set<std::string> getWitnessVariables(
         }
     };
 
-    auto aggregatorlessClause = mk<Clause>(QualifiedName::fromString("*"));
+    auto aggregatorlessClause = mk<Clause>("*");
     aggregatorlessClause->setBodyLiterals(clone(clause.getBodyLiterals()));
 
     auto negatedHead = mk<Negation>(clone(clause.getHead()));
@@ -104,14 +104,14 @@ std::set<std::string> getWitnessVariables(
     // Replace all aggregates with variables
     M update;
     aggregatorlessClause->apply(update);
-    auto groundingAtom = mk<Atom>(QualifiedName::fromString("+grounding_atom"));
+    auto groundingAtom = mk<Atom>("+grounding_atom");
     for (std::string variableName : update.getAggregatorVariables()) {
         groundingAtom->addArgument(mk<Variable>(variableName));
     }
     aggregatorlessClause->addToBody(std::move(groundingAtom));
     // 2. Create an aggregate clause so that we can check
     // that it IS this aggregate giving a grounding to the candidate variable.
-    auto aggregateSubclause = mk<Clause>(QualifiedName::fromString("*"));
+    auto aggregateSubclause = mk<Clause>("*");
     aggregateSubclause->setBodyLiterals(clone(aggregate.getBodyLiterals()));
 
     std::set<std::string> witnessVariables;
@@ -177,7 +177,7 @@ std::string findUniqueVariableName(const Clause& clause, std::string base) {
 std::string findUniqueRelationName(const Program& program, std::string base) {
     int counter = 0;
     auto candidate = base;
-    while (program.getRelation(QualifiedName::fromString(candidate)) != nullptr) {
+    while (program.getRelation(candidate) != nullptr) {
         candidate = base + toString(counter++);
     }
     return candidate;
@@ -321,7 +321,7 @@ std::set<std::string> getInjectedVariables(
     };
     // 2. make a clone of the clause and then apply that mapper onto it
     auto clauseCopy = clone(clause);
-    auto tweakedClause = mk<Clause>(QualifiedName::fromString("*"));
+    auto tweakedClause = mk<Clause>("*");
     tweakedClause->setBodyLiterals(clone(clause.getBodyLiterals()));
 
     // copy in the head as a negated atom
@@ -330,7 +330,7 @@ std::set<std::string> getInjectedVariables(
     ReplaceAggregatesWithVariables update(std::move(ancestorAggregates), clone(aggregate));
     tweakedClause->apply(update);
     // the update will now tell us which variables we need to ground!
-    auto groundingAtom = mk<Atom>(QualifiedName::fromString("+grounding_atom"));
+    auto groundingAtom = mk<Atom>("+grounding_atom");
     for (std::string variableName : update.getAggregatorVariables()) {
         groundingAtom->addArgument(mk<Variable>(variableName));
     }
diff --git a/src/ast/analysis/ClauseNormalisation.cpp b/src/ast/analysis/ClauseNormalisation.cpp
index 97a886f..f597432 100644
--- a/src/ast/analysis/ClauseNormalisation.cpp
+++ b/src/ast/analysis/ClauseNormalisation.cpp
@@ -44,7 +44,7 @@ namespace souffle::ast::analysis {
 
 NormalisedClause::NormalisedClause(const Clause* clause) {
     // head
-    QualifiedName name = QualifiedName::fromString("@min:head");
+    QualifiedName name("@min:head");
     std::vector<std::string> headVars;
     for (const auto* arg : clause->getHead()->getArguments()) {
         headVars.push_back(normaliseArgument(arg));
@@ -76,7 +76,7 @@ void NormalisedClause::addClauseBodyLiteral(const std::string& scopeID, const Li
     } else if (const auto* neg = as<Negation>(lit)) {
         addClauseAtom("@min:neg", scopeID, neg->getAtom());
     } else if (const auto* bc = as<BinaryConstraint>(lit)) {
-        QualifiedName name = QualifiedName::fromString(toBinaryConstraintSymbol(bc->getBaseOperator()));
+        QualifiedName name(toBinaryConstraintSymbol(bc->getBaseOperator()));
         name.prepend("@min:operator");
         std::vector<std::string> vars;
         vars.push_back(scopeID);
@@ -88,7 +88,7 @@ void NormalisedClause::addClauseBodyLiteral(const std::string& scopeID, const Li
         fullyNormalised = false;
         std::stringstream qualifier;
         qualifier << "@min:unhandled:lit:" << scopeID;
-        QualifiedName name = QualifiedName::fromString(toString(*lit));
+        QualifiedName name(toString(*lit));
         name.prepend(qualifier.str());
         clauseElements.push_back({name, std::vector<std::string>()});
     }
@@ -130,7 +130,7 @@ std::string NormalisedClause::normaliseArgument(const Argument* arg) {
         std::vector<std::string> aggrTypeSignatureComponents;
 
         // - the operator is fixed and cannot be changed
-        aggrTypeSignature << ":" << aggr->getBaseOperatorName();
+        aggrTypeSignature << ":" << aggr->getBaseOperator();
 
         // - the scope can be remapped as a variable
         aggrTypeSignatureComponents.push_back(scopeID.str());
@@ -142,8 +142,7 @@ std::string NormalisedClause::normaliseArgument(const Argument* arg) {
         }
 
         // Type signature is its own special atom
-        clauseElements.push_back(
-                {QualifiedName::fromString(aggrTypeSignature.str()), aggrTypeSignatureComponents});
+        clauseElements.push_back({aggrTypeSignature.str(), aggrTypeSignatureComponents});
 
         // Add each contained normalised clause literal, tying it with the new scope ID
         for (const auto* literal : aggr->getBodyLiterals()) {
diff --git a/src/ast/analysis/ComponentLookup.cpp b/src/ast/analysis/ComponentLookup.cpp
index 665b971..8ba4b22 100644
--- a/src/ast/analysis/ComponentLookup.cpp
+++ b/src/ast/analysis/ComponentLookup.cpp
@@ -42,10 +42,10 @@ void ComponentLookupAnalysis::run(const TranslationUnit& translationUnit) {
 const Component* ComponentLookupAnalysis::getComponent(
         const Component* scope, const std::string& name, const TypeBinding& activeBinding) const {
     // forward according to binding (we do not do this recursively on purpose)
-    const QualifiedName qn = QualifiedName::fromString(name);
-    QualifiedName boundName = activeBinding.find(qn);
+    QualifiedName boundName = activeBinding.find(name);
     if (boundName.empty()) {
-        boundName = qn;
+        // compName is not bound to anything => just just compName
+        boundName = name;
     }
 
     // search nested scopes bottom up
diff --git a/src/ast/analysis/ComponentLookup.h b/src/ast/analysis/ComponentLookup.h
index 6e288f3..84d1e58 100644
--- a/src/ast/analysis/ComponentLookup.h
+++ b/src/ast/analysis/ComponentLookup.h
@@ -67,7 +67,7 @@ private:
      * Key value pair. Keys are names that should be forwarded to value,
      * which is the actual name. Example T->MyImplementation.
      */
-    UnorderedQualifiedNameMap<QualifiedName> binding;
+    std::map<QualifiedName, QualifiedName> binding;
 };
 
 class ComponentLookupAnalysis : public Analysis {
diff --git a/src/ast/analysis/Constraint.h b/src/ast/analysis/Constraint.h
index ab50319..a94ea71 100644
--- a/src/ast/analysis/Constraint.h
+++ b/src/ast/analysis/Constraint.h
@@ -17,8 +17,6 @@
 #pragma once
 
 #include "ConstraintSystem.h"
-#include "ErrorAnalyzer.h"
-#include "ValueChecker.h"
 #include "ast/Argument.h"
 #include "ast/Clause.h"
 #include "ast/Node.h"
@@ -46,12 +44,6 @@ struct ConstraintAnalysisVar : public Variable<const Argument*, PropertySpace> {
     void print(std::ostream& out) const override {
         out << "var(" << *(this->id) << ")";
     }
-
-    const std::string name() const {
-        std::stringstream ss;
-        ss << *(this->id);
-        return ss.str();
-    }
 };
 
 /**
@@ -63,12 +55,11 @@ struct ConstraintAnalysisVar : public Variable<const Argument*, PropertySpace> {
  *      to be utilized by this analysis.
  */
 template <typename AnalysisVar>
-class ConstraintAnalysis : public Visitor<void>, ValueChecker<AnalysisVar> {
+class ConstraintAnalysis : public Visitor<void> {
 public:
     using value_type = typename AnalysisVar::property_space::value_type;
     using constraint_type = std::shared_ptr<Constraint<AnalysisVar>>;
     using solution_type = std::map<const Argument*, value_type>;
-    using error_analyzer_type = ErrorAnalyzer<AnalysisVar>;
 
     virtual void collectConstraints(const Clause& clause) {
         visit(clause, *this);
@@ -81,9 +72,7 @@ public:
      * @param debug a flag enabling the printing of debug information
      * @return an assignment mapping a property to each argument in the given clause
      */
-    solution_type analyse(const Clause& clause, error_analyzer_type* errorAnalyzer = nullptr,
-            std::ostream* debugOutput = nullptr) {
-        this->errorAnalyzer = errorAnalyzer;
+    solution_type analyse(const Clause& clause, std::ostream* debugOutput = nullptr) {
         collectConstraints(clause);
 
         assignment = constraints.solve();
@@ -95,29 +84,9 @@ public:
             *debugOutput << "Solution:\n" << assignment << "\n";
         }
 
-        if (errorAnalyzer) {
-            std::map<AnalysisVar, typename Problem<AnalysisVar>::unsat_core_type> unsat_cores;
-            for (const auto& [arg, value] : assignment) {
-                if (!this->valueIsValid(value)) {
-                    auto unsat_core = constraints.extractUnsatCore(arg);
-                    unsat_cores[arg] = unsat_core;
-                }
-            }
-            std::map<AnalysisVar, std::set<const Argument*>> equivalentArguments;
-            visit(clause, [&](const Argument& arg) {
-                errorAnalyzer->addUnsatCore(&arg, unsat_cores[getVar(arg)]);
-                equivalentArguments[getVar(arg)].emplace(&arg);
-            });
-            for (const auto& [_, argSet] : equivalentArguments) {
-                errorAnalyzer->addEquivalentArgumentSet(argSet);
-            }
-        }
-
         // convert assignment to result
         solution_type solution;
         visit(clause, [&](const Argument& arg) { solution[&arg] = assignment[getVar(arg)]; });
-
-        this->errorAnalyzer = nullptr;
         return solution;
     }
 
@@ -162,8 +131,6 @@ protected:
 
     /** A map mapping variables to unique instances to facilitate the unification of variables */
     std::map<std::string, AnalysisVar> variables;
-
-    error_analyzer_type* errorAnalyzer = nullptr;
 };
 
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/ConstraintSystem.h b/src/ast/analysis/ConstraintSystem.h
index 9fa9f57..41488d4 100644
--- a/src/ast/analysis/ConstraintSystem.h
+++ b/src/ast/analysis/ConstraintSystem.h
@@ -16,7 +16,6 @@
 
 #pragma once
 
-#include "ValueChecker.h"
 #include "souffle/utility/StreamUtil.h"
 #include <iostream>
 #include <map>
@@ -65,13 +64,6 @@ struct default_meet_op {
         return res;
     }
 };
-
-template <typename T>
-struct default_is_valid_op {
-    bool operator()(const T&) {
-        return true;
-    }
-};
 }  // namespace detail
 
 /**
@@ -93,13 +85,11 @@ struct default_is_valid_op {
  */
 template <typename T, typename meet_assign_op,
         typename bottom_factory = typename detail::default_bottom_factory<T>,
-        typename meet_op = typename detail::default_meet_op<T, meet_assign_op>,
-        typename is_valid_op = typename detail::default_is_valid_op<T>>
+        typename meet_op = typename detail::default_meet_op<T, meet_assign_op>>
 struct property_space {
     using value_type = T;
     using meet_assign_op_type = meet_assign_op;
     using meet_op_type = meet_op;
-    using is_valid_op_type = is_valid_op;
     using bottom_factory_type = bottom_factory;
 };
 
@@ -214,10 +204,6 @@ public:
         c.print(out);
         return out;
     }
-
-    virtual std::optional<std::string> customMessage() const {
-        return std::nullopt;
-    }
 };
 
 //----------------------------------------------------------------------
@@ -377,18 +363,11 @@ public:
  * @tparam Var the domain of variables handled by this problem
  */
 template <typename Var>
-class Problem : public ValueChecker<Var> {
+class Problem {
     // a few type definitions
     using constraint = Constraint<Var>;
     using constraint_ptr = std::shared_ptr<constraint>;
 
-    using value_type = typename Var::property_space::value_type;
-    using problem_type = Problem<Var>;
-
-public:
-    using unsat_core_type = typename std::set<constraint_ptr>;
-
-private:
     /** The list of covered constraints */
     std::vector<constraint_ptr> constraints;
 
@@ -430,31 +409,6 @@ public:
         return assignment;
     }
 
-    unsat_core_type extractUnsatCore(const Var& var) {
-        unsat_core_type unsat_core;
-        const auto& constraints = (static_cast<Problem*>(this))->constraints;
-
-        while (true) {
-            Assignment<Var> assignment;
-            for (const auto& constraint : unsat_core) {
-                constraint->update(assignment);
-            }
-            if (!this->valueIsValid(assignment[var])) {
-                break;
-            }
-            auto size_unsat_core = unsat_core.size();
-            for (const auto& constraint : constraints) {
-                constraint->update(assignment);
-                if (!this->valueIsValid(assignment[var])) {
-                    unsat_core.insert(constraint);
-                    break;
-                }
-            }
-            if (size_unsat_core == unsat_core.size()) break;
-        }
-        return unsat_core;
-    }
-
     /** Enables a problem to be printed (debugging) */
     void print(std::ostream& out) const {
         if (constraints.empty()) {
diff --git a/src/ast/analysis/Functor.cpp b/src/ast/analysis/Functor.cpp
index 78990d6..0ca9525 100644
--- a/src/ast/analysis/Functor.cpp
+++ b/src/ast/analysis/Functor.cpp
@@ -19,7 +19,6 @@
 #include "ast/FunctorDeclaration.h"
 #include "ast/IntrinsicFunctor.h"
 #include "ast/TranslationUnit.h"
-#include "ast/UserDefinedAggregator.h"
 #include "ast/UserDefinedFunctor.h"
 #include "ast/utility/Visitor.h"
 
@@ -37,10 +36,6 @@ bool FunctorAnalysis::isStatefulFunctor(const UserDefinedFunctor& functor) const
     return getFunctorDeclaration(functor).isStateful();
 }
 
-bool FunctorAnalysis::isStatefulFunctor(const UserDefinedAggregator& aggregator) const {
-    return getFunctorDeclaration(aggregator).isStateful();
-}
-
 QualifiedName const& FunctorAnalysis::getFunctorReturnType(const UserDefinedFunctor& functor) const {
     return getFunctorDeclaration(functor).getReturnType().getTypeName();
 }
@@ -53,11 +48,6 @@ FunctorDeclaration const& FunctorAnalysis::getFunctorDeclaration(const UserDefin
     return *functorNameToDeclaration.at(functor.getName());
 }
 
-FunctorDeclaration const& FunctorAnalysis::getFunctorDeclaration(
-        const UserDefinedAggregator& aggregator) const {
-    return *functorNameToDeclaration.at(aggregator.getBaseOperatorName());
-}
-
 bool FunctorAnalysis::isMultiResult(const Functor& functor) {
     if (isA<UserDefinedFunctor>(functor)) {
         return false;
diff --git a/src/ast/analysis/Functor.h b/src/ast/analysis/Functor.h
index 839ade4..28d8db0 100644
--- a/src/ast/analysis/Functor.h
+++ b/src/ast/analysis/Functor.h
@@ -18,7 +18,6 @@
 
 #include "ast/FunctorDeclaration.h"
 #include "ast/TranslationUnit.h"
-#include "ast/UserDefinedAggregator.h"
 #include "souffle/TypeAttribute.h"
 #include <iosfwd>
 #include <unordered_map>
@@ -51,9 +50,7 @@ public:
     std::size_t getFunctorArity(UserDefinedFunctor const& functor) const;
     QualifiedName const& getFunctorReturnType(const UserDefinedFunctor& functor) const;
     bool isStatefulFunctor(const UserDefinedFunctor& functor) const;
-    bool isStatefulFunctor(const UserDefinedAggregator& aggregator) const;
     const FunctorDeclaration& getFunctorDeclaration(const UserDefinedFunctor& functor) const;
-    const FunctorDeclaration& getFunctorDeclaration(const UserDefinedAggregator& aggregator) const;
 
     /** Return whether a UDF is stateful */
     bool isStateful(const UserDefinedFunctor& udf) const;
diff --git a/src/ast/analysis/Ground.cpp b/src/ast/analysis/Ground.cpp
index 4c657e8..52d7c94 100644
--- a/src/ast/analysis/Ground.cpp
+++ b/src/ast/analysis/Ground.cpp
@@ -154,23 +154,8 @@ BoolDisjunctConstraint imply(const std::vector<BoolDisjunctVar>& vars, const Boo
 struct GroundednessAnalysis : public ConstraintAnalysis<BoolDisjunctVar> {
     Program& program;
     std::set<const Atom*> ignore;
-    UnorderedQualifiedNameMap<std::set<std::size_t>> latticeAttributes;
-    bool isLatticeTransformerPass;
-
-    GroundednessAnalysis(const TranslationUnit& tu, bool isLatticeTransformerPass)
-            : program(tu.getProgram()), isLatticeTransformerPass(isLatticeTransformerPass) {
-        if (isLatticeTransformerPass) {
-            for (const Relation* rel : program.getRelations()) {
-                const auto attributes = rel->getAttributes();
-                const auto& name = rel->getQualifiedName();
-                for (std::size_t i = 0; i < attributes.size(); i++) {
-                    if (attributes[i]->getIsLattice()) {
-                        latticeAttributes[name].insert(i);
-                    }
-                }
-            }
-        }
-    }
+
+    GroundednessAnalysis(const TranslationUnit& tu) : program(tu.getProgram()) {}
 
     // atoms are producing grounded variables
     void visit_(type_identity<Atom>, const Atom& cur) override {
@@ -179,14 +164,9 @@ struct GroundednessAnalysis : public ConstraintAnalysis<BoolDisjunctVar> {
             return;
         }
 
-        // all arguments are grounded except lattice arguments
-        const auto& name = cur.getQualifiedName();
-        const auto& args = cur.getArguments();
-        for (std::size_t i = 0; i < cur.getArity(); i++) {
-            if (!isLatticeTransformerPass || !latticeAttributes.count(name) ||
-                    !latticeAttributes[name].count(i)) {
-                addConstraint(isTrue(getVar(args[i])));
-            }
+        // all arguments are grounded
+        for (const auto& arg : cur.getArguments()) {
+            addConstraint(isTrue(getVar(arg)));
         }
     }
 
@@ -285,10 +265,9 @@ struct GroundednessAnalysis : public ConstraintAnalysis<BoolDisjunctVar> {
 /***
  * computes for variables in the clause whether they are grounded
  */
-std::map<const Argument*, bool> getGroundedTerms(
-        const TranslationUnit& tu, const Clause& clause, bool isLatticeTransformerPass) {
+std::map<const Argument*, bool> getGroundedTerms(const TranslationUnit& tu, const Clause& clause) {
     // run analysis on given clause
-    return GroundednessAnalysis(tu, isLatticeTransformerPass).analyse(clause);
+    return GroundednessAnalysis(tu).analyse(clause);
 }
 
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/Ground.h b/src/ast/analysis/Ground.h
index 8ac8689..f6ca733 100644
--- a/src/ast/analysis/Ground.h
+++ b/src/ast/analysis/Ground.h
@@ -32,7 +32,6 @@ namespace souffle::ast::analysis {
  * @return a map mapping each contained argument to a boolean indicating
  *      whether the argument represents a grounded value or not
  */
-std::map<const Argument*, bool> getGroundedTerms(
-        const TranslationUnit& tu, const Clause& clause, bool isLatticeTransformerPass = false);
+std::map<const Argument*, bool> getGroundedTerms(const TranslationUnit& tu, const Clause& clause);
 
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/IOType.h b/src/ast/analysis/IOType.h
index ff39612..9bf0dc4 100644
--- a/src/ast/analysis/IOType.h
+++ b/src/ast/analysis/IOType.h
@@ -69,10 +69,10 @@ public:
     }
 
 private:
-    RelationSet inputRelations;
-    RelationSet outputRelations;
-    RelationSet printSizeRelations;
-    RelationSet limitSizeRelations;
+    std::set<const Relation*> inputRelations;
+    std::set<const Relation*> outputRelations;
+    std::set<const Relation*> printSizeRelations;
+    std::set<const Relation*> limitSizeRelations;
     std::map<const Relation*, std::size_t> limitSize;
 };
 
diff --git a/src/ast/analysis/PrecedenceGraph.cpp b/src/ast/analysis/PrecedenceGraph.cpp
index 64e3492..5c783cb 100644
--- a/src/ast/analysis/PrecedenceGraph.cpp
+++ b/src/ast/analysis/PrecedenceGraph.cpp
@@ -27,7 +27,6 @@
 #include "ast/Relation.h"
 #include "ast/TranslationUnit.h"
 #include "ast/utility/Visitor.h"
-#include "souffle/utility/StringUtil.h"
 #include <set>
 #include <string>
 #include <vector>
@@ -49,13 +48,6 @@ void PrecedenceGraphAnalysis::run(const TranslationUnit& translationUnit) {
                 souffle::visit(literals[i], addEdgeToR);
             }
         }
-
-        // delta_debug relation are computed from the original relation
-        if (const auto deltaDebug = r->getIsDeltaDebug()) {
-            const auto* dbg = program.getRelation(deltaDebug.value());
-            backingGraph.insert(r, dbg);
-            backingGraph.insert(dbg, r);
-        }
     }
 }
 
diff --git a/src/ast/analysis/PrecedenceGraph.h b/src/ast/analysis/PrecedenceGraph.h
index fda88f6..abeb366 100644
--- a/src/ast/analysis/PrecedenceGraph.h
+++ b/src/ast/analysis/PrecedenceGraph.h
@@ -21,9 +21,7 @@
 #include "GraphUtils.h"
 #include "ast/Relation.h"
 #include "ast/TranslationUnit.h"
-#include "souffle/datastructure/Graph.h"
-#include <ostream>
-#include <sstream>
+#include <string>
 
 namespace souffle::ast {
 
@@ -45,16 +43,16 @@ public:
     /** Output precedence graph in text format to a given stream */
     void print(std::ostream& os) const override;
 
-    /** Output precedence graph in image format to a given stream */
-    void printHTML(std::ostream& os) const override;
+    /** Output precedence graph in graphviz format to a given stream */
+    void printHTML(std::ostream& os) const;
 
-    const Graph<const Relation*, UnorderedNameComparison>& graph() const {
+    const Graph<const Relation*, NameComparison>& graph() const {
         return backingGraph;
     }
 
 private:
     /** Adjacency list of precedence graph (determined by the dependencies of the relations) */
-    Graph<const Relation*, UnorderedNameComparison> backingGraph;
+    Graph<const Relation*, NameComparison> backingGraph;
 
     /** Output precedence graph in text format to a given stringstream */
     void printRaw(std::stringstream& ss) const;
diff --git a/src/ast/analysis/ProfileUse.cpp b/src/ast/analysis/ProfileUse.cpp
index b6fc8ce..fe290ea 100644
--- a/src/ast/analysis/ProfileUse.cpp
+++ b/src/ast/analysis/ProfileUse.cpp
@@ -17,7 +17,6 @@
 
 #include "ast/analysis/ProfileUse.h"
 #include "Global.h"
-#include "ast/Program.h"
 #include "ast/QualifiedName.h"
 #include "souffle/profile/ProgramRun.h"
 #include "souffle/profile/Reader.h"
@@ -30,10 +29,10 @@ namespace souffle::ast::analysis {
 /**
  * Run analysis, i.e., retrieve profile information
  */
-void ProfileUseAnalysis::run(const TranslationUnit& TU) {
+void ProfileUseAnalysis::run(const TranslationUnit&) {
     std::string filename;
-    if (TU.global().config().has("auto-schedule")) {
-        filename = TU.global().config().get("auto-schedule");
+    if (Global::config().has("auto-schedule")) {
+        filename = Global::config().get("auto-schedule");
     }
     reader = mk<profile::Reader>(filename, programRun);
     reader->processFile();
@@ -66,14 +65,14 @@ bool ProfileUseAnalysis::hasAutoSchedulerStats() const {
     return reader->hasAutoSchedulerStats();
 }
 
-double ProfileUseAnalysis::getNonRecursiveJoinSize(
+std::size_t ProfileUseAnalysis::getNonRecursiveUniqueKeys(
         const std::string& rel, const std::string& attributes, const std::string& constants) const {
-    return reader->getNonRecursiveEstimateJoinSize(rel, attributes, constants);
+    return reader->getNonRecursiveCountUniqueKeys(rel, attributes, constants);
 }
 
-double ProfileUseAnalysis::getRecursiveJoinSize(const std::string& rel, const std::string& attributes,
+std::size_t ProfileUseAnalysis::getRecursiveUniqueKeys(const std::string& rel, const std::string& attributes,
         const std::string& constants, const std::string& iteration) const {
-    return reader->getRecursiveEstimateJoinSize(rel, attributes, constants, iteration);
+    return reader->getRecursiveCountUniqueKeys(rel, attributes, constants, iteration);
 }
 
 std::size_t ProfileUseAnalysis::getIterations(const std::string& rel) const {
diff --git a/src/ast/analysis/ProfileUse.h b/src/ast/analysis/ProfileUse.h
index 9ec7351..d23de41 100644
--- a/src/ast/analysis/ProfileUse.h
+++ b/src/ast/analysis/ProfileUse.h
@@ -56,10 +56,10 @@ public:
 
     bool hasAutoSchedulerStats() const;
 
-    double getNonRecursiveJoinSize(
+    std::size_t getNonRecursiveUniqueKeys(
             const std::string& rel, const std::string& attributes, const std::string& constants) const;
 
-    double getRecursiveJoinSize(const std::string& rel, const std::string& attributes,
+    std::size_t getRecursiveUniqueKeys(const std::string& rel, const std::string& attributes,
             const std::string& constants, const std::string& iteration) const;
 
     std::size_t getIterations(const std::string& rel) const;
diff --git a/src/ast/analysis/RecursiveClauses.cpp b/src/ast/analysis/RecursiveClauses.cpp
index 0d0a5d8..870ed07 100644
--- a/src/ast/analysis/RecursiveClauses.cpp
+++ b/src/ast/analysis/RecursiveClauses.cpp
@@ -10,10 +10,9 @@
  *
  * @file RecursiveClauses.cpp
  *
- * Compute the set of recursive clauses.
- *
- * A recursive clause is a clause of a rule R that depends directly or
- * transitively on that rule R.
+ * Implements method of precedence graph to build the precedence graph,
+ * compute strongly connected components of the precedence graph, and
+ * build the strongly connected component graph.
  *
  ***********************************************************************/
 
@@ -27,9 +26,7 @@
 #include "ast/utility/Utils.h"
 #include "ast/utility/Visitor.h"
 #include "souffle/utility/StreamUtil.h"
-
 #include <algorithm>
-#include <map>
 #include <set>
 #include <utility>
 #include <vector>
@@ -38,68 +35,66 @@ namespace souffle::ast::analysis {
 
 void RecursiveClausesAnalysis::run(const TranslationUnit& translationUnit) {
     Program& program = translationUnit.getProgram();
+    visit(program, [&](const Clause& clause) {
+        if (computeIsRecursive(clause, translationUnit)) {
+            recursiveClauses.insert(&clause);
+        }
+    });
+}
 
-    // Mapping from a relation to the set of relations that it depends on directly.
-    //
-    // It is the adjacency list of the relations dependency graph.
-    std::map<uint32_t, std::set<uint32_t>> relationUseRelation;
+void RecursiveClausesAnalysis::print(std::ostream& os) const {
+    os << recursiveClauses << std::endl;
+}
 
-    // Mapping from a clause to the set of relations that it depends on directly.
-    std::map<const Clause*, std::set<uint32_t>> clauseUseRelation;
+bool RecursiveClausesAnalysis::computeIsRecursive(
+        const Clause& clause, const TranslationUnit& translationUnit) const {
+    const Program& program = translationUnit.getProgram();
 
-    // Mapping from a clause to its relations.
-    std::map<const Clause*, uint32_t> clauseRelation;
+    // we want to reach the atom of the head through the body
+    const Relation* trg = program.getRelation(clause);
 
-    std::vector<uint32_t> relations;
+    std::set<const Relation*> reached;
+    std::vector<const Relation*> worklist;
 
-    // gather dependencies
-    for (const auto& qninfo : program.getRelationInfo()) {
-        const uint32_t head = qninfo.first.getIndex();
-        relations.emplace_back(head);
-        for (const auto& clause : qninfo.second.clauses) {
-            clauseRelation.emplace(clause.get(), head);
-            for (const auto& atom : getBodyLiterals<Atom>(*clause)) {
-                const uint32_t rhs = atom->getQualifiedName().getIndex();
-                relationUseRelation[head].emplace(rhs);
-                clauseUseRelation[clause.get()].emplace(rhs);
-            }
+    // set up start list
+    for (const auto* cur : getBodyLiterals<Atom>(clause)) {
+        auto rel = program.getRelation(*cur);
+        if (rel == trg) {
+            return true;
         }
+        worklist.push_back(rel);
     }
 
-    // Mapping from a relation to the set of transitively reachable relations
-    // it depends on, including itself.
-    std::map<uint32_t, std::set<uint32_t>> reachableRelation;
+    // process remaining elements
+    while (!worklist.empty()) {
+        // get next to process
+        const Relation* cur = worklist.back();
+        worklist.pop_back();
 
-    // called when we discoved that `head` transitively reach `reached`.
-    const std::function<void(uint32_t, uint32_t)> dfs = [&](uint32_t head, uint32_t reached) {
-        reachableRelation[head].emplace(reached);
-        for (uint32_t rel : relationUseRelation[reached]) {
-            if (reachableRelation[head].emplace(rel).second) {
-                // discovered that relation `rel` is reachabel from `head`
-                dfs(head, rel);
-            }
+        // skip null pointers (errors in the input code)
+        if (cur == nullptr) {
+            continue;
         }
-    };
 
-    // Compute the transitive closure of reachable (dependencies) relations from each relation.
-    for (const uint32_t head : relations) {
-        // include itself in the closure
-        dfs(head, head);
-    }
+        // check whether this one has been checked before
+        if (!reached.insert(cur).second) {
+            continue;
+        }
 
-    for (const auto& [clause, rel] : clauseRelation) {
-        for (const uint32_t used : clauseUseRelation[clause]) {
-            if (reachableRelation[used].count(rel) > 0) {
-                // clause is recursive
-                recursiveClauses.emplace(clause);
-                break;
+        // check all atoms in the relations
+        for (auto&& cl : program.getClauses(*cur)) {
+            for (const Atom* at : getBodyLiterals<Atom>(*cl)) {
+                auto rel = program.getRelation(*at);
+                if (rel == trg) {
+                    return true;
+                }
+                worklist.push_back(rel);
             }
         }
     }
-}
 
-void RecursiveClausesAnalysis::print(std::ostream& os) const {
-    os << recursiveClauses << std::endl;
+    // no cycles found
+    return false;
 }
 
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/RecursiveClauses.h b/src/ast/analysis/RecursiveClauses.h
index 00fe7b9..56ae27e 100644
--- a/src/ast/analysis/RecursiveClauses.h
+++ b/src/ast/analysis/RecursiveClauses.h
@@ -49,6 +49,9 @@ public:
 
 private:
     std::set<const Clause*> recursiveClauses;
+
+    /** Determines whether the given clause is recursive within the given program */
+    bool computeIsRecursive(const Clause& clause, const TranslationUnit& translationUnit) const;
 };
 
 }  // namespace analysis
diff --git a/src/ast/analysis/RedundantRelations.cpp b/src/ast/analysis/RedundantRelations.cpp
index babf0eb..cb08841 100644
--- a/src/ast/analysis/RedundantRelations.cpp
+++ b/src/ast/analysis/RedundantRelations.cpp
@@ -33,8 +33,8 @@ namespace souffle::ast::analysis {
 void RedundantRelationsAnalysis::run(const TranslationUnit& translationUnit) {
     precedenceGraph = &translationUnit.getAnalysis<PrecedenceGraphAnalysis>();
 
-    RelationSet work;
-    RelationSet notRedundant;
+    std::set<const Relation*> work;
+    std::set<const Relation*> notRedundant;
     auto& ioType = translationUnit.getAnalysis<IOTypeAnalysis>();
     Program& program = translationUnit.getProgram();
 
diff --git a/src/ast/analysis/RedundantRelations.h b/src/ast/analysis/RedundantRelations.h
index 93518f4..9480ffc 100644
--- a/src/ast/analysis/RedundantRelations.h
+++ b/src/ast/analysis/RedundantRelations.h
@@ -44,13 +44,13 @@ public:
 
     void print(std::ostream& os) const override;
 
-    const UnorderedQualifiedNameSet& getRedundantRelations() const {
+    const std::set<QualifiedName>& getRedundantRelations() const {
         return redundantRelations;
     }
 
 private:
     PrecedenceGraphAnalysis* precedenceGraph = nullptr;
-    UnorderedQualifiedNameSet redundantRelations;
+    std::set<QualifiedName> redundantRelations;
 };
 
 }  // namespace analysis
diff --git a/src/ast/analysis/RelationSchedule.cpp b/src/ast/analysis/RelationSchedule.cpp
index 921d2d8..d2c4269 100644
--- a/src/ast/analysis/RelationSchedule.cpp
+++ b/src/ast/analysis/RelationSchedule.cpp
@@ -53,34 +53,33 @@ void RelationScheduleAnalysisStep::print(std::ostream& os) const {
 void RelationScheduleAnalysis::run(const TranslationUnit& translationUnit) {
     topsortSCCGraphAnalysis = &translationUnit.getAnalysis<TopologicallySortedSCCGraphAnalysis>();
     precedenceGraph = &translationUnit.getAnalysis<PrecedenceGraphAnalysis>();
-    sccGraph = &translationUnit.getAnalysis<SCCGraphAnalysis>();
 
-    const std::size_t numSCCs = sccGraph->getNumberOfSCCs();
-    std::vector<RelationSet> relationExpirySchedule = computeRelationExpirySchedule();
+    std::size_t numSCCs = translationUnit.getAnalysis<SCCGraphAnalysis>().getNumberOfSCCs();
+    std::vector<std::set<const Relation*>> relationExpirySchedule =
+            computeRelationExpirySchedule(translationUnit);
 
     relationSchedule.clear();
     for (std::size_t i = 0; i < numSCCs; i++) {
-        const auto scc = topsortSCCGraphAnalysis->order()[i];
-        const RelationSet computedRelations = sccGraph->getInternalRelations(scc);
-        relationSchedule.emplace_back(
-                computedRelations, relationExpirySchedule[i], sccGraph->isRecursive(scc));
+        auto scc = topsortSCCGraphAnalysis->order()[i];
+        const std::set<const Relation*> computedRelations =
+                translationUnit.getAnalysis<SCCGraphAnalysis>().getInternalRelations(scc);
+        relationSchedule.emplace_back(computedRelations, relationExpirySchedule[i],
+                translationUnit.getAnalysis<SCCGraphAnalysis>().isRecursive(scc));
     }
-
-    topsortSCCGraphAnalysis = nullptr;
-    precedenceGraph = nullptr;
-    sccGraph = nullptr;
 }
 
-std::vector<RelationSet> RelationScheduleAnalysis::computeRelationExpirySchedule() {
-    std::vector<RelationSet> relationExpirySchedule;
+std::vector<std::set<const Relation*>> RelationScheduleAnalysis::computeRelationExpirySchedule(
+        const TranslationUnit& translationUnit) {
+    std::vector<std::set<const Relation*>> relationExpirySchedule;
     /* Compute for each step in the reverse topological order
        of evaluating the SCC the set of alive relations. */
     std::size_t numSCCs = topsortSCCGraphAnalysis->order().size();
 
     /* Alive set for each step */
-    std::vector<UnorderedRelationSet> alive(numSCCs);
+    std::vector<std::set<const Relation*>> alive(numSCCs);
     /* Resize expired relations sets */
     relationExpirySchedule.resize(numSCCs);
+    const auto& sccGraph = translationUnit.getAnalysis<SCCGraphAnalysis>();
 
     /* Compute all alive relations by iterating over all steps in reverse order
        determine the dependencies */
@@ -90,7 +89,7 @@ std::vector<RelationSet> RelationScheduleAnalysis::computeRelationExpirySchedule
 
         /* Add predecessors of relations computed in this step */
         auto scc = topsortSCCGraphAnalysis->order()[numSCCs - orderedSCC];
-        for (const Relation* r : sccGraph->getInternalRelations(scc)) {
+        for (const Relation* r : sccGraph.getInternalRelations(scc)) {
             for (const Relation* predecessor : precedenceGraph->graph().predecessors(r)) {
                 alive[orderedSCC].insert(predecessor);
             }
@@ -98,10 +97,10 @@ std::vector<RelationSet> RelationScheduleAnalysis::computeRelationExpirySchedule
 
         /* Compute expired relations in reverse topological order using the set difference of the alive sets
            between steps. */
-        std::copy_if(alive[orderedSCC].begin(), alive[orderedSCC].end(),
+        std::set_difference(alive[orderedSCC].begin(), alive[orderedSCC].end(), alive[orderedSCC - 1].begin(),
+                alive[orderedSCC - 1].end(),
                 std::inserter(relationExpirySchedule[numSCCs - orderedSCC],
-                        relationExpirySchedule[numSCCs - orderedSCC].end()),
-                [&](const Relation* r) { return alive[orderedSCC - 1].count(r) == 0; });
+                        relationExpirySchedule[numSCCs - orderedSCC].end()));
     }
 
     return relationExpirySchedule;
@@ -111,6 +110,21 @@ void RelationScheduleAnalysis::print(std::ostream& os) const {
     os << "begin schedule\n";
     for (const RelationScheduleAnalysisStep& step : relationSchedule) {
         os << step;
+        os << "computed: ";
+        for (const Relation* compRel : step.computed()) {
+            os << compRel->getQualifiedName() << ", ";
+        }
+        os << "\nexpired: ";
+        for (const Relation* compRel : step.expired()) {
+            os << compRel->getQualifiedName() << ", ";
+        }
+        os << "\n";
+        if (step.recursive()) {
+            os << "recursive";
+        } else {
+            os << "not recursive";
+        }
+        os << "\n";
     }
     os << "end schedule\n";
 }
diff --git a/src/ast/analysis/RelationSchedule.h b/src/ast/analysis/RelationSchedule.h
index 8f2fee7..1bfbd4f 100644
--- a/src/ast/analysis/RelationSchedule.h
+++ b/src/ast/analysis/RelationSchedule.h
@@ -21,9 +21,7 @@
 #include "ast/Relation.h"
 #include "ast/TranslationUnit.h"
 #include "ast/analysis/PrecedenceGraph.h"
-#include "ast/analysis/SCCGraph.h"
 #include "ast/analysis/TopologicallySortedSCCGraph.h"
-
 #include <ostream>
 #include <set>
 #include <string>
@@ -38,16 +36,16 @@ namespace souffle::ast::analysis {
  */
 class RelationScheduleAnalysisStep {
 public:
-    RelationScheduleAnalysisStep(
-            RelationSet computedRelations, RelationSet expiredRelations, const bool isRecursive)
+    RelationScheduleAnalysisStep(std::set<const Relation*> computedRelations,
+            std::set<const Relation*> expiredRelations, const bool isRecursive)
             : computedRelations(std::move(computedRelations)), expiredRelations(std::move(expiredRelations)),
               isRecursive(isRecursive) {}
 
-    const RelationSet& computed() const {
+    const std::set<const Relation*>& computed() const {
         return computedRelations;
     }
 
-    const RelationSet& expired() const {
+    const std::set<const Relation*>& expired() const {
         return expiredRelations;
     }
 
@@ -64,8 +62,8 @@ public:
     }
 
 private:
-    RelationSet computedRelations;
-    RelationSet expiredRelations;
+    std::set<const Relation*> computedRelations;
+    std::set<const Relation*> expiredRelations;
     const bool isRecursive;
 };
 
@@ -90,12 +88,12 @@ public:
 private:
     TopologicallySortedSCCGraphAnalysis* topsortSCCGraphAnalysis = nullptr;
     PrecedenceGraphAnalysis* precedenceGraph = nullptr;
-    const SCCGraphAnalysis* sccGraph = nullptr;
 
     /** Relations computed and expired relations at each step */
     std::vector<RelationScheduleAnalysisStep> relationSchedule;
 
-    std::vector<RelationSet> computeRelationExpirySchedule();
+    std::vector<std::set<const Relation*>> computeRelationExpirySchedule(
+            const TranslationUnit& translationUnit);
 };
 
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/SCCGraph.cpp b/src/ast/analysis/SCCGraph.cpp
index b05a2b6..b9cbd9c 100644
--- a/src/ast/analysis/SCCGraph.cpp
+++ b/src/ast/analysis/SCCGraph.cpp
@@ -36,7 +36,6 @@ namespace souffle::ast::analysis {
 void SCCGraphAnalysis::run(const TranslationUnit& translationUnit) {
     precedenceGraph = &translationUnit.getAnalysis<PrecedenceGraphAnalysis>();
     ioType = &translationUnit.getAnalysis<IOTypeAnalysis>();
-    programName = translationUnit.global().config().get("name");
     sccToRelation.clear();
     relationToScc.clear();
     predecessors.clear();
@@ -116,7 +115,7 @@ void SCCGraphAnalysis::scR(const Relation* w, std::map<const Relation*, std::siz
 }
 
 void SCCGraphAnalysis::printRaw(std::stringstream& ss) const {
-    const std::string& name = programName;
+    const std::string& name = Global::config().get("name");
     /* Print SCC graph */
     ss << "digraph {" << std::endl;
     /* Print nodes of SCC graph */
diff --git a/src/ast/analysis/SCCGraph.h b/src/ast/analysis/SCCGraph.h
index fa165d9..d1cc4d6 100644
--- a/src/ast/analysis/SCCGraph.h
+++ b/src/ast/analysis/SCCGraph.h
@@ -94,13 +94,13 @@ public:
     }
 
     /** Get all internal relations of a given SCC. */
-    const RelationSet& getInternalRelations(const std::size_t scc) const {
+    const std::set<const Relation*>& getInternalRelations(const std::size_t scc) const {
         return sccToRelation.at(scc);
     }
 
     /** Get all external output predecessor relations of a given SCC. */
-    RelationSet getExternalOutputPredecessorRelations(const std::size_t scc) const {
-        RelationSet externOutPreds;
+    std::set<const Relation*> getExternalOutputPredecessorRelations(const std::size_t scc) const {
+        std::set<const Relation*> externOutPreds;
         for (const auto& relation : getInternalRelations(scc)) {
             for (const auto& predecessor : precedenceGraph->graph().predecessors(relation)) {
                 if (relationToScc.at(predecessor) != scc && ioType->isOutput(predecessor)) {
@@ -112,8 +112,8 @@ public:
     }
 
     /** Get all external non-output predecessor relations of a given SCC. */
-    RelationSet getExternalNonOutputPredecessorRelations(const std::size_t scc) const {
-        RelationSet externNonOutPreds;
+    std::set<const Relation*> getExternalNonOutputPredecessorRelations(const std::size_t scc) const {
+        std::set<const Relation*> externNonOutPreds;
         for (const auto& relation : getInternalRelations(scc)) {
             for (const auto& predecessor : precedenceGraph->graph().predecessors(relation)) {
                 if (relationToScc.at(predecessor) != scc && !ioType->isOutput(predecessor)) {
@@ -125,8 +125,8 @@ public:
     }
 
     /** Get all external predecessor relations of a given SCC. */
-    RelationSet getExternalPredecessorRelations(const std::size_t scc) const {
-        RelationSet externPreds;
+    std::set<const Relation*> getExternalPredecessorRelations(const std::size_t scc) const {
+        std::set<const Relation*> externPreds;
         for (const auto& relation : getInternalRelations(scc)) {
             for (const auto& predecessor : precedenceGraph->graph().predecessors(relation)) {
                 if (relationToScc.at(predecessor) != scc) {
@@ -138,8 +138,8 @@ public:
     }
 
     /** Get all internal output relations of a given SCC. */
-    RelationSet getInternalOutputRelations(const std::size_t scc) const {
-        RelationSet internOuts;
+    std::set<const Relation*> getInternalOutputRelations(const std::size_t scc) const {
+        std::set<const Relation*> internOuts;
         for (const auto& relation : getInternalRelations(scc)) {
             if (ioType->isOutput(relation)) {
                 internOuts.insert(relation);
@@ -149,8 +149,8 @@ public:
     }
 
     /** Get all internal relations of a given SCC with external successors. */
-    RelationSet getInternalRelationsWithExternalSuccessors(const std::size_t scc) const {
-        RelationSet internsWithExternSuccs;
+    std::set<const Relation*> getInternalRelationsWithExternalSuccessors(const std::size_t scc) const {
+        std::set<const Relation*> internsWithExternSuccs;
         for (const auto& relation : getInternalRelations(scc)) {
             for (const auto& successor : precedenceGraph->graph().successors(relation)) {
                 if (relationToScc.at(successor) != scc) {
@@ -163,8 +163,9 @@ public:
     }
 
     /** Get all internal non-output relations of a given SCC with external successors. */
-    RelationSet getInternalNonOutputRelationsWithExternalSuccessors(const std::size_t scc) const {
-        RelationSet internNonOutsWithExternSuccs;
+    std::set<const Relation*> getInternalNonOutputRelationsWithExternalSuccessors(
+            const std::size_t scc) const {
+        std::set<const Relation*> internNonOutsWithExternSuccs;
         for (const auto& relation : getInternalRelations(scc)) {
             if (!ioType->isOutput(relation)) {
                 for (const auto& successor : precedenceGraph->graph().successors(relation)) {
@@ -179,8 +180,8 @@ public:
     }
 
     /** Get all internal input relations of a given SCC. */
-    RelationSet getInternalInputRelations(const std::size_t scc) const {
-        RelationSet internIns;
+    std::set<const Relation*> getInternalInputRelations(const std::size_t scc) const {
+        std::set<const Relation*> internIns;
         for (const auto& relation : getInternalRelations(scc)) {
             if (ioType->isInput(relation)) {
                 internIns.insert(relation);
@@ -191,7 +192,7 @@ public:
 
     /** Return if the given SCC is recursive. */
     bool isRecursive(const std::size_t scc) const {
-        const RelationSet& sccRelations = sccToRelation.at(scc);
+        const std::set<const Relation*>& sccRelations = sccToRelation.at(scc);
         if (sccRelations.size() == 1) {
             const Relation* singleRelation = *sccRelations.begin();
             if (precedenceGraph->graph().predecessors(singleRelation).count(singleRelation) == 0u) {
@@ -205,7 +206,7 @@ public:
     void print(std::ostream& os) const override;
 
     /** Print the SCC graph in HTML format. */
-    void printHTML(std::ostream& os) const override;
+    void printHTML(std::ostream& os) const;
 
 private:
     PrecedenceGraphAnalysis* precedenceGraph = nullptr;
@@ -220,7 +221,7 @@ private:
     std::vector<std::set<std::size_t>> predecessors;
 
     /** Relations contained in a SCC */
-    std::vector<RelationSet> sccToRelation;
+    std::vector<std::set<const Relation*>> sccToRelation;
 
     /** Recursive scR method for computing SCC */
     void scR(const Relation* relation, std::map<const Relation*, std::size_t>& preOrder, std::size_t& counter,
@@ -228,8 +229,6 @@ private:
 
     IOTypeAnalysis* ioType = nullptr;
 
-    std::string programName;
-
     /** Print the SCC graph to a string. */
     void printRaw(std::stringstream& ss) const;
 };
diff --git a/src/ast/analysis/TopologicallySortedSCCGraph.cpp b/src/ast/analysis/TopologicallySortedSCCGraph.cpp
index bd0b480..23ed6a1 100644
--- a/src/ast/analysis/TopologicallySortedSCCGraph.cpp
+++ b/src/ast/analysis/TopologicallySortedSCCGraph.cpp
@@ -28,8 +28,6 @@
 
 namespace souffle::ast::analysis {
 
-TopologicallySortedSCCGraphAnalysis::TopologicallySortedSCCGraphAnalysis() : Analysis(name) {}
-
 int TopologicallySortedSCCGraphAnalysis::topologicalOrderingCost(
         const std::vector<std::size_t>& permutationOfSCCs) const {
     // create variables to hold the cost of the current SCC and the permutation as a whole
@@ -69,73 +67,86 @@ int TopologicallySortedSCCGraphAnalysis::topologicalOrderingCost(
 }
 
 void TopologicallySortedSCCGraphAnalysis::computeTopologicalOrdering(
-        std::size_t scc, std::vector<int>& visited) {
-    if (visited[scc] >= 0) {
+        std::size_t scc, std::vector<bool>& visited) {
+    // create a flag to indicate that a successor was visited (by default it hasn't been)
+    bool found = false;
+    bool hasUnvisitedSuccessor = false;
+    bool hasUnvisitedPredecessor = false;
+    // for each successor of the input scc
+    const auto& successorsToVisit = sccGraph->getSuccessorSCCs(scc);
+    for (const auto scc_i : successorsToVisit) {
+        if (visited[scc_i]) {
+            continue;
+        }
+        hasUnvisitedPredecessor = false;
+        const auto& successorsPredecessors = sccGraph->getPredecessorSCCs(scc_i);
+        for (const auto scc_j : successorsPredecessors) {
+            if (!visited[scc_j]) {
+                hasUnvisitedPredecessor = true;
+                break;
+            }
+        }
+        if (!hasUnvisitedPredecessor) {
+            // give it a temporary marking
+            visited[scc_i] = true;
+            // add it to the permanent ordering
+            sccOrder.push_back(scc_i);
+            // and use it as a root node in a recursive call to this function
+            computeTopologicalOrdering(scc_i, visited);
+            // finally, indicate that a successor has been found for this node
+            found = true;
+        }
+    }
+    // return at once if no valid successors have been found; as either it has none or they all have a
+    // better predecessor
+    if (!found) {
         return;
     }
-
-    int maxDist = 0;
+    hasUnvisitedPredecessor = false;
     const auto& predecessors = sccGraph->getPredecessorSCCs(scc);
-    for (const auto pred : predecessors) {
-        if (visited[pred] < 0) {
-            // has an unvisited predecessor
-            return;
-        } else {
-            maxDist = std::max(maxDist, visited[pred] + 1);
+    for (const auto scc_j : predecessors) {
+        if (!visited[scc_j]) {
+            hasUnvisitedPredecessor = true;
+            break;
         }
     }
-
-    visited[scc] = maxDist;
-    sccDistance.emplace(scc, maxDist);
-    sccOrder.emplace_back(scc);
-
-    for (const auto succ : sccGraph->getSuccessorSCCs(scc)) {
-        computeTopologicalOrdering(succ, visited);
+    hasUnvisitedSuccessor = false;
+    const auto& successors = sccGraph->getSuccessorSCCs(scc);
+    for (const auto scc_j : successors) {
+        if (!visited[scc_j]) {
+            hasUnvisitedSuccessor = true;
+            break;
+        }
+    }
+    // otherwise, if more white successors remain for the current scc, use it again as the root node in a
+    // recursive call to this function
+    if (hasUnvisitedSuccessor && !hasUnvisitedPredecessor) {
+        computeTopologicalOrdering(scc, visited);
     }
 }
 
 void TopologicallySortedSCCGraphAnalysis::run(const TranslationUnit& translationUnit) {
     // obtain the scc graph
     sccGraph = &translationUnit.getAnalysis<SCCGraphAnalysis>();
-
     // clear the list of ordered sccs
     sccOrder.clear();
-    sccDistance.clear();
-
-    // Compute the maximum distance from the root scc(s) to each scc.
-    //
-    // visited[scc] < 0 when the scc distance from the root(s) is not known yet
-    // visited[scc] >= 0 is the maximum distance of the scc from a root
-    //
-    // this provides a partial order between sccs, several sccs may have the
-    // same maximum distance from the roots.
-    std::vector<int> visited;
+    std::vector<bool> visited;
     visited.resize(sccGraph->getNumberOfSCCs());
-    std::fill(visited.begin(), visited.end(), -1);
-    for (std::size_t scc = 0; scc < sccGraph->getNumberOfSCCs(); ++scc) {
-        computeTopologicalOrdering(scc, visited);
-    }
-
-    // find the least relation qualified name of each scc, using the lexicographic order.
-    std::vector<QualifiedName> sccLeastQN;
-    sccLeastQN.resize(sccGraph->getNumberOfSCCs());
+    std::fill(visited.begin(), visited.end(), false);
+    // generate topological ordering using forwards algorithm (like Khan's algorithm)
+    // for each of the sccs in the graph
     for (std::size_t scc = 0; scc < sccGraph->getNumberOfSCCs(); ++scc) {
-        sccLeastQN[scc] = (*sccGraph->getInternalRelations(scc).begin())->getQualifiedName();
-    }
-
-    // sort sccs by distance from roots and then by lexicographic order of the least
-    // relation qualified name in each scc.
-    //
-    // this provides a deterministic total order between sccs.
-    std::sort(sccOrder.begin(), sccOrder.end(), [&](std::size_t lhs, std::size_t rhs) {
-        if (sccDistance[lhs] < sccDistance[rhs]) {
-            return true;
-        } else if (sccDistance[lhs] > sccDistance[rhs]) {
-            return false;
-        } else {
-            return sccLeastQN[lhs].lexicalLess(sccLeastQN[rhs]);
+        // if that scc has no predecessors
+        if (sccGraph->getPredecessorSCCs(scc).empty()) {
+            // put it in the ordering
+            sccOrder.push_back(scc);
+            visited[scc] = true;
+            // if the scc has successors
+            if (!sccGraph->getSuccessorSCCs(scc).empty()) {
+                computeTopologicalOrdering(scc, visited);
+            }
         }
-    });
+    }
 }
 
 void TopologicallySortedSCCGraphAnalysis::print(std::ostream& os) const {
@@ -164,27 +175,4 @@ void TopologicallySortedSCCGraphAnalysis::print(std::ostream& os) const {
     os << "cost: " << topologicalOrderingCost(sccOrder) << std::endl;
 }
 
-const std::vector<std::size_t>& TopologicallySortedSCCGraphAnalysis::order() const {
-    return sccOrder;
-}
-
-std::size_t TopologicallySortedSCCGraphAnalysis::sccOfIndex(const std::size_t index) const {
-    return sccOrder.at(index);
-}
-
-std::size_t TopologicallySortedSCCGraphAnalysis::indexOfScc(const std::size_t scc) const {
-    auto it = std::find(sccOrder.begin(), sccOrder.end(), scc);
-    assert(it != sccOrder.end());
-    return (std::size_t)std::distance(sccOrder.begin(), it);
-}
-
-std::set<std::size_t> TopologicallySortedSCCGraphAnalysis::indexOfScc(
-        const std::set<std::size_t>& sccs) const {
-    std::set<std::size_t> indices;
-    for (const auto scc : sccs) {
-        indices.insert(indexOfScc(scc));
-    }
-    return indices;
-}
-
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/TopologicallySortedSCCGraph.h b/src/ast/analysis/TopologicallySortedSCCGraph.h
index 9f9213f..a2d4552 100644
--- a/src/ast/analysis/TopologicallySortedSCCGraph.h
+++ b/src/ast/analysis/TopologicallySortedSCCGraph.h
@@ -42,17 +42,31 @@ class TopologicallySortedSCCGraphAnalysis : public Analysis {
 public:
     static constexpr const char* name = "topological-scc-graph";
 
-    explicit TopologicallySortedSCCGraphAnalysis();
+    TopologicallySortedSCCGraphAnalysis() : Analysis(name) {}
 
     void run(const TranslationUnit& translationUnit) override;
 
-    const std::vector<std::size_t>& order() const;
+    const std::vector<std::size_t>& order() const {
+        return sccOrder;
+    }
 
-    std::size_t sccOfIndex(const std::size_t index) const;
+    std::size_t sccOfIndex(const std::size_t index) const {
+        return sccOrder.at(index);
+    }
 
-    std::size_t indexOfScc(const std::size_t scc) const;
+    std::size_t indexOfScc(const std::size_t scc) const {
+        auto it = std::find(sccOrder.begin(), sccOrder.end(), scc);
+        assert(it != sccOrder.end());
+        return (std::size_t)std::distance(sccOrder.begin(), it);
+    }
 
-    std::set<std::size_t> indexOfScc(const std::set<std::size_t>& sccs) const;
+    std::set<std::size_t> indexOfScc(const std::set<std::size_t>& sccs) const {
+        std::set<std::size_t> indices;
+        for (const auto scc : sccs) {
+            indices.insert(indexOfScc(scc));
+        }
+        return indices;
+    }
 
     /** Output topologically sorted strongly connected component graph in text format */
     void print(std::ostream& os) const override;
@@ -64,15 +78,12 @@ private:
     /** The final topological ordering of the SCCs. */
     std::vector<std::size_t> sccOrder;
 
-    /** The mapping from an SCC index to its maximum distance from roots */
-    std::map<std::size_t, int> sccDistance;
-
     /** Calculate the topological ordering cost of a permutation of as of yet unordered SCCs
     using the ordered SCCs. Returns -1 if the given vector is not a valid topological ordering. */
     int topologicalOrderingCost(const std::vector<std::size_t>& permutationOfSCCs) const;
 
     /** Recursive component for the forwards algorithm computing the topological ordering of the SCCs. */
-    void computeTopologicalOrdering(std::size_t scc, std::vector<int>& visited);
+    void computeTopologicalOrdering(std::size_t scc, std::vector<bool>& visited);
 };
 
 }  // namespace analysis
diff --git a/src/ast/analysis/UniqueKeys.cpp b/src/ast/analysis/UniqueKeys.cpp
new file mode 100644
index 0000000..475eb6f
--- /dev/null
+++ b/src/ast/analysis/UniqueKeys.cpp
@@ -0,0 +1,581 @@
+/*
+ * Souffle - A Datalog Compiler
+ * Copyright (c) 2022, The Souffle Developers. All rights reserved
+ * Licensed under the Universal Permissive License v 1.0 as shown at:
+ * - https://opensource.org/licenses/UPL
+ * - <souffle root>/licenses/SOUFFLE-UPL.txt
+ */
+
+/************************************************************************
+ *
+ * @file UniqueKeys.cpp
+ *
+ * CountUniqueKeys are used for accumulating selectivity statistics for the auto scheduler
+ * This analysis determines which CountUniqueKeys statements to emit in the RAM
+ *
+ ***********************************************************************/
+
+#include "ast/analysis/UniqueKeys.h"
+#include "Global.h"
+#include "GraphUtils.h"
+#include "ast/BinaryConstraint.h"
+#include "ast/Constant.h"
+#include "ast/NilConstant.h"
+#include "ast/QualifiedName.h"
+#include "ast/Relation.h"
+#include "ast/StringConstant.h"
+#include "ast/SubsumptiveClause.h"
+#include "ast/UnnamedVariable.h"
+#include "ast2ram/utility/Utils.h"
+#include "ram/FloatConstant.h"
+#include "ram/SignedConstant.h"
+#include "ram/StringConstant.h"
+#include "ram/UnsignedConstant.h"
+#include "souffle/BinaryConstraintOps.h"
+#include "souffle/utility/ContainerUtil.h"
+#include <algorithm>
+#include <cstddef>
+#include <iterator>
+#include <memory>
+#include <numeric>
+#include <optional>
+#include <set>
+#include <unordered_map>
+
+namespace souffle::ast::analysis {
+
+const analysis::PowerSet& UniqueKeysAnalysis::getSubsets(std::size_t N, std::size_t K) const {
+    if (cache.count({N, K})) {
+        return cache.at({N, K});
+    }
+
+    // this powerset represents all possible subsets of cardinality K of the set {1,...,N}
+    analysis::PowerSet res;
+
+    // specific combination
+    std::vector<std::size_t> cur;
+    cur.reserve(K);
+
+    // use bitmask for subset generation
+    std::string bitmask(K, 1);  // K leading 1's
+    bitmask.resize(N, 0);       // N-K trailing 0's
+
+    // generate the next permutation of the bitmask
+    do {
+        cur.clear();
+
+        // construct the subset using the set bits in the bitmask
+        for (std::size_t i = 0; i < N; ++i)  // [0..N-1] integers
+        {
+            if (bitmask[i]) {
+                cur.push_back(i);
+            }
+        }
+        res.push_back(cur);
+    } while (std::prev_permutation(bitmask.begin(), bitmask.end()));
+
+    cache[std::make_pair(N, K)] = res;
+    return cache.at({N, K});
+}
+
+analysis::StratumUniqueKeys UniqueKeysAnalysis::computeRuleVersionStatements(
+        const std::set<const ast::Relation*>& scc, const ast::Clause& clause,
+        std::optional<std::size_t> version, ast2ram::TranslationMode mode) {
+    auto* prog = program;
+    auto* poly = polyAnalysis;
+    auto sccAtoms = filter(ast::getBodyLiterals<ast::Atom>(clause),
+            [&](auto* atom) { return contains(scc, prog->getRelation(*atom)); });
+
+    auto translateConstant = [poly](const ast::Constant& constant) -> Own<souffle::ram::Expression> {
+        if (auto strConstant = as<ast::StringConstant>(constant)) {
+            return mk<ram::StringConstant>(strConstant->getConstant());
+        } else if (isA<ast::NilConstant>(&constant)) {
+            return mk<ram::SignedConstant>(0);
+        } else if (auto* numConstant = as<ast::NumericConstant>(constant)) {
+            switch (poly->getInferredType(*numConstant)) {
+                case ast::NumericConstant::Type::Int:
+                    return mk<ram::SignedConstant>(
+                            RamSignedFromString(numConstant->getConstant(), nullptr, 0));
+                case ast::NumericConstant::Type::Uint:
+                    return mk<ram::UnsignedConstant>(
+                            RamUnsignedFromString(numConstant->getConstant(), nullptr, 0));
+                case ast::NumericConstant::Type::Float:
+                    return mk<ram::FloatConstant>(RamFloatFromString(numConstant->getConstant()));
+            }
+        }
+        fatal("unaccounted-for constant");
+    };
+
+    analysis::StratumUniqueKeys statements;
+
+    auto getClauseAtomName = [&sccAtoms, &version](const ast::Clause& clause, const ast::Atom* atom,
+                                     bool isRecursive, ast2ram::TranslationMode mode) {
+        using namespace souffle::ast2ram;
+
+        if (isA<ast::SubsumptiveClause>(clause)) {
+            // find the dominated / dominating heads
+            const auto& body = clause.getBodyLiterals();
+            auto dominatedHeadAtom = dynamic_cast<const ast::Atom*>(body[0]);
+            auto dominatingHeadAtom = dynamic_cast<const ast::Atom*>(body[1]);
+
+            if (clause.getHead() == atom) {
+                if (mode == SubsumeDeleteCurrentDelta || mode == SubsumeDeleteCurrentCurrent) {
+                    return getDeleteRelationName(atom->getQualifiedName());
+                }
+                return getRejectRelationName(atom->getQualifiedName());
+            }
+
+            if (dominatedHeadAtom == atom) {
+                if (mode == SubsumeDeleteCurrentDelta || mode == SubsumeDeleteCurrentCurrent) {
+                    return getConcreteRelationName(atom->getQualifiedName());
+                }
+                return getNewRelationName(atom->getQualifiedName());
+            }
+
+            if (dominatingHeadAtom == atom) {
+                switch (mode) {
+                    case SubsumeRejectNewCurrent:
+                    case SubsumeDeleteCurrentCurrent:
+                        return getConcreteRelationName(atom->getQualifiedName());
+                    case SubsumeDeleteCurrentDelta: return getDeltaRelationName(atom->getQualifiedName());
+                    default: return getNewRelationName(atom->getQualifiedName());
+                }
+            }
+
+            if (isRecursive) {
+                if (sccAtoms.at(*version + 1) == atom) {
+                    return getDeltaRelationName(atom->getQualifiedName());
+                }
+            }
+        }
+
+        if (!isRecursive) {
+            return getConcreteRelationName(atom->getQualifiedName());
+        }
+        if (clause.getHead() == atom) {
+            return getNewRelationName(atom->getQualifiedName());
+        }
+        if (sccAtoms.at(*version) == atom) {
+            return getDeltaRelationName(atom->getQualifiedName());
+        }
+        return getConcreteRelationName(atom->getQualifiedName());
+    };
+
+    using AtomIdx = std::size_t;
+    using AtomSet = std::set<std::size_t>;
+
+    AtomSet recursiveInCurrentStratum;
+    auto atoms = ast::getBodyLiterals<ast::Atom>(clause);
+    auto constraints = ast::getBodyLiterals<ast::BinaryConstraint>(clause);
+
+    for (auto* a : sccAtoms) {
+        for (AtomIdx i = 0; i < atoms.size(); ++i) {
+            if (*atoms[i] == *a) {
+                recursiveInCurrentStratum.insert(i);
+            }
+        }
+    }
+
+    using VarName = std::string;
+    using VarSet = std::set<VarName>;
+    using ArgIdx = std::size_t;
+
+    // map variable name to constants if possible
+    std::unordered_map<VarName, ast::Constant*> varToConstant;
+
+    // map variables to necessary variables on other side of the equality
+    // i.e. x = y + z we should map x -> { y, z }
+    std::unordered_map<VarName, VarSet> varToOtherVars;
+
+    // map variable name to the lower and upper bounds of the inequality
+    // i.e. EA < Addr < EA + Size we should map Addr -> { { EA }, { EA, Size } }
+    std::unordered_map<VarName, std::pair<VarSet, VarSet>> ineqToUpperLower;
+
+    for (auto* constraint : constraints) {
+        auto* lhs = constraint->getLHS();
+        auto* rhs = constraint->getRHS();
+
+        if (isIneqConstraint(constraint->getBaseOperator())) {
+            if (auto* var = as<ast::Variable>(lhs)) {
+                VarSet otherVars;
+                visit(rhs, [&](const ast::Variable& v) { otherVars.insert(v.getName()); });
+                if (isLessThan(constraint->getBaseOperator()) || isLessEqual(constraint->getBaseOperator())) {
+                    ineqToUpperLower[var->getName()].second = otherVars;
+                }
+                if (isGreaterThan(constraint->getBaseOperator()) ||
+                        isGreaterEqual(constraint->getBaseOperator())) {
+                    ineqToUpperLower[var->getName()].first = otherVars;
+                }
+            }
+
+            if (auto* var = as<ast::Variable>(rhs)) {
+                VarSet otherVars;
+                visit(lhs, [&](const ast::Variable& v) { otherVars.insert(v.getName()); });
+                if (isLessThan(constraint->getBaseOperator()) || isLessEqual(constraint->getBaseOperator())) {
+                    ineqToUpperLower[var->getName()].first = otherVars;
+                }
+                if (isGreaterThan(constraint->getBaseOperator()) ||
+                        isGreaterEqual(constraint->getBaseOperator())) {
+                    ineqToUpperLower[var->getName()].second = otherVars;
+                }
+            }
+        }
+
+        // only consider = constraint
+        if (!isEqConstraint(constraint->getBaseOperator())) {
+            continue;
+        }
+
+        if (isA<ast::Variable>(lhs) && isA<ast::Constant>(rhs)) {
+            varToConstant[as<ast::Variable>(lhs)->getName()] = as<ast::Constant>(rhs);
+            continue;
+        }
+
+        if (isA<ast::Constant>(lhs) && isA<ast::Variable>(rhs)) {
+            varToConstant[as<ast::Variable>(rhs)->getName()] = as<ast::Constant>(lhs);
+            continue;
+        }
+
+        if (auto* var = as<ast::Variable>(lhs)) {
+            VarSet otherVars;
+            visit(rhs, [&](const ast::Variable& v) { otherVars.insert(v.getName()); });
+            varToOtherVars[var->getName()] = otherVars;
+            continue;
+        }
+
+        if (auto* var = as<ast::Variable>(rhs)) {
+            VarSet otherVars;
+            visit(lhs, [&](const ast::Variable& v) { otherVars.insert(v.getName()); });
+            varToOtherVars[var->getName()] = otherVars;
+            continue;
+        }
+    }
+
+    // check for bounded inequality i.e. EA < EA2 < EA + Size
+    for (auto& p : ineqToUpperLower) {
+        // consider this like an equality
+        auto& [lower, upper] = p.second;
+        if (!lower.empty() && !upper.empty() &&
+                std::includes(upper.begin(), upper.end(), lower.begin(), lower.end())) {
+            varToOtherVars[p.first] = upper;
+        }
+    }
+
+    std::unordered_map<AtomIdx, VarSet> atomIdxToGroundedVars;
+    for (AtomIdx i = 0; i < atoms.size(); ++i) {
+        VarSet groundedVars;
+        visit(*atoms[i], [&](const ast::Variable& v) { groundedVars.insert(v.getName()); });
+        atomIdxToGroundedVars[i] = groundedVars;
+    }
+
+    std::unordered_map<AtomIdx, std::map<ArgIdx, const ram::Expression*>> atomToIdxConstants;
+
+    VecOwn<const ram::Expression> constants;
+
+    AtomIdx atomIdx = 0;
+    for (auto* atom : atoms) {
+        bool isRecursive = recursiveInCurrentStratum.count(atomIdx) > 0;
+        std::string name = getClauseAtomName(clause, atom, isRecursive, mode);
+        std::map<ArgIdx, const ram::Expression*> idxConstant;
+
+        ArgIdx varIdx = 0;
+        for (auto* argument : atom->getArguments()) {
+            // if we have a variable and a constraint of the form x = 2 then treat x as 2
+            if (auto* var = as<ast::Variable>(argument)) {
+                if (varToConstant.count(var->getName()) > 0) {
+                    argument = varToConstant.at(var->getName());
+                }
+            }
+
+            if (auto* constant = as<ast::Constant>(argument)) {
+                auto ramConstant = translateConstant(*constant);
+                idxConstant[varIdx] = ramConstant.get();
+                constants.push_back(std::move(ramConstant));
+            }
+            ++varIdx;
+        }
+
+        atomToIdxConstants[atomIdx] = std::move(idxConstant);
+        ++atomIdx;
+    }
+
+    // for each element in the atom
+    for (AtomIdx i = 0; i < atoms.size(); ++i) {
+        // construct the set S \ S[i] and S[i]
+        AtomSet otherAtoms;
+        for (AtomIdx j = 0; j < atoms.size(); ++j) {
+            if (i != j) {
+                otherAtoms.insert(j);
+            }
+        }
+
+        // construct the set of variables that can be used for an indexed scan on this atom
+        VarSet varDependencies;
+        for (const auto& arg : atoms[i]->getArguments()) {
+            if (const auto* var = as<const ast::Variable>(arg)) {
+                varDependencies.insert(var->getName());
+                auto& dependentVars = varToOtherVars[var->getName()];
+                varDependencies.insert(dependentVars.begin(), dependentVars.end());
+            }
+        }
+
+        // remove atoms which don't ground any variables in the current atom
+        AtomSet toRemove;
+        for (AtomIdx atomIdx : otherAtoms) {
+            auto& varsGroundedByAtom = atomIdxToGroundedVars[atomIdx];
+            bool requiredAtom = std::any_of(varsGroundedByAtom.begin(), varsGroundedByAtom.end(),
+                    [&varDependencies](const std::string& var) { return varDependencies.count(var) > 0; });
+            if (!requiredAtom) {
+                toRemove.insert(atomIdx);
+            }
+        }
+
+        for (auto idx : toRemove) {
+            otherAtoms.erase(idx);
+        }
+
+        // Next step is to remove atoms which ground the same set of variables in the current atom
+        toRemove.clear();
+        std::set<VarSet> relevantGroundedVars;
+        std::unordered_map<AtomIdx, VarSet> atomIdxToRelevantGroundedVars;
+        for (AtomIdx atomIdx : otherAtoms) {
+            VarSet groundedVars;
+            auto& varsGroundedByAtom = atomIdxToGroundedVars[atomIdx];
+            for (const auto& var : varsGroundedByAtom) {
+                if (varDependencies.count(var) > 0) {
+                    groundedVars.insert(var);
+                }
+            }
+            if (relevantGroundedVars.count(groundedVars) > 0) {
+                toRemove.insert(atomIdx);
+            } else {
+                relevantGroundedVars.insert(groundedVars);
+                atomIdxToRelevantGroundedVars[atomIdx] = groundedVars;
+            }
+        }
+
+        for (auto idx : toRemove) {
+            otherAtoms.erase(idx);
+        }
+
+        auto N = otherAtoms.size();
+        for (AtomIdx K = 0; K <= N; ++K) {
+            for (auto& subset : getSubsets(N, K)) {
+                auto* atom = atoms[i];
+                // do set union of the atoms
+
+                VarSet providedVars;
+                for (auto x : subset) {
+                    auto it = otherAtoms.begin();
+                    std::advance(it, x);
+                    auto atomIdx = *it;
+                    auto& newVars = atomIdxToRelevantGroundedVars[atomIdx];
+                    providedVars.insert(newVars.begin(), newVars.end());
+                }
+
+                // construct the node
+                std::vector<ArgIdx> joinColumns;
+                const auto& args = atom->getArguments();
+                std::size_t numBound = 0;
+                for (ArgIdx argIdx = 0; argIdx < args.size(); ++argIdx) {
+                    auto* arg = args[argIdx];
+                    // if we have a constant or var = constant then we ignore
+                    if (atomToIdxConstants.at(i).count(argIdx) > 0) {
+                        ++numBound;
+                        joinColumns.push_back(argIdx);
+                        continue;
+                    }
+
+                    // unnamed variable i.e. _
+                    if (isA<ast::UnnamedVariable>(arg)) {
+                        ++numBound;
+                        continue;
+                    }
+
+                    if (auto* var = as<ast::Variable>(arg)) {
+                        // free variable so we can't join on it
+                        if (varToOtherVars.count(var->getName()) > 0) {
+                            auto& dependentVars = varToOtherVars.at(var->getName());
+                            if (!dependentVars.empty() &&
+                                    std::includes(providedVars.begin(), providedVars.end(),
+                                            dependentVars.begin(), dependentVars.end())) {
+                                joinColumns.push_back(argIdx);
+                                ++numBound;
+                                continue;
+                            }
+                        }
+
+                        // direct match on variable
+                        if (providedVars.count(var->getName()) > 0) {
+                            joinColumns.push_back(argIdx);
+                            ++numBound;
+                            continue;
+                        }
+                    }
+                }
+
+                // construct a CountUniqueKeys ram node
+                bool isRecursive = recursiveInCurrentStratum.count(i) > 0;
+                auto relation = getClauseAtomName(clause, atom, isRecursive, mode);
+                auto& constantMap = atomToIdxConstants.at(i);
+
+                std::stringstream ss;
+                ss << relation << " " << joinColumns << " ";
+                for (auto& p : constantMap) {
+                    ss << "(" << p.first << ", " << *p.second << ") ";
+                }
+                ss << isRecursive;
+
+                if (seenNodes.count(ss.str()) == 0) {
+                    auto node = mk<souffle::ram::CountUniqueKeys>(
+                            relation, joinColumns, constantMap, isRecursive);
+                    seenNodes.insert(ss.str());
+
+                    if (!joinColumns.empty() || isRecursive) {
+                        statements.push_back(std::move(node));
+                    }
+                }
+            }
+        }
+    }
+    return statements;
+}
+
+std::vector<analysis::StratumUniqueKeys> UniqueKeysAnalysis::computeUniqueKeyStatements() {
+    auto* prog = program;
+    auto getSccAtoms = [prog](const ast::Clause* clause, const std::set<const ast::Relation*>& scc) {
+        const auto& sccAtoms = filter(ast::getBodyLiterals<ast::Atom>(*clause),
+                [&](const ast::Atom* atom) { return contains(scc, prog->getRelation(*atom)); });
+        return sccAtoms;
+    };
+
+    const auto& sccOrdering = topsortSCCGraphAnalysis->order();
+
+    std::vector<analysis::StratumUniqueKeys> uniqueKeyStatements;
+    uniqueKeyStatements.resize(sccOrdering.size());
+
+    auto& config = Global::config();
+    if (!config.has("index-stats")) {
+        return uniqueKeyStatements;
+    }
+
+    // for each stratum (formed from scc ordering)
+    for (std::size_t i = 0; i < sccOrdering.size(); i++) {
+        analysis::StratumUniqueKeys stratumNodes;
+
+        auto scc = sccOrdering[i];
+        const std::set<const ast::Relation*> sccRelations = sccGraph->getInternalRelations(scc);
+        for (auto* rel : sccRelations) {
+            // Translate each recursive clasue
+            for (auto&& clause : program->getClauses(*rel)) {
+                // Assumption: no subsumption
+                assert(!isA<SubsumptiveClause>(clause) &&
+                        "Error: assumed no subsumptive clauses while auto-scheduling!");
+                auto sccAtoms = getSccAtoms(clause, sccRelations);
+                if (recursiveClauses->recursive(clause)) {
+                    // for each rule version
+                    for (std::size_t version = 0; version < sccAtoms.size(); version++) {
+                        if (isA<ast::SubsumptiveClause>(clause)) {
+                            using namespace souffle::ast2ram;
+                            auto rejectNew = computeRuleVersionStatements(
+                                    sccRelations, *clause, {version}, TranslationMode::SubsumeRejectNewNew);
+                            auto rejectNewCurrent = computeRuleVersionStatements(sccRelations, *clause,
+                                    {version}, TranslationMode::SubsumeRejectNewCurrent);
+                            auto mode = (sccAtoms.size() > 1) ? TranslationMode::SubsumeDeleteCurrentCurrent
+                                                              : TranslationMode::SubsumeDeleteCurrentDelta;
+                            auto deleteCurrent =
+                                    computeRuleVersionStatements(sccRelations, *clause, {version}, mode);
+
+                            for (auto& s : rejectNew) {
+                                stratumNodes.push_back(std::move(s));
+                            }
+
+                            for (auto& s : rejectNewCurrent) {
+                                stratumNodes.push_back(std::move(s));
+                            }
+
+                            for (auto& s : deleteCurrent) {
+                                stratumNodes.push_back(std::move(s));
+                            }
+
+                        } else {
+                            auto res = computeRuleVersionStatements(sccRelations, *clause, {version});
+                            for (auto& s : res) {
+                                stratumNodes.push_back(std::move(s));
+                            }
+                        }
+                    }
+                } else {
+                    auto res = computeRuleVersionStatements(sccRelations, *clause, {});
+                    for (auto& s : res) {
+                        stratumNodes.push_back(std::move(s));
+                    }
+                }
+            }
+        }
+        uniqueKeyStatements[scc] = std::move(stratumNodes);
+    }
+
+    std::map<std::string, std::size_t> relationToCompletedStratum;
+
+    // first step is to compute the earliest stratum that a non-recursive relation completes
+    for (std::size_t i = 0; i < sccOrdering.size(); ++i) {
+        auto scc = sccOrdering[i];
+        for (const auto& statement : uniqueKeyStatements[scc]) {
+            const auto& rel = statement->getRelation();
+
+            if (statement->isRecursiveRelation()) {
+                continue;
+            }
+
+            if (relationToCompletedStratum.count(rel) == 0) {
+                assert(i > 0 && "Can't access non-recursive relation on stratum 0");
+                relationToCompletedStratum[rel] = sccOrdering[i - 1];
+            }
+        }
+    }
+
+    for (std::size_t i = 0; i < sccOrdering.size(); ++i) {
+        auto scc = sccOrdering[i];
+        for (auto& statement : uniqueKeyStatements[scc]) {
+            const auto& rel = statement->getRelation();
+            if (statement->isRecursiveRelation()) {
+                continue;
+            }
+            // sanity check that we have an earliest stratum
+            assert(relationToCompletedStratum.count(rel) > 0 &&
+                    "Must have earliest stratum where relation is fully computed!");
+            std::size_t newStratum = relationToCompletedStratum.at(rel);
+
+            // move the node into the new stratum
+            uniqueKeyStatements[newStratum].push_back(std::move(statement));
+        }
+
+        // erase remove all nullptr from the vector since moved from unique_ptr are guaranteed to be nullptr
+        auto& v = uniqueKeyStatements[scc];
+        v.erase(std::remove(v.begin(), v.end(), nullptr), v.end());
+    }
+    return uniqueKeyStatements;
+}
+
+void UniqueKeysAnalysis::run(const TranslationUnit& translationUnit) {
+    program = &translationUnit.getProgram();
+    sccGraph = &translationUnit.getAnalysis<SCCGraphAnalysis>();
+    topsortSCCGraphAnalysis = &translationUnit.getAnalysis<TopologicallySortedSCCGraphAnalysis>();
+    recursiveClauses = &translationUnit.getAnalysis<RecursiveClausesAnalysis>();
+    polyAnalysis = &translationUnit.getAnalysis<ast::analysis::PolymorphicObjectsAnalysis>();
+    uniqueKeyStatements = computeUniqueKeyStatements();
+}
+
+void UniqueKeysAnalysis::print(std::ostream& os) const {
+    os << "Begin UniqueKeyStatements\n";
+    for (std::size_t i = 0; i < uniqueKeyStatements.size(); ++i) {
+        os << "Stratum: " << i << "\n";
+        for (auto& s : uniqueKeyStatements[i]) {
+            os << *s << "\n";
+        }
+    }
+    os << "End UniqueKeyStatements\n";
+}
+
+}  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/UniqueKeys.h b/src/ast/analysis/UniqueKeys.h
new file mode 100644
index 0000000..c7fff08
--- /dev/null
+++ b/src/ast/analysis/UniqueKeys.h
@@ -0,0 +1,79 @@
+/*
+ * Souffle - A Datalog Compiler
+ * Copyright (c) 2022, The Souffle Developers. All rights reserved
+ * Licensed under the Universal Permissive License v 1.0 as shown at:
+ * - https://opensource.org/licenses/UPL
+ * - <souffle root>/licenses/SOUFFLE-UPL.txt
+ */
+
+/************************************************************************
+ *
+ * @file UniqueKeys.h
+
+ * Computes for every stratum, which CountUniqueKeys nodes to emit in the RAM
+ * This is useful for the auto-scheduler to accumulate selectivity statistics
+ *
+ ***********************************************************************/
+
+#pragma once
+
+#include "ast/Program.h"
+#include "ast/Relation.h"
+#include "ast/TranslationUnit.h"
+#include "ast/analysis/RecursiveClauses.h"
+#include "ast/analysis/SCCGraph.h"
+#include "ast/analysis/TopologicallySortedSCCGraph.h"
+#include "ast/analysis/typesystem/PolymorphicObjects.h"
+#include "ast/utility/Visitor.h"
+#include "ast2ram/ClauseTranslator.h"
+#include "ram/CountUniqueKeys.h"
+#include "ram/Expression.h"
+#include <ostream>
+#include <set>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace souffle::ast::analysis {
+
+/**
+ * Analysis pass computing a schedule for computing relations.
+ */
+using PowerSet = std::vector<std::vector<std::size_t>>;
+using StratumUniqueKeys = std::vector<Own<ram::CountUniqueKeys>>;
+
+class UniqueKeysAnalysis : public Analysis {
+public:
+    static constexpr const char* name = "unique-keys";
+
+    UniqueKeysAnalysis() : Analysis(name) {}
+
+    void run(const TranslationUnit& translationUnit) override;
+
+    /** Dump this relation schedule to standard error. */
+    void print(std::ostream& os) const override;
+
+    const StratumUniqueKeys& getUniqueKeyStatementsInSCC(std::size_t scc) const {
+        return uniqueKeyStatements[scc];
+    }
+
+private:
+    std::vector<StratumUniqueKeys> uniqueKeyStatements;
+
+    std::set<std::string> seenNodes;
+    ast::Program* program = nullptr;
+    SCCGraphAnalysis* sccGraph = nullptr;
+    TopologicallySortedSCCGraphAnalysis* topsortSCCGraphAnalysis = nullptr;
+    RecursiveClausesAnalysis* recursiveClauses = nullptr;
+    PolymorphicObjectsAnalysis* polyAnalysis = nullptr;
+
+    // for each stratum compute the CountUniqueKeys nodes to emit
+    std::vector<StratumUniqueKeys> computeUniqueKeyStatements();
+    StratumUniqueKeys computeRuleVersionStatements(const std::set<const ast::Relation*>& sccRelations,
+            const ast::Clause& clause, std::optional<std::size_t> version,
+            ast2ram::TranslationMode mode = ast2ram::TranslationMode::DEFAULT);
+    const PowerSet& getSubsets(std::size_t N, std::size_t K) const;
+    mutable std::map<std::pair<std::size_t, std::size_t>, PowerSet> cache;
+};
+
+}  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/typesystem/PolymorphicObjects.cpp b/src/ast/analysis/typesystem/PolymorphicObjects.cpp
index d13113d..7d2e07e 100644
--- a/src/ast/analysis/typesystem/PolymorphicObjects.cpp
+++ b/src/ast/analysis/typesystem/PolymorphicObjects.cpp
@@ -46,7 +46,7 @@ BinaryConstraintOp PolymorphicObjectsAnalysis::getOverloadedOperator(const Binar
     return typeAnalysis->getPolymorphicOperator(bc);
 }
 
-AggregateOp PolymorphicObjectsAnalysis::getOverloadedOperator(const IntrinsicAggregator& agg) const {
+AggregateOp PolymorphicObjectsAnalysis::getOverloadedOperator(const Aggregator& agg) const {
     return typeAnalysis->getPolymorphicOperator(agg);
 }
 
diff --git a/src/ast/analysis/typesystem/PolymorphicObjects.h b/src/ast/analysis/typesystem/PolymorphicObjects.h
index 9b88b6d..b7c1319 100644
--- a/src/ast/analysis/typesystem/PolymorphicObjects.h
+++ b/src/ast/analysis/typesystem/PolymorphicObjects.h
@@ -26,7 +26,7 @@ enum class FunctorOp;
 }  // namespace souffle
 
 namespace souffle::ast {
-class IntrinsicAggregator;
+class Aggregator;
 class BinaryConstraint;
 class IntrinsicFunctor;
 class TranslationUnit;
@@ -57,7 +57,7 @@ public:
     BinaryConstraintOp getOverloadedOperator(const BinaryConstraint& bc) const;
 
     // Aggregators
-    AggregateOp getOverloadedOperator(const IntrinsicAggregator& agg) const;
+    AggregateOp getOverloadedOperator(const Aggregator& agg) const;
 
 private:
     const TypeAnalysis* typeAnalysis = nullptr;
diff --git a/src/ast/analysis/typesystem/SumTypeBranches.h b/src/ast/analysis/typesystem/SumTypeBranches.h
index 8ca530d..cfd6327 100644
--- a/src/ast/analysis/typesystem/SumTypeBranches.h
+++ b/src/ast/analysis/typesystem/SumTypeBranches.h
@@ -51,7 +51,7 @@ public:
     }
 
 private:
-    OrderedQualifiedNameMap<const Type*> branchToType;
+    std::map<QualifiedName, const Type*> branchToType;
 };
 
 }  // namespace analysis
diff --git a/src/ast/analysis/typesystem/Type.cpp b/src/ast/analysis/typesystem/Type.cpp
index b50ae83..fb06511 100644
--- a/src/ast/analysis/typesystem/Type.cpp
+++ b/src/ast/analysis/typesystem/Type.cpp
@@ -23,7 +23,6 @@
 #include "ast/BinaryConstraint.h"
 #include "ast/BranchInit.h"
 #include "ast/Clause.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/IntrinsicFunctor.h"
 #include "ast/Negation.h"
 #include "ast/NumericConstant.h"
@@ -31,12 +30,10 @@
 #include "ast/Relation.h"
 #include "ast/TranslationUnit.h"
 #include "ast/TypeCast.h"
-#include "ast/UserDefinedAggregator.h"
 #include "ast/UserDefinedFunctor.h"
 #include "ast/Variable.h"
 #include "ast/analysis/Constraint.h"
 #include "ast/analysis/ConstraintSystem.h"
-#include "ast/analysis/ErrorAnalyzer.h"
 #include "ast/analysis/typesystem/SumTypeBranches.h"
 #include "ast/analysis/typesystem/TypeConstrainsAnalysis.h"
 #include "ast/analysis/typesystem/TypeConstraints.h"
@@ -73,12 +70,12 @@ Own<Clause> TypeAnalysis::createAnnotatedClause(
         Own<Node> operator()(Own<Node> node) const override {
             if (auto* var = as<ast::Variable>(node)) {
                 std::stringstream newVarName;
-                newVarName << var->getName() << "∈" << types.find(var)->second;
+                newVarName << var->getName() << "&isin;" << types.find(var)->second;
                 return mk<ast::Variable>(newVarName.str());
             } else if (auto* var = as<UnnamedVariable>(node)) {
                 std::stringstream newVarName;
                 newVarName << "_"
-                           << "∈" << types.find(var)->second;
+                           << "&isin;" << types.find(var)->second;
                 return mk<ast::Variable>(newVarName.str());
             }
             node->apply(*this);
@@ -125,9 +122,9 @@ Own<Clause> TypeAnalysis::createAnnotatedClause(
     return annotatedClause;
 }
 
-std::map<const Argument*, TypeSet> TypeAnalysis::analyseTypes(const TranslationUnit& tu, const Clause& clause,
-        TypeErrorAnalyzer* errorAnalyzer, std::ostream* logs) {
-    return TypeConstraintsAnalysis(tu).analyse(clause, errorAnalyzer, logs);
+std::map<const Argument*, TypeSet> TypeAnalysis::analyseTypes(
+        const TranslationUnit& tu, const Clause& clause, std::ostream* logs) {
+    return TypeConstraintsAnalysis(tu).analyse(clause, logs);
 }
 
 void TypeAnalysis::print(std::ostream& os) const {
@@ -196,35 +193,6 @@ std::vector<TypeAttribute> TypeAnalysis::getFunctorParamTypeAttributes(
     return res;
 }
 
-TypeAttribute TypeAnalysis::getAggregatorReturnTypeAttribute(const UserDefinedAggregator& aggregator) const {
-    return getTypeAttribute(getAggregatorReturnType(aggregator));
-}
-
-Type const& TypeAnalysis::getAggregatorReturnType(const UserDefinedAggregator& aggregator) const {
-    return nameToType(functorAnalysis->getFunctorDeclaration(aggregator).getReturnType().getTypeName());
-}
-
-Type const& TypeAnalysis::getAggregatorParamType(
-        const UserDefinedAggregator& aggregator, std::size_t idx) const {
-    return nameToType(functorAnalysis->getFunctorDeclaration(aggregator).getParams().at(idx)->getTypeName());
-}
-
-TypeAttribute TypeAnalysis::getAggregatorParamTypeAttribute(
-        const UserDefinedAggregator& aggregator, std::size_t idx) const {
-    return getTypeAttribute(getAggregatorParamType(aggregator, idx));
-}
-
-std::vector<TypeAttribute> TypeAnalysis::getAggregatorParamTypeAttributes(
-        const UserDefinedAggregator& aggregator) const {
-    auto const& decl = functorAnalysis->getFunctorDeclaration(aggregator);
-    std::vector<TypeAttribute> res;
-    res.reserve(decl.getArity());
-    auto const& params = decl.getParams();
-    std::transform(params.begin(), params.end(), std::back_inserter(res),
-            [this](auto const& attr) { return nameToTypeAttribute(attr->getTypeName()); });
-    return res;
-}
-
 const std::map<const NumericConstant*, NumericConstant::Type>& TypeAnalysis::getNumericConstantTypes() const {
     return numericConstantType;
 }
@@ -307,15 +275,8 @@ bool TypeAnalysis::hasValidTypeInfo(const Argument& argument) const {
         }
     } else if (auto* nc = as<NumericConstant>(argument)) {
         return contains(numericConstantType, nc);
-    } else if (auto* agg = as<IntrinsicAggregator>(argument)) {
+    } else if (auto* agg = as<Aggregator>(argument)) {
         return contains(aggregatorType, agg);
-    } else if (auto* uda = as<UserDefinedAggregator>(argument)) {
-        try {
-            auto const& declaration = functorAnalysis->getFunctorDeclaration(*uda);
-            return hasValidTypeInfo(declaration);
-        } catch (...) {  // functor hasn't been declared
-            return false;
-        }
     }
     return true;
 }
@@ -339,7 +300,7 @@ BinaryConstraintOp TypeAnalysis::getPolymorphicOperator(const BinaryConstraint&
     return constraintType.at(&bc);
 }
 
-AggregateOp TypeAnalysis::getPolymorphicOperator(const IntrinsicAggregator& agg) const {
+AggregateOp TypeAnalysis::getPolymorphicOperator(const Aggregator& agg) const {
     assert(hasValidTypeInfo(agg) && "aggregator operator not set");
     return aggregatorType.at(&agg);
 }
@@ -420,7 +381,7 @@ bool TypeAnalysis::analyseAggregators(const TranslationUnit& translationUnit) {
     bool changed = false;
     const auto& program = translationUnit.getProgram();
 
-    auto setAggregatorType = [&](const IntrinsicAggregator& agg, TypeAttribute attr) {
+    auto setAggregatorType = [&](const Aggregator& agg, TypeAttribute attr) {
         auto overloadedType = convertOverloadedAggregator(agg.getBaseOperator(), attr);
         if (contains(aggregatorType, &agg) && aggregatorType.at(&agg) == overloadedType) {
             return;
@@ -429,7 +390,7 @@ bool TypeAnalysis::analyseAggregators(const TranslationUnit& translationUnit) {
         aggregatorType[&agg] = overloadedType;
     };
 
-    visit(program, [&](const IntrinsicAggregator& agg) {
+    visit(program, [&](const Aggregator& agg) {
         if (isOverloadedAggregator(agg.getBaseOperator())) {
             auto* targetExpression = agg.getTargetExpression();
             if (isFloat(targetExpression)) {
@@ -511,8 +472,7 @@ bool TypeAnalysis::isSymbol(const Argument* argument) const {
 void TypeAnalysis::run(const TranslationUnit& translationUnit) {
     // Check if debugging information is being generated
     std::ostream* debugStream = nullptr;
-    if (translationUnit.global().config().has("debug-report") ||
-            translationUnit.global().config().has("show", "type-analysis")) {
+    if (Global::config().has("debug-report") || Global::config().has("show", "type-analysis")) {
         debugStream = &analysisLogs;
     }
 
@@ -530,8 +490,7 @@ void TypeAnalysis::run(const TranslationUnit& translationUnit) {
 
         // Analyse general argument types, clause by clause.
         for (const Clause* clause : program.getClauses()) {
-            auto clauseArgumentTypes =
-                    analyseTypes(translationUnit, *clause, errorAnalyzer.get(), debugStream);
+            auto clauseArgumentTypes = analyseTypes(translationUnit, *clause, debugStream);
             argumentTypes.insert(clauseArgumentTypes.begin(), clauseArgumentTypes.end());
 
             if (debugStream != nullptr) {
@@ -582,8 +541,6 @@ void TypeAnnotationPrinter::branchOnArgument(const Argument* cur, const Type& ty
         print_(type_identity<UserDefinedFunctor>(), *as<UserDefinedFunctor>(cur));
     } else if (isA<Counter>(*cur)) {
         print_(type_identity<Counter>(), *as<Counter>(cur));
-    } else if (isA<IterationCounter>(*cur)) {
-        print_(type_identity<IterationCounter>(), *as<IterationCounter>(cur));
     } else if (isA<Aggregator>(*cur)) {
         print_(type_identity<Aggregator>(), *as<Aggregator>(cur));
     } else {
@@ -707,7 +664,8 @@ void TypeAnnotationPrinter::print_(type_identity<UserDefinedFunctor>, const User
     auto arguments = fun.getArguments();
     os << "@" << fun.getName() << "(";
     for (std::size_t i = 0; i < arguments.size(); ++i) {
-        const auto& ty = typeAnalysis.getFunctorParamType(fun, i);
+        TypeAttribute argType = typeAnalysis.getFunctorParamTypeAttribute(fun, i);
+        auto& ty = typeEnv.getConstantType(argType);
         branchOnArgument(arguments[i], ty);
         if (i + 1 < arguments.size()) {
             os << ",";
@@ -720,11 +678,6 @@ void TypeAnnotationPrinter::print_(type_identity<Counter>, [[maybe_unused]] cons
     os << "$∈{number}";
 }
 
-void TypeAnnotationPrinter::print_(
-        type_identity<IterationCounter>, [[maybe_unused]] const IterationCounter& counter) {
-    os << "$∈{unsigned}";
-}
-
 void TypeAnnotationPrinter::print_(type_identity<TypeCast>, const ast::TypeCast& typeCast) {
     os << "as(";
     auto& ty = typeEnv.getType(typeCast.getType());
@@ -735,7 +688,7 @@ void TypeAnnotationPrinter::print_(type_identity<TypeCast>, const ast::TypeCast&
 void TypeAnnotationPrinter::print_(
         type_identity<RecordInit>, const RecordInit& record, const RecordType& type) {
     auto arguments = record.getArguments();
-    const auto& ftypes = type.getFields();
+    auto& ftypes = type.getFields();
     os << "[";
     for (std::size_t i = 0; i < arguments.size(); ++i) {
         branchOnArgument(arguments[i], *ftypes[i]);
@@ -776,7 +729,7 @@ void TypeAnnotationPrinter::print_(type_identity<BranchInit>, const BranchInit&
 }
 
 void TypeAnnotationPrinter::print_(type_identity<Aggregator>, const Aggregator& agg) {
-    auto baseOperator = agg.getBaseOperatorName();
+    auto baseOperator = agg.getBaseOperator();
     auto bodyLiterals = agg.getBodyLiterals();
     os << baseOperator << " ";
     auto targetExpr = agg.getTargetExpression();
@@ -824,9 +777,4 @@ void TypeAnnotationPrinter::printAnnotatedClause(const Clause& clause) {
     os << "." << std::endl;
 }
 
-TypeAnalysis::TypeAnalysis() : Analysis(name) {
-    errorAnalyzer = std::make_shared<TypeErrorAnalyzer>();
-}
-TypeAnalysis::~TypeAnalysis() = default;
-
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/typesystem/Type.h b/src/ast/analysis/typesystem/Type.h
index ac87828..a49ee89 100644
--- a/src/ast/analysis/typesystem/Type.h
+++ b/src/ast/analysis/typesystem/Type.h
@@ -21,7 +21,6 @@
 #include "ast/Clause.h"
 #include "ast/NumericConstant.h"
 #include "ast/TranslationUnit.h"
-#include "ast/UserDefinedAggregator.h"
 #include "ast/analysis/Functor.h"
 #include "ast/analysis/typesystem/SumTypeBranches.h"
 #include "ast/analysis/typesystem/TypeEnvironment.h"
@@ -37,13 +36,11 @@
 namespace souffle::ast {
 class Argument;
 class Aggregator;
-class IntrinsicAggregator;
 class BinaryConstraint;
 class Clause;
 class Functor;
 class FunctorDeclaration;
 class IntrinsicFunctor;
-class IterationCounter;
 class NumericConstant;
 class Type;
 class UserDefinedFunctor;
@@ -61,12 +58,9 @@ class TypeEnvironment;
 
 class TypeAnalysis : public Analysis {
 public:
-    class TypeErrorAnalyzer;
-
     static constexpr const char* name = "type-analysis";
 
-    TypeAnalysis();
-    ~TypeAnalysis();
+    TypeAnalysis() : Analysis(name) {}
 
     void run(const TranslationUnit& translationUnit) override;
 
@@ -84,8 +78,8 @@ public:
      *
      * @return a map mapping each contained argument to a set of types
      */
-    static std::map<const Argument*, TypeSet> analyseTypes(const TranslationUnit& tu, const Clause& clause,
-            TypeErrorAnalyzer* errorAnalyzer = nullptr, std::ostream* logs = nullptr);
+    static std::map<const Argument*, TypeSet> analyseTypes(
+            const TranslationUnit& tu, const Clause& clause, std::ostream* logs = nullptr);
 
     // Checks whether an argument has been assigned a valid type
     bool hasValidTypeInfo(const Argument& argument) const;
@@ -102,19 +96,10 @@ public:
     TypeAttribute getFunctorParamTypeAttribute(const Functor& functor, std::size_t idx) const;
     std::vector<TypeAttribute> getFunctorParamTypeAttributes(const UserDefinedFunctor& functor) const;
 
-    /** -- User-defined Aggregator-related methods -- */
-    TypeAttribute getAggregatorReturnTypeAttribute(const UserDefinedAggregator& aggregator) const;
-    Type const& getAggregatorReturnType(const UserDefinedAggregator& aggregator) const;
-    Type const& getAggregatorParamType(const UserDefinedAggregator& aggregator, std::size_t idx) const;
-    TypeAttribute getAggregatorParamTypeAttribute(
-            const UserDefinedAggregator& aggregator, std::size_t idx) const;
-    std::vector<TypeAttribute> getAggregatorParamTypeAttributes(
-            const UserDefinedAggregator& aggregator) const;
-
     /** -- Polymorphism-related methods -- */
     NumericConstant::Type getPolymorphicNumericConstantType(const NumericConstant& nc) const;
     const std::map<const NumericConstant*, NumericConstant::Type>& getNumericConstantTypes() const;
-    AggregateOp getPolymorphicOperator(const IntrinsicAggregator& agg) const;
+    AggregateOp getPolymorphicOperator(const Aggregator& agg) const;
     BinaryConstraintOp getPolymorphicOperator(const BinaryConstraint& bc) const;
     FunctorOp getPolymorphicOperator(const IntrinsicFunctor& inf) const;
 
@@ -123,11 +108,6 @@ private:
     TypeEnvironment const* typeEnv = nullptr;
     FunctorAnalysis const* functorAnalysis = nullptr;
     std::map<const Argument*, TypeSet> argumentTypes;
-
-public:
-    std::shared_ptr<TypeErrorAnalyzer> errorAnalyzer;
-
-private:
     VecOwn<Clause> annotatedClauses;
     std::stringstream analysisLogs;
     const TranslationUnit* translationUnit;
@@ -139,7 +119,7 @@ private:
     // Polymorphic objects analysis
     std::map<const IntrinsicFunctor*, const IntrinsicFunctorInfo*> functorInfo;
     std::map<const NumericConstant*, NumericConstant::Type> numericConstantType;
-    std::map<const IntrinsicAggregator*, AggregateOp> aggregatorType;
+    std::map<const Aggregator*, AggregateOp> aggregatorType;
     std::map<const BinaryConstraint*, BinaryConstraintOp> constraintType;
 
     bool analyseIntrinsicFunctors(const TranslationUnit& translationUnit);
@@ -190,7 +170,6 @@ private:
     void print_(type_identity<IntrinsicFunctor>, const IntrinsicFunctor& fun);
     void print_(type_identity<UserDefinedFunctor>, const UserDefinedFunctor& fun);
     void print_(type_identity<Counter>, const Counter& counter);
-    void print_(type_identity<IterationCounter>, const IterationCounter& counter);
     void print_(type_identity<TypeCast>, const ast::TypeCast& typeCast);
     void print_(type_identity<RecordInit>, const RecordInit& record, const RecordType&);
     void print_(type_identity<BranchInit>, const BranchInit& adt);
diff --git a/src/ast/analysis/typesystem/TypeConstrainsAnalysis.cpp b/src/ast/analysis/typesystem/TypeConstrainsAnalysis.cpp
index 588ebfd..f6c3c32 100644
--- a/src/ast/analysis/typesystem/TypeConstrainsAnalysis.cpp
+++ b/src/ast/analysis/typesystem/TypeConstrainsAnalysis.cpp
@@ -13,7 +13,6 @@
  ***********************************************************************/
 
 #include "ast/analysis/typesystem/TypeConstrainsAnalysis.h"
-#include "ast/UserDefinedAggregator.h"
 #include "ast/analysis/typesystem/TypeConstraints.h"
 
 namespace souffle::ast::analysis {
@@ -39,11 +38,7 @@ void TypeConstraintsAnalysis::visit_(type_identity<Atom>, const Atom& atom) {
     }
 
     iterateOverAtom(atom, [&](const Argument& argument, const Type& attributeType) {
-        auto constraint = isSubtypeOf(getVar(argument), attributeType);
-        addConstraint(constraint);
-        if (errorAnalyzer) {
-            errorAnalyzer->localizeConstraint(constraint, atom.getSrcLoc());
-        }
+        addConstraint(isSubtypeOf(getVar(argument), attributeType));
     });
 }
 
@@ -174,10 +169,6 @@ void TypeConstraintsAnalysis::visit_(type_identity<Counter>, const Counter& coun
     addConstraint(isSubtypeOf(getVar(counter), typeEnv.getConstantType(TypeAttribute::Signed)));
 }
 
-void TypeConstraintsAnalysis::visit_(type_identity<IterationCounter>, const IterationCounter& counter) {
-    addConstraint(isSubtypeOf(getVar(counter), typeEnv.getConstantType(TypeAttribute::Unsigned)));
-}
-
 void TypeConstraintsAnalysis::visit_(type_identity<TypeCast>, const ast::TypeCast& typeCast) {
     auto& typeName = typeCast.getType();
     if (!typeEnv.isType(typeName)) {
@@ -240,7 +231,7 @@ void TypeConstraintsAnalysis::visit_(type_identity<BranchInit>, const BranchInit
     }
 }
 
-void TypeConstraintsAnalysis::visit_(type_identity<IntrinsicAggregator>, const IntrinsicAggregator& agg) {
+void TypeConstraintsAnalysis::visit_(type_identity<Aggregator>, const Aggregator& agg) {
     if (agg.getBaseOperator() == AggregateOp::COUNT) {
         addConstraint(isSubtypeOf(getVar(agg), typeEnv.getConstantType(TypeAttribute::Signed)));
     } else if (agg.getBaseOperator() == AggregateOp::MEAN) {
@@ -256,17 +247,6 @@ void TypeConstraintsAnalysis::visit_(type_identity<IntrinsicAggregator>, const I
     }
 }
 
-void TypeConstraintsAnalysis::visit_(type_identity<UserDefinedAggregator>, const UserDefinedAggregator& agg) {
-    auto const& init = agg.getInit();
-
-    Type const& returnType = typeAnalysis.getAggregatorReturnType(agg);
-    addConstraint(isSubtypeOf(getVar(init), returnType));
-    addConstraint(isSubtypeOf(getVar(agg), returnType));
-
-    Type const& argType = typeAnalysis.getAggregatorParamType(agg, 1);
-    addConstraint(isSubtypeOf(getVar(agg.getTargetExpression()), argType));
-}
-
 void TypeConstraintsAnalysis::iterateOverAtom(
         const Atom& atom, std::function<void(const Argument&, const Type&)> map) {
     // get relation
diff --git a/src/ast/analysis/typesystem/TypeConstrainsAnalysis.h b/src/ast/analysis/typesystem/TypeConstrainsAnalysis.h
index e55f9a7..627fe51 100644
--- a/src/ast/analysis/typesystem/TypeConstrainsAnalysis.h
+++ b/src/ast/analysis/typesystem/TypeConstrainsAnalysis.h
@@ -60,12 +60,10 @@ private:
     void visit_(type_identity<IntrinsicFunctor>, const IntrinsicFunctor& fun) override;
     void visit_(type_identity<UserDefinedFunctor>, const UserDefinedFunctor& fun) override;
     void visit_(type_identity<Counter>, const Counter& counter) override;
-    void visit_(type_identity<IterationCounter>, const IterationCounter& counter) override;
     void visit_(type_identity<TypeCast>, const ast::TypeCast& typeCast) override;
     void visit_(type_identity<RecordInit>, const RecordInit& record) override;
     void visit_(type_identity<BranchInit>, const BranchInit& adt) override;
-    void visit_(type_identity<IntrinsicAggregator>, const IntrinsicAggregator& agg) override;
-    void visit_(type_identity<UserDefinedAggregator>, const UserDefinedAggregator& agg) override;
+    void visit_(type_identity<Aggregator>, const Aggregator& agg) override;
 };
 
 }  // namespace souffle::ast::analysis
\ No newline at end of file
diff --git a/src/ast/analysis/typesystem/TypeConstraints.cpp b/src/ast/analysis/typesystem/TypeConstraints.cpp
index 5660d11..2819cb2 100644
--- a/src/ast/analysis/typesystem/TypeConstraints.cpp
+++ b/src/ast/analysis/typesystem/TypeConstraints.cpp
@@ -30,7 +30,6 @@ TypeConstraint isSubtypeOf(const TypeVar& a, const TypeVar& b) {
  * a are subtypes of type b.
  */
 TypeConstraint isSubtypeOf(const TypeVar& variable, const Type& type) {
-    // @here
     struct C : public Constraint<TypeVar> {
         TypeVar variable;
         const Type& type;
@@ -62,13 +61,6 @@ TypeConstraint isSubtypeOf(const TypeVar& variable, const Type& type) {
         void print(std::ostream& out) const override {
             out << variable << " <: " << type.getName();
         }
-
-        std::optional<std::string> customMessage() const override {
-            std::stringstream ss;
-            ss << "Type of variable '" << variable.name() << "' should be a subtype of '"
-               << type.getPrettyName() << "'";
-            return ss.str();
-        }
     };
 
     return std::make_shared<C>(variable, type);
diff --git a/src/ast/analysis/typesystem/TypeConstraints.h b/src/ast/analysis/typesystem/TypeConstraints.h
index 537335f..dedb7f3 100644
--- a/src/ast/analysis/typesystem/TypeConstraints.h
+++ b/src/ast/analysis/typesystem/TypeConstraints.h
@@ -58,13 +58,6 @@ struct all_type_factory {
     }
 };
 
-template <>
-struct detail::default_is_valid_op<TypeSet> {
-    bool operator()(const TypeSet& a) {
-        return !a.empty();
-    }
-};
-
 /**
  * The type lattice forming the property space for the Type analysis. The
  * value set is given by sets of types and the meet operator is based on the
@@ -88,6 +81,4 @@ TypeConstraint satisfiesOverload(const TypeEnvironment& typeEnv, IntrinsicFuncto
 TypeConstraint isSubtypeOfComponent(
         const TypeVar& elementVariable, const TypeVar& recordVariable, std::size_t index);
 
-class TypeAnalysis::TypeErrorAnalyzer : public ErrorAnalyzer<TypeVar> {};
-
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/typesystem/TypeEnvironment.cpp b/src/ast/analysis/typesystem/TypeEnvironment.cpp
index d432728..326cafe 100644
--- a/src/ast/analysis/typesystem/TypeEnvironment.cpp
+++ b/src/ast/analysis/typesystem/TypeEnvironment.cpp
@@ -15,6 +15,7 @@
  ***********************************************************************/
 
 #include "ast/analysis/typesystem/TypeEnvironment.h"
+#include "GraphUtils.h"
 #include "ast/AlgebraicDataType.h"
 #include "ast/AliasType.h"
 #include "ast/Attribute.h"
@@ -26,7 +27,6 @@
 #include "ast/Type.h"
 #include "ast/UnionType.h"
 #include "ast/analysis/typesystem/TypeSystem.h"
-#include "souffle/datastructure/Graph.h"
 #include "souffle/utility/MiscUtil.h"
 #include "souffle/utility/tinyformat.h"
 #include <algorithm>
@@ -40,10 +40,8 @@ namespace souffle::ast::analysis {
 
 namespace {
 
-using QNGraph = GraphLabeled<QualifiedName, Unit, UnorderedQualifiedNameLess>;
-
-QNGraph createTypeDependencyGraph(const std::vector<ast::Type*>& programTypes) {
-    QNGraph typeDependencyGraph;
+Graph<QualifiedName> createTypeDependencyGraph(const std::vector<ast::Type*>& programTypes) {
+    Graph<QualifiedName> typeDependencyGraph;
     for (const auto* astType : programTypes) {
         if (auto type = as<ast::SubsetType>(astType)) {
             typeDependencyGraph.insert(type->getQualifiedName(), type->getBaseType());
@@ -79,9 +77,9 @@ QNGraph createTypeDependencyGraph(const std::vector<ast::Type*>& programTypes) {
 /**
  * Find all the type with a cyclic definition (in terms of being a subtype/alias)
  */
-UnorderedQualifiedNameSet analyseCyclicTypes(
-        const QNGraph& dependencyGraph, const std::vector<ast::Type*>& programTypes) {
-    UnorderedQualifiedNameSet cyclicTypes;
+std::set<QualifiedName> analyseCyclicTypes(
+        const Graph<QualifiedName>& dependencyGraph, const std::vector<ast::Type*>& programTypes) {
+    std::set<QualifiedName> cyclicTypes;
     for (const auto& astType : programTypes) {
         QualifiedName typeName = astType->getQualifiedName();
         if (dependencyGraph.reaches(typeName, typeName)) {
@@ -94,10 +92,10 @@ UnorderedQualifiedNameSet analyseCyclicTypes(
 /**
  * Find all the primitive types that are the subtypes of the union types.
  */
-UnorderedQualifiedNameMap<UnorderedQualifiedNameSet> analysePrimitiveTypesInUnion(
-        const QNGraph& dependencyGraph, const std::vector<ast::Type*>& programTypes,
+std::map<QualifiedName, std::set<QualifiedName>> analysePrimitiveTypesInUnion(
+        const Graph<QualifiedName>& dependencyGraph, const std::vector<ast::Type*>& programTypes,
         const TypeEnvironment& env) {
-    UnorderedQualifiedNameMap<UnorderedQualifiedNameSet> primitiveTypesInUnions;
+    std::map<QualifiedName, std::set<QualifiedName>> primitiveTypesInUnions;
 
     for (const auto& astType : programTypes) {
         auto* unionType = as<ast::UnionType>(astType);
@@ -131,13 +129,13 @@ void TypeEnvironmentAnalysis::run(const TranslationUnit& translationUnit) {
     const Program& program = translationUnit.getProgram();
 
     auto rawProgramTypes = program.getTypes();
-    QNGraph typeDependencyGraph{createTypeDependencyGraph(rawProgramTypes)};
+    Graph<QualifiedName> typeDependencyGraph{createTypeDependencyGraph(rawProgramTypes)};
 
     cyclicTypes = analyseCyclicTypes(typeDependencyGraph, rawProgramTypes);
 
     primitiveTypesInUnions = analysePrimitiveTypesInUnion(typeDependencyGraph, rawProgramTypes, env);
 
-    UnorderedQualifiedNameMap<const ast::Type*> nameToType;
+    std::map<QualifiedName, const ast::Type*> nameToType;
 
     // Filter redefined primitive types and cyclic types.
     std::vector<ast::Type*> programTypes;
@@ -155,7 +153,7 @@ void TypeEnvironmentAnalysis::run(const TranslationUnit& translationUnit) {
 }
 
 const Type* TypeEnvironmentAnalysis::createType(
-        const QualifiedName& typeName, const UnorderedQualifiedNameMap<const ast::Type*>& nameToType) {
+        const QualifiedName& typeName, const std::map<QualifiedName, const ast::Type*>& nameToType) {
     // base case
     if (env.isType(typeName)) {
         return &env.getType(typeName);
diff --git a/src/ast/analysis/typesystem/TypeEnvironment.h b/src/ast/analysis/typesystem/TypeEnvironment.h
index 867204a..6176c3f 100644
--- a/src/ast/analysis/typesystem/TypeEnvironment.h
+++ b/src/ast/analysis/typesystem/TypeEnvironment.h
@@ -42,7 +42,7 @@ public:
         return env;
     }
 
-    const UnorderedQualifiedNameSet& getPrimitiveTypesInUnion(const QualifiedName& identifier) const {
+    const std::set<QualifiedName>& getPrimitiveTypesInUnion(const QualifiedName& identifier) const {
         return primitiveTypesInUnions.at(identifier);
     }
 
@@ -52,15 +52,15 @@ public:
 
 private:
     TypeEnvironment env;
-    UnorderedQualifiedNameMap<UnorderedQualifiedNameSet> primitiveTypesInUnions;
-    UnorderedQualifiedNameSet cyclicTypes;
+    std::map<QualifiedName, std::set<QualifiedName>> primitiveTypesInUnions;
+    std::set<QualifiedName> cyclicTypes;
 
     /**
      * Recursively create a type in env, that is
      * first create its base types and then the type itself.
      */
     const Type* createType(
-            const QualifiedName& typeName, const UnorderedQualifiedNameMap<const ast::Type*>& nameToType);
+            const QualifiedName& typeName, const std::map<QualifiedName, const ast::Type*>& nameToType);
 };
 
 }  // namespace souffle::ast::analysis
diff --git a/src/ast/analysis/typesystem/TypeSystem.cpp b/src/ast/analysis/typesystem/TypeSystem.cpp
index f3ca043..c891e59 100644
--- a/src/ast/analysis/typesystem/TypeSystem.cpp
+++ b/src/ast/analysis/typesystem/TypeSystem.cpp
@@ -45,22 +45,18 @@ void RecordType::print(std::ostream& out) const {
 }
 
 TypeSet TypeEnvironment::initializeConstantTypes() {
-    auto& signedConstant = createType<ConstantType>(
-            QualifiedName::fromString("__numberConstant"), QualifiedName::fromString("number"));
-    auto& floatConstant = createType<ConstantType>(
-            QualifiedName::fromString("__floatConstant"), QualifiedName::fromString("float"));
-    auto& symbolConstant = createType<ConstantType>(
-            QualifiedName::fromString("__symbolConstant"), QualifiedName::fromString("symbol"));
-    auto& unsignedConstant = createType<ConstantType>(
-            QualifiedName::fromString("__unsignedConstant"), QualifiedName::fromString("unsigned"));
+    auto& signedConstant = createType<ConstantType>("__numberConstant");
+    auto& floatConstant = createType<ConstantType>("__floatConstant");
+    auto& symbolConstant = createType<ConstantType>("__symbolConstant");
+    auto& unsignedConstant = createType<ConstantType>("__unsignedConstant");
 
     return TypeSet(signedConstant, floatConstant, symbolConstant, unsignedConstant);
 }
 
 TypeSet TypeEnvironment::initializePrimitiveTypes() {
-#define CREATE_PRIMITIVE(TYPE)                                                     \
-    auto& TYPE##Type = createType<PrimitiveType>(QualifiedName::fromString(#TYPE), \
-            static_cast<const ConstantType&>(getType(QualifiedName::fromString("__" #TYPE "Constant"))));
+#define CREATE_PRIMITIVE(TYPE)                    \
+    auto& TYPE##Type = createType<PrimitiveType>( \
+            #TYPE, static_cast<const ConstantType&>(getType("__" #TYPE "Constant")));
 
     CREATE_PRIMITIVE(number);
     CREATE_PRIMITIVE(float);
diff --git a/src/ast/analysis/typesystem/TypeSystem.h b/src/ast/analysis/typesystem/TypeSystem.h
index cba1fd8..2fdd748 100644
--- a/src/ast/analysis/typesystem/TypeSystem.h
+++ b/src/ast/analysis/typesystem/TypeSystem.h
@@ -51,20 +51,6 @@ class TypeEnvironment;
  */
 class Type {
 public:
-    /// LLVM-style no-RTTI dynamic cast
-    // clang-format off
-    enum TypeKind {
-      TK_ConstantType,
-      TK_SubsetType,
-        TK_PrimitiveType,
-      TK_LastSubsetType,
-      TK_AliasType,
-      TK_UnionType,
-      TK_RecordType,
-      TK_AlgebraicDataType
-    };
-    // clang-format on
-
     Type(const Type& other) = delete;
 
     virtual ~Type() = default;
@@ -73,11 +59,6 @@ public:
         return name;
     }
 
-    const QualifiedName& getPrettyName() const {
-        if (maybePrettyName) return *maybePrettyName;
-        return name;
-    }
-
     const TypeEnvironment& getTypeEnvironment() const {
         return environment;
     }
@@ -91,7 +72,7 @@ public:
     }
 
     bool operator<(const Type& other) const {
-        return name.lexicalLess(other.name);
+        return name < other.name;
     }
 
     virtual void print(std::ostream& out) const {
@@ -102,25 +83,15 @@ public:
         return t.print(out), out;
     }
 
-    TypeKind getKind() const {
-        return kind;
-    }
-
-private:
-    const TypeKind kind;
-
 protected:
-    explicit Type(TypeKind tyKind, const TypeEnvironment& environment, QualifiedName name,
-            std::optional<QualifiedName> maybePrettyName = std::nullopt)
-            : kind(tyKind), environment(environment), name(std::move(name)),
-              maybePrettyName(std::move(maybePrettyName)) {}
+    Type(const TypeEnvironment& environment, QualifiedName name)
+            : environment(environment), name(std::move(name)) {}
 
     /** Type environment of type */
     const TypeEnvironment& environment;
 
     /** Qualified type name */
     QualifiedName name;
-    std::optional<QualifiedName> maybePrettyName;
 };
 
 /**
@@ -133,14 +104,7 @@ protected:
  *                 FloatConstant | SymbolConstant
  */
 class ConstantType : public Type {
-    ConstantType(const TypeEnvironment& environment, const QualifiedName& name,
-            std::optional<QualifiedName> maybePrettyName = std::nullopt)
-            : Type(TK_ConstantType, environment, name, std::move(maybePrettyName)) {}
-
-public:
-    static bool classof(const Type* t) {
-        return t->getKind() == TK_ConstantType;
-    }
+    ConstantType(const TypeEnvironment& environment, const QualifiedName& name) : Type(environment, name) {}
 
 private:
     friend class TypeEnvironment;
@@ -156,7 +120,7 @@ private:
  *
  * where T is a type.
  */
-class SubsetType : public Type {
+class SubsetType : virtual public Type {
 public:
     void print(std::ostream& out) const override;
 
@@ -164,16 +128,9 @@ public:
         return baseType;
     }
 
-    static bool classof(const Type* t) {
-        return t->getKind() >= TK_SubsetType && t->getKind() < TK_LastSubsetType;
-    }
-
-    SubsetType(TypeKind kind, const TypeEnvironment& environment, const QualifiedName& name, const Type& base)
-            : Type(kind, environment, name), baseType(base) {}
-
 protected:
     SubsetType(const TypeEnvironment& environment, const QualifiedName& name, const Type& base)
-            : SubsetType(TK_SubsetType, environment, name, base) {}
+            : Type(environment, name), baseType(base){};
 
 private:
     friend class TypeEnvironment;
@@ -200,13 +157,9 @@ public:
         return aliasType;
     }
 
-    static bool classof(const Type* t) {
-        return t->getKind() == TK_AliasType;
-    }
-
 protected:
     AliasType(const TypeEnvironment& environment, const QualifiedName& name, const Type& alias)
-            : Type(TK_AliasType, environment, name), aliasType(alias){};
+            : Type(environment, name), aliasType(alias){};
 
 private:
     friend class TypeEnvironment;
@@ -232,13 +185,9 @@ public:
         out << name;
     }
 
-    static bool classof(const Type* t) {
-        return t->getKind() == TK_PrimitiveType;
-    }
-
 protected:
     PrimitiveType(const TypeEnvironment& environment, const QualifiedName& name, const ConstantType& base)
-            : SubsetType(TK_PrimitiveType, environment, name, base) {}
+            : Type(environment, name), SubsetType(environment, name, base) {}
 
 private:
     friend class TypeEnvironment;
@@ -267,14 +216,10 @@ public:
 
     void print(std::ostream& out) const override;
 
-    static bool classof(const Type* t) {
-        return t->getKind() == TK_UnionType;
-    }
-
 protected:
     UnionType(const TypeEnvironment& environment, const QualifiedName& name,
             std::vector<const Type*> elementTypes = {})
-            : Type(TK_UnionType, environment, name), elementTypes(std::move(elementTypes)) {}
+            : Type(environment, name), elementTypes(std::move(elementTypes)) {}
 
 private:
     friend class TypeEnvironment;
@@ -305,14 +250,10 @@ public:
 
     void print(std::ostream& out) const override;
 
-    static bool classof(const Type* t) {
-        return t->getKind() == TK_RecordType;
-    }
-
 protected:
     RecordType(const TypeEnvironment& environment, const QualifiedName& name,
             const std::vector<const Type*> fields = {})
-            : Type(TK_RecordType, environment, name), fields(fields) {}
+            : Type(environment, name), fields(fields) {}
 
 private:
     friend class TypeEnvironment;
@@ -361,7 +302,7 @@ public:
     void setBranches(std::vector<Branch> bs) {
         branches = std::move(bs);
         std::sort(branches.begin(), branches.end(),
-                [](const Branch& left, const Branch& right) { return left.name.lexicalLess(right.name); });
+                [](const Branch& left, const Branch& right) { return left.name < right.name; });
     }
 
     const std::vector<const Type*>& getBranchTypes(const QualifiedName& name) const {
@@ -377,13 +318,8 @@ public:
         return branches;
     }
 
-    static bool classof(const Type* t) {
-        return t->getKind() == TK_AlgebraicDataType;
-    }
-
 protected:
-    AlgebraicDataType(const TypeEnvironment& env, QualifiedName name)
-            : Type(TK_AlgebraicDataType, env, std::move(name)) {}
+    AlgebraicDataType(const TypeEnvironment& env, QualifiedName name) : Type(env, std::move(name)) {}
 
 private:
     friend class TypeEnvironment;
@@ -573,12 +509,12 @@ public:
 
     const Type& getConstantType(TypeAttribute type) const {
         switch (type) {
-            case TypeAttribute::Signed: return getType(QualifiedName::fromString("__numberConstant"));
-            case TypeAttribute::Unsigned: return getType(QualifiedName::fromString("__unsignedConstant"));
-            case TypeAttribute::Float: return getType(QualifiedName::fromString("__floatConstant"));
-            case TypeAttribute::Symbol: return getType(QualifiedName::fromString("__symbolConstant"));
-            case TypeAttribute::Record: return getType(QualifiedName::fromString("__numberConstant"));
-            case TypeAttribute::ADT: return getType(QualifiedName::fromString("__numberConstant"));
+            case TypeAttribute::Signed: return getType("__numberConstant");
+            case TypeAttribute::Unsigned: return getType("__unsignedConstant");
+            case TypeAttribute::Float: return getType("__floatConstant");
+            case TypeAttribute::Symbol: return getType("__symbolConstant");
+            case TypeAttribute::Record: return getType("__numberConstant");
+            case TypeAttribute::ADT: return getType("__numberConstant");
         }
         fatal("Unhandled type");
     }
@@ -626,12 +562,11 @@ private:
     TypeSet initializeConstantTypes();
 
     /** Map for storing named types */
-    UnorderedQualifiedNameMap<Own<Type>> types;
+    std::map<QualifiedName, Own<Type>> types;
 
     const TypeSet constantTypes = initializeConstantTypes();
-    const TypeSet constantNumericTypes = TypeSet(getType(QualifiedName::fromString("__numberConstant")),
-            getType(QualifiedName::fromString("__unsignedConstant")),
-            getType(QualifiedName::fromString("__floatConstant")));
+    const TypeSet constantNumericTypes =
+            TypeSet(getType("__numberConstant"), getType("__unsignedConstant"), getType("__floatConstant"));
 
     const TypeSet primitiveTypes = initializePrimitiveTypes();
 };
diff --git a/src/ast/tests/CMakeLists.txt b/src/ast/tests/CMakeLists.txt
index 359035a..4457758 100644
--- a/src/ast/tests/CMakeLists.txt
+++ b/src/ast/tests/CMakeLists.txt
@@ -12,4 +12,3 @@ souffle_add_binary_test(ast_transformers_test ast)
 souffle_add_binary_test(ast_utils_test ast)
 souffle_add_binary_test(type_system_test ast)
 souffle_add_binary_test(constraints_test ast)
-souffle_add_binary_test(ast_recursive_clauses_test ast)
diff --git a/src/ast/tests/ast_print_test.cpp b/src/ast/tests/ast_print_test.cpp
index 74f964c..536a125 100644
--- a/src/ast/tests/ast_print_test.cpp
+++ b/src/ast/tests/ast_print_test.cpp
@@ -22,7 +22,6 @@
 #include "ast/Atom.h"
 #include "ast/Clause.h"
 #include "ast/Counter.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/Literal.h"
 #include "ast/NilConstant.h"
 #include "ast/Node.h"
@@ -44,15 +43,10 @@
 
 namespace souffle::ast::test {
 
-QualifiedName qn(std::string_view s) {
-    return QualifiedName::fromString(s);
-}
-
 inline Own<TranslationUnit> makeATU(std::string program = ".decl A,B,C(x:number)") {
-    Global glb;
     ErrorReport e;
-    DebugReport d(glb);
-    return ParserDriver::parseTranslationUnit(glb, program, e, d);
+    DebugReport d;
+    return ParserDriver::parseTranslationUnit(program, e, d);
 }
 
 inline Own<TranslationUnit> makePrintedATU(Own<TranslationUnit>& tu) {
@@ -62,7 +56,7 @@ inline Own<TranslationUnit> makePrintedATU(Own<TranslationUnit>& tu) {
 }
 
 inline Own<Clause> makeClauseA(Own<Argument> headArgument) {
-    auto clause = mk<Clause>(qn("A"));
+    auto clause = mk<Clause>("A");
     auto headAtom = clause->getHead();
     headAtom->addArgument(std::move(headArgument));
     return clause;
@@ -89,12 +83,11 @@ TEST(AstPrint, NumberConstant) {
 }
 
 TEST(AstPrint, StringConstant) {
-    Global glb;
     ErrorReport e;
-    DebugReport d(glb);
+    DebugReport d;
     auto testArgument = mk<StringConstant>("test string");
 
-    auto tu1 = ParserDriver::parseTranslationUnit(glb, ".decl A,B,C(x:number)", e, d);
+    auto tu1 = ParserDriver::parseTranslationUnit(".decl A,B,C(x:number)", e, d);
     tu1->getProgram().addClause(makeClauseA(std::move(testArgument)));
     auto tu2 = makePrintedATU(tu1);
     EXPECT_EQ(tu1->getProgram(), tu2->getProgram());
@@ -128,12 +121,12 @@ TEST(AstPrint, Counter) {
 }
 
 TEST(AstPrint, AggregatorMin) {
-    auto atom = mk<Atom>(qn("B"));
+    auto atom = mk<Atom>("B");
     atom->addArgument(mk<Variable>("x"));
-    auto min = mk<IntrinsicAggregator>(AggregateOp::MIN, mk<Variable>("x"));
+    auto min = mk<Aggregator>(AggregateOp::MIN, mk<Variable>("x"));
 
     VecOwn<Literal> body;
-    body.push_back(mk<Atom>(qn("B")));
+    body.push_back(mk<Atom>("B"));
 
     min->setBodyLiterals(std::move(body));
 
@@ -145,9 +138,9 @@ TEST(AstPrint, AggregatorMin) {
 }
 
 TEST(AstPrint, AggregatorMax) {
-    auto atom = mk<Atom>(qn("B"));
+    auto atom = mk<Atom>("B");
     atom->addArgument(mk<Variable>("x"));
-    auto max = mk<IntrinsicAggregator>(AggregateOp::MAX, mk<Variable>("x"));
+    auto max = mk<Aggregator>(AggregateOp::MAX, mk<Variable>("x"));
 
     VecOwn<Literal> body;
     body.push_back(std::move(atom));
@@ -161,9 +154,9 @@ TEST(AstPrint, AggregatorMax) {
 }
 
 TEST(AstPrint, AggregatorCount) {
-    auto atom = mk<Atom>(qn("B"));
+    auto atom = mk<Atom>("B");
     atom->addArgument(mk<Variable>("x"));
-    auto count = mk<IntrinsicAggregator>(AggregateOp::COUNT);
+    auto count = mk<Aggregator>(AggregateOp::COUNT);
 
     VecOwn<Literal> body;
     body.push_back(std::move(atom));
@@ -177,9 +170,9 @@ TEST(AstPrint, AggregatorCount) {
 }
 
 TEST(AstPrint, AggregatorSum) {
-    auto atom = mk<Atom>(qn("B"));
+    auto atom = mk<Atom>("B");
     atom->addArgument(mk<Variable>("x"));
-    auto sum = mk<IntrinsicAggregator>(AggregateOp::SUM, mk<Variable>("x"));
+    auto sum = mk<Aggregator>(AggregateOp::SUM, mk<Variable>("x"));
 
     VecOwn<Literal> body;
     body.push_back(std::move(atom));
diff --git a/src/ast/tests/ast_program_test.cpp b/src/ast/tests/ast_program_test.cpp
index cd405e1..8a31847 100644
--- a/src/ast/tests/ast_program_test.cpp
+++ b/src/ast/tests/ast_program_test.cpp
@@ -22,7 +22,6 @@
 #include "ast/Atom.h"
 #include "ast/Attribute.h"
 #include "ast/Clause.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/Literal.h"
 #include "ast/Node.h"
 #include "ast/Program.h"
@@ -43,31 +42,29 @@
 namespace souffle::ast::test {
 
 inline Own<TranslationUnit> makeATU(std::string program) {
-    Global glb;
     ErrorReport e;
-    DebugReport d(glb);
-    return ParserDriver::parseTranslationUnit(glb, program, e, d);
+    DebugReport d;
+    return ParserDriver::parseTranslationUnit(program, e, d);
 }
 
 inline Own<Clause> makeClause(std::string name, Own<Argument> headArgument) {
-    auto clause = mk<Clause>(QualifiedName::fromString(name));
+    auto clause = mk<Clause>(name);
     auto headAtom = clause->getHead();
     headAtom->addArgument(std::move(headArgument));
     return clause;
 }
 
 TEST(Program, Parse) {
-    Global glb;
     ErrorReport e;
-    DebugReport d(glb);
+    DebugReport d;
     // check the empty program
-    Own<TranslationUnit> empty = ParserDriver::parseTranslationUnit(glb, "", e, d);
+    Own<TranslationUnit> empty = ParserDriver::parseTranslationUnit("", e, d);
 
     EXPECT_TRUE(empty->getProgram().getTypes().empty());
     EXPECT_TRUE(empty->getProgram().getRelations().empty());
 
     // check something simple
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                    .type Node <: symbol
                    .decl e ( a : Node , b : Node )
@@ -84,22 +81,21 @@ TEST(Program, Parse) {
     EXPECT_EQ(1, prog.getTypes().size());
     EXPECT_EQ(2, prog.getRelations().size());
 
-    EXPECT_TRUE(prog.getRelation(QualifiedName::fromString("e")));
-    EXPECT_TRUE(prog.getRelation(QualifiedName::fromString("r")));
-    EXPECT_FALSE(prog.getRelation(QualifiedName::fromString("n")));
+    EXPECT_TRUE(prog.getRelation("e"));
+    EXPECT_TRUE(prog.getRelation("r"));
+    EXPECT_FALSE(prog.getRelation("n"));
 }
 
-#define TESTASTCLONEANDEQUAL(SUBTYPE, DL)                                            \
-    TEST(Ast, CloneAndEqual##SUBTYPE) {                                              \
-        Global glb;                                                                  \
-        ErrorReport e;                                                               \
-        DebugReport d(glb);                                                          \
-        Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb, DL, e, d); \
-        Program& program = tu->getProgram();                                         \
-        EXPECT_EQ(program, program);                                                 \
-        Own<Program> cl(clone(program));                                             \
-        EXPECT_NE(cl.get(), &program);                                               \
-        EXPECT_EQ(*cl, program);                                                     \
+#define TESTASTCLONEANDEQUAL(SUBTYPE, DL)                                       \
+    TEST(Ast, CloneAndEqual##SUBTYPE) {                                         \
+        ErrorReport e;                                                          \
+        DebugReport d;                                                          \
+        Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(DL, e, d); \
+        Program& program = tu->getProgram();                                    \
+        EXPECT_EQ(program, program);                                            \
+        Own<Program> cl(clone(program));                                        \
+        EXPECT_NE(cl.get(), &program);                                          \
+        EXPECT_EQ(*cl, program);                                                \
     }
 
 TESTASTCLONEANDEQUAL(Program,
@@ -201,9 +197,9 @@ TESTASTCLONEANDEQUAL(RelationCopies,
 
 // should *not* remove anything because `removeClause` operates by identity, not equality
 TEST(Program, RemoveClauseByEquality) {
-    auto atom = mk<Atom>(QualifiedName::fromString("B"));
+    auto atom = mk<Atom>("B");
     atom->addArgument(mk<Variable>("x"));
-    auto sum = mk<IntrinsicAggregator>(AggregateOp::SUM, mk<Variable>("x"));
+    auto sum = mk<Aggregator>(AggregateOp::SUM, mk<Variable>("x"));
     VecOwn<Literal> body;
     body.push_back(std::move(atom));
     sum->setBodyLiterals(std::move(body));
@@ -225,7 +221,7 @@ TEST(Program, RemoveClauseByEquality) {
 
 TEST(Program, RemoveClauseByIdentity) {
     auto tu1 = makeATU(".decl A,B(x:number) \n A(sum x : B(x)).");
-    auto clauses = tu1->getProgram().getClauses(QualifiedName::fromString("A"));
+    auto clauses = tu1->getProgram().getClauses("A");
     EXPECT_EQ(1, clauses.size());
     tu1->getProgram().removeClause(*clauses[0]);
 
@@ -237,8 +233,8 @@ TEST(Program, AppendRelation) {
     auto tu1 = makeATU(".decl A,B,C(x:number)");
     auto& prog1 = tu1->getProgram();
     auto rel = mk<Relation>();
-    rel->setQualifiedName(QualifiedName::fromString("D"));
-    rel->addAttribute(mk<Attribute>("x", QualifiedName::fromString("number")));
+    rel->setQualifiedName("D");
+    rel->addAttribute(mk<Attribute>("x", "number"));
     prog1.addRelation(std::move(rel));
     auto tu2 = makeATU(".decl A,B,C,D(x:number)");
     EXPECT_EQ(tu1->getProgram(), tu2->getProgram());
@@ -246,7 +242,7 @@ TEST(Program, AppendRelation) {
 
 TEST(Program, RemoveRelation) {
     auto tu1 = makeATU(".decl A,B,C(x:number)");
-    EXPECT_TRUE(tu1->getProgram().removeRelation(QualifiedName::fromString("B")));
+    EXPECT_TRUE(tu1->getProgram().removeRelation("B"));
     auto tu2 = makeATU(".decl A,C(x:number)");
     EXPECT_EQ(tu1->getProgram(), tu2->getProgram());
 }
diff --git a/src/ast/tests/ast_transformers_test.cpp b/src/ast/tests/ast_transformers_test.cpp
index bcfac10..274e02a 100644
--- a/src/ast/tests/ast_transformers_test.cpp
+++ b/src/ast/tests/ast_transformers_test.cpp
@@ -43,16 +43,11 @@
 namespace souffle::ast::transform::test {
 using namespace analysis;
 
-QualifiedName qn(std::string_view s) {
-    return QualifiedName::fromString(s);
-}
-
 TEST(Transformers, GroundTermPropagation) {
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
     // load some test program
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .type D <: symbol
                 .decl p(a:D,b:D)
@@ -64,7 +59,7 @@ TEST(Transformers, GroundTermPropagation) {
     Program& program = tu->getProgram();
 
     // check types in clauses
-    auto* a = program.getClauses(qn("p"))[0];
+    auto* a = program.getClauses("p")[0];
 
     EXPECT_EQ("p(a,b) :- \n   p(x,y),\n   r = [x,y],\n   s = r,\n   s = [w,v],\n   [w,v] = [a,b].",
             toString(*a));
@@ -80,11 +75,10 @@ TEST(Transformers, GroundTermPropagation) {
 }
 
 TEST(Transformers, GroundTermPropagation2) {
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
     // load some test program
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                .type D <: symbol
                .decl p(a:D,b:D)
@@ -96,7 +90,7 @@ TEST(Transformers, GroundTermPropagation2) {
     Program& program = tu->getProgram();
 
     // check types in clauses
-    auto* a = program.getClauses(qn("p"))[0];
+    auto* a = program.getClauses("p")[0];
 
     EXPECT_EQ("p(a,b) :- \n   p(x,y),\n   x = y,\n   x = a,\n   y = b.", toString(*a));
 
@@ -109,10 +103,9 @@ TEST(Transformers, GroundTermPropagation2) {
 
 TEST(Transformers, ResolveGroundedAliases) {
     // load some test program
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    DebugReport debugReport;
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .type D <: symbol
                 .decl p(a:D,b:D)
@@ -124,19 +117,18 @@ TEST(Transformers, ResolveGroundedAliases) {
     Program& program = tu->getProgram();
 
     EXPECT_EQ("p(a,b) :- \n   p(x,y),\n   r = [x,y],\n   s = r,\n   s = [w,v],\n   [w,v] = [a,b].",
-            toString(*program.getClauses(qn("p"))[0]));
+            toString(*program.getClauses("p")[0]));
 
     mk<ResolveAliasesTransformer>()->apply(*tu);
 
-    EXPECT_EQ("p(x,y) :- \n   p(x,y).", toString(*program.getClauses(qn("p"))[0]));
+    EXPECT_EQ("p(x,y) :- \n   p(x,y).", toString(*program.getClauses("p")[0]));
 }
 
 TEST(Transformers, ResolveAliasesWithTermsInAtoms) {
     // load some test program
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    DebugReport debugReport;
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .type D <: symbol
                 .decl p(a:D,b:D)
@@ -148,12 +140,12 @@ TEST(Transformers, ResolveAliasesWithTermsInAtoms) {
     Program& program = tu->getProgram();
 
     EXPECT_EQ("p(x,c) :- \n   p(x,b),\n   p(b,c),\n   c = (b+1),\n   x = (c+2).",
-            toString(*program.getClauses(qn("p"))[0]));
+            toString(*program.getClauses("p")[0]));
 
     mk<ResolveAliasesTransformer>()->apply(*tu);
 
     EXPECT_EQ("p(x,c) :- \n   p(x,b),\n   p(b,c),\n   c = (b+1),\n   x = (c+2).",
-            toString(*program.getClauses(qn("p"))[0]));
+            toString(*program.getClauses("p")[0]));
 }
 
 /**
@@ -171,11 +163,10 @@ TEST(Transformers, ResolveAliasesWithTermsInAtoms) {
  */
 
 TEST(Transformers, RemoveRelationCopies) {
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
     // load some test program
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .type D = number
                 .decl a(a:D,b:D)
@@ -217,11 +208,10 @@ TEST(Transformers, RemoveRelationCopies) {
  *
  */
 TEST(Transformers, RemoveRelationCopiesOutput) {
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
     // load some test program
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .type D = number
                 .decl a(a:D,b:D)
@@ -252,11 +242,10 @@ TEST(Transformers, RemoveRelationCopiesOutput) {
  * Test the equivalence (or lack of equivalence) of clauses using the MinimiseProgramTransfomer.
  */
 TEST(Transformers, CheckClausalEquivalence) {
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .decl A(x:number, y:number)
                 .decl B(x:number)
@@ -278,9 +267,9 @@ TEST(Transformers, CheckClausalEquivalence) {
 
     // Resolve aliases to remove trivial equalities
     mk<ResolveAliasesTransformer>()->apply(*tu);
-    auto aClauses = program.getClauses(qn("A"));
-    auto bClauses = program.getClauses(qn("B"));
-    auto cClauses = program.getClauses(qn("C"));
+    auto aClauses = program.getClauses("A");
+    auto bClauses = program.getClauses("B");
+    auto cClauses = program.getClauses("C");
 
     EXPECT_EQ(3, aClauses.size());
     EXPECT_EQ("A(0,0).", toString(*aClauses[0]));
@@ -320,9 +309,9 @@ TEST(Transformers, CheckClausalEquivalence) {
 
     // Make sure equivalent (and only equivalent) clauses are removed by the minimiser
     mk<MinimiseProgramTransformer>()->apply(*tu);
-    auto&& aMinClauses = program.getClauses(qn("A"));
-    auto&& bMinClauses = program.getClauses(qn("B"));
-    auto&& cMinClauses = program.getClauses(qn("C"));
+    auto&& aMinClauses = program.getClauses("A");
+    auto&& bMinClauses = program.getClauses("B");
+    auto&& cMinClauses = program.getClauses("C");
 
     EXPECT_EQ(2, aMinClauses.size());
     EXPECT_EQ("A(0,0).", toString(*aMinClauses[0]));
@@ -344,11 +333,10 @@ TEST(Transformers, CheckClausalEquivalence) {
  * Test the equivalence (or lack of equivalence) of aggregators using the MinimiseProgramTransfomer.
  */
 TEST(Transformers, CheckAggregatorEquivalence) {
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .decl A,B,C,D(X:number) input
                 // first and second are equivalent
@@ -380,13 +368,13 @@ TEST(Transformers, CheckAggregatorEquivalence) {
 
     // A, B, C, D should still be the relations
     EXPECT_EQ(4, program.getRelations().size());
-    EXPECT_NE(nullptr, program.getRelation(qn("A")));
-    EXPECT_NE(nullptr, program.getRelation(qn("B")));
-    EXPECT_NE(nullptr, program.getRelation(qn("C")));
-    EXPECT_NE(nullptr, program.getRelation(qn("D")));
+    EXPECT_NE(nullptr, program.getRelation("A"));
+    EXPECT_NE(nullptr, program.getRelation("B"));
+    EXPECT_NE(nullptr, program.getRelation("C"));
+    EXPECT_NE(nullptr, program.getRelation("D"));
 
     // D should now only have the two clauses non-equivalent clauses
-    auto&& dClauses = program.getClauses(qn("D"));
+    auto&& dClauses = program.getClauses("D");
     EXPECT_EQ(2, dClauses.size());
     EXPECT_EQ(
             "D(X) :- \n   B(X),\n   X < max Y : { C(Y),B(Y),Y < 2 },\n   A(Z),\n   Z = sum A : { C(A),B(A),A "
@@ -408,11 +396,10 @@ TEST(Transformers, CheckAggregatorEquivalence) {
  *          e.g. a(x) :- a(x), x != 0. is only true if a(x) is already true
  */
 TEST(Transformers, RemoveClauseRedundancies) {
-    Global glb;
     ErrorReport errorReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .decl a,b,c(X:number)
                 a(0).
@@ -435,8 +422,8 @@ TEST(Transformers, RemoveClauseRedundancies) {
     // In particular: Replacing relation `c` with `b` should not create a clause
     // `b(x) :- b(x)` from `c(x) :- b(x)`.
     mk<RemoveRelationCopiesTransformer>()->apply(*tu);
-    EXPECT_EQ(nullptr, program.getRelation(qn("c")));
-    auto&& bIntermediateClauses = program.getClauses(qn("b"));
+    EXPECT_EQ(nullptr, program.getRelation("c"));
+    auto&& bIntermediateClauses = program.getClauses("b");
     EXPECT_EQ(1, bIntermediateClauses.size());
     EXPECT_EQ("b(1).", toString(*bIntermediateClauses[0]));
 
@@ -444,16 +431,16 @@ TEST(Transformers, RemoveClauseRedundancies) {
     mk<MinimiseProgramTransformer>()->apply(*tu);
     EXPECT_EQ(3, program.getRelations().size());
 
-    auto&& aClauses = program.getClauses(qn("a"));
+    auto&& aClauses = program.getClauses("a");
     EXPECT_EQ(2, aClauses.size());
     EXPECT_EQ("a(0).", toString(*aClauses[0]));
     EXPECT_EQ("a(X) :- \n   b(X).", toString(*aClauses[1]));
 
-    auto&& bClauses = program.getClauses(qn("b"));
+    auto&& bClauses = program.getClauses("b");
     EXPECT_EQ(1, bClauses.size());
     EXPECT_EQ("b(1).", toString(*bClauses[0]));
 
-    auto&& qClauses = program.getClauses(qn("q"));
+    auto&& qClauses = program.getClauses("q");
     EXPECT_EQ(1, qClauses.size());
     EXPECT_EQ("q(X) :- \n   a(X).", toString(*qClauses[0]));
 }
@@ -466,11 +453,10 @@ TEST(Transformers, RemoveClauseRedundancies) {
  *      (4) MagicSetTransformer
  */
 TEST(Transformers, MagicSetComprehensive) {
-    Global glb;
     ErrorReport e;
-    DebugReport d(glb);
+    DebugReport d;
 
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 // Stratum 0 - Base Relations
                 .decl BaseOne(X:number) magic
diff --git a/src/ast/tests/ast_utils_test.cpp b/src/ast/tests/ast_utils_test.cpp
index 19deb0f..6839e6b 100644
--- a/src/ast/tests/ast_utils_test.cpp
+++ b/src/ast/tests/ast_utils_test.cpp
@@ -46,13 +46,9 @@ namespace souffle::ast {
 
 namespace test {
 
-QualifiedName qn(std::string_view s) {
-    return QualifiedName::fromString(s);
-}
-
 TEST(AstUtils, Grounded) {
     // create an example clause:
-    auto clause = mk<Clause>(qn("r"));
+    auto clause = mk<Clause>("r");
 
     // something like:
     //   r(X,Y,Z) :- a(X), X = Y, !b(Z).
@@ -64,7 +60,7 @@ TEST(AstUtils, Grounded) {
     head->addArgument(Own<Argument>(new Variable("Z")));
 
     // a(X)
-    auto* a = new Atom(qn("a"));
+    auto* a = new Atom("a");
     a->addArgument(Own<Argument>(new Variable("X")));
     clause->addToBody(Own<Literal>(a));
 
@@ -74,7 +70,7 @@ TEST(AstUtils, Grounded) {
     clause->addToBody(Own<Literal>(e1));
 
     // !b(Z)
-    auto* b = new Atom(qn("b"));
+    auto* b = new Atom("b");
     b->addArgument(Own<Argument>(new Variable("Z")));
     auto* neg = new Negation(Own<Atom>(b));
     clause->addToBody(Own<Literal>(neg));
@@ -82,12 +78,11 @@ TEST(AstUtils, Grounded) {
     // check construction
     EXPECT_EQ("r(X,Y,Z) :- \n   a(X),\n   X = Y,\n   !b(Z).", toString(*clause));
 
-    Global glb;
     auto program = mk<Program>();
     program->addClause(std::move(clause));
-    DebugReport dbgReport(glb);
+    DebugReport dbgReport;
     ErrorReport errReport;
-    TranslationUnit tu{glb, std::move(program), errReport, dbgReport};
+    TranslationUnit tu{std::move(program), errReport, dbgReport};
 
     // obtain groundness
     auto isGrounded = analysis::getGroundedTerms(tu, *tu.getProgram().getClauses()[0]);
@@ -100,10 +95,9 @@ TEST(AstUtils, Grounded) {
 }
 
 TEST(AstUtils, GroundedRecords) {
-    Global glb;
     ErrorReport e;
-    DebugReport d(glb);
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    DebugReport d;
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                  .type N <: symbol
                  .type R = [ a : N, B : N ]
@@ -118,7 +112,7 @@ TEST(AstUtils, GroundedRecords) {
 
     Program& program = tu->getProgram();
 
-    auto* clause = program.getClauses(qn("s"))[0];
+    auto* clause = program.getClauses("s")[0];
 
     // check construction
     EXPECT_EQ("s(x) :- \n   r([x,y]).", toString(*clause));
@@ -138,11 +132,10 @@ TEST(AstUtils, GroundedRecords) {
 }
 
 TEST(AstUtils, ReorderClauseAtoms) {
-    Global glb;
     ErrorReport e;
-    DebugReport d(glb);
+    DebugReport d;
 
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .decl a,b,c,d,e(x:number)
                 a(x) :- b(x), c(x), 1 != 2, d(y), !e(z), c(z), e(x).
@@ -153,8 +146,8 @@ TEST(AstUtils, ReorderClauseAtoms) {
     Program& program = tu->getProgram();
     EXPECT_EQ(5, program.getRelations().size());
 
-    EXPECT_NE(program.getRelation(qn("a")), nullptr);
-    auto&& clauses = program.getClauses(qn("a"));
+    EXPECT_NE(program.getRelation("a"), nullptr);
+    auto&& clauses = program.getClauses("a");
     EXPECT_EQ(1, clauses.size());
 
     auto&& clause = clauses[0];
@@ -175,11 +168,10 @@ TEST(AstUtils, ReorderClauseAtoms) {
 }
 
 TEST(AstUtils, RemoveEquivalentClauses) {
-    Global glb;
     ErrorReport e;
-    DebugReport d(glb);
+    DebugReport d;
 
-    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(glb,
+    Own<TranslationUnit> tu = ParserDriver::parseTranslationUnit(
             R"(
                 .decl a()
                 a(). a(). a(). a(). a(). a(). a(). a(). a(). a(). a(). a(). a(). a(). a().
@@ -189,11 +181,11 @@ TEST(AstUtils, RemoveEquivalentClauses) {
     Program& program = tu->getProgram();
     EXPECT_EQ(1, program.getRelations().size());
 
-    EXPECT_NE(program.getRelation(qn("a")), nullptr);
-    EXPECT_EQ(15, program.getClauses(qn("a")).size());
+    EXPECT_NE(program.getRelation("a"), nullptr);
+    EXPECT_EQ(15, program.getClauses("a").size());
 
-    program.removeRelation(qn("a"));
-    EXPECT_EQ(0, program.getClauses(qn("a")).size());
+    program.removeRelation("a");
+    EXPECT_EQ(0, program.getClauses("a").size());
 }
 
 }  // namespace test
diff --git a/src/ast/tests/type_system_test.cpp b/src/ast/tests/type_system_test.cpp
index c3f49eb..cfeab10 100644
--- a/src/ast/tests/type_system_test.cpp
+++ b/src/ast/tests/type_system_test.cpp
@@ -28,19 +28,15 @@
 namespace souffle::ast::test {
 using namespace analysis;
 
-QualifiedName qn(std::string_view s) {
-    return QualifiedName::fromString(s);
-}
-
 TEST(TypeSystem, Basic) {
     TypeEnvironment env;
 
-    const analysis::Type& A = env.createType<SubsetType>(qn("A"), env.getType(qn("number")));
-    const analysis::Type& B = env.createType<SubsetType>(qn("B"), env.getType(qn("symbol")));
+    const analysis::Type& A = env.createType<SubsetType>("A", env.getType("number"));
+    const analysis::Type& B = env.createType<SubsetType>("B", env.getType("symbol"));
 
-    auto& U = env.createType<UnionType>(qn("U"), toVector(&A, &B));
+    auto& U = env.createType<UnionType>("U", toVector(&A, &B));
 
-    auto& R = env.createType<RecordType>(qn("R"));
+    auto& R = env.createType<RecordType>("R");
     R.setFields(toVector(&A, &B));
 
     EXPECT_EQ("A <: number", toString(A));
@@ -53,12 +49,12 @@ TEST(TypeSystem, Basic) {
 TEST(TypeSystem, isNumberType) {
     TypeEnvironment env;
 
-    const analysis::Type& N = env.getType(qn("number"));
+    const analysis::Type& N = env.getType("number");
 
-    const analysis::Type& A = env.createType<SubsetType>(qn("A"), env.getType(qn("number")));
-    const analysis::Type& B = env.createType<SubsetType>(qn("B"), env.getType(qn("number")));
+    const analysis::Type& A = env.createType<SubsetType>("A", env.getType("number"));
+    const analysis::Type& B = env.createType<SubsetType>("B", env.getType("number"));
 
-    const analysis::Type& C = env.createType<SubsetType>(qn("C"), env.getType(qn("symbol")));
+    const analysis::Type& C = env.createType<SubsetType>("C", env.getType("symbol"));
 
     EXPECT_TRUE(isOfKind(N, TypeAttribute::Signed));
     EXPECT_TRUE(isOfKind(A, TypeAttribute::Signed));
@@ -72,15 +68,15 @@ TEST(TypeSystem, isNumberType) {
 
     // check the union type
     {
-        const analysis::Type& U = env.createType<UnionType>(qn("U"), toVector(&A, &B));
+        const analysis::Type& U = env.createType<UnionType>("U", toVector(&A, &B));
         EXPECT_TRUE(isOfKind(U, TypeAttribute::Signed));
         EXPECT_FALSE(isOfKind(U, TypeAttribute::Symbol));
-        const analysis::Type& U2 = env.createType<UnionType>(qn("U2"), toVector(&A, &B, &C));
+        const analysis::Type& U2 = env.createType<UnionType>("U2", toVector(&A, &B, &C));
         EXPECT_FALSE(isOfKind(U2, TypeAttribute::Signed));
         EXPECT_FALSE(isOfKind(U2, TypeAttribute::Symbol));
     }
     {
-        const analysis::Type& U3 = env.createType<UnionType>(qn("U3"), toVector(&A));
+        const analysis::Type& U3 = env.createType<UnionType>("U3", toVector(&A));
         EXPECT_TRUE(isOfKind(U3, TypeAttribute::Signed));
     }
 }
@@ -94,8 +90,8 @@ TEST(TypeSystem, isSubtypeOf_Basic) {
 
     // start with the two predefined types
 
-    const analysis::Type& N = env.getType(qn("number"));
-    const analysis::Type& S = env.getType(qn("symbol"));
+    const analysis::Type& N = env.getType("number");
+    const analysis::Type& S = env.getType("symbol");
 
     EXPECT_PRED2(isSubtypeOf, N, N);
     EXPECT_PRED2(isSubtypeOf, S, S);
@@ -105,8 +101,8 @@ TEST(TypeSystem, isSubtypeOf_Basic) {
 
     // check primitive type
 
-    const analysis::Type& A = env.createType<SubsetType>(qn("A"), env.getType(qn("number")));
-    const analysis::Type& B = env.createType<SubsetType>(qn("B"), env.getType(qn("number")));
+    const analysis::Type& A = env.createType<SubsetType>("A", env.getType("number"));
+    const analysis::Type& B = env.createType<SubsetType>("B", env.getType("number"));
 
     EXPECT_PRED2(isSubtypeOf, A, A);
     EXPECT_PRED2(isSubtypeOf, B, B);
@@ -122,7 +118,7 @@ TEST(TypeSystem, isSubtypeOf_Basic) {
 
     // check union types
 
-    const analysis::Type& U = env.createType<UnionType>(qn("U"), toVector(&A, &B));
+    const analysis::Type& U = env.createType<UnionType>("U", toVector(&A, &B));
 
     EXPECT_PRED2(isSubtypeOf, U, U);
     EXPECT_PRED2(isSubtypeOf, A, U);
@@ -133,7 +129,7 @@ TEST(TypeSystem, isSubtypeOf_Basic) {
     EXPECT_PRED2(isNotSubtypeOf, U, B);
     EXPECT_PRED2(isNotSubtypeOf, N, U);
 
-    auto& V = env.createType<UnionType>(qn("V"), toVector(&A, &B, &U));
+    auto& V = env.createType<UnionType>("V", toVector(&A, &B, &U));
 
     EXPECT_PRED2(isSubtypeOf, V, U);
     EXPECT_PRED2(isSubtypeOf, U, V);
@@ -142,11 +138,11 @@ TEST(TypeSystem, isSubtypeOf_Basic) {
 TEST(TypeSystem, isSubtypeOf_Records) {
     TypeEnvironment env;
 
-    const analysis::Type& A = env.createType<SubsetType>(qn("A"), env.getType(qn("number")));
-    const analysis::Type& B = env.createType<SubsetType>(qn("B"), env.getType(qn("number")));
+    const analysis::Type& A = env.createType<SubsetType>("A", env.getType("number"));
+    const analysis::Type& B = env.createType<SubsetType>("B", env.getType("number"));
 
-    auto& R1 = env.createType<RecordType>(qn("R1"));
-    auto& R2 = env.createType<RecordType>(qn("R2"));
+    auto& R1 = env.createType<RecordType>("R1");
+    auto& R2 = env.createType<RecordType>("R2");
 
     EXPECT_FALSE(isSubtypeOf(R1, R2));
     EXPECT_FALSE(isSubtypeOf(R2, R1));
@@ -161,11 +157,11 @@ TEST(TypeSystem, isSubtypeOf_Records) {
 TEST(TypeSystem, GreatestCommonSubtype) {
     TypeEnvironment env;
 
-    const analysis::Type& N = env.getType(qn("number"));
+    const analysis::Type& N = env.getType("number");
 
-    const analysis::Type& A = env.createType<SubsetType>(qn("A"), env.getType(qn("number")));
-    const analysis::Type& B = env.createType<SubsetType>(qn("B"), env.getType(qn("number")));
-    const analysis::Type& C = env.createType<SubsetType>(qn("C"), env.getType(qn("symbol")));
+    const analysis::Type& A = env.createType<SubsetType>("A", env.getType("number"));
+    const analysis::Type& B = env.createType<SubsetType>("B", env.getType("number"));
+    const analysis::Type& C = env.createType<SubsetType>("C", env.getType("symbol"));
 
     EXPECT_EQ("{number}", toString(getGreatestCommonSubtypes(N, N)));
 
@@ -190,8 +186,8 @@ TEST(TypeSystem, GreatestCommonSubtype) {
 
     // // bring in unions
 
-    auto& U = env.createType<UnionType>(qn("U"));
-    auto& S = env.createType<UnionType>(qn("S"));
+    auto& U = env.createType<UnionType>("U");
+    auto& S = env.createType<UnionType>("S");
 
     U.setElements(toVector(&A));
     EXPECT_EQ("{S}", toString(getGreatestCommonSubtypes(U, S)));
@@ -208,7 +204,7 @@ TEST(TypeSystem, GreatestCommonSubtype) {
     EXPECT_EQ("{U}", toString(getGreatestCommonSubtypes(U, S, N)));
 
     // bring in a union of unions
-    auto& R = env.createType<UnionType>(qn("R"));
+    auto& R = env.createType<UnionType>("R");
 
     EXPECT_EQ("{R}", toString(getGreatestCommonSubtypes(U, R)));
     EXPECT_EQ("{R}", toString(getGreatestCommonSubtypes(S, R)));
@@ -236,18 +232,18 @@ TEST(TypeSystem, GreatestCommonSubtype) {
 TEST(TypeSystem, complexSubsetTypes) {
     TypeEnvironment env;
 
-    auto& A = env.createType<SubsetType>(qn("A"), env.getType(qn("number")));
-    auto& BfromA = env.createType<SubsetType>(qn("B"), A);
-    auto& CfromA = env.createType<SubsetType>(qn("C"), A);
+    auto& A = env.createType<SubsetType>("A", env.getType("number"));
+    auto& BfromA = env.createType<SubsetType>("B", A);
+    auto& CfromA = env.createType<SubsetType>("C", A);
 
     EXPECT_EQ("{B}", toString(getGreatestCommonSubtypes(A, BfromA)));
     EXPECT_EQ("{C}", toString(getGreatestCommonSubtypes(A, CfromA)));
     EXPECT_EQ("{}", toString(getGreatestCommonSubtypes(A, BfromA, CfromA)));
     EXPECT_EQ("{}", toString(getGreatestCommonSubtypes(BfromA, CfromA)));
 
-    auto* base = &env.createType<SubsetType>(qn("B0"), BfromA);
+    auto* base = &env.createType<SubsetType>("B0", BfromA);
     for (std::size_t i = 1; i <= 10; ++i) {
-        base = &env.createType<SubsetType>(qn("B" + std::to_string(i)), *base);
+        base = &env.createType<SubsetType>("B" + std::to_string(i), *base);
         EXPECT_PRED2(isSubtypeOf, *base, A);
     }
 }
@@ -255,9 +251,9 @@ TEST(TypeSystem, complexSubsetTypes) {
 TEST(TypeSystem, RecordSubsets) {
     TypeEnvironment env;
 
-    auto& R = env.createType<RecordType>(qn("R"));
+    auto& R = env.createType<RecordType>("R");
 
-    auto& A = env.createType<SubsetType>(qn("A"), R);
+    auto& A = env.createType<SubsetType>("A", R);
     EXPECT_PRED2(isSubtypeOf, A, R);
 
     EXPECT_EQ("{A}", toString(getGreatestCommonSubtypes(A, R)));
@@ -266,8 +262,8 @@ TEST(TypeSystem, RecordSubsets) {
 TEST(TypeSystem, EquivTypes) {
     TypeEnvironment env;
 
-    auto& A = env.createType<SubsetType>(qn("A"), env.getType(qn("number")));
-    auto& U = env.createType<UnionType>(qn("U"), toVector(dynamic_cast<const analysis::Type*>(&A)));
+    auto& A = env.createType<SubsetType>("A", env.getType("number"));
+    auto& U = env.createType<UnionType>("U", toVector(dynamic_cast<const analysis::Type*>(&A)));
 
     EXPECT_TRUE(areEquivalentTypes(A, U));
 }
@@ -275,7 +271,7 @@ TEST(TypeSystem, EquivTypes) {
 TEST(TypeSystem, AlgebraicDataType) {
     TypeEnvironment env;
 
-    auto& A = env.createType<AlgebraicDataType>(qn("A"));
+    auto& A = env.createType<AlgebraicDataType>("A");
 
     EXPECT_TRUE(isSubtypeOf(A, A));
     EXPECT_EQ("{A}", toString(getGreatestCommonSubtypes(A, A)));
diff --git a/src/ast/transform/AddNullariesToAtomlessAggregates.cpp b/src/ast/transform/AddNullariesToAtomlessAggregates.cpp
index 62914ca..932a43c 100644
--- a/src/ast/transform/AddNullariesToAtomlessAggregates.cpp
+++ b/src/ast/transform/AddNullariesToAtomlessAggregates.cpp
@@ -32,9 +32,6 @@
 namespace souffle::ast::transform {
 
 bool AddNullariesToAtomlessAggregatesTransformer::transform(TranslationUnit& translationUnit) {
-    // +Tautology()
-    const QualifiedName relName = QualifiedName::fromString("+Tautology");
-
     bool changed{false};
     Program& program = translationUnit.getProgram();
     visit(program, [&](Aggregator& agg) {
@@ -49,6 +46,8 @@ bool AddNullariesToAtomlessAggregatesTransformer::transform(TranslationUnit& tra
         }
         // We will add in the Tautology atom to the body of this aggregate now
         changed = true;
+        // +Tautology()
+        std::string const relName = "+Tautology";
 
         if (program.getRelation(relName) == nullptr) {
             // +Tautology().
diff --git a/src/ast/transform/ComponentChecker.cpp b/src/ast/transform/ComponentChecker.cpp
index 9127b5c..9515c0b 100644
--- a/src/ast/transform/ComponentChecker.cpp
+++ b/src/ast/transform/ComponentChecker.cpp
@@ -50,7 +50,7 @@ bool ComponentChecker::transform(TranslationUnit& translationUnit) {
 const Component* ComponentChecker::checkComponentNameReference(ErrorReport& report,
         const Component* enclosingComponent, const ComponentLookupAnalysis& componentLookup,
         const std::string& name, const SrcLocation& loc, const TypeBinding& binding) {
-    const QualifiedName& forwarded = binding.find(QualifiedName::fromString(name));
+    const QualifiedName& forwarded = binding.find(name);
     if (!forwarded.empty()) {
         // for forwarded types we do not check anything, because we do not know
         // what the actual type will be
@@ -111,8 +111,7 @@ void ComponentChecker::checkComponent(ErrorReport& report, const Component* encl
     // Type parameter for us here is unknown type that will be bound at the template
     // instantiation time.
     auto parentTypeParameters = component.getComponentType()->getTypeParameters();
-    std::vector<QualifiedName> actualParams(
-            parentTypeParameters.size(), QualifiedName::fromString("<type parameter>"));
+    std::vector<QualifiedName> actualParams(parentTypeParameters.size(), "<type parameter>");
     TypeBinding activeBinding = binding.extend(parentTypeParameters, actualParams);
 
     // check parents of component
@@ -192,7 +191,7 @@ void ComponentChecker::checkComponents(
         checkComponent(report, nullptr, componentLookup, *cur, TypeBinding());
     }
 
-    for (ComponentInit* cur : program.getInstantiations()) {
+    for (ComponentInit* cur : program.getComponentInstantiations()) {
         checkComponentInit(report, nullptr, componentLookup, *cur, TypeBinding());
     }
 }
@@ -228,7 +227,7 @@ void ComponentChecker::checkComponentNamespaces(ErrorReport& report, const Progr
         }
     }
 
-    for (const auto& inst : program.getInstantiations()) {
+    for (const auto& inst : program.getComponentInstantiations()) {
         const std::string name = toString(inst->getInstanceName());
         if (names.count(name) != 0u) {
             report.addError("Name clash on instantiation " + name, inst->getSrcLoc());
diff --git a/src/ast/transform/ComponentInstantiation.cpp b/src/ast/transform/ComponentInstantiation.cpp
index 39be1f8..a17f6ea 100644
--- a/src/ast/transform/ComponentInstantiation.cpp
+++ b/src/ast/transform/ComponentInstantiation.cpp
@@ -23,7 +23,6 @@
 #include "ast/ComponentInit.h"
 #include "ast/ComponentType.h"
 #include "ast/Directive.h"
-#include "ast/Lattice.h"
 #include "ast/Node.h"
 #include "ast/Program.h"
 #include "ast/QualifiedName.h"
@@ -59,7 +58,6 @@ static const unsigned int MAX_INSTANTIATION_DEPTH = 100;
  */
 struct ComponentContent {
     VecOwn<ast::Type> types;
-    VecOwn<ast::Lattice> lattices;
     VecOwn<Relation> relations;
     VecOwn<Directive> directives;
     VecOwn<Clause> clauses;
@@ -79,22 +77,6 @@ struct ComponentContent {
         types.push_back(std::move(type));
     }
 
-    void add(Own<ast::Lattice>& lattice, ErrorReport& report) {
-        // add to result content (check existence first)
-        auto foundItem =
-                std::find_if(lattices.begin(), lattices.end(), [&](const Own<ast::Lattice>& element) {
-                    return (element->getQualifiedName() == lattice->getQualifiedName());
-                });
-        if (foundItem != lattices.end()) {
-            Diagnostic err(Diagnostic::Type::ERROR,
-                    DiagnosticMessage("Redefinition of lattice " + toString(lattice->getQualifiedName()),
-                            lattice->getSrcLoc()),
-                    {DiagnosticMessage("Previous definition", (*foundItem)->getSrcLoc())});
-            report.addDiagnostic(err);
-        }
-        lattices.push_back(std::move(lattice));
-    }
-
     void add(Own<Relation>& rel, ErrorReport& report) {
         // add to result content (check existence first)
         auto foundItem = std::find_if(relations.begin(), relations.end(), [&](const Own<Relation>& element) {
@@ -182,11 +164,6 @@ void collectContent(Program& program, const Component& component, const TypeBind
                     res.add(type, report);
                 }
 
-                // process lattices
-                for (auto& lattice : content.lattices) {
-                    res.add(lattice, report);
-                }
-
                 // process relations
                 for (auto& rel : content.relations) {
                     res.add(rel, report);
@@ -279,17 +256,6 @@ void collectContent(Program& program, const Component& component, const TypeBind
         res.add(type, report);
     }
 
-    for (const auto& cur : component.getLattices()) {
-        // create a clone
-        Own<ast::Lattice> lattice(clone(cur));
-
-        auto&& newName = binding.find(lattice->getQualifiedName());
-        if (!newName.empty()) {
-            lattice->setQualifiedName(newName);
-        }
-        res.add(lattice, report);
-    }
-
     // and the local relations
     // (replacing formal parameters with actual parameters)
     for (const auto& cur : component.getRelations()) {
@@ -317,7 +283,7 @@ void collectContent(Program& program, const Component& component, const TypeBind
     }
 
     // index the available relations
-    UnorderedQualifiedNameMap<Relation*> index;
+    std::map<QualifiedName, Relation*> index;
     for (const auto& cur : res.relations) {
         index[cur->getQualifiedName()] = cur.get();
     }
@@ -370,8 +336,6 @@ ComponentContent getInstantiatedContent(Program& program, const ComponentInit& c
 
     if (component == nullptr) {
         // this component is not defined => will trigger a semantic error
-        report.addError("Component " + componentInit.getComponentType()->getName() + " not found",
-                componentInit.getComponentType()->getSrcLoc());
         return res;
     }
 
@@ -391,11 +355,6 @@ ComponentContent getInstantiatedContent(Program& program, const ComponentInit& c
             res.add(type, report);
         }
 
-        // add types
-        for (auto& lattice : nestedContent.lattices) {
-            res.add(lattice, report);
-        }
-
         // add relations
         for (auto& rel : nestedContent.relations) {
             res.add(rel, report);
@@ -417,7 +376,7 @@ ComponentContent getInstantiatedContent(Program& program, const ComponentInit& c
             componentLookup, res, orphans, overridden, report, maxDepth);
 
     // update user-defined type names
-    UnorderedQualifiedNameMap<QualifiedName> typeNameMapping;
+    std::map<QualifiedName, QualifiedName> typeNameMapping;
     for (const auto& cur : res.types) {
         auto newName = componentInit.getInstanceName() + cur->getQualifiedName();
         typeNameMapping[cur->getQualifiedName()] = newName;
@@ -430,13 +389,8 @@ ComponentContent getInstantiatedContent(Program& program, const ComponentInit& c
         });
     }
 
-    for (const auto& cur : res.lattices) {
-        auto newName = componentInit.getInstanceName() + cur->getQualifiedName();
-        cur->setQualifiedName(newName);
-    }
-
     // update relation names
-    UnorderedQualifiedNameMap<QualifiedName> relationNameMapping;
+    std::map<QualifiedName, QualifiedName> relationNameMapping;
     for (const auto& cur : res.relations) {
         auto newName = componentInit.getInstanceName() + cur->getQualifiedName();
         relationNameMapping[cur->getQualifiedName()] = newName;
@@ -461,15 +415,6 @@ ComponentContent getInstantiatedContent(Program& program, const ComponentInit& c
             }
         });
 
-        visit(node, [&](Relation& rel) {
-            if (rel.getIsDeltaDebug()) {
-                auto pos = relationNameMapping.find(rel.getIsDeltaDebug().value());
-                if (pos != relationNameMapping.end()) {
-                    rel.setIsDeltaDebug(pos->second);
-                }
-            }
-        });
-
         // rename directives
         visit(node, [&](Directive& directive) {
             auto pos = relationNameMapping.find(directive.getQualifiedName());
@@ -587,7 +532,7 @@ bool ComponentInstantiationTransformer::transform(TranslationUnit& translationUn
 
     auto& componentLookup = translationUnit.getAnalysis<ComponentLookupAnalysis>();
 
-    for (const auto* cur : program.getInstantiations()) {
+    for (const auto* cur : program.getComponentInstantiations()) {
         VecOwn<Clause> orphans;
         const std::set<std::string> overridden;
 
@@ -598,9 +543,6 @@ bool ComponentInstantiationTransformer::transform(TranslationUnit& translationUn
         for (auto& type : content.types) {
             program.addType(std::move(type));
         }
-        for (auto& lattice : content.lattices) {
-            program.addLattice(std::move(lattice));
-        }
         for (auto& rel : content.relations) {
             program.addRelation(std::move(rel));
         }
diff --git a/src/ast/transform/DebugReporter.cpp b/src/ast/transform/DebugReporter.cpp
index 8153be1..97b1c1f 100644
--- a/src/ast/transform/DebugReporter.cpp
+++ b/src/ast/transform/DebugReporter.cpp
@@ -19,27 +19,24 @@
 #include "ast/TranslationUnit.h"
 #include "ast/utility/Utils.h"
 #include "reports/DebugReport.h"
-#include "souffle/utility/MiscUtil.h"
-
-#include <string>
+#include <chrono>
 
 namespace souffle::ast::transform {
 
 bool DebugReporter::transform(TranslationUnit& translationUnit) {
     translationUnit.getDebugReport().startSection();
     auto datalogSpecOriginal = pprint(translationUnit.getProgram());
-    auto start = now();
+    auto start = std::chrono::high_resolution_clock::now();
     bool changed = applySubtransformer(translationUnit, wrappedTransformer.get());
-    auto end = now();
+    auto end = std::chrono::high_resolution_clock::now();
 
     if (changed) {
         generateDebugReport(translationUnit, datalogSpecOriginal);
     }
 
-    const auto elapsed = duration_in_us(start, end);
+    auto elapsed = std::to_string(std::chrono::duration<double>(end - start).count());
     translationUnit.getDebugReport().endSection(wrappedTransformer->getName(),
-            wrappedTransformer->getName() + " (" + std::to_string(elapsed / 1000000.0) + "s)" +
-                    (changed ? "" : " (unchanged)"));
+            wrappedTransformer->getName() + " (" + elapsed + "s)" + (changed ? "" : " (unchanged)"));
     return changed;
 }
 
diff --git a/src/ast/transform/ExecutionPlanChecker.cpp b/src/ast/transform/ExecutionPlanChecker.cpp
index 255a6c2..b3254a6 100644
--- a/src/ast/transform/ExecutionPlanChecker.cpp
+++ b/src/ast/transform/ExecutionPlanChecker.cpp
@@ -43,21 +43,18 @@ bool ExecutionPlanChecker::transform(TranslationUnit& translationUnit) {
 
     Program& program = translationUnit.getProgram();
     for (const analysis::RelationScheduleAnalysisStep& step : relationSchedule.schedule()) {
-        const RelationSet& scc = step.computed();
+        const std::set<const Relation*>& scc = step.computed();
         for (const Relation* rel : scc) {
             for (auto&& clause : program.getClauses(*rel)) {
                 if (!recursiveClauses.recursive(clause)) {
-                    if (clause->getExecutionPlan() != nullptr) {
-                        auto order = clause->getExecutionPlan()->getOrders().begin()->second;
-                        report.addError(
-                                "Ignored execution plan for non-recursive clause", order->getSrcLoc());
-                    }
                     continue;
                 }
                 if (clause->getExecutionPlan() == nullptr) {
                     continue;
                 }
-
+                if (isA<SubsumptiveClause>(clause)) {
+                    continue;
+                }
                 std::size_t version = 0;
                 for (const auto* atom : getBodyLiterals<Atom>(*clause)) {
                     if (scc.count(program.getRelation(*atom)) != 0u) {
@@ -77,14 +74,8 @@ bool ExecutionPlanChecker::transform(TranslationUnit& translationUnit) {
                         }
                     }
                     auto numAtoms = getBodyLiterals<Atom>(*clause).size();
-                    if (order.size() != numAtoms) {
-                        report.addError("Invalid execution order in plan (expected " +
-                                                std::to_string(numAtoms) + " atoms, not " +
-                                                std::to_string(order.size()) + ")",
-                                cur.second->getSrcLoc());
-                    } else if (!isComplete) {
-                        report.addError(
-                                "Invalid execution order in plan (incomplete)", cur.second->getSrcLoc());
+                    if (order.size() != numAtoms || !isComplete) {
+                        report.addError("Invalid execution order in plan", cur.second->getSrcLoc());
                     }
                 }
 
diff --git a/src/ast/transform/IOAttributes.h b/src/ast/transform/IOAttributes.h
index 79af600..ab3ccf0 100644
--- a/src/ast/transform/IOAttributes.h
+++ b/src/ast/transform/IOAttributes.h
@@ -158,8 +158,8 @@ private:
         return changed;
     }
 
-    const std::string& getRelationName(const Directive* node) {
-        return node->getQualifiedName().toString();
+    std::string getRelationName(const Directive* node) {
+        return toString(join(node->getQualifiedName().getQualifiers(), "."));
     }
 
     /**
diff --git a/src/ast/transform/IODefaults.h b/src/ast/transform/IODefaults.h
index 592631e..5ce2563 100644
--- a/src/ast/transform/IODefaults.h
+++ b/src/ast/transform/IODefaults.h
@@ -68,7 +68,6 @@ private:
     bool setDefaults(TranslationUnit& translationUnit) {
         bool changed = false;
         Program& program = translationUnit.getProgram();
-        const Global& glb = translationUnit.global();
         for (Directive* io : program.getDirectives()) {
             // Don't do anything for a directive which
             // is not an I/O directive
@@ -92,19 +91,19 @@ private:
                     io->addParameter("operation", "input");
                     changed = true;
                     // Configure input directory
-                    if (glb.config().has("fact-dir")) {
-                        io->addParameter("fact-dir", glb.config().get("fact-dir"));
+                    if (Global::config().has("fact-dir")) {
+                        io->addParameter("fact-dir", Global::config().get("fact-dir"));
                     }
                 } else if (io->getType() == ast::DirectiveType::output) {
                     io->addParameter("operation", "output");
                     changed = true;
                     // Configure output directory
-                    if (glb.config().has("output-dir")) {
-                        if (glb.config().has("output-dir", "-")) {
+                    if (Global::config().has("output-dir")) {
+                        if (Global::config().has("output-dir", "-")) {
                             io->addParameter("IO", "stdout");
                             io->addParameter("headers", "true");
                         } else {
-                            io->addParameter("output-dir", glb.config().get("output-dir"));
+                            io->addParameter("output-dir", Global::config().get("output-dir"));
                         }
                     }
                 } else if (io->getType() == ast::DirectiveType::printsize) {
@@ -123,8 +122,8 @@ private:
      *
      * @return Valid relation name from the concatenated qualified name.
      */
-    const std::string& getRelationName(const Directive* node) {
-        return node->getQualifiedName().toString();
+    std::string getRelationName(const Directive* node) {
+        return toString(join(node->getQualifiedName().getQualifiers(), "."));
     }
 };
 
diff --git a/src/ast/transform/InlineRelations.cpp b/src/ast/transform/InlineRelations.cpp
index 15401d7..12eb123 100644
--- a/src/ast/transform/InlineRelations.cpp
+++ b/src/ast/transform/InlineRelations.cpp
@@ -27,7 +27,6 @@
 #include "ast/Constant.h"
 #include "ast/Constraint.h"
 #include "ast/Functor.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/IntrinsicFunctor.h"
 #include "ast/Literal.h"
 #include "ast/Negation.h"
@@ -42,9 +41,7 @@
 #include "ast/UnnamedVariable.h"
 #include "ast/UserDefinedFunctor.h"
 #include "ast/Variable.h"
-#include "ast/analysis/Ground.h"
 #include "ast/analysis/typesystem/PolymorphicObjects.h"
-#include "ast/analysis/typesystem/TypeEnvironment.h"
 #include "ast/utility/Utils.h"
 #include "ast/utility/Visitor.h"
 #include "souffle/BinaryConstraintOps.h"
@@ -153,10 +150,16 @@ bool normaliseInlinedHeads(Program& program) {
 bool nameInlinedUnderscores(Program& program) {
     struct M : public NodeMapper {
         mutable bool changed = false;
-        const UnorderedQualifiedNameSet inlinedRelations;
+        const std::set<QualifiedName> inlinedRelations;
         bool replaceUnderscores;
 
-        M(UnorderedQualifiedNameSet inlinedRelations, bool replaceUnderscores)
+        void clear() {
+            this->changed = false;
+            const_cast<std::set<QualifiedName>&>(this->inlinedRelations).clear();
+            this->replaceUnderscores = false;
+        }
+
+        M(std::set<QualifiedName> inlinedRelations, bool replaceUnderscores)
                 : inlinedRelations(std::move(inlinedRelations)), replaceUnderscores(replaceUnderscores) {}
 
         Own<Node> operator()(Own<Node> node) const override {
@@ -168,9 +171,10 @@ bool nameInlinedUnderscores(Program& program) {
                     if (inlinedRelations.find(atom->getQualifiedName()) != inlinedRelations.end()) {
                         // Atom associated with an inlined relation, so replace the underscores
                         // in all of its subnodes with named variables.
-                        M replace(inlinedRelations, true);
+                        static M replace(inlinedRelations, true);  // TODO: thread safe
                         node->apply(replace);
                         changed |= replace.changed;
+                        replace.clear();
                         return node;
                     }
                 }
@@ -178,7 +182,8 @@ bool nameInlinedUnderscores(Program& program) {
                 // Give a unique name to the underscored variable
                 // TODO (azreika): need a more consistent way of handling internally generated variables in
                 // general
-                std::stringstream newVarName;
+                static std::stringstream newVarName;  // TODO: thread safe
+                newVarName.clear();
                 newVarName << "<underscore_" << underscoreCount++ << ">";
                 changed = true;
                 return mk<ast::Variable>(newVarName.str());
@@ -190,7 +195,7 @@ bool nameInlinedUnderscores(Program& program) {
     };
 
     // Store the names of all relations to be inlined
-    UnorderedQualifiedNameSet inlinedRelations;
+    std::set<QualifiedName> inlinedRelations;
     for (Relation* rel : program.getRelations()) {
         if (rel->hasQualifier(RelationQualifier::INLINE)) {
             inlinedRelations.insert(rel->getQualifiedName());
@@ -565,15 +570,7 @@ NullableVector<Argument*> getInlinedArgument(Program& program, const Argument* a
 
                 // Create a new aggregator per version of the target expression
                 for (Argument* newArg : argumentVersions.getVector()) {
-                    auto* newAggr = [&]() -> Aggregator* {
-                        if (const auto* aggr = as<IntrinsicAggregator>(arg)) {
-                            return new IntrinsicAggregator(aggr->getBaseOperator(), Own<Argument>(newArg));
-                        } else {
-                            // TODO
-                            assert(false && "TODO");
-                            return nullptr;
-                        }
-                    }();
+                    auto* newAggr = new Aggregator(aggr->getBaseOperator(), Own<Argument>(newArg));
                     VecOwn<Literal> newBody;
                     for (Literal* lit : aggr->getBodyLiterals()) {
                         newBody.push_back(clone(lit));
@@ -597,6 +594,8 @@ NullableVector<Argument*> getInlinedArgument(Program& program, const Argument* a
                     // Literal can be inlined!
                     changed = true;
 
+                    AggregateOp op = aggr->getBaseOperator();
+
                     // Create an aggregator (with the same operation) for each possible body
                     std::vector<Aggregator*> aggrVersions;
                     for (std::vector<Literal*> inlineVersions : literalVersions.getVector()) {
@@ -604,15 +603,7 @@ NullableVector<Argument*> getInlinedArgument(Program& program, const Argument* a
                         if (aggr->getTargetExpression() != nullptr) {
                             target = clone(aggr->getTargetExpression());
                         }
-                        auto* newAggr = [&]() -> Aggregator* {
-                            if (const auto* aggr = as<IntrinsicAggregator>(arg)) {
-                                return new IntrinsicAggregator(aggr->getBaseOperator(), std::move(target));
-                            } else {
-                                // TODO
-                                assert(false && "TODO");
-                                return nullptr;
-                            }
-                        }();
+                        auto* newAggr = new Aggregator(aggr->getBaseOperator(), std::move(target));
 
                         VecOwn<Literal> newBody;
                         // Add in everything except the current literal being replaced
@@ -651,12 +642,8 @@ NullableVector<Argument*> getInlinedArgument(Program& program, const Argument* a
                     };
                     // Create the actual overall aggregator that ties the replacement aggregators together.
                     // example: min x : { a(x) }. <=> min ( min x : { a1(x) }, min x : { a2(x) }, ... )
-                    if (const auto* intrinsicAggr = as<IntrinsicAggregator>(aggr)) {
-                        // TODO not complete
-                        AggregateOp op = intrinsicAggr->getBaseOperator();
-                        if (op != AggregateOp::MEAN) {
-                            versions.push_back(combineAggregators(aggrVersions, aggregateToFunctor(op)));
-                        }
+                    if (op != AggregateOp::MEAN) {
+                        versions.push_back(combineAggregators(aggrVersions, aggregateToFunctor(op)));
                     }
                 }
 
@@ -1029,11 +1016,11 @@ std::vector<Clause*> getInlinedClause(Program& program, const Clause& clause) {
     }
 }
 
-ExcludedRelations InlineRelationsTransformer::excluded(Global& glb) {
+ExcludedRelations InlineRelationsTransformer::excluded() {
     ExcludedRelations xs;
     auto addAll = [&](const std::string& name) {
-        for (auto&& r : splitString(glb.config().get(name), ','))
-            xs.insert(QualifiedName::fromString(r));
+        for (auto&& r : splitString(Global::config().get(name), ','))
+            xs.insert(QualifiedName(r));
     };
 
     addAll("inline-exclude");
@@ -1094,7 +1081,7 @@ bool InlineUnmarkExcludedTransform::transform(TranslationUnit& translationUnit)
     bool changed = false;
     Program& program = translationUnit.getProgram();
 
-    auto&& excluded = InlineRelationsTransformer::excluded(translationUnit.global());
+    auto&& excluded = InlineRelationsTransformer::excluded();
 
     for (Relation* rel : program.getRelations()) {
         // no-magic implies no inlining
diff --git a/src/ast/transform/InlineRelations.h b/src/ast/transform/InlineRelations.h
index 77aba18..6c7466e 100644
--- a/src/ast/transform/InlineRelations.h
+++ b/src/ast/transform/InlineRelations.h
@@ -29,8 +29,8 @@ namespace souffle::ast::transform {
  */
 class InlineRelationsTransformer : public Transformer {
 public:
-    using ExcludedRelations = UnorderedQualifiedNameSet;
-    static ExcludedRelations excluded(Global& glb);
+    using ExcludedRelations = std::set<QualifiedName>;
+    static ExcludedRelations excluded();
 
     std::string getName() const override {
         return "InlineRelationsTransformer";
diff --git a/src/ast/transform/MagicSet.cpp b/src/ast/transform/MagicSet.cpp
index c5fa4c2..bad6ba5 100644
--- a/src/ast/transform/MagicSet.cpp
+++ b/src/ast/transform/MagicSet.cpp
@@ -31,7 +31,6 @@
 #include "ast/StringConstant.h"
 #include "ast/TranslationUnit.h"
 #include "ast/UnnamedVariable.h"
-#include "ast/UserDefinedAggregator.h"
 #include "ast/analysis/IOType.h"
 #include "ast/analysis/PrecedenceGraph.h"
 #include "ast/analysis/SCCGraph.h"
@@ -61,10 +60,10 @@ using NegativeLabellingTransformer =
 using PositiveLabellingTransformer =
         MagicSetTransformer::LabelDatabaseTransformer::PositiveLabellingTransformer;
 
-UnorderedQualifiedNameSet MagicSetTransformer::getTriviallyIgnoredRelations(const TranslationUnit& tu) {
+std::set<QualifiedName> MagicSetTransformer::getTriviallyIgnoredRelations(const TranslationUnit& tu) {
     const auto& program = tu.getProgram();
     const auto& ioTypes = tu.getAnalysis<analysis::IOTypeAnalysis>();
-    UnorderedQualifiedNameSet triviallyIgnoredRelations;
+    std::set<QualifiedName> triviallyIgnoredRelations;
 
     // - Any relations known in constant time (IDB relations)
     for (auto* rel : program.getRelations()) {
@@ -87,21 +86,23 @@ UnorderedQualifiedNameSet MagicSetTransformer::getTriviallyIgnoredRelations(cons
     return triviallyIgnoredRelations;
 }
 
-UnorderedQualifiedNameSet MagicSetTransformer::getWeaklyIgnoredRelations(const TranslationUnit& tu) {
+std::set<QualifiedName> MagicSetTransformer::getWeaklyIgnoredRelations(const TranslationUnit& tu) {
     const auto& program = tu.getProgram();
     const auto& precedenceGraph = tu.getAnalysis<analysis::PrecedenceGraphAnalysis>().graph();
     const auto& polyAnalysis = tu.getAnalysis<analysis::PolymorphicObjectsAnalysis>();
-    UnorderedQualifiedNameSet weaklyIgnoredRelations;
+    std::set<QualifiedName> weaklyIgnoredRelations;
 
     // Add magic-transform-exclude relations to the weakly ignored set
-    for (const auto& relStr : splitString(tu.global().config().get("magic-transform-exclude"), ',')) {
-        weaklyIgnoredRelations.insert(QualifiedName::fromString(relStr));
+    for (const auto& relStr : splitString(Global::config().get("magic-transform-exclude"), ',')) {
+        std::vector<std::string> qualifiers = splitString(relStr, '.');
+        weaklyIgnoredRelations.insert(QualifiedName(qualifiers));
     }
 
     // Pick up specified relations from config
-    UnorderedQualifiedNameSet specifiedRelations;
-    for (const auto& relStr : splitString(tu.global().config().get("magic-transform"), ',')) {
-        specifiedRelations.insert(QualifiedName::fromString(relStr));
+    std::set<QualifiedName> specifiedRelations;
+    for (const auto& relStr : splitString(Global::config().get("magic-transform"), ',')) {
+        std::vector<std::string> qualifiers = splitString(relStr, '.');
+        specifiedRelations.insert(QualifiedName(qualifiers));
     }
 
     // Pick up specified relations and ignored relations from relation tags
@@ -114,11 +115,8 @@ UnorderedQualifiedNameSet MagicSetTransformer::getWeaklyIgnoredRelations(const T
     }
 
     // Get the complement if not everything is magic'd
-    UnorderedQualifiedNameSet includedRelations;
-    std::copy_if(specifiedRelations.begin(), specifiedRelations.end(),
-            std::inserter(includedRelations, includedRelations.end()),
-            [&](const QualifiedName& qn) { return weaklyIgnoredRelations.count(qn) == 0; });
-    if (!contains(includedRelations, QualifiedName::fromString("*"))) {
+    std::set<QualifiedName> includedRelations = specifiedRelations - weaklyIgnoredRelations;
+    if (!contains(includedRelations, "*")) {
         for (const Relation* rel : program.getRelations()) {
             if (!contains(specifiedRelations, rel->getQualifiedName())) {
                 weaklyIgnoredRelations.insert(rel->getQualifiedName());
@@ -216,10 +214,10 @@ UnorderedQualifiedNameSet MagicSetTransformer::getWeaklyIgnoredRelations(const T
     return weaklyIgnoredRelations;
 }
 
-UnorderedQualifiedNameSet MagicSetTransformer::getStronglyIgnoredRelations(const TranslationUnit& tu) {
+std::set<QualifiedName> MagicSetTransformer::getStronglyIgnoredRelations(const TranslationUnit& tu) {
     const auto& program = tu.getProgram();
     const auto& precedenceGraph = tu.getAnalysis<analysis::PrecedenceGraphAnalysis>().graph();
-    UnorderedQualifiedNameSet stronglyIgnoredRelations;
+    std::set<QualifiedName> stronglyIgnoredRelations;
 
     // - Any atom appearing at the head of a clause containing a counter
     for (const auto* clause : program.getClauses()) {
@@ -232,7 +230,7 @@ UnorderedQualifiedNameSet MagicSetTransformer::getStronglyIgnoredRelations(const
     while (!fixpointReached) {
         fixpointReached = true;
         // - To prevent poslabelling issues, all dependent strata should also be strongly ignored
-        UnorderedQualifiedNameSet dependentRelations;
+        std::set<QualifiedName> dependentRelations;
         for (const auto& relName : stronglyIgnoredRelations) {
             precedenceGraph.visit(program.getRelation(relName), [&](const auto* dependentRel) {
                 dependentRelations.insert(dependentRel->getQualifiedName());
@@ -246,7 +244,7 @@ UnorderedQualifiedNameSet MagicSetTransformer::getStronglyIgnoredRelations(const
         }
 
         // - Since we can't duplicate the rules, nothing should be labelled in the bodies as well
-        UnorderedQualifiedNameSet bodyRelations;
+        std::set<QualifiedName> bodyRelations;
         for (const auto& relName : stronglyIgnoredRelations) {
             visit(program.getClauses(relName),
                     [&](Atom& atom) { bodyRelations.insert(atom.getQualifiedName()); });
@@ -262,8 +260,8 @@ UnorderedQualifiedNameSet MagicSetTransformer::getStronglyIgnoredRelations(const
     return stronglyIgnoredRelations;
 }
 
-UnorderedQualifiedNameSet MagicSetTransformer::getRelationsToNotLabel(const TranslationUnit& tu) {
-    UnorderedQualifiedNameSet result;
+std::set<QualifiedName> MagicSetTransformer::getRelationsToNotLabel(const TranslationUnit& tu) {
+    std::set<QualifiedName> result;
     for (const auto& name : getTriviallyIgnoredRelations(tu)) {
         result.insert(name);
     }
@@ -275,7 +273,7 @@ UnorderedQualifiedNameSet MagicSetTransformer::getRelationsToNotLabel(const Tran
 
 bool MagicSetTransformer::shouldRun(const TranslationUnit& tu) {
     const Program& program = tu.getProgram();
-    if (tu.global().config().has("magic-transform")) return true;
+    if (Global::config().has("magic-transform")) return true;
     for (const auto* rel : program.getRelations()) {
         if (rel->hasQualifier(RelationQualifier::MAGIC)) return true;
     }
@@ -309,7 +307,7 @@ bool NormaliseDatabaseTransformer::partitionIO(TranslationUnit& translationUnit)
     const auto& ioTypes = translationUnit.getAnalysis<analysis::IOTypeAnalysis>();
 
     // Get all relations that are both input and output
-    UnorderedQualifiedNameSet relationsToSplit;
+    std::set<QualifiedName> relationsToSplit;
     for (auto* rel : program.getRelations()) {
         if (ioTypes.isInput(rel) && (ioTypes.isOutput(rel) || ioTypes.isPrintSize(rel))) {
             relationsToSplit.insert(rel->getQualifiedName());
@@ -385,7 +383,7 @@ bool NormaliseDatabaseTransformer::extractIDB(TranslationUnit& translationUnit)
     };
 
     // Get all input relations that also have IDB rules attached
-    UnorderedQualifiedNameSet inputRelationNames;
+    std::set<QualifiedName> inputRelationNames;
     for (auto* rel : program.getRelations()) {
         if (ioTypes.isInput(rel) && !isStrictlyEDB(rel)) {
             assert(!ioTypes.isOutput(rel) && !ioTypes.isPrintSize(rel) &&
@@ -396,7 +394,7 @@ bool NormaliseDatabaseTransformer::extractIDB(TranslationUnit& translationUnit)
 
     // Add a new intermediate non-input relation for each
     // These will cover relation appearances in IDB rules
-    UnorderedQualifiedNameMap<QualifiedName> inputToIntermediate;
+    std::map<QualifiedName, QualifiedName> inputToIntermediate;
     for (const auto& inputRelationName : inputRelationNames) {
         // Give it a unique name
         QualifiedName intermediateName(inputRelationName);
@@ -461,7 +459,7 @@ bool NormaliseDatabaseTransformer::querifyOutputRelations(TranslationUnit& trans
 
     // Get all output relations that need to be normalised
     const auto& ioTypes = translationUnit.getAnalysis<analysis::IOTypeAnalysis>();
-    UnorderedQualifiedNameSet outputRelationNames;
+    std::set<QualifiedName> outputRelationNames;
     for (auto* rel : program.getRelations()) {
         if ((ioTypes.isOutput(rel) || ioTypes.isPrintSize(rel)) && !isStrictlyOutput(rel)) {
             assert(!ioTypes.isInput(rel) && "output relations should not be input at this stage");
@@ -471,7 +469,7 @@ bool NormaliseDatabaseTransformer::querifyOutputRelations(TranslationUnit& trans
 
     // Add a new intermediate non-output relation for each
     // These will cover relation appearances in intermediate rules
-    UnorderedQualifiedNameMap<QualifiedName> outputToIntermediate;
+    std::map<QualifiedName, QualifiedName> outputToIntermediate;
     for (const auto& outputRelationName : outputRelationNames) {
         // Give it a unique name
         QualifiedName intermediateName(outputRelationName);
@@ -536,20 +534,10 @@ bool NormaliseDatabaseTransformer::normaliseArguments(TranslationUnit& translati
                 append(newBodyLiterals, cloneRange(subConstraints));
 
                 // Update the node to reflect normalised aggregator
-                node = [&]() -> Own<Aggregator> {
-                    if (auto* intrinsicAggr = as<IntrinsicAggregator>(aggr)) {
-                        return mk<IntrinsicAggregator>(intrinsicAggr->getBaseOperator(),
-                                (aggr->getTargetExpression() != nullptr ? clone(aggr->getTargetExpression())
-                                                                        : nullptr),
-                                std::move(newBodyLiterals));
-                    } else {
-                        auto* uda = as<UserDefinedAggregator>(aggr);
-                        return mk<UserDefinedAggregator>(uda->getBaseOperatorName(), clone(uda->getInit()),
-                                (aggr->getTargetExpression() != nullptr ? clone(aggr->getTargetExpression())
-                                                                        : nullptr),
-                                std::move(newBodyLiterals));
-                    }
-                }();
+                node = aggr->getTargetExpression() != nullptr
+                               ? mk<Aggregator>(aggr->getBaseOperator(), clone(aggr->getTargetExpression()),
+                                         std::move(newBodyLiterals))
+                               : mk<Aggregator>(aggr->getBaseOperator(), nullptr, std::move(newBodyLiterals));
             } else {
                 // Otherwise, just normalise children as usual.
                 node->apply(*this);
@@ -793,7 +781,7 @@ bool NegativeLabellingTransformer::transform(TranslationUnit& translationUnit) {
     const auto& sccGraph = translationUnit.getAnalysis<analysis::SCCGraphAnalysis>();
     Program& program = translationUnit.getProgram();
 
-    UnorderedQualifiedNameSet relationsToLabel;
+    std::set<QualifiedName> relationsToLabel;
     VecOwn<Clause> clausesToAdd;
     const auto& relationsToNotLabel = getRelationsToNotLabel(translationUnit);
 
@@ -820,7 +808,7 @@ bool NegativeLabellingTransformer::transform(TranslationUnit& translationUnit) {
     for (std::size_t stratum = 0; stratum < sccGraph.getNumberOfSCCs(); stratum++) {
         // Check which relations to label in this stratum
         const auto& stratumRels = sccGraph.getInternalRelations(stratum);
-        UnorderedQualifiedNameMap<QualifiedName> newSccFriendNames;
+        std::map<QualifiedName, QualifiedName> newSccFriendNames;
         for (const auto* rel : stratumRels) {
             auto relName = rel->getQualifiedName();
             if (contains(relationsToNotLabel, relName)) continue;
@@ -910,7 +898,7 @@ bool PositiveLabellingTransformer::transform(TranslationUnit& translationUnit) {
         for (const auto* rel : sccGraph.getInternalRelations(stratum)) {
             assert(isNegativelyLabelled(rel->getQualifiedName()) &&
                     "should only be looking at neglabelled strata");
-            UnorderedQualifiedNameSet relsToCopy;
+            std::set<QualifiedName> relsToCopy;
 
             // Get the unignored unlabelled relations appearing in the rules
             for (auto&& clause : program.getClauses(*rel)) {
@@ -922,7 +910,7 @@ bool PositiveLabellingTransformer::transform(TranslationUnit& translationUnit) {
                 });
             }
 
-            UnorderedQualifiedNameMap<QualifiedName> labelledNames;
+            std::map<QualifiedName, QualifiedName> labelledNames;
             for (const auto& relName : relsToCopy) {
                 std::size_t relStratum = sccGraph.getSCC(program.getRelation(relName));
                 std::size_t copyCount = originalStrataCopyCount.at(relStratum) + 1;
@@ -944,7 +932,7 @@ bool PositiveLabellingTransformer::transform(TranslationUnit& translationUnit) {
 
                 for (auto&& clause : program.getClauses(*rel)) {
                     // Grab the new names for all unignored unlabelled positive atoms
-                    UnorderedQualifiedNameMap<QualifiedName> labelledNames;
+                    std::map<QualifiedName, QualifiedName> labelledNames;
                     visit(*clause, [&](const Atom& atom) {
                         const auto& relName = atom.getQualifiedName();
                         if (contains(relationsToNotLabel, relName) || isNegativelyLabelled(relName)) return;
diff --git a/src/ast/transform/MagicSet.h b/src/ast/transform/MagicSet.h
index 54a6442..babee2d 100644
--- a/src/ast/transform/MagicSet.h
+++ b/src/ast/transform/MagicSet.h
@@ -30,7 +30,6 @@
 #include <memory>
 #include <set>
 #include <string>
-#include <unordered_set>
 #include <utility>
 #include <vector>
 
@@ -81,26 +80,26 @@ private:
      * Gets the set of relations that are trivially computable,
      * and so should not be magic-set.
      */
-    static UnorderedQualifiedNameSet getTriviallyIgnoredRelations(const TranslationUnit& tu);
+    static std::set<QualifiedName> getTriviallyIgnoredRelations(const TranslationUnit& tu);
 
     /**
      * Gets the set of relations to weakly ignore during the MST process.
      * Weakly-ignored relations cannot be adorned/magic'd.
      * Superset of strongly-ignored relations.
      */
-    static UnorderedQualifiedNameSet getWeaklyIgnoredRelations(const TranslationUnit& tu);
+    static std::set<QualifiedName> getWeaklyIgnoredRelations(const TranslationUnit& tu);
 
     /**
      * Gets the set of relations to strongly ignore during the MST process.
      * Strongly-ignored relations cannot be safely duplicated without affecting semantics.
      */
-    static UnorderedQualifiedNameSet getStronglyIgnoredRelations(const TranslationUnit& tu);
+    static std::set<QualifiedName> getStronglyIgnoredRelations(const TranslationUnit& tu);
 
     /**
      * Gets the set of relations to not label.
      * The union of strongly and trivially ignored.
      */
-    static UnorderedQualifiedNameSet getRelationsToNotLabel(const TranslationUnit& tu);
+    static std::set<QualifiedName> getRelationsToNotLabel(const TranslationUnit& tu);
 };
 
 /**
@@ -241,19 +240,9 @@ private:
 
     using adorned_predicate = std::pair<QualifiedName, std::string>;
 
-    struct AdornedPredicateHash {
-        std::size_t operator()(const adorned_predicate& pred) const {
-            std::size_t seed = qnhasher(pred.first);
-            seed ^= strhasher(pred.second) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
-            return seed;
-        }
-        std::hash<QualifiedName> qnhasher;
-        std::hash<std::string> strhasher;
-    };
-
-    std::unordered_set<adorned_predicate, AdornedPredicateHash> headAdornmentsToDo;
-    UnorderedQualifiedNameSet headAdornmentsSeen;
-    UnorderedQualifiedNameSet weaklyIgnoredRelations;
+    std::set<adorned_predicate> headAdornmentsToDo;
+    std::set<QualifiedName> headAdornmentsSeen;
+    std::set<QualifiedName> weaklyIgnoredRelations;
 
     bool transform(TranslationUnit& translationUnit) override;
 
diff --git a/src/ast/transform/MaterializeAggregationQueries.cpp b/src/ast/transform/MaterializeAggregationQueries.cpp
index 6dba5c5..3c5f7b2 100644
--- a/src/ast/transform/MaterializeAggregationQueries.cpp
+++ b/src/ast/transform/MaterializeAggregationQueries.cpp
@@ -14,13 +14,11 @@
 
 #include "ast/transform/MaterializeAggregationQueries.h"
 #include "AggregateOp.h"
-#include "FunctorOps.h"
 #include "ast/Aggregator.h"
 #include "ast/Argument.h"
 #include "ast/Atom.h"
 #include "ast/Attribute.h"
 #include "ast/Clause.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/Literal.h"
 #include "ast/Node.h"
 #include "ast/Program.h"
@@ -35,7 +33,6 @@
 #include "ast/analysis/typesystem/TypeSystem.h"
 #include "ast/utility/Utils.h"
 #include "ast/utility/Visitor.h"
-#include "ram/IntrinsicOperator.h"
 #include "souffle/TypeAttribute.h"
 #include "souffle/utility/MiscUtil.h"
 #include "souffle/utility/NodeMapper.h"
@@ -139,7 +136,7 @@ void MaterializeAggregationQueriesTransformer::groundInjectedParameters(
     };
 
     auto aggClauseInnerAggregatesMasked = clone(aggClause);
-    aggClauseInnerAggregatesMasked->setHead(mk<Atom>(QualifiedName::fromString("*")));
+    aggClauseInnerAggregatesMasked->setHead(mk<Atom>("*"));
     NegateAggregateAtoms update;
     aggClauseInnerAggregatesMasked->apply(update);
 
@@ -193,7 +190,7 @@ void MaterializeAggregationQueriesTransformer::groundInjectedParameters(
                 continue;
             }
             // 2. Variable must be grounded by this literal.
-            auto singleLiteralClause = mk<Clause>(QualifiedName::fromString("*"));
+            auto singleLiteralClause = mk<Clause>("*");
             singleLiteralClause->addToBody(clone(lit));
             bool variableGroundedByLiteral = false;
             for (const auto& argPair : analysis::getGroundedTerms(translationUnit, *singleLiteralClause)) {
@@ -273,15 +270,8 @@ bool MaterializeAggregationQueriesTransformer::materializeAggregationQueries(
         return true;
     });
 
-    // keep literals alive while we use the type analysis, issue (#1896).
-    VecOwn<Literal> oldBodyLiterals;
-
     for (auto&& cl : program.getClauses()) {
         auto& clause = *cl;
-
-        // the mapping from the Arguments in the original clause to their type(s)
-        std::optional<std::map<const Argument*, analysis::TypeSet>> clauseArgTypes;
-
         visit(clause, [&](Aggregator& agg) {
             if (!needsMaterializedRelation(agg)) {
                 return;
@@ -290,21 +280,13 @@ bool MaterializeAggregationQueriesTransformer::materializeAggregationQueries(
             if (innerAggregates.find(&agg) != innerAggregates.end()) {
                 return;
             }
-
-            // compute types before the clause gets modified
-            if (!clauseArgTypes) {
-                clauseArgTypes = analysis::TypeAnalysis::analyseTypes(translationUnit, clause);
-            }
-
             // begin materialisation process
             auto aggregateBodyRelationName = analysis::findUniqueRelationName(program, "__agg_subclause");
             // quickly copy in all the literals from the aggregate body
-            auto aggClause = mk<Clause>(QualifiedName::fromString(aggregateBodyRelationName));
+            auto aggClause = mk<Clause>(aggregateBodyRelationName);
             aggClause->setBodyLiterals(clone(agg.getBodyLiterals()));
-            if (const auto* intrinsicAgg = as<IntrinsicAggregator>(agg)) {
-                if (intrinsicAgg->getBaseOperator() == AggregateOp::COUNT) {
-                    instantiateUnnamedVariables(*aggClause);
-                }
+            if (agg.getBaseOperator() == AggregateOp::COUNT) {
+                instantiateUnnamedVariables(*aggClause);
             }
             // pull in any necessary grounding atoms
             groundInjectedParameters(translationUnit, *aggClause, clause, agg);
@@ -317,28 +299,17 @@ bool MaterializeAggregationQueriesTransformer::materializeAggregationQueries(
             for (const auto& variableName : headArguments) {
                 aggClauseHead->addArgument(mk<Variable>(variableName));
             }
-
-            // add them to the relation as well
-            auto aggRel = mk<Relation>(QualifiedName::fromString(aggregateBodyRelationName));
+            // add them to the relation as well (need to do a bit of type analysis to make this work)
+            auto aggRel = mk<Relation>(aggregateBodyRelationName);
+            std::map<const Argument*, analysis::TypeSet> argTypes =
+                    analysis::TypeAnalysis::analyseTypes(translationUnit, *aggClause);
 
             for (const auto& cur : aggClauseHead->getArguments()) {
-                // Find type of argument variable in original clause
-                auto it = std::find_if(clauseArgTypes->cbegin(), clauseArgTypes->cend(),
-                        [&](const std::pair<const Argument*, analysis::TypeSet>& pair) -> bool {
-                            if (const Variable* var = as<Variable>(pair.first)) {
-                                // use type from first variable matching the name
-                                return (var->getName() == toString(*cur));
-                            }
-                            return false;
-                        });
-                assert(it != clauseArgTypes->cend() && "unexpected unknown argument");
-
-                if (it != clauseArgTypes->cend()) {
-                    auto const curArgType = it->second;
-                    assert(!curArgType.empty() && "unexpected empty typeset");
-                    assert(curArgType.size() == 1 && "expected fully resolved type");
-                    aggRel->addAttribute(mk<Attribute>(toString(*cur), curArgType.begin()->getName()));
-                }
+                // cur will point us to a particular argument
+                // that is found in the aggClause
+                auto const curArgType = argTypes[cur];
+                assert(!curArgType.empty() && "unexpected empty typeset");
+                aggRel->addAttribute(mk<Attribute>(toString(*cur), curArgType.begin()->getName()));
             }
 
             // Set up the aggregate body atom that will represent the materialised relation we just created
@@ -370,9 +341,7 @@ bool MaterializeAggregationQueriesTransformer::materializeAggregationQueries(
 
             VecOwn<Literal> newBody;
             newBody.push_back(std::move(aggAtom));
-            VecOwn<Literal> oldBody = agg.setBodyLiterals(std::move(newBody));
-            oldBodyLiterals.insert(oldBodyLiterals.end(), std::make_move_iterator(oldBody.begin()),
-                    std::make_move_iterator(oldBody.end()));
+            agg.setBodyLiterals(std::move(newBody));
             // Now we can just add these new things (relation and its single clause) to the program
             program.addClause(std::move(aggClause));
             program.addRelation(std::move(aggRel));
@@ -410,19 +379,6 @@ bool MaterializeAggregationQueriesTransformer::needsMaterializedRelation(const A
         return true;
     }
 
-    // If we have a multi-result intrinsic functor within this aggregate => materialize
-    bool seenMultiresultIntrinsicFunctor = false;
-    visit(agg, [&](const IntrinsicFunctor& intFunc) {
-        auto candidates = functorBuiltIn(intFunc.getBaseFunctionOp());
-        seenMultiresultIntrinsicFunctor |= std::any_of(candidates.cbegin(), candidates.cend(),
-                [](const std::reference_wrapper<const IntrinsicFunctorInfo>& info) -> bool {
-                    return isFunctorMultiResult(info.get().op);
-                });
-    });
-    if (seenMultiresultIntrinsicFunctor) {
-        return true;
-    }
-
     // If the same variable occurs several times => materialize
     bool duplicates = false;
     std::set<std::string> vars;
diff --git a/src/ast/transform/MaterializeSingletonAggregation.cpp b/src/ast/transform/MaterializeSingletonAggregation.cpp
index 0853f5a..28ca724 100644
--- a/src/ast/transform/MaterializeSingletonAggregation.cpp
+++ b/src/ast/transform/MaterializeSingletonAggregation.cpp
@@ -83,8 +83,8 @@ bool MaterializeSingletonAggregationTransformer::transform(TranslationUnit& tran
         // synthesise an aggregate relation
         // __agg_rel_0()
         std::string aggRelName = analysis::findUniqueRelationName(program, "__agg_single");
-        auto aggRel = mk<Relation>(QualifiedName::fromString(aggRelName));
-        auto aggClause = mk<Clause>(QualifiedName::fromString(aggRelName));
+        auto aggRel = mk<Relation>(aggRelName);
+        auto aggClause = mk<Clause>(aggRelName);
         auto* aggHead = aggClause->getHead();
 
         // create a synthesised variable to replace the aggregate term!
diff --git a/src/ast/transform/Meta.cpp b/src/ast/transform/Meta.cpp
index 894e9da..065550a 100644
--- a/src/ast/transform/Meta.cpp
+++ b/src/ast/transform/Meta.cpp
@@ -16,20 +16,20 @@
 
 #include "ast/transform/Meta.h"
 #include "souffle/utility/MiscUtil.h"
+#include <chrono>
 #include <iostream>
 
 namespace souffle::ast::transform {
 
 bool MetaTransformer::applySubtransformer(TranslationUnit& translationUnit, Transformer* transformer) {
-    auto start = now();
+    auto start = std::chrono::high_resolution_clock::now();
     bool changed = transformer->apply(translationUnit);
-    auto end = now();
+    auto end = std::chrono::high_resolution_clock::now();
 
     if (verbose && (!isA<MetaTransformer>(transformer))) {
         std::string changedString = changed ? "changed" : "unchanged";
-        const auto elapsed = duration_in_us(start, end);
-        std::cout << transformer->getName() << " time: " << std::to_string(elapsed / 1000000.0) << "s ["
-                  << changedString << "]" << std::endl;
+        std::cout << transformer->getName() << " time: " << std::chrono::duration<double>(end - start).count()
+                  << "sec [" << changedString << "]" << std::endl;
     }
 
     return changed;
diff --git a/src/ast/transform/MinimiseProgram.cpp b/src/ast/transform/MinimiseProgram.cpp
index 9e8f699..c56c88d 100644
--- a/src/ast/transform/MinimiseProgram.cpp
+++ b/src/ast/transform/MinimiseProgram.cpp
@@ -314,7 +314,7 @@ bool MinimiseProgramTransformer::reduceSingletonRelations(TranslationUnit& trans
     }
 
     // Keep track of canonical relation name for each redundant clause
-    UnorderedQualifiedNameMap<QualifiedName> canonicalName;
+    std::map<QualifiedName, QualifiedName> canonicalName;
 
     // Check pairwise equivalence of each singleton relation
     for (std::size_t i = 0; i < singletonRelationClauses.size(); i++) {
diff --git a/src/ast/transform/PartitionBodyLiterals.cpp b/src/ast/transform/PartitionBodyLiterals.cpp
index 88ecb8e..9eb5411 100644
--- a/src/ast/transform/PartitionBodyLiterals.cpp
+++ b/src/ast/transform/PartitionBodyLiterals.cpp
@@ -13,6 +13,7 @@
  ***********************************************************************/
 
 #include "ast/transform/PartitionBodyLiterals.h"
+#include "GraphUtils.h"
 #include "ast/Atom.h"
 #include "ast/Clause.h"
 #include "ast/Literal.h"
@@ -22,7 +23,6 @@
 #include "ast/TranslationUnit.h"
 #include "ast/Variable.h"
 #include "ast/utility/Visitor.h"
-#include "souffle/datastructure/Graph.h"
 #include "souffle/utility/MiscUtil.h"
 #include <algorithm>
 #include <functional>
@@ -150,7 +150,7 @@ bool PartitionBodyLiteralsTransformer::transform(TranslationUnit& translationUni
             static int disconnectedCount = 0;
             std::stringstream nextName;
             nextName << "+disconnected" << disconnectedCount;
-            QualifiedName newRelationName = QualifiedName::fromString(nextName.str());
+            QualifiedName newRelationName = nextName.str();
             disconnectedCount++;
 
             // Create the extracted relation and clause for the component
diff --git a/src/ast/transform/PragmaChecker.cpp b/src/ast/transform/PragmaChecker.cpp
index a4a1776..efd0610 100644
--- a/src/ast/transform/PragmaChecker.cpp
+++ b/src/ast/transform/PragmaChecker.cpp
@@ -26,8 +26,8 @@
 
 namespace souffle::ast::transform {
 
-PragmaChecker::Merger::Merger(Global& g) : glb(g) {
-    auto& config = glb.config();
+PragmaChecker::Merger::Merger() {
+    auto& config = Global::config();
 
     for (auto&& [k, v] : config.data()) {
         if (config.state(k) == MainConfig::State::set) {
@@ -40,7 +40,7 @@ bool PragmaChecker::Merger::operator()(std::string_view k, std::string_view v) {
     // Command line options take precedence, even if the param allows multiple
     if (contains(locked_keys, k)) return false;
 
-    auto& config = glb.config();
+    auto& config = Global::config();
     if (config.allowsMultiple(k))
         config.append(k, std::string(v));
     else
@@ -50,10 +50,9 @@ bool PragmaChecker::Merger::operator()(std::string_view k, std::string_view v) {
 }
 
 bool PragmaChecker::transform(TranslationUnit& translationUnit) {
-    Merger merger(translationUnit.global());
+    Merger merger;
 
     auto& program = translationUnit.getProgram();
-    auto& glb = translationUnit.global();
     auto& error = translationUnit.getErrorReport();
     bool changed = false;
     std::map<std::string, Pragma const*> previous_pragma;
@@ -63,7 +62,7 @@ bool PragmaChecker::transform(TranslationUnit& translationUnit) {
         auto&& [k, v] = pragma->getkvp();
 
         // warn if subsequent pragmas override one another
-        if (!glb.config().allowsMultiple(k)) {
+        if (!Global::config().allowsMultiple(k)) {
             auto it = previous_pragma.find(k);
             if (it != previous_pragma.end()) {
                 error.addDiagnostic({Diagnostic::Type::WARNING,
diff --git a/src/ast/transform/PragmaChecker.h b/src/ast/transform/PragmaChecker.h
index d975da1..3f6b775 100644
--- a/src/ast/transform/PragmaChecker.h
+++ b/src/ast/transform/PragmaChecker.h
@@ -32,13 +32,10 @@ public:
 
     // This helper is used to implement both `--pragma` cmd ln args and `.pragma` statements.
     struct Merger {
-        Merger(Global&);
+        Merger();
         bool operator()(std::string_view key, std::string_view value);
 
         std::set<std::string, std::less<>> locked_keys;
-
-    private:
-        Global& glb;
     };
 
 private:
diff --git a/src/ast/transform/ReduceExistentials.cpp b/src/ast/transform/ReduceExistentials.cpp
index 02daf99..fe79b1d 100644
--- a/src/ast/transform/ReduceExistentials.cpp
+++ b/src/ast/transform/ReduceExistentials.cpp
@@ -13,6 +13,7 @@
  ***********************************************************************/
 
 #include "ast/transform/ReduceExistentials.h"
+#include "GraphUtils.h"
 #include "RelationTag.h"
 #include "ast/Aggregator.h"
 #include "ast/Argument.h"
@@ -29,7 +30,6 @@
 #include "ast/analysis/IOType.h"
 #include "ast/utility/Utils.h"
 #include "ast/utility/Visitor.h"
-#include "souffle/datastructure/Graph.h"
 #include "souffle/utility/MiscUtil.h"
 #include <functional>
 #include <memory>
@@ -58,8 +58,7 @@ bool ReduceExistentialsTransformer::transform(TranslationUnit& translationUnit)
     // - An edge (a,b) exists iff a uses b "non-existentially" in one of its *recursive* clauses
     // This way, a relation can be transformed into an existential form
     // if and only if all its predecessors can also be transformed.
-    using QNGraph = GraphLabeled<QualifiedName, Unit, UnorderedQualifiedNameLess>;
-    QNGraph relationGraph;
+    Graph<QualifiedName> relationGraph = Graph<QualifiedName>();
 
     // Add in the nodes
     for (Relation* relation : program.getRelations()) {
@@ -67,7 +66,7 @@ bool ReduceExistentialsTransformer::transform(TranslationUnit& translationUnit)
     }
 
     // Keep track of all relations that cannot be transformed
-    UnorderedQualifiedNameSet minimalIrreducibleRelations;
+    std::set<QualifiedName> minimalIrreducibleRelations;
 
     auto& ioType = translationUnit.getAnalysis<analysis::IOTypeAnalysis>();
 
@@ -106,14 +105,14 @@ bool ReduceExistentialsTransformer::transform(TranslationUnit& translationUnit)
     // Run a DFS from each 'bad' source
     // A node is reachable in a DFS from an irreducible node if and only if it is
     // also an irreducible node
-    UnorderedQualifiedNameSet irreducibleRelations;
+    std::set<QualifiedName> irreducibleRelations;
     for (QualifiedName relationName : minimalIrreducibleRelations) {
         relationGraph.visit(
                 relationName, [&](const QualifiedName& subRel) { irreducibleRelations.insert(subRel); });
     }
 
     // All other relations are necessarily existential
-    UnorderedQualifiedNameSet existentialRelations;
+    std::set<QualifiedName> existentialRelations;
     for (Relation* relation : program.getRelations()) {
         if (!program.getClauses(*relation).empty() && relation->getArity() != 0 &&
                 irreducibleRelations.find(relation->getQualifiedName()) == irreducibleRelations.end()) {
@@ -127,9 +126,8 @@ bool ReduceExistentialsTransformer::transform(TranslationUnit& translationUnit)
 
         std::stringstream newRelationName;
         newRelationName << "+?exists_" << relationName;
-        const QualifiedName newRelationQName = QualifiedName::fromString(newRelationName.str());
 
-        auto newRelation = mk<Relation>(newRelationQName, originalRelation->getSrcLoc());
+        auto newRelation = mk<Relation>(newRelationName.str(), originalRelation->getSrcLoc());
 
         // EqRel relations require two arguments, so remove it from the qualifier
         if (newRelation->getRepresentation() == RelationRepresentation::EQREL) {
@@ -139,7 +137,7 @@ bool ReduceExistentialsTransformer::transform(TranslationUnit& translationUnit)
         // Keep all non-recursive clauses
         for (auto&& clause : program.getClauses(*originalRelation)) {
             if (!isRecursiveClause(*clause)) {
-                auto newClause = mk<Clause>(mk<Atom>(newRelationQName), clone(clause->getBodyLiterals()),
+                auto newClause = mk<Clause>(mk<Atom>(newRelationName.str()), clone(clause->getBodyLiterals()),
                         // clone handles nullptr gracefully
                         clone(clause->getExecutionPlan()), clause->getSrcLoc());
                 program.addClause(std::move(newClause));
@@ -152,9 +150,9 @@ bool ReduceExistentialsTransformer::transform(TranslationUnit& translationUnit)
     // Mapper that renames the occurrences of marked relations with their existential
     // counterparts
     struct renameExistentials : public NodeMapper {
-        const UnorderedQualifiedNameSet& relations;
+        const std::set<QualifiedName>& relations;
 
-        renameExistentials(UnorderedQualifiedNameSet& relations) : relations(relations) {}
+        renameExistentials(std::set<QualifiedName>& relations) : relations(relations) {}
 
         Own<Node> operator()(Own<Node> node) const override {
             if (auto* clause = as<Clause>(node)) {
@@ -167,7 +165,7 @@ bool ReduceExistentialsTransformer::transform(TranslationUnit& translationUnit)
                     // Relation is now existential, so rename it
                     std::stringstream newName;
                     newName << "+?exists_" << atom->getQualifiedName();
-                    return mk<Atom>(QualifiedName::fromString(newName.str()));
+                    return mk<Atom>(newName.str());
                 }
             }
             node->apply(*this);
diff --git a/src/ast/transform/RemoveEmptyRelations.cpp b/src/ast/transform/RemoveEmptyRelations.cpp
index e231de5..6b6b985 100644
--- a/src/ast/transform/RemoveEmptyRelations.cpp
+++ b/src/ast/transform/RemoveEmptyRelations.cpp
@@ -37,18 +37,17 @@ bool RemoveEmptyRelationsTransformer::removeEmptyRelations(TranslationUnit& tran
     Program& program = translationUnit.getProgram();
     auto& ioTypes = translationUnit.getAnalysis<analysis::IOTypeAnalysis>();
 
-    UnorderedQualifiedNameSet atoms_in_aggs;
+    std::set<QualifiedName> atoms_in_aggs;
     visitFrontier(program, [&](Aggregator& agg) {
         visit(agg, [&](Atom& atom) { atoms_in_aggs.insert(atom.getQualifiedName()); });
         return true;
     });
 
-    UnorderedQualifiedNameSet emptyRelations;
+    std::set<QualifiedName> emptyRelations;
     bool changed = false;
     for (auto rel : program.getRelations()) {
         if (ioTypes.isInput(rel)) continue;
         if (!program.getClauses(*rel).empty()) continue;
-        if (rel->getIsDeltaDebug()) continue;
 
         emptyRelations.insert(rel->getQualifiedName());
 
diff --git a/src/ast/transform/RemoveRedundantSums.cpp b/src/ast/transform/RemoveRedundantSums.cpp
index 29cdecb..e6205dd 100644
--- a/src/ast/transform/RemoveRedundantSums.cpp
+++ b/src/ast/transform/RemoveRedundantSums.cpp
@@ -14,8 +14,8 @@
 
 #include "ast/transform/RemoveRedundantSums.h"
 #include "AggregateOp.h"
+#include "ast/Aggregator.h"
 #include "ast/Argument.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/IntrinsicFunctor.h"
 #include "ast/Literal.h"
 #include "ast/Node.h"
@@ -37,12 +37,12 @@ bool RemoveRedundantSumsTransformer::transform(TranslationUnit& translationUnit)
         Own<Node> operator()(Own<Node> node) const override {
             // Apply to all aggregates of the form
             // sum k : { .. } where k is a constant
-            if (auto* agg = as<IntrinsicAggregator>(node)) {
+            if (auto* agg = as<Aggregator>(node)) {
                 if (agg->getBaseOperator() == AggregateOp::SUM) {
                     if (const auto* constant = as<NumericConstant>(agg->getTargetExpression())) {
                         changed = true;
                         // Then construct the new thing to replace it with
-                        auto count = mk<IntrinsicAggregator>(AggregateOp::COUNT);
+                        auto count = mk<Aggregator>(AggregateOp::COUNT);
                         // Duplicate the body of the aggregate
                         VecOwn<Literal> newBody;
                         for (const auto& lit : agg->getBodyLiterals()) {
diff --git a/src/ast/transform/RemoveRelationCopies.cpp b/src/ast/transform/RemoveRelationCopies.cpp
index cba325b..715a987 100644
--- a/src/ast/transform/RemoveRelationCopies.cpp
+++ b/src/ast/transform/RemoveRelationCopies.cpp
@@ -36,7 +36,7 @@
 namespace souffle::ast::transform {
 
 bool RemoveRelationCopiesTransformer::removeRelationCopies(TranslationUnit& translationUnit) {
-    using alias_map = UnorderedQualifiedNameMap<QualifiedName>;
+    using alias_map = std::map<QualifiedName, QualifiedName>;
 
     // collect aliases
     alias_map isDirectAliasOf;
@@ -107,12 +107,12 @@ bool RemoveRelationCopiesTransformer::removeRelationCopies(TranslationUnit& tran
     alias_map isAliasOf;
 
     // track any copy cycles; cyclic rules are effectively empty
-    UnorderedQualifiedNameSet cycle_reps;
+    std::set<QualifiedName> cycle_reps;
 
     for (std::pair<QualifiedName, QualifiedName> cur : isDirectAliasOf) {
         // compute replacement
 
-        UnorderedQualifiedNameSet visited;
+        std::set<QualifiedName> visited;
         visited.insert(cur.first);
         visited.insert(cur.second);
 
diff --git a/src/ast/transform/ResolveAliases.cpp b/src/ast/transform/ResolveAliases.cpp
index c205070..427d21b 100644
--- a/src/ast/transform/ResolveAliases.cpp
+++ b/src/ast/transform/ResolveAliases.cpp
@@ -34,7 +34,6 @@
 #include "souffle/BinaryConstraintOps.h"
 #include "souffle/utility/FunctionalUtil.h"
 #include "souffle/utility/MiscUtil.h"
-#include "souffle/utility/NodeMapper.h"
 #include "souffle/utility/StreamUtil.h"
 #include "souffle/utility/StringUtil.h"
 #include <algorithm>
@@ -201,27 +200,6 @@ public:
     }
 };
 
-bool nameUnnamedInit(Clause& clause) {
-    int varid = 0;
-    bool changed = false;
-
-    auto namer = nodeMapper<ast::Node>([&](auto&& self, Own<Node> node) -> Own<ast::Node> {
-        if (const auto* unnamed = as<ast::UnnamedVariable>(node)) {
-            changed = true;
-            varid += 1;
-            return mk<ast::Variable>("_<unnamed_" + std::to_string(varid) + ">", unnamed->getSrcLoc());
-        } else {
-            node->apply(self);
-            return node;
-        }
-    });
-
-    visit(clause, [&](RecordInit& rec) { rec.apply(namer); });
-    visit(clause, [&](BranchInit& adt) { adt.apply(namer); });
-
-    return changed;
-}
-
 }  // namespace
 
 Own<Clause> ResolveAliasesTransformer::resolveAliases(const Clause& clause) {
@@ -520,7 +498,7 @@ bool ResolveAliasesTransformer::transform(TranslationUnit& translationUnit) {
     Program& program = translationUnit.getProgram();
 
     // get all clauses
-    std::vector<Clause*> clauses;
+    std::vector<const Clause*> clauses;
     visit(program, [&](const Relation& rel) {
         const auto& qualifiers = rel.getQualifiers();
         // Don't resolve clauses of inlined relations
@@ -532,12 +510,7 @@ bool ResolveAliasesTransformer::transform(TranslationUnit& translationUnit) {
     });
 
     // clean all clauses
-    for (Clause* clause : clauses) {
-        // -- Step 0 --
-        // Name unnamed variables in record and branch inits (souffle-lang/souffle#2482)
-        // This is fine as long as this transformer runs after the semantics checker
-        changed |= nameUnnamedInit(*clause);
-
+    for (const Clause* clause : clauses) {
         // -- Step 1 --
         // get rid of aliases
         Own<Clause> noAlias = resolveAliases(*clause);
diff --git a/src/ast/transform/SemanticChecker.cpp b/src/ast/transform/SemanticChecker.cpp
index f3f7540..91f7fa5 100644
--- a/src/ast/transform/SemanticChecker.cpp
+++ b/src/ast/transform/SemanticChecker.cpp
@@ -35,10 +35,7 @@
 #include "ast/ExecutionOrder.h"
 #include "ast/ExecutionPlan.h"
 #include "ast/Functor.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/IntrinsicFunctor.h"
-#include "ast/IterationCounter.h"
-#include "ast/Lattice.h"
 #include "ast/Literal.h"
 #include "ast/Negation.h"
 #include "ast/NilConstant.h"
@@ -112,11 +109,11 @@ private:
     const Program& program = tu.getProgram();
     ErrorReport& report = tu.getErrorReport();
 
-    void checkAtom(const Clause& parent, const Atom& atom);
-    void checkLiteral(const Clause& parent, const Literal& literal);
-    void checkAggregator(const Clause& parent, const Aggregator& aggregator);
+    void checkAtom(const Atom& atom);
+    void checkLiteral(const Literal& literal);
+    void checkAggregator(const Aggregator& aggregator);
     bool isDependent(const Clause& agg1, const Clause& agg2);
-    void checkArgument(const Clause& parent, const Argument& arg);
+    void checkArgument(const Argument& arg);
     void checkConstant(const Argument& argument);
     void checkFact(const Clause& fact);
     void checkClause(const Clause& clause);
@@ -125,7 +122,6 @@ private:
     void checkRelationFunctionalDependencies(const Relation& relation);
     void checkRelation(const Relation& relation);
     void checkType(ast::Attribute const& attr, std::string const& name = {});
-    void checkLatticeDeclaration(const Lattice& lattice);
     void checkFunctorDeclaration(const FunctorDeclaration& decl);
 
     void checkNamespaces();
@@ -141,9 +137,9 @@ bool SemanticChecker::transform(TranslationUnit& translationUnit) {
 
 SemanticCheckerImpl::SemanticCheckerImpl(TranslationUnit& tu) : tu(tu) {
     // suppress warnings for given relations
-    if (tu.global().config().has("suppress-warnings")) {
+    if (Global::config().has("suppress-warnings")) {
         std::vector<std::string> suppressedRelations =
-                splitString(tu.global().config().get("suppress-warnings"), ',');
+                splitString(Global::config().get("suppress-warnings"), ',');
 
         if (std::find(suppressedRelations.begin(), suppressedRelations.end(), "*") !=
                 suppressedRelations.end()) {
@@ -154,9 +150,13 @@ SemanticCheckerImpl::SemanticCheckerImpl(TranslationUnit& tu) : tu(tu) {
         } else {
             // mute only the given relations (if they exist)
             for (auto& relname : suppressedRelations) {
-                if (!relname.empty()) {
+                const std::vector<std::string> comps = splitString(relname, '.');
+                if (!comps.empty()) {
                     // generate the relation identifier
-                    QualifiedName relid = QualifiedName::fromString(relname);
+                    QualifiedName relid(comps[0]);
+                    for (std::size_t i = 1; i < comps.size(); i++) {
+                        relid.append(comps[i]);
+                    }
 
                     // update suppressed qualifier if the relation is found
                     if (Relation* rel = program.getRelation(relid)) {
@@ -171,9 +171,6 @@ SemanticCheckerImpl::SemanticCheckerImpl(TranslationUnit& tu) : tu(tu) {
     for (auto* rel : program.getRelations()) {
         checkRelation(*rel);
     }
-    for (auto* lattice : program.getLattices()) {
-        checkLatticeDeclaration(*lattice);
-    }
     for (auto* clause : program.getClauses()) {
         checkClause(*clause);
     }
@@ -208,19 +205,19 @@ SemanticCheckerImpl::SemanticCheckerImpl(TranslationUnit& tu) : tu(tu) {
 
     // - stratification --
     // check for cyclic dependencies
-    for (const Relation* cur : program.getRelations()) {
+    for (Relation* cur : program.getRelations()) {
         std::size_t scc = sccGraph.getSCC(cur);
         if (sccGraph.isRecursive(scc)) {
-            const RelationSet& relSet = sccGraph.getInternalRelations(scc);
-            for (const Relation* cyclicRelation : relSet) {
+            for (const Relation* cyclicRelation : sccGraph.getInternalRelations(scc)) {
                 // Negations and aggregations need to be stratified
                 const Literal* foundLiteral = nullptr;
                 bool hasNegation = hasClauseWithNegatedRelation(cyclicRelation, cur, &program, foundLiteral);
-                bool hasAggregate =
-                        hasClauseWithAggregatedRelation(cyclicRelation, cur, &program, foundLiteral);
-                if (hasNegation || hasAggregate) {
+                if (hasNegation ||
+                        hasClauseWithAggregatedRelation(cyclicRelation, cur, &program, foundLiteral)) {
+                    auto const& relSet = sccGraph.getInternalRelations(scc);
+                    std::set<const Relation*, NameComparison> sortedRelSet(relSet.begin(), relSet.end());
                     // Negations and aggregations need to be stratified
-                    std::string relationsListStr = toString(join(relSet, ",",
+                    std::string relationsListStr = toString(join(sortedRelSet, ",",
                             [](std::ostream& out, const Relation* r) { out << r->getQualifiedName(); }));
                     std::vector<DiagnosticMessage> messages;
                     messages.push_back(DiagnosticMessage(
@@ -238,22 +235,22 @@ SemanticCheckerImpl::SemanticCheckerImpl(TranslationUnit& tu) : tu(tu) {
     }
 }
 
-void SemanticCheckerImpl::checkAtom(const Clause& parent, const Atom& atom) {
+void SemanticCheckerImpl::checkAtom(const Atom& atom) {
     // check existence of relation
     auto* r = program.getRelation(atom);
     if (r == nullptr) {
         report.addError("Undefined relation " + toString(atom.getQualifiedName()), atom.getSrcLoc());
         return;
     }
-    std::size_t arity = r->getArity();
-    if (arity != atom.getArity()) {
+
+    if (r->getArity() != atom.getArity()) {
         report.addError("Mismatching arity of relation " + toString(atom.getQualifiedName()) + " (expected " +
-                                toString(arity) + ", got " + toString(atom.getArity()) + ")",
+                                toString(r->getArity()) + ", got " + toString(atom.getArity()) + ")",
                 atom.getSrcLoc());
     }
 
     for (const Argument* arg : atom.getArguments()) {
-        checkArgument(parent, *arg);
+        checkArgument(*arg);
     }
 }
 
@@ -280,19 +277,19 @@ std::set<const UnnamedVariable*> getUnnamedVariables(const Node& node) {
 
 }  // namespace
 
-void SemanticCheckerImpl::checkLiteral(const Clause& parent, const Literal& literal) {
+void SemanticCheckerImpl::checkLiteral(const Literal& literal) {
     // check potential nested atom
     if (const auto* atom = as<Atom>(literal)) {
-        checkAtom(parent, *atom);
+        checkAtom(*atom);
     }
 
     if (const auto* neg = as<Negation>(literal)) {
-        checkAtom(parent, *neg->getAtom());
+        checkAtom(*neg->getAtom());
     }
 
     if (const auto* constraint = as<BinaryConstraint>(literal)) {
-        checkArgument(parent, *constraint->getLHS());
-        checkArgument(parent, *constraint->getRHS());
+        checkArgument(*constraint->getLHS());
+        checkArgument(*constraint->getRHS());
 
         std::set<const UnnamedVariable*> unnamedInRecord;
         visit(*constraint, [&](const RecordInit& record) {
@@ -302,13 +299,6 @@ void SemanticCheckerImpl::checkLiteral(const Clause& parent, const Literal& lite
                 }
             }
         });
-        visit(*constraint, [&](const BranchInit& init) {
-            for (auto* arg : init.getArguments()) {
-                if (auto* unnamed = as<UnnamedVariable>(arg)) {
-                    unnamedInRecord.insert(unnamed);
-                }
-            }
-        });
 
         // Don't worry about underscores if either side is an aggregate (because of witness exporting)
         if (isA<Aggregator>(*constraint->getLHS()) || isA<Aggregator>(*constraint->getRHS())) {
@@ -349,12 +339,12 @@ bool SemanticCheckerImpl::isDependent(const Clause& agg1, const Clause& agg2) {
     return dependent;
 }
 
-void SemanticCheckerImpl::checkAggregator(const Clause& parent, const Aggregator& aggregator) {
+void SemanticCheckerImpl::checkAggregator(const Aggregator& aggregator) {
     auto& report = tu.getErrorReport();
-    const QualifiedName dummyQN = QualifiedName::fromString("dummy");
-    Clause dummyClauseAggregator(dummyQN);
+    const Program& program = tu.getProgram();
+    Clause dummyClauseAggregator("dummy");
 
-    visit(parent, [&](const Literal& parentLiteral) {
+    visit(program, [&](const Literal& parentLiteral) {
         visit(parentLiteral, [&](const Aggregator& candidateAggregate) {
             if (candidateAggregate != aggregator) {
                 return;
@@ -365,10 +355,10 @@ void SemanticCheckerImpl::checkAggregator(const Clause& parent, const Aggregator
         });
     });
 
-    visit(parent, [&](const Literal& parentLiteral) {
+    visit(program, [&](const Literal& parentLiteral) {
         visit(parentLiteral, [&](const Aggregator& /* otherAggregate */) {
             // Create the other aggregate's dummy clause
-            Clause dummyClauseOther(dummyQN);
+            Clause dummyClauseOther("dummy");
             dummyClauseOther.addToBody(clone(parentLiteral));
             // Check dependency between the aggregator and this one
             if (isDependent(dummyClauseAggregator, dummyClauseOther) &&
@@ -379,16 +369,16 @@ void SemanticCheckerImpl::checkAggregator(const Clause& parent, const Aggregator
     });
 
     for (Literal* literal : aggregator.getBodyLiterals()) {
-        checkLiteral(parent, *literal);
+        checkLiteral(*literal);
     }
 }
 
-void SemanticCheckerImpl::checkArgument(const Clause& parent, const Argument& arg) {
+void SemanticCheckerImpl::checkArgument(const Argument& arg) {
     if (const auto* agg = as<Aggregator>(arg)) {
-        checkAggregator(parent, *agg);
+        checkAggregator(*agg);
     } else if (const auto* func = as<Functor>(arg)) {
         for (auto arg : func->getArguments()) {
-            checkArgument(parent, *arg);
+            checkArgument(*arg);
         }
 
         if (auto const* udFunc = as<UserDefinedFunctor const>(func)) {
@@ -417,8 +407,6 @@ bool isConstantArgument(const Argument* arg) {
         // if all argument of functor are constant, then
         // assume functor returned value is constant.
         return all_of(udf->getArguments(), isConstantArgument);
-    } else if (isA<IterationCounter>(arg)) {
-        return false;
     } else if (isA<Counter>(arg)) {
         return false;
     } else if (auto* typeCast = as<ast::TypeCast>(arg)) {
@@ -459,7 +447,7 @@ void SemanticCheckerImpl::checkFact(const Clause& fact) {
 
 void SemanticCheckerImpl::checkClause(const Clause& clause) {
     // check head atom
-    checkAtom(clause, *clause.getHead());
+    checkAtom(*clause.getHead());
 
     // Check for absence of underscores in head
     for (auto* unnamed : getUnnamedVariables(*clause.getHead())) {
@@ -468,7 +456,7 @@ void SemanticCheckerImpl::checkClause(const Clause& clause) {
 
     // check body literals
     for (Literal* lit : clause.getBodyLiterals()) {
-        checkLiteral(clause, *lit);
+        checkLiteral(*lit);
     }
 
     // check facts
@@ -503,8 +491,7 @@ void SemanticCheckerImpl::checkClause(const Clause& clause) {
         if (varName[0] == '_') {
             assert(varName.size() > 1 && "named variable should not be a single underscore");
             if (numAppearances > 1) {
-                report.addWarning(WarnType::VarAppearsOnce,
-                        "Variable " + varName + " marked as singleton but occurs more than once",
+                report.addWarning("Variable " + varName + " marked as singleton but occurs more than once",
                         varLocation);
             }
         }
@@ -519,113 +506,43 @@ void SemanticCheckerImpl::checkClause(const Clause& clause) {
 }
 
 void SemanticCheckerImpl::checkComplexRule(const std::set<const Clause*>& multiRule) {
-    // variable v occurs only once if:
-    // - it occurs at most once in each clause body of the (possibly) multi-clause rule.
-    // - and it never occurs in any clause head of the (possibly) multi-clause rule.
-    //
-    // note that ungrounded variables are already detected by another check so
-    // we don't report them here (ungrounded variables warning, argument in
-    // fact is not constant warning).
-
-    /// variables that occurs in some clause head, these variables are not
-    /// candidate to "occurs only once" warning.
-    std::set<std::string> varOccursInSomeHead;
-
-    /// variables that occurs more than once in some clause body, these
-    /// variables are not candidate to "occurs only once" warning.
-    std::set<std::string> varOccursMoreThanOnceInSomeBody;
-
-    /// variables that never occur in clause head, and at most once in
-    /// each clause body, these variables "occurs only once".
-    std::set<std::string> varOccursAtMostOnce;
-
-    struct VarsCounter : public Visitor<void> {
-        // map from variable name to the occurrence count
-        std::map<std::string, int> occurrences;
-
-        void visit_(type_identity<ast::Variable>, const ast::Variable& var) override {
-            const auto& name = var.getName();
-            if (name[0] == '_') {
-                // do not count variables starting with underscore
-                return;
-            }
-            auto it = occurrences.find(name);
-            if (it == occurrences.end()) {
-                occurrences[name] = 1;
-            } else {
-                it->second += 1;
+    std::map<std::string, int> var_count;
+    std::map<std::string, const ast::Variable*> var_pos;
+
+    auto count_var = [&](const ast::Variable& var) {
+        const auto& varName = var.getName();
+        if (0 == var_count[varName]++) {
+            var_pos[varName] = &var;
+        } else {
+            const auto& PrevLoc = var_pos[varName]->getSrcLoc();
+            const auto& Loc = var.getSrcLoc();
+            if (PrevLoc < Loc) {
+                var_pos[varName] = &var;
             }
         }
     };
 
-    {  // find variables that occurs in some clause head
-        VarsCounter vc;
-        for (const Clause* cl : multiRule) {
-            // count occurrences in clause head
-            visit(cl->getHead(), vc);
-        }
-        for (const auto& entry : vc.occurrences) {
-            varOccursInSomeHead.emplace(entry.first);
-        }
+    // Count the variable occurrence for the body of a
+    // complex rule only once.
+    // TODO (b-scholz): for negation / disjunction this is not quite
+    // right; we would need more semantic information here.
+    for (auto literal : (*multiRule.begin())->getBodyLiterals()) {
+        visit(*literal, count_var);
     }
 
-    for (const Clause* cl : multiRule) {
-        // TODO (b-scholz): for negation / disjunction this is not quite
-        // right; we would need more semantic information here.
-        VarsCounter vc;
-        for (auto lit : cl->getBodyLiterals()) {
-            visit(*lit, vc);
-        }
-
-        for (const auto& entry : vc.occurrences) {
-            const std::string name = entry.first;
-            if (varOccursInSomeHead.count(name) > 0) {
-                // variable occurs in some head => not a candidate for
-                // "variable occurs only once"
-                continue;
-            }
-
-            const int occurences = entry.second;
-            if (occurences == 1 && varOccursMoreThanOnceInSomeBody.count(name) == 0) {
-                varOccursAtMostOnce.emplace(name);
-            } else {
-                // variable occurs more than once in some body => not a
-                // candidate for "variable occurs only once"
-                varOccursMoreThanOnceInSomeBody.emplace(name);
-                varOccursAtMostOnce.erase(name);
-            }
-        }
+    // Count variable occurrence for each head separately
+    for (auto clause : multiRule) {
+        visit(*(clause->getHead()), count_var);
     }
 
-    /// Find the least source location of a variable.
-    struct VarFinder : public Visitor<void> {
-        const std::string& name;
-        bool seen = false;
-        SrcLocation leastLoc = {};
-
-        explicit VarFinder(const std::string& varName) : name(varName) {}
-
-        void visit_(type_identity<ast::Variable>, const ast::Variable& var) override {
-            if (var.getName() == name) {
-                if (!seen) {
-                    leastLoc = var.getSrcLoc();
-                    seen = true;
-                } else if (var.getSrcLoc() < leastLoc) {
-                    leastLoc = var.getSrcLoc();
-                }
-            }
-        }
-    };
-
-    for (const auto& name : varOccursAtMostOnce) {
-        VarFinder vf(name);
-        // find the least source location of the variable to give a warning location
-        for (const Clause* cl : multiRule) {
-            for (auto lit : cl->getBodyLiterals()) {
-                visit(*lit, vf);
-            }
+    // Check that a variables occurs more than once
+    for (const auto& cur : var_count) {
+        int numAppearances = cur.second;
+        const auto& varName = cur.first;
+        const auto& varLocation = var_pos[varName]->getSrcLoc();
+        if (varName[0] != '_' && numAppearances == 1) {
+            report.addWarning("Variable " + varName + " only occurs once", varLocation);
         }
-        report.addWarning(WarnType::VarAppearsOnce, "Variable " + name + " only occurs once", vf.leastLoc);
     }
 }
 
@@ -660,43 +577,11 @@ void SemanticCheckerImpl::checkFunctorDeclaration(const FunctorDeclaration& decl
     }
 }
 
-void SemanticCheckerImpl::checkLatticeDeclaration(const Lattice& lattice) {
-    const auto& name = lattice.getQualifiedName();
-    auto* existingType = getIf(
-            program.getTypes(), [&](const ast::Type* type) { return type->getQualifiedName() == name; });
-    if (!existingType) {
-        report.addError(tfm::format("Undefined type %s", name), lattice.getSrcLoc());
-    }
-    if (lattice.hasLub()) {
-        if (!isA<UserDefinedFunctor>(lattice.getLub())) {
-            report.addError(
-                    tfm::format("Lattice operator Lub must be a user-defined functor"), lattice.getSrcLoc());
-        }
-    } else {
-        report.addError(tfm::format("Lattice %s<> does not define Lub", name), lattice.getSrcLoc());
-    }
-    if (lattice.hasGlb()) {
-        if (!isA<UserDefinedFunctor>(lattice.getGlb())) {
-            report.addError(
-                    tfm::format("Lattice operator Glb must be a user-defined functor"), lattice.getSrcLoc());
-        }
-    } else {
-        report.addWarning(WarnType::LatticeMissingOperator,
-                tfm::format("Lattice %s<> does not define Glb", name), lattice.getSrcLoc());
-    }
-    if (!lattice.hasBottom()) {
-        report.addWarning(WarnType::LatticeMissingOperator,
-                tfm::format("Lattice %s<> does not define Bottom", name), lattice.getSrcLoc());
-    }
-}
-
 void SemanticCheckerImpl::checkRelationDeclaration(const Relation& relation) {
     const auto& attributes = relation.getAttributes();
-    const std::size_t arity = relation.getArity();
-    std::size_t firstAuxiliary = arity - relation.getAuxiliaryArity();
+    assert(attributes.size() == relation.getArity() && "mismatching attribute size and arity");
 
-    assert(attributes.size() == arity && "mismatching attribute size and arity");
-    for (std::size_t i = 0; i < arity; i++) {
+    for (std::size_t i = 0; i < relation.getArity(); i++) {
         Attribute* attr = attributes[i];
         checkType(*attr);
 
@@ -706,25 +591,6 @@ void SemanticCheckerImpl::checkRelationDeclaration(const Relation& relation) {
                 report.addError(tfm::format("Doubly defined attribute name %s", *attr), attr->getSrcLoc());
             }
         }
-
-        /* check that lattice elements are always the last */
-        if (i < firstAuxiliary && attr->getIsLattice()) {
-            report.addError(
-                    tfm::format(
-                            "Lattice attribute %s should be placed after all non-lattice attributes", *attr),
-                    attr->getSrcLoc());
-        }
-
-        /* check that lattice attributes have a correct lattice definition */
-        if (attr->getIsLattice()) {
-            const auto& typeName = attr->getTypeName();
-            auto* existingType = getIf(program.getLattices(),
-                    [&](const ast::Lattice* lattice) { return lattice->getQualifiedName() == typeName; });
-            if (!existingType) {
-                report.addError(
-                        tfm::format("Missing lattice definition for type %s", typeName), attr->getSrcLoc());
-            }
-        }
     }
 }
 
@@ -770,8 +636,7 @@ void SemanticCheckerImpl::checkRelation(const Relation& relation) {
         return sClause.getHead()->getQualifiedName() == relation.getQualifiedName();
     });
     if (relation.getRepresentation() == RelationRepresentation::BTREE_DELETE && !hasSubsumptiveRule) {
-        report.addWarning(WarnType::NoSubsumptiveRule,
-                "No subsumptive rule for relation " + toString(relation.getQualifiedName()),
+        report.addWarning("No subsumptive rule for relation " + toString(relation.getQualifiedName()),
                 relation.getSrcLoc());
     } else if (relation.getRepresentation() != RelationRepresentation::BTREE_DELETE && hasSubsumptiveRule) {
         report.addError("Relation \"" + toString(relation.getQualifiedName()) +
@@ -781,21 +646,7 @@ void SemanticCheckerImpl::checkRelation(const Relation& relation) {
     }
     if (relation.getRepresentation() == RelationRepresentation::BTREE_DELETE && relation.getArity() == 0) {
         report.addError("Subsumptive relation \"" + toString(relation.getQualifiedName()) +
-                                "\" must not be a nullary relation",
-                relation.getSrcLoc());
-    }
-
-    if (hasSubsumptiveRule && relation.getAuxiliaryArity()) {
-        report.addError("Relation \"" + toString(relation.getQualifiedName()) +
-                                "\" must not have both subsumptive rules and lattice arguments",
-                relation.getSrcLoc());
-    }
-
-    if (relation.getAuxiliaryArity() &&
-            (relation.getRepresentation() != RelationRepresentation::BTREE &&
-                    relation.getRepresentation() != RelationRepresentation::DEFAULT)) {
-        report.addError(
-                "Relation \"" + toString(relation.getQualifiedName()) + "\" must have a btree representation",
+                                "\"  must not be a nullary relation",
                 relation.getSrcLoc());
     }
 
@@ -807,28 +658,10 @@ void SemanticCheckerImpl::checkRelation(const Relation& relation) {
 
     // check whether this relation is empty
     if (program.getClauses(relation).empty() && !ioTypes.isInput(&relation) &&
-            !relation.getIsDeltaDebug().has_value() &&
             !relation.hasQualifier(RelationQualifier::SUPPRESSED)) {
-        report.addWarning(WarnType::NoRulesNorFacts,
-                "No rules/facts defined for relation " + toString(relation.getQualifiedName()),
+        report.addWarning("No rules/facts defined for relation " + toString(relation.getQualifiedName()),
                 relation.getSrcLoc());
     }
-
-    // if the relation is a delta_debug, make sure if has no clause
-    if (relation.getIsDeltaDebug().has_value()) {
-        if (!program.getClauses(relation).empty() || ioTypes.isInput(&relation)) {
-            report.addError("Unexpected rules/facts for delta_debug relation " +
-                                    toString(relation.getQualifiedName()),
-                    relation.getSrcLoc());
-        }
-        const auto orig = relation.getIsDeltaDebug().value();
-        if (!program.getRelation(orig)) {
-            report.addError("Could not find relation " + toString(orig) +
-                                    " referred to by the delta_debug relation " +
-                                    toString(relation.getQualifiedName()),
-                    relation.getSrcLoc());
-        }
-    }
 }
 
 void SemanticCheckerImpl::checkIO() {
@@ -855,14 +688,14 @@ void SemanticCheckerImpl::checkIO() {
  *
  **/
 static const std::vector<SrcLocation> usesInvalidWitness(
-        TranslationUnit& tu, const Clause& clause, const IntrinsicAggregator& aggregate) {
+        TranslationUnit& tu, const Clause& clause, const Aggregator& aggregate) {
     std::vector<SrcLocation> invalidWitnessLocations;
 
     if (aggregate.getBaseOperator() == AggregateOp::MIN || aggregate.getBaseOperator() == AggregateOp::MAX) {
         return invalidWitnessLocations;  // ie empty result
     }
 
-    auto aggregateSubclause = mk<Clause>(QualifiedName::fromString("*"));
+    auto aggregateSubclause = mk<Clause>("*");
     aggregateSubclause->setBodyLiterals(clone(aggregate.getBodyLiterals()));
 
     struct InnerAggregateMasker : public NodeMapper {
@@ -902,7 +735,7 @@ void SemanticCheckerImpl::checkWitnessProblem() {
     // an aggregate where it doesn't make sense to use it, i.e.
     // count, sum, mean
     visit(program, [&](const Clause& clause) {
-        visit(clause, [&](const IntrinsicAggregator& agg) {
+        visit(clause, [&](const Aggregator& agg) {
             for (auto&& invalidArgument : usesInvalidWitness(tu, clause, agg)) {
                 report.addError(
                         "Witness problem: argument grounded by an aggregator's inner scope is used "
@@ -953,7 +786,7 @@ std::vector<QualifiedName> findInlineCycle(const PrecedenceGraphAnalysis& preced
     }
 
     // Check neighbours
-    const RelationSet& successors = orderedRelationSet(precedenceGraph.graph().successors(current));
+    const RelationSet& successors = precedenceGraph.graph().successors(current);
     for (const Relation* successor : successors) {
         // Only care about inlined neighbours in the graph
         if (successor->hasQualifier(RelationQualifier::INLINE)) {
diff --git a/src/ast/transform/SimplifyAggregateTargetExpression.cpp b/src/ast/transform/SimplifyAggregateTargetExpression.cpp
index 10a6209..269a031 100644
--- a/src/ast/transform/SimplifyAggregateTargetExpression.cpp
+++ b/src/ast/transform/SimplifyAggregateTargetExpression.cpp
@@ -81,13 +81,7 @@ Aggregator* SimplifyAggregateTargetExpressionTransformer::simplifyTargetExpressi
     });
 
     // Create the new simplified aggregator
-    if (auto* intrinsicAgg = as<IntrinsicAggregator>(aggregator)) {
-        return new IntrinsicAggregator(
-                intrinsicAgg->getBaseOperator(), std::move(newTargetExpression), std::move(newBody));
-    } else {
-        assert(false && "todo");
-        return nullptr;
-    }
+    return new Aggregator(aggregator.getBaseOperator(), std::move(newTargetExpression), std::move(newBody));
 }
 
 bool SimplifyAggregateTargetExpressionTransformer::transform(TranslationUnit& translationUnit) {
diff --git a/src/ast/transform/TypeChecker.cpp b/src/ast/transform/TypeChecker.cpp
index a85ce33..30b3cbf 100644
--- a/src/ast/transform/TypeChecker.cpp
+++ b/src/ast/transform/TypeChecker.cpp
@@ -34,7 +34,6 @@
 #include "ast/analysis/typesystem/PolymorphicObjects.h"
 #include "ast/analysis/typesystem/SumTypeBranches.h"
 #include "ast/analysis/typesystem/Type.h"
-#include "ast/analysis/typesystem/TypeConstraints.h"
 #include "ast/analysis/typesystem/TypeEnvironment.h"
 #include "ast/analysis/typesystem/TypeSystem.h"
 #include "ast/utility/Utils.h"
@@ -125,7 +124,7 @@ private:
     /* Type checks */
     /** Check if declared types of the relation match deduced types. */
     void visit_(type_identity<Atom>, const Atom& atom) override;
-    void visit_(type_identity<souffle::ast::Variable>, const souffle::ast::Variable& var) override;
+    void visit_(type_identity<Variable>, const Variable& var) override;
     void visit_(type_identity<StringConstant>, const StringConstant& constant) override;
     void visit_(type_identity<NumericConstant>, const NumericConstant& constant) override;
     void visit_(type_identity<NilConstant>, const NilConstant& constant) override;
@@ -135,8 +134,7 @@ private:
     void visit_(type_identity<IntrinsicFunctor>, const IntrinsicFunctor& fun) override;
     void visit_(type_identity<UserDefinedFunctor>, const UserDefinedFunctor& fun) override;
     void visit_(type_identity<BinaryConstraint>, const BinaryConstraint& constraint) override;
-    void visit_(type_identity<IntrinsicAggregator>, const IntrinsicAggregator& aggregator) override;
-    void visit_(type_identity<UserDefinedAggregator>, const UserDefinedAggregator& aggregator) override;
+    void visit_(type_identity<Aggregator>, const Aggregator& aggregator) override;
 };  // namespace souffle::ast::transform
 
 void TypeChecker::verify(TranslationUnit& tu) {
@@ -153,7 +151,7 @@ void TypeChecker::verify(TranslationUnit& tu) {
 
 void TypeDeclarationChecker::checkUnionType(const ast::UnionType& type) {
     // check presence of all the element types and that all element types are based off a primitive
-    for (const QualifiedName& sub : orderedQualifiedNameSet(type.getTypes())) {
+    for (const QualifiedName& sub : type.getTypes()) {
         if (typeEnv.isPrimitiveType(sub)) {
             continue;
         }
@@ -186,8 +184,7 @@ void TypeDeclarationChecker::checkUnionType(const ast::UnionType& type) {
 
         const auto& name = type->getQualifiedName();
 
-        const auto predefinedTypesInUnion =
-                orderedQualifiedNameSet(typeEnvAnalysis.getPrimitiveTypesInUnion(name));
+        const auto& predefinedTypesInUnion = typeEnvAnalysis.getPrimitiveTypesInUnion(name);
 
         // Report error (if size == 0, then the union is cyclic)
         if (predefinedTypesInUnion.size() > 1) {
@@ -305,7 +302,7 @@ void TypeDeclarationChecker::run() {
     }
 
     // Check if all the branch names are unique in sum types.
-    UnorderedQualifiedNameMap<std::vector<SrcLocation>> branchToLocation;
+    std::map<QualifiedName, std::vector<SrcLocation>> branchToLocation;
     visit(program.getTypes(), [&](const ast::AlgebraicDataType& type) {
         for (auto* branch : type.getBranches()) {
             branchToLocation[branch->getBranchName()].push_back(branch->getSrcLoc());
@@ -369,7 +366,7 @@ void TypeCheckerImpl::visit_(type_identity<Atom>, const Atom& atom) {
                 return isA<analysis::RecordType>(type) && !isA<analysis::SubsetType>(type);
             });
 
-            if (!validAttribute && !tu.global().config().has("legacy")) {
+            if (!validAttribute && !Global::config().has("legacy")) {
                 auto primaryDiagnostic =
                         DiagnosticMessage("Atom's argument type is not a subtype of its declared type",
                                 arguments[i]->getSrcLoc());
@@ -385,12 +382,10 @@ void TypeCheckerImpl::visit_(type_identity<Atom>, const Atom& atom) {
             // Declared attribute and deduced type agree if:
             // They are the same type, or
             // They are derived from the same constant type.
-            // They are equivalent types.
             bool validAttribute = all_of(argTypes, [&](const analysis::Type& type) {
-                return type == attributeType || areEquivalentTypes(type, attributeType) ||
-                       any_of(typeEnv.getConstantTypes(), [&](auto& constantType) {
-                           return isSubtypeOf(attributeType, constantType) && isSubtypeOf(type, constantType);
-                       });
+                return type == attributeType || any_of(typeEnv.getConstantTypes(), [&](auto& constantType) {
+                    return isSubtypeOf(attributeType, constantType) && isSubtypeOf(type, constantType);
+                });
             });
 
             if (!validAttribute) {
@@ -407,14 +402,9 @@ void TypeCheckerImpl::visit_(type_identity<Atom>, const Atom& atom) {
     }
 }
 
-void TypeCheckerImpl::visit_(type_identity<souffle::ast::Variable>, const ast::Variable& var) {
+void TypeCheckerImpl::visit_(type_identity<Variable>, const ast::Variable& var) {
     if (typeAnalysis.getTypes(&var).empty()) {
-        if (typeAnalysis.errorAnalyzer) {
-            typeAnalysis.errorAnalyzer->explain(
-                    report, &var, "Unable to deduce type for variable " + var.getName());
-        } else {
-            report.addError("Unable to deduce type for variable " + var.getName(), var.getSrcLoc());
-        }
+        report.addError("Unable to deduce type for variable " + var.getName(), var.getSrcLoc());
     }
 }
 
@@ -675,7 +665,7 @@ void TypeCheckerImpl::visit_(type_identity<BinaryConstraint>, const BinaryConstr
     }
 }
 
-void TypeCheckerImpl::visit_(type_identity<IntrinsicAggregator>, const IntrinsicAggregator& aggregator) {
+void TypeCheckerImpl::visit_(type_identity<Aggregator>, const Aggregator& aggregator) {
     auto op = polyAnalysis.getOverloadedOperator(aggregator);
 
     auto aggregatorType = typeAnalysis.getTypes(&aggregator);
@@ -688,11 +678,6 @@ void TypeCheckerImpl::visit_(type_identity<IntrinsicAggregator>, const Intrinsic
     }
 }
 
-void TypeCheckerImpl::visit_(type_identity<UserDefinedAggregator>, const UserDefinedAggregator& aggregator) {
-    // TODO
-    /*const TypeSet& resultTypes =*/typeAnalysis.getTypes(&aggregator);
-}
-
 void TypeCheckerImpl::visit_(type_identity<Negation>, const Negation& neg) {
     negatedAtoms.insert(neg.getAtom());
 }
diff --git a/src/ast/utility/BindingStore.cpp b/src/ast/utility/BindingStore.cpp
index 478a0d4..af49e0d 100644
--- a/src/ast/utility/BindingStore.cpp
+++ b/src/ast/utility/BindingStore.cpp
@@ -165,4 +165,5 @@ std::size_t BindingStore::numBoundArguments(const Atom* atom) const {
     }
     return count;
 }
+
 }  // namespace souffle::ast
diff --git a/src/ast/utility/SipsMetric.cpp b/src/ast/utility/SipsMetric.cpp
new file mode 100644
index 0000000..5f98a04
--- /dev/null
+++ b/src/ast/utility/SipsMetric.cpp
@@ -0,0 +1,797 @@
+/*
+ * Souffle - A Datalog Compiler
+ * Copyright (c) 2020, The Souffle Developers. All rights reserved
+ * Licensed under the Universal Permissive License v 1.0 as shown at:
+ * - https://opensource.org/licenses/UPL
+ * - <souffle root>/licenses/SOUFFLE-UPL.txt
+ */
+
+/************************************************************************
+ *
+ * @file SipsMetric.cpp
+ *
+ * Defines the SipsMetric class, which specifies cost functions for atom orderings in a clause.
+ *
+ ***********************************************************************/
+
+#include "ast/utility/SipsMetric.h"
+#include "Global.h"
+#include "ast/Clause.h"
+#include "ast/TranslationUnit.h"
+#include "ast/Variable.h"
+#include "ast/analysis/IOType.h"
+#include "ast/analysis/ProfileUse.h"
+#include "ast/analysis/SCCGraph.h"
+#include "ast/analysis/typesystem/PolymorphicObjects.h"
+#include "ast/utility/BindingStore.h"
+#include "ast/utility/Utils.h"
+#include "ast/utility/Visitor.h"
+#include "ast2ram/utility/Utils.h"
+#include "ram/Expression.h"
+#include "ram/FloatConstant.h"
+#include "ram/SignedConstant.h"
+#include "ram/StringConstant.h"
+#include "ram/UnsignedConstant.h"
+#include <cmath>
+#include <limits>
+#include <numeric>
+#include <unordered_set>
+#include <vector>
+
+namespace souffle::ast {
+
+SipsMetric::SipsMetric(const TranslationUnit& tu) : program(tu.getProgram()) {
+    sccGraph = &tu.getAnalysis<ast::analysis::SCCGraphAnalysis>();
+}
+
+std::vector<std::size_t> StaticSipsMetric::getReordering(
+        const Clause* clause, std::size_t version, ast2ram::TranslationMode mode) const {
+    std::size_t relStratum = sccGraph->getSCC(program.getRelation(*clause));
+    auto sccRelations = sccGraph->getInternalRelations(relStratum);
+
+    auto sccAtoms = filter(ast::getBodyLiterals<ast::Atom>(*clause),
+            [&](auto* atom) { return contains(sccRelations, program.getRelation(*atom)); });
+
+    BindingStore bindingStore(clause);
+    auto atoms = getBodyLiterals<Atom>(*clause);
+    std::vector<std::size_t> newOrder(atoms.size());
+
+    std::size_t numAdded = 0;
+    while (numAdded < atoms.size()) {
+        // grab the index of the next atom, based on the SIPS function
+        const auto& costs = evaluateCosts(clause, sccAtoms, atoms, bindingStore, version, mode);
+        assert(atoms.size() == costs.size() && "each atom should have exactly one cost");
+        std::size_t minIdx = static_cast<std::size_t>(
+                std::distance(costs.begin(), std::min_element(costs.begin(), costs.end())));
+        const auto* nextAtom = atoms[minIdx];
+        assert(nextAtom != nullptr && "nullptr atoms should have maximal cost");
+
+        // set all arguments that are variables as bound
+        for (const auto* arg : nextAtom->getArguments()) {
+            if (const auto* var = as<Variable>(arg)) {
+                bindingStore.bindVariableStrongly(var->getName());
+            }
+        }
+
+        newOrder[numAdded] = minIdx;  // add to the ordering
+        atoms[minIdx] = nullptr;      // mark as done
+        numAdded++;                   // move on
+    }
+
+    return newOrder;
+}
+
+SelingerProfileSipsMetric::SelingerProfileSipsMetric(const TranslationUnit& tu) : SipsMetric(tu) {
+    profileUseAnalysis = &tu.getAnalysis<ast::analysis::ProfileUseAnalysis>();
+    polyAnalysis = &tu.getAnalysis<ast::analysis::PolymorphicObjectsAnalysis>();
+}
+
+std::vector<std::size_t> SelingerProfileSipsMetric::getReordering(
+        const Clause* clause, std::size_t version, ast2ram::TranslationMode mode) const {
+    auto atoms = ast::getBodyLiterals<ast::Atom>(*clause);
+
+    // remember to exit for single atom bodies
+    if (atoms.size() <= 1) {
+        std::vector<std::size_t> res;
+        res.resize(atoms.size());
+        std::iota(res.begin(), res.end(), 0);
+        return res;
+    }
+
+    auto constraints = ast::getBodyLiterals<ast::BinaryConstraint>(*clause);
+    std::size_t relStratum = sccGraph->getSCC(program.getRelation(*clause));
+    auto sccRelations = sccGraph->getInternalRelations(relStratum);
+    auto sccAtoms = filter(ast::getBodyLiterals<ast::Atom>(*clause),
+            [&](auto* atom) { return contains(sccRelations, program.getRelation(*atom)); });
+
+    assert(profileUseAnalysis->hasAutoSchedulerStats() && "Must have stats in order to auto-schedule!");
+
+    auto* prof = profileUseAnalysis;
+    auto getRelationSize = [&prof](bool isRecursive, const ast::QualifiedName& rel,
+                                   const std::vector<std::size_t>& joinColumns,
+                                   const std::map<std::size_t, std::string>& constantsMap,
+                                   const std::string& iteration) {
+        std::set<std::size_t> joinKeys(joinColumns.begin(), joinColumns.end());
+        for (auto& [k, _] : constantsMap) {
+            joinKeys.insert(k);
+        }
+
+        if (joinKeys.empty() && !isRecursive) {
+            return prof->getRelationSize(rel);
+        }
+
+        std::stringstream ss;
+        ss << joinKeys;
+        std::string attributes = ss.str();
+        attributes[0] = '[';
+        attributes[attributes.size() - 1] = ']';
+
+        std::stringstream cc;
+        cc << constantsMap;
+        std::string constants = cc.str();
+        constants[0] = '[';
+        constants[constants.size() - 1] = ']';
+
+        if (isRecursive) {
+            return prof->getRecursiveUniqueKeys(rel.toString(), attributes, constants, iteration);
+        }
+
+        return prof->getNonRecursiveUniqueKeys(rel.toString(), attributes, constants);
+    };
+
+    using AtomIdx = std::size_t;
+    using AtomSet = std::set<std::size_t>;
+
+    AtomSet recursiveInCurrentStratum;
+
+    for (auto* a : sccAtoms) {
+        for (AtomIdx i = 0; i < atoms.size(); ++i) {
+            if (*atoms[i] == *a) {
+                recursiveInCurrentStratum.insert(i);
+            }
+        }
+    }
+
+    using VarName = std::string;
+    using VarSet = std::set<VarName>;
+    using ArgIdx = std::size_t;
+
+    // map variable name to constants if possible
+    std::unordered_map<VarName, ast::Constant*> varToConstant;
+
+    // map variables to necessary variables on other side of the equality
+    // i.e. x = y + z we should map x -> { y, z }
+    std::unordered_map<VarName, VarSet> varToOtherVars;
+
+    // map variable name to the lower and upper bounds of the inequality
+    // i.e. EA < Addr < EA + Size we should map Addr -> { { EA }, { EA, Size } }
+    std::unordered_map<VarName, std::pair<VarSet, VarSet>> ineqToUpperLower;
+
+    for (auto* constraint : constraints) {
+        auto* lhs = constraint->getLHS();
+        auto* rhs = constraint->getRHS();
+
+        if (isIneqConstraint(constraint->getBaseOperator())) {
+            if (auto* var = as<ast::Variable>(lhs)) {
+                VarSet otherVars;
+                visit(rhs, [&](const ast::Variable& v) { otherVars.insert(v.getName()); });
+                if (isLessThan(constraint->getBaseOperator()) || isLessEqual(constraint->getBaseOperator())) {
+                    ineqToUpperLower[var->getName()].second = otherVars;
+                }
+                if (isGreaterThan(constraint->getBaseOperator()) ||
+                        isGreaterEqual(constraint->getBaseOperator())) {
+                    ineqToUpperLower[var->getName()].first = otherVars;
+                }
+            }
+
+            if (auto* var = as<ast::Variable>(rhs)) {
+                VarSet otherVars;
+                visit(lhs, [&](const ast::Variable& v) { otherVars.insert(v.getName()); });
+                if (isLessThan(constraint->getBaseOperator()) || isLessEqual(constraint->getBaseOperator())) {
+                    ineqToUpperLower[var->getName()].first = otherVars;
+                }
+                if (isGreaterThan(constraint->getBaseOperator()) ||
+                        isGreaterEqual(constraint->getBaseOperator())) {
+                    ineqToUpperLower[var->getName()].second = otherVars;
+                }
+            }
+        }
+
+        // only consider = constraint
+        if (!isEqConstraint(constraint->getBaseOperator())) {
+            continue;
+        }
+
+        if (isA<ast::Variable>(lhs) && isA<ast::Constant>(rhs)) {
+            varToConstant[as<ast::Variable>(lhs)->getName()] = as<ast::Constant>(rhs);
+            continue;
+        }
+
+        if (isA<ast::Constant>(lhs) && isA<ast::Variable>(rhs)) {
+            varToConstant[as<ast::Variable>(rhs)->getName()] = as<ast::Constant>(lhs);
+            continue;
+        }
+
+        if (auto* var = as<ast::Variable>(lhs)) {
+            VarSet otherVars;
+            visit(rhs, [&](const ast::Variable& v) { otherVars.insert(v.getName()); });
+            varToOtherVars[var->getName()] = otherVars;
+            continue;
+        }
+
+        if (auto* var = as<ast::Variable>(rhs)) {
+            VarSet otherVars;
+            visit(lhs, [&](const ast::Variable& v) { otherVars.insert(v.getName()); });
+            varToOtherVars[var->getName()] = otherVars;
+            continue;
+        }
+    }
+
+    // check for bounded inequality i.e. EA < EA2 < EA + Size
+    for (auto& p : ineqToUpperLower) {
+        // consider this like an equality
+        auto& [lower, upper] = p.second;
+        if (!lower.empty() && !upper.empty() &&
+                std::includes(upper.begin(), upper.end(), lower.begin(), lower.end())) {
+            varToOtherVars[p.first] = upper;
+        }
+    }
+
+    std::unordered_map<AtomIdx, VarSet> atomIdxToGroundedVars;
+    for (AtomIdx i = 0; i < atoms.size(); ++i) {
+        VarSet groundedVars;
+        visit(*atoms[i], [&](const ast::Variable& v) { groundedVars.insert(v.getName()); });
+        atomIdxToGroundedVars[i] = groundedVars;
+    }
+
+    // #atoms -> variables to join -> plan, cost
+    std::map<std::size_t, std::map<AtomSet, PlanTuplesCost>> cache;
+
+    std::unordered_map<AtomIdx, std::map<ArgIdx, std::string>> atomToIdxConstants;
+
+    std::size_t iterations = 1;
+    for (std::size_t i = 0; i < atoms.size(); ++i) {
+        auto* atom = atoms[i];
+        std::string name = getClauseAtomName(*clause, atom, sccAtoms, version, mode);
+        bool isRecursive = recursiveInCurrentStratum.count(i) > 0;
+        if (isRecursive) {
+            iterations = prof->getIterations(name);
+            break;
+        }
+    }
+
+    AtomIdx atomIdx = 0;
+    for (auto* atom : atoms) {
+        std::string name = getClauseAtomName(*clause, atom, sccAtoms, version, mode);
+        std::map<ArgIdx, std::string> idxConstant;
+
+        ArgIdx varIdx = 0;
+        for (auto* argument : atom->getArguments()) {
+            // if we have a variable and a constraint of the form x = 2 then treat x as 2
+            if (auto* var = as<ast::Variable>(argument)) {
+                if (varToConstant.count(var->getName())) {
+                    argument = varToConstant[var->getName()];
+                }
+            }
+
+            if (auto* constant = as<ast::Constant>(argument)) {
+                std::stringstream ss;
+                ss << *translateConstant(*constant);
+                std::string constantValue = ss.str();
+                idxConstant[varIdx] = constantValue;
+            }
+            ++varIdx;
+        }
+
+        atomToIdxConstants[atomIdx] = idxConstant;
+
+        // start by storing the access cost for each individual relation
+        std::vector<AtomIdx> empty;
+        bool isRecursive = recursiveInCurrentStratum.count(atomIdx) > 0;
+        AtomSet singleton = {atomIdx};
+        std::vector<AtomIdx> plan = {atomIdx};
+        PlanTuplesCost p;
+        p.plan = plan;
+        for (std::size_t iter = 0; iter < iterations; ++iter) {
+            std::size_t tuples = getRelationSize(isRecursive, name, empty, idxConstant, std::to_string(iter));
+            double cost = static_cast<double>(tuples * atom->getArity());
+            p.tuplesPerIteration.push_back(tuples);
+            p.costsPerIteration.push_back(cost);
+        }
+        cache[1].insert(std::make_pair(singleton, p));
+        ++atomIdx;
+    }
+
+    // do selinger's algorithm
+    auto N = atoms.size();
+    for (std::size_t K = 2; K <= N; ++K) {
+        // for each K sized subset
+        for (auto& subset : getSubsets(N, K)) {
+            // remove an entry from the subset
+            for (AtomIdx i = 0; i < subset.size(); ++i) {
+                // construct the set S \ S[i]
+                AtomSet smallerSubset;
+                for (AtomIdx j = 0; j < subset.size(); ++j) {
+                    if (i == j) {
+                        continue;
+                    }
+                    smallerSubset.insert(subset[j]);
+                }
+
+                // compute the grounded variables from the subset
+                VarSet groundedVariablesFromSubset;
+                for (auto idx : smallerSubset) {
+                    auto& varsGroundedByAtom = atomIdxToGroundedVars[idx];
+                    groundedVariablesFromSubset.insert(varsGroundedByAtom.begin(), varsGroundedByAtom.end());
+                }
+
+                // compute new cost
+                AtomIdx atomIdx = subset[i];
+                auto* atom = atoms[atomIdx];
+                std::vector<ArgIdx> joinColumns;
+                const auto& args = atom->getArguments();
+                std::size_t numBound = 0;
+                for (ArgIdx argIdx = 0; argIdx < args.size(); ++argIdx) {
+                    auto* arg = args[argIdx];
+                    // if we have a constant or var = constant then we ignore
+                    if (atomToIdxConstants[atomIdx].count(argIdx) > 0) {
+                        ++numBound;
+                        continue;
+                    }
+
+                    // unnamed variable i.e. _
+                    if (isA<ast::UnnamedVariable>(arg)) {
+                        ++numBound;
+                        continue;
+                    }
+
+                    if (auto* var = as<ast::Variable>(arg)) {
+                        // free variable so we can't join on it
+                        if (varToOtherVars.count(var->getName()) > 0) {
+                            auto& dependentVars = varToOtherVars.at(var->getName());
+                            if (std::includes(groundedVariablesFromSubset.begin(),
+                                        groundedVariablesFromSubset.end(), dependentVars.begin(),
+                                        dependentVars.end())) {
+                                joinColumns.push_back(argIdx);
+                                ++numBound;
+                                continue;
+                            }
+                        }
+
+                        // direct match on variable
+                        if (groundedVariablesFromSubset.count(var->getName()) > 0) {
+                            joinColumns.push_back(argIdx);
+                            ++numBound;
+                            continue;
+                        }
+                    }
+                }
+
+                // lookup the cost in the cache
+                auto& planTuplesCost = cache[K - 1].at(smallerSubset);
+                auto& oldPlan = planTuplesCost.plan;
+                auto oldTuples = planTuplesCost.tuplesPerIteration;
+                auto oldCost = planTuplesCost.costsPerIteration;
+
+                PlanTuplesCost p;
+                bool isRecursive = recursiveInCurrentStratum.count(atomIdx) > 0;
+                std::vector<ArgIdx> empty;
+                double expectedTuples = 0;
+                double newTotalCost = 0.0;
+                for (std::size_t iter = 0; iter < iterations; ++iter) {
+                    if (numBound == atom->getArity()) {
+                        expectedTuples = 1;
+                    } else {
+                        auto relSizeWithConstants = getRelationSize(isRecursive,
+                                getClauseAtomName(*clause, atom, sccAtoms, version, mode), empty,
+                                atomToIdxConstants[atomIdx], std::to_string(iter));
+
+                        if (joinColumns.empty()) {
+                            expectedTuples = static_cast<double>(relSizeWithConstants);
+                        } else {
+                            auto uniqueKeys = getRelationSize(isRecursive,
+                                    getClauseAtomName(*clause, atom, sccAtoms, version, mode), joinColumns,
+                                    atomToIdxConstants[atomIdx], std::to_string(iter));
+
+                            bool normalize = (uniqueKeys > 0);
+                            expectedTuples =
+                                    static_cast<double>(relSizeWithConstants) / (normalize ? uniqueKeys : 1);
+                        }
+                    }
+
+                    // calculate new number of tuples
+                    std::size_t newTuples = static_cast<std::size_t>(oldTuples[iter] * expectedTuples);
+
+                    // calculate new cost
+                    double newCost = oldCost[iter] + newTuples * atom->getArity();
+
+                    // add to vector of costs/tuples
+                    p.tuplesPerIteration.push_back(newTuples);
+                    p.costsPerIteration.push_back(newCost);
+                    newTotalCost += newCost;
+                }
+
+                // calculate new plan
+                std::vector<AtomIdx> newPlan(oldPlan.begin(), oldPlan.end());
+                newPlan.push_back(atomIdx);
+                p.plan = newPlan;
+
+                // if no plan then insert it
+                AtomSet currentSet(subset.begin(), subset.end());
+                if (cache[K].count(currentSet) == 0) {
+                    cache[K].insert(std::make_pair(currentSet, p));
+                } else {
+                    // if we have a lower cost
+                    auto& costVector = cache[K].at(currentSet).costsPerIteration;
+                    double oldTotalCost = std::accumulate(costVector.begin(), costVector.end(), 0.0);
+                    if (oldTotalCost >= newTotalCost) {
+                        cache[K].erase(currentSet);
+                        cache[K].insert(std::make_pair(currentSet, p));
+                    }
+                }
+            }
+        }
+    }
+
+    std::vector<AtomIdx> newOrder;
+    assert(cache[N].size() == 1);
+    auto& bestPlanTuplesCost = cache[N].begin()->second;
+    auto& bestPlan = bestPlanTuplesCost.plan;
+    for (AtomIdx elem : bestPlan) {
+        newOrder.push_back(elem);
+    }
+
+    return newOrder;
+}
+
+Own<ram::Expression> SelingerProfileSipsMetric::translateConstant(const ast::Constant& constant) const {
+    if (auto strConstant = as<ast::StringConstant>(constant)) {
+        return mk<ram::StringConstant>(strConstant->getConstant());
+    } else if (isA<ast::NilConstant>(&constant)) {
+        return mk<ram::SignedConstant>(0);
+    } else if (auto* numConstant = as<ast::NumericConstant>(constant)) {
+        switch (polyAnalysis->getInferredType(*numConstant)) {
+            case ast::NumericConstant::Type::Int:
+                return mk<ram::SignedConstant>(RamSignedFromString(numConstant->getConstant(), nullptr, 0));
+            case ast::NumericConstant::Type::Uint:
+                return mk<ram::UnsignedConstant>(
+                        RamUnsignedFromString(numConstant->getConstant(), nullptr, 0));
+            case ast::NumericConstant::Type::Float:
+                return mk<ram::FloatConstant>(RamFloatFromString(numConstant->getConstant()));
+        }
+    }
+    fatal("unaccounted-for constant");
+}
+
+std::string SipsMetric::getClauseAtomName(const ast::Clause& clause, const ast::Atom* atom,
+        const std::vector<ast::Atom*>& sccAtoms, std::size_t version, ast2ram::TranslationMode mode) const {
+    using namespace souffle::ast2ram;
+
+    bool isRecursive = !sccAtoms.empty();
+
+    if (isA<ast::SubsumptiveClause>(clause)) {
+        // find the dominated / dominating heads
+        const auto& body = clause.getBodyLiterals();
+        auto dominatedHeadAtom = dynamic_cast<const ast::Atom*>(body[0]);
+        auto dominatingHeadAtom = dynamic_cast<const ast::Atom*>(body[1]);
+
+        if (clause.getHead() == atom) {
+            if (mode == SubsumeDeleteCurrentDelta || mode == SubsumeDeleteCurrentCurrent) {
+                return getDeleteRelationName(atom->getQualifiedName());
+            }
+            return getRejectRelationName(atom->getQualifiedName());
+        }
+
+        if (dominatedHeadAtom == atom) {
+            if (mode == SubsumeDeleteCurrentDelta || mode == SubsumeDeleteCurrentCurrent) {
+                return getConcreteRelationName(atom->getQualifiedName());
+            }
+            return getNewRelationName(atom->getQualifiedName());
+        }
+
+        if (dominatingHeadAtom == atom) {
+            switch (mode) {
+                case SubsumeRejectNewCurrent:
+                case SubsumeDeleteCurrentCurrent: return getConcreteRelationName(atom->getQualifiedName());
+                case SubsumeDeleteCurrentDelta: return getDeltaRelationName(atom->getQualifiedName());
+                default: return getNewRelationName(atom->getQualifiedName());
+            }
+        }
+
+        if (isRecursive) {
+            if (sccAtoms.at(version + 1) == atom) {
+                return getDeltaRelationName(atom->getQualifiedName());
+            }
+        }
+    }
+
+    if (!isRecursive) {
+        return getConcreteRelationName(atom->getQualifiedName());
+    }
+    if (clause.getHead() == atom) {
+        return getNewRelationName(atom->getQualifiedName());
+    }
+    if (sccAtoms.at(version) == atom) {
+        return getDeltaRelationName(atom->getQualifiedName());
+    }
+    return getConcreteRelationName(atom->getQualifiedName());
+}
+
+const ast::PowerSet& SelingerProfileSipsMetric::getSubsets(std::size_t N, std::size_t K) const {
+    if (cache.count({N, K})) {
+        return cache.at({N, K});
+    }
+    // this powerset represents all possible subsets of cardinality K of the set {1,...,N}
+    ast::PowerSet res;
+
+    // generate the next permutation of the bitmask
+    std::vector<std::size_t> cur;
+    cur.reserve(K);
+
+    // use bitmask for subset generation
+    std::string bitmask(K, 1);  // K leading 1's
+    bitmask.resize(N, 0);       // N-K trailing 0's
+
+    // generate the combination while there are combinations to go
+    do {
+        cur.clear();
+
+        // construct the subset using the set bits in the bitmask
+        for (std::size_t i = 0; i < N; ++i)  // [0..N-1] integers
+        {
+            if (bitmask[i]) {
+                cur.push_back(i);
+            }
+        }
+        res.push_back(cur);
+    } while (std::prev_permutation(bitmask.begin(), bitmask.end()));
+
+    cache[std::make_pair(N, K)] = res;
+    return cache.at({N, K});
+}
+
+/** Create a SIPS metric based on a given heuristic. */
+std::unique_ptr<SipsMetric> SipsMetric::create(const std::string& heuristic, const TranslationUnit& tu) {
+    if (Global::config().has("auto-schedule")) {
+        return mk<SelingerProfileSipsMetric>(tu);
+    } else if (heuristic == "strict")
+        return mk<StrictSips>(tu);
+    else if (heuristic == "all-bound")
+        return mk<AllBoundSips>(tu);
+    else if (heuristic == "naive")
+        return mk<NaiveSips>(tu);
+    else if (heuristic == "max-bound")
+        return mk<MaxBoundSips>(tu);
+    else if (heuristic == "delta-max-bound")
+        return mk<DeltaMaxBoundSips>(tu);
+    else if (heuristic == "max-ratio")
+        return mk<MaxRatioSips>(tu);
+    else if (heuristic == "least-free")
+        return mk<LeastFreeSips>(tu);
+    else if (heuristic == "least-free-vars")
+        return mk<LeastFreeVarsSips>(tu);
+    else if (heuristic == "input")
+        return mk<InputSips>(tu);
+
+    // default is all-bound
+    return create("all-bound", tu);
+}
+
+std::vector<double> StrictSips::evaluateCosts(const Clause* /*clause*/,
+        const std::vector<ast::Atom*>& /*sccAtoms*/, const std::vector<Atom*> atoms,
+        const BindingStore& /* bindingStore */, std::size_t /*version*/,
+        ast2ram::TranslationMode /*mode*/) const {
+    // Goal: Always choose the left-most atom
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        cost.push_back(atom == nullptr ? std::numeric_limits<double>::max() : 0);
+    }
+    assert(atoms.size() == cost.size() && "each atom should have exactly one cost");
+    return cost;
+}
+
+std::vector<double> AllBoundSips::evaluateCosts(const Clause* /*clause*/,
+        const std::vector<ast::Atom*>& /*sccAtoms*/, const std::vector<Atom*> atoms,
+        const BindingStore& bindingStore, std::size_t /*version*/, ast2ram::TranslationMode /*mode*/) const {
+    // Goal: Prioritise atoms with all arguments bound
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        if (atom == nullptr) {
+            cost.push_back(std::numeric_limits<double>::max());
+            continue;
+        }
+
+        std::size_t arity = atom->getArity();
+        std::size_t numBound = bindingStore.numBoundArguments(atom);
+        cost.push_back(arity == numBound ? 0 : 1);
+    }
+    assert(atoms.size() == cost.size() && "each atom should have exactly one cost");
+    return cost;
+}
+
+std::vector<double> NaiveSips::evaluateCosts(const Clause* /*clause*/,
+        const std::vector<ast::Atom*>& /*sccAtoms*/, const std::vector<Atom*> atoms,
+        const BindingStore& bindingStore, std::size_t /*version*/, ast2ram::TranslationMode /*mode*/) const {
+    // Goal: Prioritise (1) all bound, then (2) atoms with at least one bound argument, then (3) left-most
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        if (atom == nullptr) {
+            cost.push_back(std::numeric_limits<double>::max());
+            continue;
+        }
+
+        std::size_t arity = atom->getArity();
+        std::size_t numBound = bindingStore.numBoundArguments(atom);
+        if (arity == numBound) {
+            cost.push_back(0);
+        } else if (numBound >= 1) {
+            cost.push_back(1);
+        } else {
+            cost.push_back(2);
+        }
+    }
+    assert(atoms.size() == cost.size() && "each atom should have exactly one cost");
+    return cost;
+}
+
+std::vector<double> MaxBoundSips::evaluateCosts(const Clause* /*clause*/,
+        const std::vector<ast::Atom*>& /*sccAtoms*/, const std::vector<Atom*> atoms,
+        const BindingStore& bindingStore, std::size_t /*version*/, ast2ram::TranslationMode /*mode*/) const {
+    // Goal: prioritise (1) all-bound, then (2) max number of bound vars, then (3) left-most
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        if (atom == nullptr) {
+            cost.push_back(std::numeric_limits<double>::max());
+            continue;
+        }
+
+        std::size_t arity = atom->getArity();
+        std::size_t numBound = bindingStore.numBoundArguments(atom);
+        if (arity == numBound) {
+            // Always better than anything else
+            cost.push_back(0);
+        } else if (numBound == 0) {
+            // Always worse than any number of bound vars
+            cost.push_back(2);
+        } else {
+            // Between 0 and 1, decreasing with more num bound
+            cost.push_back(1.0 / numBound);
+        }
+    }
+    assert(atoms.size() == cost.size() && "each atom should have exactly one cost");
+    return cost;
+}
+
+std::vector<double> MaxRatioSips::evaluateCosts(const Clause* /*clause*/,
+        const std::vector<ast::Atom*>& /*sccAtoms*/, const std::vector<Atom*> atoms,
+        const BindingStore& bindingStore, std::size_t /*version*/, ast2ram::TranslationMode /*mode*/) const {
+    // Goal: prioritise max ratio of bound args
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        if (atom == nullptr) {
+            cost.push_back(std::numeric_limits<double>::max());
+            continue;
+        }
+
+        std::size_t arity = atom->getArity();
+        std::size_t numBound = bindingStore.numBoundArguments(atom);
+        if (arity == 0) {
+            // Always better than anything else
+            cost.push_back(0);
+        } else if (numBound == 0) {
+            // Always worse than anything else
+            cost.push_back(2);
+        } else {
+            // Between 0 and 1, decreasing as the ratio increases
+            cost.push_back(1.0 - numBound / arity);
+        }
+    }
+    assert(atoms.size() == cost.size() && "each atom should have exactly one cost");
+    return cost;
+}
+
+std::vector<double> LeastFreeSips::evaluateCosts(const Clause* /*clause*/,
+        const std::vector<ast::Atom*>& /*sccAtoms*/, const std::vector<Atom*> atoms,
+        const BindingStore& bindingStore, std::size_t /*version*/, ast2ram::TranslationMode /*mode*/) const {
+    // Goal: choose the atom with the least number of unbound arguments
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        if (atom == nullptr) {
+            cost.push_back(std::numeric_limits<double>::max());
+            continue;
+        }
+
+        cost.push_back((double)(atom->getArity() - bindingStore.numBoundArguments(atom)));
+    }
+    return cost;
+}
+
+std::vector<double> LeastFreeVarsSips::evaluateCosts(const Clause* /*clause*/,
+        const std::vector<ast::Atom*>& /*sccAtoms*/, const std::vector<Atom*> atoms,
+        const BindingStore& bindingStore, std::size_t /*version*/, ast2ram::TranslationMode /*mode*/) const {
+    // Goal: choose the atom with the least amount of unbound variables
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        if (atom == nullptr) {
+            cost.push_back(std::numeric_limits<double>::max());
+            continue;
+        }
+
+        // use a set to hold all free variables to avoid double-counting
+        std::set<std::string> freeVars;
+        visit(*atom, [&](const Variable& var) {
+            if (bindingStore.isBound(var.getName())) {
+                freeVars.insert(var.getName());
+            }
+        });
+        cost.push_back((double)freeVars.size());
+    }
+    return cost;
+}
+
+InputSips::InputSips(const TranslationUnit& tu)
+        : StaticSipsMetric(tu), ioTypes(tu.getAnalysis<analysis::IOTypeAnalysis>()) {}
+
+std::vector<double> InputSips::evaluateCosts(const Clause* /*clause*/,
+        const std::vector<ast::Atom*>& /*sccAtoms*/, const std::vector<Atom*> atoms,
+        const BindingStore& bindingStore, std::size_t /*version*/, ast2ram::TranslationMode /*mode*/) const {
+    // Goal: prioritise (1) all-bound, (2) input, then (3) rest
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        if (atom == nullptr) {
+            cost.push_back(std::numeric_limits<double>::max());
+            continue;
+        }
+
+        const auto& relName = atom->getQualifiedName();
+        std::size_t arity = atom->getArity();
+        std::size_t numBound = bindingStore.numBoundArguments(atom);
+        if (arity == numBound) {
+            // prioritise all-bound
+            cost.push_back(0);
+        } else if (ioTypes.isInput(program.getRelation(relName))) {
+            // then input
+            cost.push_back(1);
+        } else {
+            cost.push_back(2);
+        }
+    }
+    return cost;
+}
+
+std::vector<double> DeltaMaxBoundSips::evaluateCosts(const Clause* clause,
+        const std::vector<ast::Atom*>& sccAtoms, const std::vector<Atom*> atoms,
+        const BindingStore& bindingStore, std::size_t version, ast2ram::TranslationMode mode) const {
+    auto isDeltaRelation = [&](const Atom* atom) {
+        std::string name = getClauseAtomName(*clause, atom, sccAtoms, version, mode);
+        return isPrefix("@delta_", name);
+    };
+
+    std::vector<double> cost;
+    for (const auto* atom : atoms) {
+        if (atom == nullptr) {
+            cost.push_back(std::numeric_limits<double>::max());
+            continue;
+        }
+
+        std::size_t arity = atom->getArity();
+        std::size_t numBound = bindingStore.numBoundArguments(atom);
+        if (arity == numBound) {
+            // Always better than anything else
+            cost.push_back(0.0);
+        } else if (isDeltaRelation(atom)) {
+            // Better than any other atom that is not fully bounded
+            cost.push_back(1.0);
+        } else if (numBound == 0) {
+            // Always worse than any number of bound vars
+            cost.push_back(4.0);
+        } else {
+            // Between 2 and 3, decreasing with more num bound
+            cost.push_back(2.0 + (1.0 / (double)numBound));
+        }
+    }
+    assert(atoms.size() == cost.size() && "each atom should have exactly one cost");
+    return cost;
+}
+
+}  // namespace souffle::ast
diff --git a/src/ast/utility/SipsMetric.h b/src/ast/utility/SipsMetric.h
new file mode 100644
index 0000000..c9946e6
--- /dev/null
+++ b/src/ast/utility/SipsMetric.h
@@ -0,0 +1,221 @@
+/*
+ * Souffle - A Datalog Compiler
+ * Copyright (c) 2020, The Souffle Developers. All rights reserved
+ * Licensed under the Universal Permissive License v 1.0 as shown at:
+ * - https://opensource.org/licenses/UPL
+ * - <souffle root>/licenses/SOUFFLE-UPL.txt
+ */
+
+/************************************************************************
+ *
+ * @file SipsMetric.h
+ *
+ * Defines the SipsMetric class, which specifies cost functions for atom orderings in a clause.
+ *
+ ***********************************************************************/
+
+#pragma once
+
+#include "ast2ram/ClauseTranslator.h"
+#include "souffle/utility/Types.h"
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+
+namespace souffle::ram {
+class Expression;
+}  // namespace souffle::ram
+
+namespace souffle::ast::analysis {
+class IOTypeAnalysis;
+class ProfileUseAnalysis;
+class PolymorphicObjectsAnalysis;
+class SCCGraphAnalysis;
+}  // namespace souffle::ast::analysis
+namespace souffle::ast {
+
+class Atom;
+class BindingStore;
+class Clause;
+class Constant;
+class Program;
+class TranslationUnit;
+
+using PowerSet = std::vector<std::vector<std::size_t>>;
+
+/**
+ * Class for SIPS cost-metric functions
+ * Each subclass represents a different heuristic used for evaluating
+ * the cost of choosing an atom next in the schedule.
+ */
+class SipsMetric {
+public:
+    SipsMetric(const TranslationUnit& tu);
+
+    virtual ~SipsMetric() = default;
+
+    /**
+     * Determines the new ordering of a clause after the SIPS is applied.
+     * @param clause clause to reorder
+     * @return the vector of new positions; v[i] = j iff atom j moves to pos i
+     */
+    virtual std::vector<std::size_t> getReordering(
+            const Clause* clause, std::size_t version, ast2ram::TranslationMode mode) const = 0;
+
+    /** Create a SIPS metric based on a given heuristic. */
+    static std::unique_ptr<SipsMetric> create(const std::string& heuristic, const TranslationUnit& tu);
+
+    std::string getClauseAtomName(const ast::Clause& clause, const ast::Atom* atom,
+            const std::vector<ast::Atom*>& sccAtoms, std::size_t version,
+            ast2ram::TranslationMode mode) const;
+
+protected:
+    const ast::Program& program;
+    const ast::analysis::SCCGraphAnalysis* sccGraph = nullptr;
+};
+
+class SelingerProfileSipsMetric : public SipsMetric {
+public:
+    SelingerProfileSipsMetric(const TranslationUnit& tu);
+    std::vector<std::size_t> getReordering(
+            const Clause* clause, std::size_t version, ast2ram::TranslationMode mode) const override;
+
+private:
+    /* helper struct for Selinger */
+    struct PlanTuplesCost {
+        std::vector<std::size_t> plan;
+        std::vector<std::size_t> tuplesPerIteration;
+        std::vector<double> costsPerIteration;
+    };
+
+    const PowerSet& getSubsets(std::size_t N, std::size_t K) const;
+
+    Own<ram::Expression> translateConstant(const ast::Constant& constant) const;
+
+    const ast::analysis::PolymorphicObjectsAnalysis* polyAnalysis = nullptr;
+    const ast::analysis::ProfileUseAnalysis* profileUseAnalysis = nullptr;
+    mutable std::map<std::pair<std::size_t, std::size_t>, PowerSet> cache;
+};
+
+class StaticSipsMetric : public SipsMetric {
+public:
+    StaticSipsMetric(const TranslationUnit& tu) : SipsMetric(tu) {}
+
+    std::vector<std::size_t> getReordering(
+            const Clause* clause, std::size_t version, ast2ram::TranslationMode mode) const override;
+
+protected:
+    /**
+     * Evaluates the cost of choosing each atom next in the current schedule
+     * @param atoms atoms to choose from; may be nullptr
+     * @param bindingStore the variables already bound to a value
+     */
+    virtual std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const = 0;
+};
+
+/** Goal: Always choose the left-most atom */
+class StrictSips : public StaticSipsMetric {
+public:
+    StrictSips(const TranslationUnit& tu) : StaticSipsMetric(tu) {}
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+};
+
+/** Goal: Prioritise atoms with all arguments bound */
+class AllBoundSips : public StaticSipsMetric {
+public:
+    AllBoundSips(const TranslationUnit& tu) : StaticSipsMetric(tu) {}
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+};
+
+/** Goal: Prioritise (1) all bound, then (2) atoms with at least one bound argument, then (3) left-most */
+class NaiveSips : public StaticSipsMetric {
+public:
+    NaiveSips(const TranslationUnit& tu) : StaticSipsMetric(tu) {}
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+};
+
+/** Goal: prioritise (1) all-bound, then (2) max number of bound vars, then (3) left-most */
+class MaxBoundSips : public StaticSipsMetric {
+public:
+    MaxBoundSips(const TranslationUnit& tu) : StaticSipsMetric(tu) {}
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+};
+
+/** Goal: prioritise (1) delta, (2) all-bound, then (3) max number of bound vars, then (4) left-most */
+class DeltaMaxBoundSips : public StaticSipsMetric {
+public:
+    DeltaMaxBoundSips(const TranslationUnit& tu) : StaticSipsMetric(tu) {}
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+};
+
+/** Goal: prioritise max ratio of bound args */
+class MaxRatioSips : public StaticSipsMetric {
+public:
+    MaxRatioSips(const TranslationUnit& tu) : StaticSipsMetric(tu) {}
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+};
+
+/** Goal: choose the atom with the least number of unbound arguments */
+class LeastFreeSips : public StaticSipsMetric {
+public:
+    LeastFreeSips(const TranslationUnit& tu) : StaticSipsMetric(tu) {}
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+};
+
+/** Goal: choose the atom with the least amount of unbound variables */
+class LeastFreeVarsSips : public StaticSipsMetric {
+public:
+    LeastFreeVarsSips(const TranslationUnit& tu) : StaticSipsMetric(tu) {}
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+};
+
+/** Goal: prioritise (1) all-bound, then (2) input, and then (3) left-most */
+class InputSips : public StaticSipsMetric {
+public:
+    InputSips(const TranslationUnit& tu);
+
+protected:
+    std::vector<double> evaluateCosts(const Clause* clause, const std::vector<ast::Atom*>& sccAtoms,
+            const std::vector<Atom*> atoms, const BindingStore& bindingStore, std::size_t version,
+            ast2ram::TranslationMode mode) const override;
+
+private:
+    const analysis::IOTypeAnalysis& ioTypes;
+};
+
+}  // namespace souffle::ast
diff --git a/src/ast/utility/Utils.cpp b/src/ast/utility/Utils.cpp
index 68a709f..e173ff8 100644
--- a/src/ast/utility/Utils.cpp
+++ b/src/ast/utility/Utils.cpp
@@ -210,7 +210,7 @@ void negateConstraintInPlace(Constraint& constraint) {
     }
 }
 
-bool renameAtoms(Own<Clause>& clause, const UnorderedQualifiedNameMap<QualifiedName>& oldToNew) {
+bool renameAtoms(Own<Clause>& clause, const std::map<QualifiedName, QualifiedName>& oldToNew) {
     bool changed = false;
     visit(clause, [&](Atom& atom) {
         auto it = oldToNew.find(atom.getQualifiedName());
@@ -222,7 +222,7 @@ bool renameAtoms(Own<Clause>& clause, const UnorderedQualifiedNameMap<QualifiedN
     return changed;
 }
 
-bool renameAtoms(Program& program, const UnorderedQualifiedNameMap<QualifiedName>& oldToNew) {
+bool renameAtoms(Program& program, const std::map<QualifiedName, QualifiedName>& oldToNew) {
     bool changed = false;
 
     // Can't rename clause head atoms while the clause is attached w/o invalidating by-name lookup tables.
@@ -253,7 +253,7 @@ bool renameAtoms(Program& program, const UnorderedQualifiedNameMap<QualifiedName
 }
 
 bool renameAtoms(Program& program, QualifiedName const& relation,
-        const UnorderedQualifiedNameMap<QualifiedName>& oldToNew) {
+        const std::map<QualifiedName, QualifiedName>& oldToNew) {
     auto info = program.getRelationInfo(relation);
     if (!info) return false;
 
diff --git a/src/ast/utility/Utils.h b/src/ast/utility/Utils.h
index c7c4cdf..29b7b69 100644
--- a/src/ast/utility/Utils.h
+++ b/src/ast/utility/Utils.h
@@ -174,7 +174,7 @@ IntrinsicFunctors validOverloads(const analysis::TypeAnalysis&, const IntrinsicF
  * @param oldToNew map from old atom names to new atom names
  * @return true if the node was changed
  */
-bool renameAtoms(Own<Clause>& clause, const UnorderedQualifiedNameMap<QualifiedName>& oldToNew);
+bool renameAtoms(Own<Clause>& clause, const std::map<QualifiedName, QualifiedName>& oldToNew);
 
 /**
  * Rename all atoms in the program to a given name, including clause heads.
@@ -182,7 +182,7 @@ bool renameAtoms(Own<Clause>& clause, const UnorderedQualifiedNameMap<QualifiedN
  * @param oldToNew map from old atom names to new atom names
  * @return true if the node was changed
  */
-bool renameAtoms(Program& program, const UnorderedQualifiedNameMap<QualifiedName>& oldToNew);
+bool renameAtoms(Program& program, const std::map<QualifiedName, QualifiedName>& oldToNew);
 
 /**
  * Rename all atoms that appear in a given relation's clauses (including the clause's head).
@@ -192,6 +192,6 @@ bool renameAtoms(Program& program, const UnorderedQualifiedNameMap<QualifiedName
  * @return true if the node was changed
  */
 bool renameAtoms(Program& program, QualifiedName const& relation,
-        const UnorderedQualifiedNameMap<QualifiedName>& oldToNew);
+        const std::map<QualifiedName, QualifiedName>& oldToNew);
 
 }  // namespace souffle::ast
diff --git a/src/ast/utility/Visitor.h b/src/ast/utility/Visitor.h
index beb0864..ebdc85f 100644
--- a/src/ast/utility/Visitor.h
+++ b/src/ast/utility/Visitor.h
@@ -36,10 +36,7 @@
 #include "ast/FunctionalConstraint.h"
 #include "ast/Functor.h"
 #include "ast/FunctorDeclaration.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/IntrinsicFunctor.h"
-#include "ast/IterationCounter.h"
-#include "ast/Lattice.h"
 #include "ast/Literal.h"
 #include "ast/Negation.h"
 #include "ast/NilConstant.h"
@@ -58,7 +55,6 @@
 #include "ast/TypeCast.h"
 #include "ast/UnionType.h"
 #include "ast/UnnamedVariable.h"
-#include "ast/UserDefinedAggregator.h"
 #include "ast/UserDefinedFunctor.h"
 #include "ast/Variable.h"
 #include "souffle/utility/FunctionalUtil.h"
@@ -90,7 +86,6 @@ struct Visitor : souffle::detail::VisitorBase<R, NodeType, Params...> {
         SOUFFLE_VISITOR_FORWARD(Variable)
         SOUFFLE_VISITOR_FORWARD(UnnamedVariable)
         SOUFFLE_VISITOR_FORWARD(IntrinsicFunctor)
-        SOUFFLE_VISITOR_FORWARD(IterationCounter)
         SOUFFLE_VISITOR_FORWARD(UserDefinedFunctor)
         SOUFFLE_VISITOR_FORWARD(Counter)
         SOUFFLE_VISITOR_FORWARD(NumericConstant)
@@ -99,8 +94,7 @@ struct Visitor : souffle::detail::VisitorBase<R, NodeType, Params...> {
         SOUFFLE_VISITOR_FORWARD(TypeCast)
         SOUFFLE_VISITOR_FORWARD(RecordInit)
         SOUFFLE_VISITOR_FORWARD(BranchInit)
-        SOUFFLE_VISITOR_FORWARD(IntrinsicAggregator)
-        SOUFFLE_VISITOR_FORWARD(UserDefinedAggregator)
+        SOUFFLE_VISITOR_FORWARD(Aggregator)
 
         // literals
         SOUFFLE_VISITOR_FORWARD(Atom)
@@ -140,7 +134,6 @@ struct Visitor : souffle::detail::VisitorBase<R, NodeType, Params...> {
     SOUFFLE_VISITOR_LINK(Variable, Argument)
     SOUFFLE_VISITOR_LINK(UnnamedVariable, Argument)
     SOUFFLE_VISITOR_LINK(Counter, Argument)
-    SOUFFLE_VISITOR_LINK(IterationCounter, Argument)
     SOUFFLE_VISITOR_LINK(TypeCast, Argument)
     SOUFFLE_VISITOR_LINK(BranchInit, Argument)
 
@@ -158,8 +151,6 @@ struct Visitor : souffle::detail::VisitorBase<R, NodeType, Params...> {
     SOUFFLE_VISITOR_LINK(Term, Argument)
 
     SOUFFLE_VISITOR_LINK(Aggregator, Argument)
-    SOUFFLE_VISITOR_LINK(IntrinsicAggregator, Aggregator)
-    SOUFFLE_VISITOR_LINK(UserDefinedAggregator, Aggregator)
 
     SOUFFLE_VISITOR_LINK(Argument, Node);
 
@@ -186,7 +177,6 @@ struct Visitor : souffle::detail::VisitorBase<R, NodeType, Params...> {
     SOUFFLE_VISITOR_LINK(Relation, Node);
     SOUFFLE_VISITOR_LINK(Pragma, Node);
     SOUFFLE_VISITOR_LINK(FunctorDeclaration, Node);
-    SOUFFLE_VISITOR_LINK(ast::Lattice, Node);
 };
 }  // namespace souffle::ast
 
diff --git a/src/ast2ram/ClauseTranslator.h b/src/ast2ram/ClauseTranslator.h
index 7e399dc..f2c5642 100644
--- a/src/ast2ram/ClauseTranslator.h
+++ b/src/ast2ram/ClauseTranslator.h
@@ -19,12 +19,9 @@
 
 #include "souffle/utility/ContainerUtil.h"
 
-#include "ast/Relation.h"
-
 namespace souffle::ast {
 class Clause;
 class Relation;
-
 }  // namespace souffle::ast
 
 namespace souffle::ram {
@@ -39,8 +36,6 @@ class TranslatorContext;
 enum TranslationMode {
     DEFAULT,
 
-    Auxiliary,
-
     // Subsumptive clauses
     //
     //   R(x0) <= R(x1) :- body.
@@ -78,7 +73,7 @@ public:
 
     /** Translate a recursive clause */
     virtual Own<ram::Statement> translateRecursiveClause(
-            const ast::Clause& clause, const ast::RelationSet& scc, std::size_t version) = 0;
+            const ast::Clause& clause, const std::set<const ast::Relation*>& scc, std::size_t version) = 0;
 
 protected:
     /** Translation context */
diff --git a/src/ast2ram/provenance/ClauseTranslator.cpp b/src/ast2ram/provenance/ClauseTranslator.cpp
index 0cd0e20..c695fdd 100644
--- a/src/ast2ram/provenance/ClauseTranslator.cpp
+++ b/src/ast2ram/provenance/ClauseTranslator.cpp
@@ -133,7 +133,7 @@ Own<ram::Operation> ClauseTranslator::addAtomScan(Own<ram::Operation> op, const
 
     // add a scan level
     std::stringstream ss;
-    if (context.getGlobal()->config().has("profile")) {
+    if (Global::config().has("profile")) {
         ss << "@frequency-atom" << ';';
         ss << clause.getHead()->getQualifiedName() << ';';
         ss << version << ';';
diff --git a/src/ast2ram/provenance/UnitTranslator.cpp b/src/ast2ram/provenance/UnitTranslator.cpp
index 1a9abb2..c6fac4a 100644
--- a/src/ast2ram/provenance/UnitTranslator.cpp
+++ b/src/ast2ram/provenance/UnitTranslator.cpp
@@ -24,14 +24,12 @@
 #include "ast2ram/utility/TranslatorContext.h"
 #include "ast2ram/utility/Utils.h"
 #include "ast2ram/utility/ValueIndex.h"
-#include "ram/AbstractOperator.h"
 #include "ram/Call.h"
 #include "ram/DebugInfo.h"
 #include "ram/ExistenceCheck.h"
 #include "ram/Expression.h"
 #include "ram/Filter.h"
 #include "ram/Insert.h"
-#include "ram/IntrinsicOperator.h"
 #include "ram/LogRelationTimer.h"
 #include "ram/MergeExtend.h"
 #include "ram/Negation.h"
@@ -52,8 +50,6 @@
 namespace souffle::ast2ram::provenance {
 
 Own<ram::Sequence> UnitTranslator::generateProgram(const ast::TranslationUnit& translationUnit) {
-    glb = &translationUnit.global();
-
     // Do the regular translation
     auto ramProgram = seminaive::UnitTranslator::generateProgram(translationUnit);
 
@@ -71,12 +67,18 @@ Own<ram::Sequence> UnitTranslator::generateProgram(const ast::TranslationUnit& t
 
 Own<ram::Relation> UnitTranslator::createRamRelation(
         const ast::Relation* baseRelation, std::string ramRelationName) const {
-    auto relation = seminaive::UnitTranslator::createRamRelation(baseRelation, ramRelationName);
+    auto arity = baseRelation->getArity();
+
+    // All relations in a provenance program should have a provenance data structure
+    auto representation = RelationRepresentation::PROVENANCE;
 
-    std::size_t arity = relation->getArity();
-    std::size_t auxiliaryArity = relation->getAuxiliaryArity();
-    std::vector<std::string> attributeNames = relation->getAttributeNames();
-    std::vector<std::string> attributeTypeQualifiers = relation->getAttributeTypes();
+    // Add in base relation information
+    std::vector<std::string> attributeNames;
+    std::vector<std::string> attributeTypeQualifiers;
+    for (const auto& attribute : baseRelation->getAttributes()) {
+        attributeNames.push_back(attribute->getName());
+        attributeTypeQualifiers.push_back(context->getAttributeTypeQualifier(attribute->getTypeName()));
+    }
 
     // Add in provenance information
     attributeNames.push_back("@rule_number");
@@ -85,8 +87,8 @@ Own<ram::Relation> UnitTranslator::createRamRelation(
     attributeNames.push_back("@level_number");
     attributeTypeQualifiers.push_back("i:number");
 
-    return mk<ram::Relation>(ramRelationName, arity + 2, auxiliaryArity + 2, attributeNames,
-            attributeTypeQualifiers, relation->getRepresentation());
+    return mk<ram::Relation>(
+            ramRelationName, arity + 2, 2, attributeNames, attributeTypeQualifiers, representation);
 }
 
 std::string UnitTranslator::getInfoRelationName(const ast::Clause* clause) const {
@@ -147,7 +149,7 @@ void UnitTranslator::addAuxiliaryArity(
 }
 
 Own<ram::Statement> UnitTranslator::generateClearExpiredRelations(
-        const ast::RelationSet& /* expiredRelations */) const {
+        const std::set<const ast::Relation*>& /* expiredRelations */) const {
     // Relations should be preserved if provenance is enabled
     return mk<ram::Sequence>();
 }
@@ -285,7 +287,7 @@ Own<ram::Sequence> UnitTranslator::generateInfoClauses(const ast::Program* progr
         auto infoClause = mk<ram::Statement, ram::Query>(std::move(factInsertion));
 
         // Add logging
-        if (glb->config().has("profile")) {
+        if (Global::config().has("profile")) {
             std::stringstream clauseText;
             clauseText << "@info.clause[" << stringify(toString(*clause)) << "]";
             const std::string logTimerStatement =
@@ -296,18 +298,17 @@ Own<ram::Sequence> UnitTranslator::generateInfoClauses(const ast::Program* progr
         // Add debug info
         std::ostringstream ds;
         ds << "@info.clause[";
-        clause->printForDebugInfo(ds);
-        ds << "]"
+        ds << toString(*clause) << "]"
            << "\nin file ";
         ds << clause->getSrcLoc();
         infoClause = mk<ram::DebugInfo>(std::move(infoClause), ds.str());
 
         // Add the subroutine to the program
-        std::string stratumID = toString(stratumCount++);
+        std::string stratumID = "stratum_" + toString(stratumCount++);
         addRamSubroutine(stratumID, std::move(infoClause));
 
         // Push up the subroutine call
-        infoClauseCalls.push_back(mk<ram::Call>("stratum_" + stratumID));
+        infoClauseCalls.push_back(mk<ram::Call>(stratumID));
     }
 
     return mk<ram::Sequence>(std::move(infoClauseCalls));
@@ -438,6 +439,7 @@ Own<ram::Statement> UnitTranslator::makeNegationSubproofSubroutine(const ast::Cl
 
     // Create the search sequence
     VecOwn<ram::Statement> searchSequence;
+    std::size_t litNumber = 0;
     for (const auto* lit : lits) {
         if (const auto* atom = as<ast::Atom>(lit)) {
             auto existenceCheck = makeRamAtomExistenceCheck(atom, idToVarName, *dummyValueIndex);
@@ -465,6 +467,8 @@ Own<ram::Statement> UnitTranslator::makeNegationSubproofSubroutine(const ast::Cl
                 appendStmt(searchSequence, std::move(ifStatement));
             }
         }
+
+        litNumber++;
     }
 
     return mk<ram::Sequence>(std::move(searchSequence));
diff --git a/src/ast2ram/provenance/UnitTranslator.h b/src/ast2ram/provenance/UnitTranslator.h
index d110fdd..c0fc6af 100644
--- a/src/ast2ram/provenance/UnitTranslator.h
+++ b/src/ast2ram/provenance/UnitTranslator.h
@@ -44,7 +44,7 @@ public:
 protected:
     Own<ram::Sequence> generateProgram(const ast::TranslationUnit& translationUnit) override;
     Own<ram::Statement> generateClearExpiredRelations(
-            const ast::RelationSet& expiredRelations) const override;
+            const std::set<const ast::Relation*>& expiredRelations) const override;
     Own<ram::Relation> createRamRelation(
             const ast::Relation* baseRelation, std::string ramRelationName) const override;
     VecOwn<ram::Relation> createRamRelations(const std::vector<std::size_t>& sccOrdering) const override;
@@ -74,8 +74,6 @@ private:
             ram::Node* node, const std::map<std::size_t, std::string>& idToVar) const;
     Own<ram::Sequence> makeIfStatement(
             Own<ram::Condition> condition, Own<ram::Operation> trueOp, Own<ram::Operation> falseOp) const;
-
-    Global* glb;
 };
 
 }  // namespace souffle::ast2ram::provenance
diff --git a/src/ast2ram/seminaive/ClauseTranslator.cpp b/src/ast2ram/seminaive/ClauseTranslator.cpp
index e527b17..c2e81e8 100644
--- a/src/ast2ram/seminaive/ClauseTranslator.cpp
+++ b/src/ast2ram/seminaive/ClauseTranslator.cpp
@@ -21,7 +21,6 @@
 #include "ast/BranchInit.h"
 #include "ast/Clause.h"
 #include "ast/Constant.h"
-#include "ast/IntrinsicAggregator.h"
 #include "ast/IntrinsicFunctor.h"
 #include "ast/NilConstant.h"
 #include "ast/NumericConstant.h"
@@ -31,25 +30,24 @@
 #include "ast/SubsumptiveClause.h"
 #include "ast/UnnamedVariable.h"
 #include "ast/analysis/Functor.h"
+#include "ast/utility/SipsMetric.h"
 #include "ast/utility/Utils.h"
 #include "ast/utility/Visitor.h"
 #include "ast2ram/utility/Location.h"
-#include "ast2ram/utility/SipsMetric.h"
 #include "ast2ram/utility/TranslatorContext.h"
 #include "ast2ram/utility/Utils.h"
 #include "ast2ram/utility/ValueIndex.h"
 #include "ram/Aggregate.h"
 #include "ram/Break.h"
 #include "ram/Constraint.h"
+#include "ram/CountUniqueKeys.h"
 #include "ram/DebugInfo.h"
 #include "ram/EmptinessCheck.h"
-#include "ram/EstimateJoinSize.h"
 #include "ram/ExistenceCheck.h"
 #include "ram/Filter.h"
 #include "ram/FloatConstant.h"
 #include "ram/GuardedInsert.h"
 #include "ram/Insert.h"
-#include "ram/IntrinsicAggregator.h"
 #include "ram/LogRelationTimer.h"
 #include "ram/Negation.h"
 #include "ram/NestedIntrinsicOperator.h"
@@ -61,9 +59,7 @@
 #include "ram/TupleElement.h"
 #include "ram/UnpackRecord.h"
 #include "ram/UnsignedConstant.h"
-#include "ram/UserDefinedAggregator.h"
 #include "ram/utility/Utils.h"
-#include "souffle/TypeAttribute.h"
 #include "souffle/utility/StringUtil.h"
 #include <map>
 #include <unordered_set>
@@ -84,8 +80,7 @@ std::string ClauseTranslator::getClauseString(const ast::Clause& clause) const {
     auto renamedClone = clone(clause);
 
     // Update the head atom
-    renamedClone->getHead()->setQualifiedName(
-            ast::QualifiedName::fromString(getClauseAtomName(clause, clause.getHead())));
+    renamedClone->getHead()->setQualifiedName(getClauseAtomName(clause, clause.getHead()));
 
     // Update the body atoms
     const auto& cloneAtoms = ast::getBodyLiterals<ast::Atom>(*renamedClone);
@@ -96,18 +91,14 @@ std::string ClauseTranslator::getClauseString(const ast::Clause& clause) const {
         const auto* originalAtom = originalAtoms.at(i);
         assert(originalAtom->getQualifiedName() == cloneAtom->getQualifiedName() &&
                 "atom sequence in clone should match");
-        cloneAtom->setQualifiedName(ast::QualifiedName::fromString(getClauseAtomName(clause, originalAtom)));
+        cloneAtom->setQualifiedName(getClauseAtomName(clause, originalAtom));
     }
 
     return toString(*renamedClone);
 }
 
-std::string ClauseTranslator::getClauseAtomName(const ast::Clause& clause, const ast::Atom* atom) const {
-    return getAtomName(clause, atom, sccAtoms, version, isRecursive(), mode);
-}
-
 Own<ram::Statement> ClauseTranslator::translateRecursiveClause(
-        const ast::Clause& clause, const ast::RelationSet& scc, std::size_t version) {
+        const ast::Clause& clause, const std::set<const ast::Relation*>& scc, std::size_t version) {
     // Update version config
     sccAtoms = filter(ast::getBodyLiterals<ast::Atom>(clause),
             [&](auto* atom) { return contains(scc, context.getProgram()->getRelation(*atom)); });
@@ -117,7 +108,7 @@ Own<ram::Statement> ClauseTranslator::translateRecursiveClause(
     Own<ram::Statement> rule = translateNonRecursiveClause(clause);
 
     // Add logging
-    if (context.getGlobal()->config().has("profile")) {
+    if (Global::config().has("profile")) {
         const std::string& relationName = getConcreteRelationName(clause.getHead()->getQualifiedName());
         const auto& srcLocation = clause.getSrcLoc();
         const std::string clauseText = stringify(toString(clause));
@@ -131,8 +122,7 @@ Own<ram::Statement> ClauseTranslator::translateRecursiveClause(
 
     // Add debug info
     std::ostringstream ds;
-    clause.printForDebugInfo(ds);
-    ds << "\nin file ";
+    ds << toString(clause) << "\nin file ";
     ds << clause.getSrcLoc();
     rule = mk<ram::DebugInfo>(std::move(rule), ds.str());
 
@@ -148,6 +138,55 @@ Own<ram::Statement> ClauseTranslator::translateNonRecursiveClause(const ast::Cla
     return createRamRuleQuery(clause);
 }
 
+std::string ClauseTranslator::getClauseAtomName(const ast::Clause& clause, const ast::Atom* atom) const {
+    if (isA<ast::SubsumptiveClause>(clause)) {
+        // find the dominated / dominating heads
+        const auto& body = clause.getBodyLiterals();
+        auto dominatedHeadAtom = dynamic_cast<const ast::Atom*>(body[0]);
+        auto dominatingHeadAtom = dynamic_cast<const ast::Atom*>(body[1]);
+
+        if (clause.getHead() == atom) {
+            if (mode == SubsumeDeleteCurrentDelta || mode == SubsumeDeleteCurrentCurrent) {
+                return getDeleteRelationName(atom->getQualifiedName());
+            }
+            return getRejectRelationName(atom->getQualifiedName());
+        }
+
+        if (dominatedHeadAtom == atom) {
+            if (mode == SubsumeDeleteCurrentDelta || mode == SubsumeDeleteCurrentCurrent) {
+                return getConcreteRelationName(atom->getQualifiedName());
+            }
+            return getNewRelationName(atom->getQualifiedName());
+        }
+
+        if (dominatingHeadAtom == atom) {
+            switch (mode) {
+                case SubsumeRejectNewCurrent:
+                case SubsumeDeleteCurrentCurrent: return getConcreteRelationName(atom->getQualifiedName());
+                case SubsumeDeleteCurrentDelta: return getDeltaRelationName(atom->getQualifiedName());
+                default: return getNewRelationName(atom->getQualifiedName());
+            }
+        }
+
+        if (isRecursive()) {
+            if (sccAtoms.at(version + 1) == atom) {
+                return getDeltaRelationName(atom->getQualifiedName());
+            }
+        }
+    }
+
+    if (!isRecursive()) {
+        return getConcreteRelationName(atom->getQualifiedName());
+    }
+    if (clause.getHead() == atom) {
+        return getNewRelationName(atom->getQualifiedName());
+    }
+    if (sccAtoms.at(version) == atom) {
+        return getDeltaRelationName(atom->getQualifiedName());
+    }
+    return getConcreteRelationName(atom->getQualifiedName());
+}
+
 Own<ram::Statement> ClauseTranslator::createRamFactQuery(const ast::Clause& clause) const {
     assert(isFact(clause) && "clause should be fact");
     assert(!isRecursive() && "recursive clauses cannot have facts");
@@ -240,7 +279,7 @@ Own<ram::Operation> ClauseTranslator::addAtomScan(Own<ram::Operation> op, const
         }
 
         std::stringstream ss;
-        if (context.getGlobal()->config().has("profile")) {
+        if (Global::config().has("profile")) {
             ss << "@frequency-atom" << ';';
             ss << clause.getHead()->getQualifiedName() << ';';
             ss << version << ';';
@@ -387,23 +426,10 @@ Own<ram::Operation> ClauseTranslator::instantiateAggregator(Own<ram::Operation>
     const auto* aggExpr = agg->getTargetExpression();
     auto expr = aggExpr ? context.translateValue(*valueIndex, aggExpr) : nullptr;
 
-    auto aggregator = [&]() -> Own<ram::Aggregator> {
-        if (const auto* ia = as<ast::IntrinsicAggregator>(agg)) {
-            return mk<ram::IntrinsicAggregator>(context.getOverloadedAggregatorOperator(*ia));
-        } else if (const auto* uda = as<ast::UserDefinedAggregator>(agg)) {
-            return mk<ram::UserDefinedAggregator>(uda->getBaseOperatorName(),
-                    context.translateValue(*valueIndex, uda->getInit()),
-                    context.getFunctorParamTypeAtributes(*uda), context.getFunctorReturnTypeAttribute(*uda),
-                    context.isStatefulFunctor(*uda));
-        } else {
-            fatal("Unhandled aggregate operation");
-        }
-    }();
-
     // add Ram-Aggregation layer
-    return mk<ram::Aggregate>(std::move(op), std::move(aggregator), getClauseAtomName(clause, aggAtom),
-            expr ? std::move(expr) : mk<ram::UndefValue>(), aggCond ? std::move(aggCond) : mk<ram::True>(),
-            curLevel);
+    return mk<ram::Aggregate>(std::move(op), context.getOverloadedAggregatorOperator(*agg),
+            getClauseAtomName(clause, aggAtom), expr ? std::move(expr) : mk<ram::UndefValue>(),
+            aggCond ? std::move(aggCond) : mk<ram::True>(), curLevel);
 }
 
 Own<ram::Operation> ClauseTranslator::instantiateMultiResultFunctor(
@@ -680,11 +706,7 @@ std::vector<ast::Atom*> ClauseTranslator::getAtomOrdering(const ast::Clause& cla
         }
     }
 
-    std::vector<std::string> atomNames;
-    for (auto* atom : atoms) {
-        atomNames.push_back(getClauseAtomName(clause, atom));
-    }
-    auto newOrder = context.getSipsMetric()->getReordering(&clause, atomNames);
+    auto newOrder = context.getSipsMetric()->getReordering(&clause, version, mode);
     return reorderAtoms(atoms, newOrder);
 }
 
@@ -775,6 +797,9 @@ void ClauseTranslator::indexAggregatorBody(const ast::Aggregator& agg) {
 }
 
 void ClauseTranslator::indexAggregators(const ast::Clause& clause) {
+    // Add each aggregator as an internal generator
+    visit(clause, [&](const ast::Aggregator& agg) { indexGenerator(agg); });
+
     // Index aggregator bodies
     visit(clause, [&](const ast::Aggregator& agg) { indexAggregatorBody(agg); });
 
@@ -789,6 +814,13 @@ void ClauseTranslator::indexAggregators(const ast::Clause& clause) {
 }
 
 void ClauseTranslator::indexMultiResultFunctors(const ast::Clause& clause) {
+    // Add each multi-result functor as an internal generator
+    visit(clause, [&](const ast::IntrinsicFunctor& func) {
+        if (ast::analysis::FunctorAnalysis::isMultiResult(func)) {
+            indexGenerator(func);
+        }
+    });
+
     // Add multi-result functor value introductions
     visit(clause, [&](const ast::BinaryConstraint& bc) {
         if (!isEqConstraint(bc.getBaseOperator())) return;
@@ -800,94 +832,8 @@ void ClauseTranslator::indexMultiResultFunctors(const ast::Clause& clause) {
     });
 }
 
-void ClauseTranslator::indexGenerators(const ast::Clause& clause) {
-    // generators must be indexed in topological order according to
-    // dependencies between them.
-    // see issue #2416
-
-    std::map<std::string, const ast::Argument*> varGenerator;
-
-    visit(clause, [&](const ast::BinaryConstraint& bc) {
-        if (!isEqConstraint(bc.getBaseOperator())) return;
-        const auto* lhs = as<ast::Variable>(bc.getLHS());
-        const ast::Argument* rhs = as<ast::IntrinsicFunctor>(bc.getRHS());
-        if (rhs == nullptr) {
-            rhs = as<ast::Aggregator>(bc.getRHS());
-        } else {
-            if (!ast::analysis::FunctorAnalysis::isMultiResult(*as<ast::IntrinsicFunctor>(rhs))) return;
-        }
-        if (lhs == nullptr || rhs == nullptr) return;
-        varGenerator[lhs->getName()] = rhs;
-    });
-
-    // all the generators in the clause
-    std::vector<const ast::Argument*> generators;
-
-    // 'predecessor' mapping from a generator to the generators that must
-    // evaluate before.
-    std::multimap<const ast::Argument*, const ast::Argument*> dependencies;
-
-    // harvest generators and dependencies
-    visit(clause, [&](const ast::Argument& arg) {
-        if (const ast::IntrinsicFunctor* func = as<ast::IntrinsicFunctor>(arg)) {
-            if (ast::analysis::FunctorAnalysis::isMultiResult(*func)) {
-                generators.emplace_back(func);
-                visit(func, [&](const ast::Variable& use) {
-                    if (varGenerator.count(use.getName()) > 0) {
-                        dependencies.emplace(func, varGenerator.at(use.getName()));
-                    }
-                });
-            }
-        } else if (const ast::Aggregator* agg = as<ast::Aggregator>(arg)) {
-            generators.emplace_back(agg);
-            visit(agg, [&](const ast::Variable& use) {
-                if (varGenerator.count(use.getName()) > 0) {
-                    dependencies.emplace(agg, varGenerator.at(use.getName()));
-                }
-            });
-        }
-    });
-
-    // the set of already indexed generators
-    std::set<const ast::Argument*> indexed;
-    // the recursion stack to detect a cycle in the depth-first traversal
-    std::set<const ast::Argument*> recStack;
-
-    // recursive depth-first traversal, perform a post-order indexing of genertors.
-    const std::function<void(const ast::Argument*)> dfs = [&](const ast::Argument* reached) {
-        if (indexed.count(reached)) {
-            return;
-        }
-
-        if (!recStack.emplace(reached).second) {
-            // cycle detected
-            fatal("cyclic dependency");
-        }
-
-        auto range = dependencies.equal_range(reached);
-        for (auto it = range.first; it != range.second; ++it) {
-            if (it->second == reached) {
-                continue;  // ignore self-dependency
-            }
-            dfs(it->second);
-        }
-
-        // index this generator
-        indexGenerator(*reached);
-
-        indexed.insert(reached);
-        recStack.erase(reached);
-    };
-
-    // topological sorting by depth-first search
-    for (const ast::Argument* root : generators) {
-        dfs(root);
-    }
-}
-
 void ClauseTranslator::indexClause(const ast::Clause& clause) {
     indexAtoms(clause);
-    indexGenerators(clause);
     indexAggregators(clause);
     indexMultiResultFunctors(clause);
 }
diff --git a/src/ast2ram/seminaive/ClauseTranslator.h b/src/ast2ram/seminaive/ClauseTranslator.h
index 5d3bcb2..d2901e4 100644
--- a/src/ast2ram/seminaive/ClauseTranslator.h
+++ b/src/ast2ram/seminaive/ClauseTranslator.h
@@ -57,7 +57,7 @@ public:
     /** Entry points */
     Own<ram::Statement> translateNonRecursiveClause(const ast::Clause& clause);
     Own<ram::Statement> translateRecursiveClause(
-            const ast::Clause& clause, const ast::RelationSet& scc, std::size_t version);
+            const ast::Clause& clause, const std::set<const ast::Relation*>& scc, std::size_t version);
 
 protected:
     std::size_t version{0};
@@ -66,6 +66,7 @@ protected:
     bool isRecursive() const;
 
     std::string getClauseString(const ast::Clause& clause) const;
+
     std::string getClauseAtomName(const ast::Clause& clause, const ast::Atom* atom) const;
 
     virtual Own<ram::Operation> addNegatedAtom(
@@ -87,7 +88,6 @@ protected:
 
     /** Indexing */
     void indexClause(const ast::Clause& clause);
-    void indexGenerators(const ast::Clause& clause);
     virtual void indexAtoms(const ast::Clause& clause);
     void indexAggregators(const ast::Clause& clause);
     void indexMultiResultFunctors(const ast::Clause& clause);
diff --git a/src/ast2ram/seminaive/UnitTranslator.cpp b/src/ast2ram/seminaive/UnitTranslator.cpp
index 47d486e..d6137ef 100644
--- a/src/ast2ram/seminaive/UnitTranslator.cpp
+++ b/src/ast2ram/seminaive/UnitTranslator.cpp
@@ -20,15 +20,12 @@
 #include "ast/Relation.h"
 #include "ast/SubsumptiveClause.h"
 #include "ast/TranslationUnit.h"
-#include "ast/UserDefinedFunctor.h"
 #include "ast/analysis/TopologicallySortedSCCGraph.h"
 #include "ast/utility/Utils.h"
 #include "ast/utility/Visitor.h"
 #include "ast2ram/ClauseTranslator.h"
 #include "ast2ram/utility/TranslatorContext.h"
 #include "ast2ram/utility/Utils.h"
-#include "ram/Aggregate.h"
-#include "ram/Assign.h"
 #include "ram/Call.h"
 #include "ram/Clear.h"
 #include "ram/Condition.h"
@@ -43,7 +40,6 @@
 #include "ram/Filter.h"
 #include "ram/IO.h"
 #include "ram/Insert.h"
-#include "ram/IntrinsicOperator.h"
 #include "ram/LogRelationTimer.h"
 #include "ram/LogSize.h"
 #include "ram/LogTimer.h"
@@ -62,11 +58,6 @@
 #include "ram/Swap.h"
 #include "ram/TranslationUnit.h"
 #include "ram/TupleElement.h"
-#include "ram/UndefValue.h"
-#include "ram/UnsignedConstant.h"
-#include "ram/UserDefinedAggregator.h"
-#include "ram/UserDefinedOperator.h"
-#include "ram/Variable.h"
 #include "ram/utility/Utils.h"
 #include "reports/DebugReport.h"
 #include "reports/ErrorReport.h"
@@ -80,7 +71,6 @@
 #include <cassert>
 #include <chrono>
 #include <cstddef>
-#include <cstdint>
 #include <map>
 #include <memory>
 #include <set>
@@ -118,11 +108,10 @@ Own<ram::Statement> UnitTranslator::generateNonRecursiveRelation(const ast::Rela
         }
 
         // Translate clause
-        TranslationMode mode = rel.getAuxiliaryArity() > 0 ? Auxiliary : DEFAULT;
-        Own<ram::Statement> rule = context->translateNonRecursiveClause(*clause, mode);
+        Own<ram::Statement> rule = context->translateNonRecursiveClause(*clause);
 
         // Add logging
-        if (glb->config().has("profile")) {
+        if (Global::config().has("profile")) {
             const std::string& relationName = toString(rel.getQualifiedName());
             const auto& srcLocation = clause->getSrcLoc();
             const std::string clauseText = stringify(toString(*clause));
@@ -133,8 +122,7 @@ Own<ram::Statement> UnitTranslator::generateNonRecursiveRelation(const ast::Rela
 
         // Add debug info
         std::ostringstream ds;
-        clause->printForDebugInfo(ds);
-        ds << "\nin file ";
+        ds << toString(*clause) << "\nin file ";
         ds << clause->getSrcLoc();
         rule = mk<ram::DebugInfo>(std::move(rule), ds.str());
 
@@ -143,7 +131,7 @@ Own<ram::Statement> UnitTranslator::generateNonRecursiveRelation(const ast::Rela
     }
 
     // Add logging for entire relation
-    if (glb->config().has("profile")) {
+    if (Global::config().has("profile")) {
         const std::string& relationName = toString(rel.getQualifiedName());
         const auto& srcLocation = rel.getSrcLoc();
         const std::string logSizeStatement = LogStatement::nNonrecursiveRelation(relationName, srcLocation);
@@ -183,24 +171,14 @@ Own<ram::Statement> UnitTranslator::generateStratum(std::size_t scc) const {
         const auto* rel = *sccRelations.begin();
         appendStmt(current, generateNonRecursiveRelation(*rel));
 
-        // lub auxiliary arities using the @lub relation
-        if (rel->getAuxiliaryArity() > 0) {
-            std::string mainRelation = getConcreteRelationName(rel->getQualifiedName());
-            std::string newRelation = getNewRelationName(rel->getQualifiedName());
-            std::string deltaRelation = getDeltaRelationName(rel->getQualifiedName());
-            appendStmt(current, generateStratumLubSequence(*rel, false));
-            std::map<std::string, std::string> directives;
-            appendStmt(current, mk<ram::Clear>(newRelation));
-        }
-
         // issue delete sequence for non-recursive subsumptions
-        appendStmt(current, generateNonRecursiveDelete(*rel));
+        appendStmt(current, generateNonRecursiveDelete(sccRelations));
     }
 
     // Get all non-recursive relation statements
-    auto nonRecursiveJoinSizeStatements = context->getNonRecursiveJoinSizeStatementsInSCC(scc);
-    auto joinSizeSequence = mk<ram::Sequence>(std::move(nonRecursiveJoinSizeStatements));
-    appendStmt(current, std::move(joinSizeSequence));
+    auto nonRecursiveUniqueKeyStatements = context->getNonRecursiveUniqueKeyStatementsInSCC(scc);
+    auto uniqueKeySequence = mk<ram::Sequence>(std::move(nonRecursiveUniqueKeyStatements));
+    appendStmt(current, std::move(uniqueKeySequence));
 
     // Store all internal output relations to the output dir with a .csv extension
     for (const auto& relation : context->getOutputRelationsInSCC(scc)) {
@@ -211,7 +189,7 @@ Own<ram::Statement> UnitTranslator::generateStratum(std::size_t scc) const {
 }
 
 Own<ram::Statement> UnitTranslator::generateClearExpiredRelations(
-        const ast::RelationSet& expiredRelations) const {
+        const std::set<const ast::Relation*>& expiredRelations) const {
     VecOwn<ram::Statement> stmts;
     for (const auto& relation : expiredRelations) {
         appendStmt(stmts, generateClearRelation(relation));
@@ -282,31 +260,8 @@ Own<ram::Statement> UnitTranslator::generateMergeRelations(
     return stmt;
 }
 
-Own<ram::Statement> UnitTranslator::generateDebugRelation(const ast::Relation* rel,
-        const std::string& destRelation, const std::string& srcRelation,
-        Own<ram::Expression> iteration) const {
-    VecOwn<ram::Expression> values;
-
-    for (std::size_t i = 0; i < rel->getArity(); i++) {
-        values.push_back(mk<ram::TupleElement>(0, i));
-    }
-
-    values.push_back(std::move(iteration));
-
-    // Proposition - insert if not empty
-    if (rel->getArity() == 0) {
-        auto insertion = mk<ram::Insert>(destRelation, std::move(values));
-        return mk<ram::Query>(mk<ram::Filter>(
-                mk<ram::Negation>(mk<ram::EmptinessCheck>(srcRelation)), std::move(insertion)));
-    }
-
-    auto insertion = mk<ram::Insert>(destRelation, std::move(values));
-    auto stmt = mk<ram::Query>(mk<ram::Scan>(srcRelation, 0, std::move(insertion)));
-    return stmt;
-}
-
 Own<ram::Statement> UnitTranslator::translateRecursiveClauses(
-        const ast::RelationSet& scc, const ast::Relation* rel) const {
+        const std::set<const ast::Relation*>& scc, const ast::Relation* rel) const {
     assert(contains(scc, rel) && "relation should belong to scc");
     VecOwn<ram::Statement> code;
 
@@ -328,7 +283,7 @@ Own<ram::Statement> UnitTranslator::translateRecursiveClauses(
 }
 
 Own<ram::Statement> UnitTranslator::translateSubsumptiveRecursiveClauses(
-        const ast::RelationSet& scc, const ast::Relation* rel) const {
+        const std::set<const ast::Relation*>& scc, const ast::Relation* rel) const {
     assert(contains(scc, rel) && "relation should belong to scc");
 
     VecOwn<ram::Statement> code;
@@ -352,11 +307,15 @@ Own<ram::Statement> UnitTranslator::translateSubsumptiveRecursiveClauses(
             continue;
         }
 
-        const std::size_t version = 0;
-        // find dominated tuples in the newR by tuples in newR  and store them in rejectR
-        appendStmt(code, context->translateRecursiveClause(*clause, scc, version, SubsumeRejectNewNew));
-        // find dominated tuples in the newR by tuples in R and store them in rejectR
-        appendStmt(code, context->translateRecursiveClause(*clause, scc, version, SubsumeRejectNewCurrent));
+        const auto& sccAtoms = getSccAtoms(clause, scc);
+        for (std::size_t version = 0; version < sccAtoms.size(); version++) {
+            // find dominated tuples in the newR by tuples in newR  and store them in rejectR
+            appendStmt(code, context->translateRecursiveClause(*clause, scc, version, SubsumeRejectNewNew));
+
+            // find dominated tuples in the newR by tuples in R and store them in rejectR
+            appendStmt(
+                    code, context->translateRecursiveClause(*clause, scc, version, SubsumeRejectNewCurrent));
+        }
     }
 
     // compute new delta set, i.e., deltaR = newR \ rejectR
@@ -374,9 +333,8 @@ Own<ram::Statement> UnitTranslator::translateSubsumptiveRecursiveClauses(
         const auto& sccAtoms = getSccAtoms(clause, scc);
         std::size_t sz = sccAtoms.size();
         for (std::size_t version = 0; version < sz; version++) {
-            appendStmt(
-                    code, context->translateRecursiveClause(*clause, scc, version,
-                                  (version >= 1) ? SubsumeDeleteCurrentCurrent : SubsumeDeleteCurrentDelta));
+            appendStmt(code, context->translateRecursiveClause(*clause, scc, version,
+                                     (sz > 1) ? SubsumeDeleteCurrentCurrent : SubsumeDeleteCurrentDelta));
         }
         appendStmt(code, generateEraseTuples(rel, mainRelation, deleteRelation));
         appendStmt(code, mk<ram::Clear>(deleteRelation));
@@ -386,7 +344,7 @@ Own<ram::Statement> UnitTranslator::translateSubsumptiveRecursiveClauses(
 }
 
 std::vector<ast::Atom*> UnitTranslator::getSccAtoms(
-        const ast::Clause* clause, const ast::RelationSet& scc) const {
+        const ast::Clause* clause, const std::set<const ast::Relation*>& scc) const {
     const auto& sccAtoms = filter(ast::getBodyLiterals<ast::Atom>(*clause), [&](const ast::Atom* atom) {
         if (isA<ast::SubsumptiveClause>(clause)) {
             const auto& body = clause->getBodyLiterals();
@@ -400,7 +358,7 @@ std::vector<ast::Atom*> UnitTranslator::getSccAtoms(
 }
 
 VecOwn<ram::Statement> UnitTranslator::generateClauseVersions(
-        const ast::Clause* clause, const ast::RelationSet& scc) const {
+        const ast::Clause* clause, const std::set<const ast::Relation*>& scc) const {
     const auto& sccAtoms = getSccAtoms(clause, scc);
 
     // Create each version
@@ -421,51 +379,55 @@ VecOwn<ram::Statement> UnitTranslator::generateClauseVersions(
     return clauseVersions;
 }
 
-Own<ram::Statement> UnitTranslator::generateNonRecursiveDelete(const ast::Relation& rel) const {
+Own<ram::Statement> UnitTranslator::generateNonRecursiveDelete(
+        const std::set<const ast::Relation*>& scc) const {
     VecOwn<ram::Statement> code;
 
     // Generate code for non-recursive subsumption
-    if (!context->hasSubsumptiveClause(rel.getQualifiedName())) {
-        return mk<ram::Sequence>(std::move(code));
-    }
-
-    std::string mainRelation = getConcreteRelationName(rel.getQualifiedName());
-    std::string deleteRelation = getDeleteRelationName(rel.getQualifiedName());
-
-    // Compute subsumptive deletions for non-recursive rules
-    for (auto clause : context->getProgram()->getClauses(rel)) {
-        if (!isA<ast::SubsumptiveClause>(clause)) {
+    for (const ast::Relation* rel : scc) {
+        if (!context->hasSubsumptiveClause(rel->getQualifiedName())) {
             continue;
         }
 
-        // Translate subsumptive clause
-        Own<ram::Statement> rule = context->translateNonRecursiveClause(*clause, SubsumeDeleteCurrentCurrent);
+        std::string mainRelation = getConcreteRelationName(rel->getQualifiedName());
+        std::string deleteRelation = getDeleteRelationName(rel->getQualifiedName());
 
-        // Add logging for subsumptive clause
-        if (glb->config().has("profile")) {
-            const std::string& relationName = toString(rel.getQualifiedName());
-            const auto& srcLocation = clause->getSrcLoc();
-            const std::string clauseText = stringify(toString(*clause));
-            const std::string logTimerStatement =
-                    LogStatement::tNonrecursiveRule(relationName, srcLocation, clauseText);
-            rule = mk<ram::LogRelationTimer>(std::move(rule), logTimerStatement, mainRelation);
-        }
+        // Compute subsumptive deletions for non-recursive rules
+        for (auto clause : context->getProgram()->getClauses(*rel)) {
+            if (!isA<ast::SubsumptiveClause>(clause)) {
+                continue;
+            }
 
-        // Add debug info for subsumptive clause
-        std::ostringstream ds;
-        ds << toString(*clause) << "\nin file ";
-        ds << clause->getSrcLoc();
-        rule = mk<ram::DebugInfo>(std::move(rule), ds.str());
+            // Translate subsumptive clause
+            Own<ram::Statement> rule =
+                    context->translateNonRecursiveClause(*clause, SubsumeDeleteCurrentCurrent);
+
+            // Add logging for subsumptive clause
+            if (Global::config().has("profile")) {
+                const std::string& relationName = toString(rel->getQualifiedName());
+                const auto& srcLocation = clause->getSrcLoc();
+                const std::string clauseText = stringify(toString(*clause));
+                const std::string logTimerStatement =
+                        LogStatement::tNonrecursiveRule(relationName, srcLocation, clauseText);
+                rule = mk<ram::LogRelationTimer>(std::move(rule), logTimerStatement, mainRelation);
+            }
+
+            // Add debug info for subsumptive clause
+            std::ostringstream ds;
+            ds << toString(*clause) << "\nin file ";
+            ds << clause->getSrcLoc();
+            rule = mk<ram::DebugInfo>(std::move(rule), ds.str());
 
-        // Add subsumptive rule to result
-        appendStmt(code, std::move(rule));
+            // Add subsumptive rule to result
+            appendStmt(code, std::move(rule));
+        }
+        appendStmt(code, mk<ram::Sequence>(generateEraseTuples(rel, mainRelation, deleteRelation),
+                                 mk<ram::Clear>(deleteRelation)));
     }
-    appendStmt(code, mk<ram::Sequence>(generateEraseTuples(&rel, mainRelation, deleteRelation),
-                             mk<ram::Clear>(deleteRelation)));
     return mk<ram::Sequence>(std::move(code));
 }
 
-Own<ram::Statement> UnitTranslator::generateStratumPreamble(const ast::RelationSet& scc) const {
+Own<ram::Statement> UnitTranslator::generateStratumPreamble(const std::set<const ast::Relation*>& scc) const {
     VecOwn<ram::Statement> preamble;
 
     // Generate code for non-recursive rules
@@ -473,34 +435,22 @@ Own<ram::Statement> UnitTranslator::generateStratumPreamble(const ast::RelationS
         std::string deltaRelation = getDeltaRelationName(rel->getQualifiedName());
         std::string mainRelation = getConcreteRelationName(rel->getQualifiedName());
         appendStmt(preamble, generateNonRecursiveRelation(*rel));
-        // lub tuples using the @lub relation
-        if (rel->getAuxiliaryArity() > 0) {
-            std::string newRelation = getNewRelationName(rel->getQualifiedName());
-            appendStmt(preamble, generateStratumLubSequence(*rel, false));
-        }
-        // Generate non recursive delete sequences for subsumptive rules
-        appendStmt(preamble, generateNonRecursiveDelete(*rel));
     }
 
+    // Generate non recursive delete sequences for subsumptive rules
+    appendStmt(preamble, generateNonRecursiveDelete(scc));
+
     // Generate code for priming relation
     for (const ast::Relation* rel : scc) {
         std::string deltaRelation = getDeltaRelationName(rel->getQualifiedName());
         std::string mainRelation = getConcreteRelationName(rel->getQualifiedName());
         appendStmt(preamble, generateMergeRelations(rel, deltaRelation, mainRelation));
     }
-
-    for (const ast::Relation* rel : scc) {
-        if (const auto* debugRel = context->getDeltaDebugRelation(rel)) {
-            const std::string debugRelation = getConcreteRelationName(debugRel->getQualifiedName());
-            std::string deltaRelation = getDeltaRelationName(rel->getQualifiedName());
-            appendStmt(preamble,
-                    generateDebugRelation(rel, debugRelation, deltaRelation, mk<ram::UnsignedConstant>(0)));
-        }
-    }
     return mk<ram::Sequence>(std::move(preamble));
 }
 
-Own<ram::Statement> UnitTranslator::generateStratumPostamble(const ast::RelationSet& scc) const {
+Own<ram::Statement> UnitTranslator::generateStratumPostamble(
+        const std::set<const ast::Relation*>& scc) const {
     VecOwn<ram::Statement> postamble;
     for (const ast::Relation* rel : scc) {
         // Drop temporary tables after recursion
@@ -510,7 +460,8 @@ Own<ram::Statement> UnitTranslator::generateStratumPostamble(const ast::Relation
     return mk<ram::Sequence>(std::move(postamble));
 }
 
-Own<ram::Statement> UnitTranslator::generateStratumTableUpdates(const ast::RelationSet& scc) const {
+Own<ram::Statement> UnitTranslator::generateStratumTableUpdates(
+        const std::set<const ast::Relation*>& scc) const {
     VecOwn<ram::Statement> updateTable;
 
     for (const ast::Relation* rel : scc) {
@@ -521,11 +472,7 @@ Own<ram::Statement> UnitTranslator::generateStratumTableUpdates(const ast::Relat
 
         // swap new and and delta relation and clear new relation afterwards (if not a subsumptive relation)
         Own<ram::Statement> updateRelTable;
-        if (rel->getAuxiliaryArity() > 0) {
-            updateRelTable =
-                    mk<ram::Sequence>(mk<ram::Clear>(deltaRelation), generateStratumLubSequence(*rel, true),
-                            generateMergeRelations(rel, mainRelation, deltaRelation));
-        } else if (!context->hasSubsumptiveClause(rel->getQualifiedName())) {
+        if (!context->hasSubsumptiveClause(rel->getQualifiedName())) {
             updateRelTable = mk<ram::Sequence>(generateMergeRelations(rel, mainRelation, newRelation),
                     mk<ram::Swap>(deltaRelation, newRelation), mk<ram::Clear>(newRelation));
         } else {
@@ -533,30 +480,22 @@ Own<ram::Statement> UnitTranslator::generateStratumTableUpdates(const ast::Relat
         }
 
         // Measure update time
-        if (glb->config().has("profile")) {
+        if (Global::config().has("profile")) {
             updateRelTable = mk<ram::LogRelationTimer>(std::move(updateRelTable),
                     LogStatement::cRecursiveRelation(toString(rel->getQualifiedName()), rel->getSrcLoc()),
                     newRelation);
         }
 
         appendStmt(updateTable, std::move(updateRelTable));
-        if (const auto* debugRel = context->getDeltaDebugRelation(rel)) {
-            const std::string debugRelation = getConcreteRelationName(debugRel->getQualifiedName());
-            appendStmt(updateTable, generateDebugRelation(rel, debugRelation, deltaRelation,
-                                            mk<ram::Variable>("loop_counter")));
-        }
     }
     return mk<ram::Sequence>(std::move(updateTable));
 }
 
-Own<ram::Statement> UnitTranslator::generateStratumLoopBody(const ast::RelationSet& scc) const {
+Own<ram::Statement> UnitTranslator::generateStratumLoopBody(const std::set<const ast::Relation*>& scc) const {
     VecOwn<ram::Statement> loopBody;
 
-    const bool hasProfile = glb->config().has("profile");
-
-    auto addProfiling = [hasProfile](
-                                const ast::Relation* rel, Own<ram::Statement> stmt) -> Own<ram::Statement> {
-        if (hasProfile) {
+    auto addProfiling = [](const ast::Relation* rel, Own<ram::Statement> stmt) -> Own<ram::Statement> {
+        if (Global::config().has("profile")) {
             const std::string& relationName = toString(rel->getQualifiedName());
             const auto& srcLocation = rel->getSrcLoc();
             const std::string logTimerStatement = LogStatement::tRecursiveRelation(relationName, srcLocation);
@@ -585,135 +524,8 @@ Own<ram::Statement> UnitTranslator::generateStratumLoopBody(const ast::RelationS
     return mk<ram::Sequence>(std::move(loopBody));
 }
 
-/// assuming the @new() relation is populated with new tuples, generate RAM code
-/// to populate the @delta() relation with the lubbed elements from @new()
-Own<ram::Statement> UnitTranslator::generateStratumLubSequence(
-        const ast::Relation& rel, bool inRecursiveLoop) const {
-    VecOwn<ram::Statement> stmts;
-    assert(rel.getAuxiliaryArity() > 0);
-
-    auto attributes = rel.getAttributes();
-    std::string name = getConcreteRelationName(rel.getQualifiedName());
-    std::string lubName = getLubRelationName(rel.getQualifiedName());
-    std::string newName = getNewRelationName(rel.getQualifiedName());
-
-    const std::size_t arity = rel.getArity();
-    const std::size_t auxiliaryArity = rel.getAuxiliaryArity();
-
-    // Step 1 : populate @lub() from @new()
-    VecOwn<ram::Expression> values;
-
-    // index of the first auxiliary element of the relation
-    std::size_t firstAuxiliary = arity - auxiliaryArity;
-
-    for (std::size_t i = 0; i < arity; i++) {
-        if (i >= firstAuxiliary) {
-            values.push_back(mk<ram::TupleElement>(i - firstAuxiliary + 1, 0));
-        } else {
-            values.push_back(mk<ram::TupleElement>(0, i));
-        }
-    }
-    Own<ram::Operation> op = mk<ram::Insert>(lubName, std::move(values));
-
-    for (std::size_t i = arity; i >= firstAuxiliary + 1; i--) {
-        const auto type = attributes[i - 1]->getTypeName();
-        std::size_t level = i - firstAuxiliary;
-        auto aggregator = context->getLatticeTypeLubAggregator(type, mk<ram::TupleElement>(0, i - 1));
-        Own<ram::Condition> condition = mk<ram::Constraint>(
-                BinaryConstraintOp::NE, mk<ram::TupleElement>(level, i - 1), mk<ram::TupleElement>(0, i - 1));
-        for (std::size_t j = 0; j < attributes.size(); j++) {
-            if (attributes[j]->getIsLattice()) break;
-            condition = mk<ram::Conjunction>(std::move(condition),
-                    mk<ram::Constraint>(BinaryConstraintOp::EQ, mk<ram::TupleElement>(level, j),
-                            mk<ram::TupleElement>(0, j)));
-        }
-        op = mk<ram::Aggregate>(std::move(op), std::move(aggregator), newName,
-                mk<ram::TupleElement>(level, i - 1), std::move(condition), level);
-    }
-
-    op = mk<ram::Scan>(newName, 0, std::move(op));
-    appendStmt(stmts, mk<ram::Query>(std::move(op)));
-
-    // clear @new() now that we no longer need it
-    appendStmt(stmts, mk<ram::Clear>(newName));
-
-    if (inRecursiveLoop) {
-        // Step 2 : populate @delta() from @lub() for tuples that have to be lubbed with @concrete
-        std::string deltaName = getDeltaRelationName(rel.getQualifiedName());
-
-        Own<ram::Condition> condition;
-        for (std::size_t i = 0; i < arity; i++) {
-            if (i < firstAuxiliary) {
-                values.push_back(mk<ram::TupleElement>(0, i));
-            } else {
-                assert(attributes[i]->getIsLattice());
-                const auto type = attributes[i]->getTypeName();
-                VecOwn<ram::Expression> args;
-                args.push_back(mk<ram::TupleElement>(0, i));
-                args.push_back(mk<ram::TupleElement>(1, i));
-                auto lub = context->getLatticeTypeLubFunctor(type, std::move(args));
-                auto cst =
-                        mk<ram::Constraint>(BinaryConstraintOp::EQ, mk<ram::TupleElement>(1, i), clone(lub));
-                if (condition) {
-                    condition = mk<ram::Conjunction>(std::move(condition), std::move(cst));
-                } else {
-                    condition = std::move(cst);
-                }
-                values.push_back(std::move(lub));
-            }
-        }
-        op = mk<ram::Insert>(deltaName, std::move(values));
-        op = mk<ram::Filter>(mk<ram::Negation>(std::move(condition)), std::move(op));
-
-        for (std::size_t i = 0; i < arity - auxiliaryArity; i++) {
-            auto cst = mk<ram::Constraint>(
-                    BinaryConstraintOp::EQ, mk<ram::TupleElement>(0, i), mk<ram::TupleElement>(1, i));
-            if (condition) {
-                condition = mk<ram::Conjunction>(std::move(condition), std::move(cst));
-            } else {
-                condition = std::move(cst);
-            }
-        }
-        if (condition) {
-            op = mk<ram::Filter>(std::move(condition), std::move(op));
-        }
-        op = mk<ram::Scan>(name, 1, std::move(op));
-        op = mk<ram::Scan>(lubName, 0, std::move(op));
-        appendStmt(stmts, mk<ram::Query>(std::move(op)));
-
-        // Step 3 : populate @delta() from @lub() for tuples that have nothing to lub in @concrete
-        for (std::size_t i = 0; i < arity; i++) {
-            values.push_back(mk<ram::TupleElement>(0, i));
-        }
-        op = mk<ram::Insert>(deltaName, std::move(values));
-        for (std::size_t i = 0; i < arity; i++) {
-            if (i < firstAuxiliary) {
-                values.push_back(mk<ram::TupleElement>(0, i));
-            } else {
-                values.push_back(mk<ram::UndefValue>());
-            }
-        }
-        op = mk<ram::Filter>(
-                mk<ram::Negation>(mk<ram::ExistenceCheck>(name, std::move(values))), std::move(op));
-        op = mk<ram::Scan>(lubName, 0, std::move(op));
-        appendStmt(stmts, mk<ram::Query>(std::move(op)));
-    } else {
-        // we are not in the recursive loop, so the concrete relation is empty for now
-        // we can just insert the content of the @lub relation into the concrete one
-        for (std::size_t i = 0; i < arity; i++) {
-            values.push_back(mk<ram::TupleElement>(0, i));
-        }
-        op = mk<ram::Insert>(name, std::move(values));
-        op = mk<ram::Scan>(lubName, 0, std::move(op));
-        appendStmt(stmts, mk<ram::Query>(std::move(op)));
-    }
-
-    appendStmt(stmts, mk<ram::Clear>(lubName));
-
-    return mk<ram::Sequence>(std::move(stmts));
-}
-
-Own<ram::Statement> UnitTranslator::generateStratumExitSequence(const ast::RelationSet& scc) const {
+Own<ram::Statement> UnitTranslator::generateStratumExitSequence(
+        const std::set<const ast::Relation*>& scc) const {
     // Helper function to add a new term to a conjunctive condition
     auto addCondition = [&](Own<ram::Condition>& cond, Own<ram::Condition> term) {
         cond = (cond == nullptr) ? std::move(term) : mk<ram::Conjunction>(std::move(cond), std::move(term));
@@ -749,7 +561,7 @@ Own<ram::Statement> UnitTranslator::generateStratumExitSequence(const ast::Relat
 
 /** generate RAM code for recursive relations in a strongly-connected component */
 Own<ram::Statement> UnitTranslator::generateRecursiveStratum(
-        const ast::RelationSet& scc, std::size_t sccNumber) const {
+        const std::set<const ast::Relation*>& scc, std::size_t sccNumber) const {
     assert(!scc.empty() && "scc set should not be empty");
     VecOwn<ram::Statement> result;
 
@@ -757,23 +569,15 @@ Own<ram::Statement> UnitTranslator::generateRecursiveStratum(
     appendStmt(result, generateStratumPreamble(scc));
 
     // Get all recursive relation statements
-    auto recursiveJoinSizeStatements = context->getRecursiveJoinSizeStatementsInSCC(sccNumber);
-    auto joinSizeSequence = mk<ram::Sequence>(std::move(recursiveJoinSizeStatements));
-
-    const std::string loop_counter = "loop_counter";
-    VecOwn<ram::Expression> inc;
-    inc.push_back(mk<ram::Variable>(loop_counter));
-    inc.push_back(mk<ram::UnsignedConstant>(1));
-    auto increment_counter = mk<ram::Assign>(mk<ram::Variable>(loop_counter),
-            mk<ram::IntrinsicOperator>(FunctorOp::UADD, std::move(inc)), false);
+    auto recursiveUniqueKeyStatements = context->getRecursiveUniqueKeyStatementsInSCC(sccNumber);
+    auto uniqueKeySequence = mk<ram::Sequence>(std::move(recursiveUniqueKeyStatements));
+
     // Add in the main fixpoint loop
     auto loopBody = generateStratumLoopBody(scc);
     auto exitSequence = generateStratumExitSequence(scc);
     auto updateSequence = generateStratumTableUpdates(scc);
-    auto fixpointLoop = mk<ram::Loop>(mk<ram::Sequence>(std::move(loopBody), std::move(joinSizeSequence),
-            std::move(exitSequence), std::move(updateSequence), std::move(increment_counter)));
-
-    appendStmt(result, mk<ram::Assign>(mk<ram::Variable>(loop_counter), mk<ram::UnsignedConstant>(1), true));
+    auto fixpointLoop = mk<ram::Loop>(mk<ram::Sequence>(std::move(loopBody), std::move(uniqueKeySequence),
+            std::move(exitSequence), std::move(updateSequence)));
     appendStmt(result, std::move(fixpointLoop));
 
     // Add in the postamble
@@ -794,7 +598,7 @@ Own<ram::Statement> UnitTranslator::generateLoadRelation(const ast::Relation* re
         for (const auto& [key, value] : load->getParameters()) {
             directives.insert(std::make_pair(key, unescape(value)));
         }
-        if (glb->config().has("no-warn")) {
+        if (Global::config().has("no-warn")) {
             directives.insert(std::make_pair("no-warn", "true"));
         }
         addAuxiliaryArity(relation, directives);
@@ -802,7 +606,7 @@ Own<ram::Statement> UnitTranslator::generateLoadRelation(const ast::Relation* re
         // Create the resultant load statement, with profile information
         std::string ramRelationName = getConcreteRelationName(relation->getQualifiedName());
         Own<ram::Statement> loadStmt = mk<ram::IO>(ramRelationName, directives);
-        if (glb->config().has("profile")) {
+        if (Global::config().has("profile")) {
             const std::string logTimerStatement =
                     LogStatement::tRelationLoadTime(ramRelationName, relation->getSrcLoc());
             loadStmt = mk<ram::LogRelationTimer>(std::move(loadStmt), logTimerStatement, ramRelationName);
@@ -825,7 +629,7 @@ Own<ram::Statement> UnitTranslator::generateStoreRelation(const ast::Relation* r
         // Create the resultant store statement, with profile information
         std::string ramRelationName = getConcreteRelationName(relation->getQualifiedName());
         Own<ram::Statement> storeStmt = mk<ram::IO>(ramRelationName, directives);
-        if (glb->config().has("profile")) {
+        if (Global::config().has("profile")) {
             const std::string logTimerStatement =
                     LogStatement::tRelationSaveTime(ramRelationName, relation->getSrcLoc());
             storeStmt = mk<ram::LogRelationTimer>(std::move(storeStmt), logTimerStatement, ramRelationName);
@@ -838,10 +642,6 @@ Own<ram::Statement> UnitTranslator::generateStoreRelation(const ast::Relation* r
 Own<ram::Relation> UnitTranslator::createRamRelation(
         const ast::Relation* baseRelation, std::string ramRelationName) const {
     auto arity = baseRelation->getArity();
-
-    bool mergeAuxiliary = (ramRelationName != getNewRelationName(baseRelation->getQualifiedName()));
-
-    auto auxArity = mergeAuxiliary ? baseRelation->getAuxiliaryArity() : 0;
     auto representation = baseRelation->getRepresentation();
     if (representation == RelationRepresentation::BTREE_DELETE && ramRelationName[0] == '@') {
         representation = RelationRepresentation::DEFAULT;
@@ -855,7 +655,7 @@ Own<ram::Relation> UnitTranslator::createRamRelation(
     }
 
     return mk<ram::Relation>(
-            ramRelationName, arity, auxArity, attributeNames, attributeTypeQualifiers, representation);
+            ramRelationName, arity, 0, attributeNames, attributeTypeQualifiers, representation);
 }
 
 VecOwn<ram::Relation> UnitTranslator::createRamRelations(const std::vector<std::size_t>& sccOrdering) const {
@@ -867,24 +667,16 @@ VecOwn<ram::Relation> UnitTranslator::createRamRelations(const std::vector<std::
             std::string mainName = getConcreteRelationName(rel->getQualifiedName());
             ramRelations.push_back(createRamRelation(rel, mainName));
 
-            if (rel->getAuxiliaryArity() > 0) {
-                // Add lub relation
-                std::string lubName = getLubRelationName(rel->getQualifiedName());
-                ramRelations.push_back(createRamRelation(rel, lubName));
-            }
-
-            if (isRecursive || rel->getAuxiliaryArity() > 0) {
-                // Add new relation
-                std::string newName = getNewRelationName(rel->getQualifiedName());
-                ramRelations.push_back(createRamRelation(rel, newName));
-            }
-
             // Recursive relations also require @delta and @new variants, with the same signature
             if (isRecursive) {
                 // Add delta relation
                 std::string deltaName = getDeltaRelationName(rel->getQualifiedName());
                 ramRelations.push_back(createRamRelation(rel, deltaName));
 
+                // Add new relation
+                std::string newName = getNewRelationName(rel->getQualifiedName());
+                ramRelations.push_back(createRamRelation(rel, newName));
+
                 // Add auxiliary relation for subsumption
                 if (context->hasSubsumptiveClause(rel->getQualifiedName())) {
                     // Add reject relation
@@ -912,7 +704,6 @@ Own<ram::Sequence> UnitTranslator::generateProgram(const ast::TranslationUnit& t
     }
     const auto& sccOrdering =
             translationUnit.getAnalysis<ast::analysis::TopologicallySortedSCCGraphAnalysis>().order();
-    VecOwn<ram::Statement> res;
 
     // Create subroutines for each SCC according to topological order
     for (std::size_t i = 0; i < sccOrdering.size(); i++) {
@@ -924,17 +715,18 @@ Own<ram::Sequence> UnitTranslator::generateProgram(const ast::TranslationUnit& t
         stratum = mk<ram::Sequence>(std::move(stratum), generateClearExpiredRelations(expiredRelations));
 
         // Add the subroutine
-        const ast::Relation* rel = *context->getRelationsInSCC(sccOrdering.at(i)).begin();
-
-        std::string stratumID = rel->getQualifiedName().toString();
+        std::string stratumID = "stratum_" + toString(i);
         addRamSubroutine(stratumID, std::move(stratum));
+    }
 
-        // invoke the strata
-        appendStmt(res, mk<ram::Call>("stratum_" + stratumID));
+    // Invoke all strata
+    VecOwn<ram::Statement> res;
+    for (std::size_t i = 0; i < sccOrdering.size(); i++) {
+        appendStmt(res, mk<ram::Call>("stratum_" + toString(i)));
     }
 
     // Add main timer if profiling
-    if (!res.empty() && glb->config().has("profile")) {
+    if (!res.empty() && Global::config().has("profile")) {
         auto newStmt = mk<ram::LogTimer>(mk<ram::Sequence>(std::move(res)), LogStatement::runtime());
         res.clear();
         appendStmt(res, std::move(newStmt));
@@ -945,8 +737,6 @@ Own<ram::Sequence> UnitTranslator::generateProgram(const ast::TranslationUnit& t
 }
 
 Own<ram::TranslationUnit> UnitTranslator::translateUnit(ast::TranslationUnit& tu) {
-    glb = &tu.global();
-
     /* -- Set-up -- */
     auto ram_start = std::chrono::high_resolution_clock::now();
     context = mk<TranslatorContext>(tu);
@@ -966,7 +756,7 @@ Own<ram::TranslationUnit> UnitTranslator::translateUnit(ast::TranslationUnit& tu
             mk<ram::Program>(std::move(ramRelations), std::move(ramMain), std::move(ramSubroutines));
 
     // Add the translated program to the debug report
-    if (glb->config().has("debug-report")) {
+    if (Global::config().has("debug-report")) {
         auto ram_end = std::chrono::high_resolution_clock::now();
         std::string runtimeStr =
                 "(" + std::to_string(std::chrono::duration<double>(ram_end - ram_start).count()) + "s)";
@@ -976,7 +766,7 @@ Own<ram::TranslationUnit> UnitTranslator::translateUnit(ast::TranslationUnit& tu
     }
 
     // Wrap the program into a translation unit
-    return mk<ram::TranslationUnit>(tu.global(), std::move(ramProgram), errReport, debugReport);
+    return mk<ram::TranslationUnit>(std::move(ramProgram), errReport, debugReport);
 }
 
 }  // namespace souffle::ast2ram::seminaive
diff --git a/src/ast2ram/seminaive/UnitTranslator.h b/src/ast2ram/seminaive/UnitTranslator.h
index 4be81c5..19f8d7e 100644
--- a/src/ast2ram/seminaive/UnitTranslator.h
+++ b/src/ast2ram/seminaive/UnitTranslator.h
@@ -14,19 +14,13 @@
 
 #pragma once
 
-#include "ast/Relation.h"
 #include "ast2ram/UnitTranslator.h"
-#include "ram/Expression.h"
 #include "souffle/utility/ContainerUtil.h"
 #include <map>
 #include <set>
 #include <string>
 #include <vector>
 
-namespace souffle {
-class Global;
-}
-
 namespace souffle::ast {
 class Clause;
 class Relation;
@@ -56,12 +50,13 @@ protected:
             const ast::Relation* baseRelation, std::string ramRelationName) const;
     virtual VecOwn<ram::Relation> createRamRelations(const std::vector<std::size_t>& sccOrdering) const;
     Own<ram::Statement> translateRecursiveClauses(
-            const ast::RelationSet& scc, const ast::Relation* rel) const;
+            const std::set<const ast::Relation*>& scc, const ast::Relation* rel) const;
     Own<ram::Statement> translateSubsumptiveRecursiveClauses(
-            const ast::RelationSet& scc, const ast::Relation* rel) const;
+            const std::set<const ast::Relation*>& scc, const ast::Relation* rel) const;
     VecOwn<ram::Statement> generateClauseVersions(
-            const ast::Clause* clause, const ast::RelationSet& scc) const;
-    std::vector<ast::Atom*> getSccAtoms(const ast::Clause* clause, const ast::RelationSet& scc) const;
+            const ast::Clause* clause, const std::set<const ast::Relation*>& scc) const;
+    std::vector<ast::Atom*> getSccAtoms(
+            const ast::Clause* clause, const std::set<const ast::Relation*>& scc) const;
 
     virtual void addAuxiliaryArity(
             const ast::Relation* relation, std::map<std::string, std::string>& directives) const;
@@ -71,7 +66,8 @@ protected:
     /** High-level relation translation */
     virtual Own<ram::Sequence> generateProgram(const ast::TranslationUnit& translationUnit);
     Own<ram::Statement> generateNonRecursiveRelation(const ast::Relation& rel) const;
-    Own<ram::Statement> generateRecursiveStratum(const ast::RelationSet& scc, std::size_t sccNum) const;
+    Own<ram::Statement> generateRecursiveStratum(
+            const std::set<const ast::Relation*>& scc, std::size_t sccNum) const;
 
     /** IO translation */
     Own<ram::Statement> generateStoreRelation(const ast::Relation* relation) const;
@@ -79,16 +75,16 @@ protected:
 
     /** Low-level stratum translation */
     Own<ram::Statement> generateStratum(std::size_t scc) const;
-    Own<ram::Statement> generateStratumPreamble(const ast::RelationSet& scc) const;
-    Own<ram::Statement> generateNonRecursiveDelete(const ast::Relation& rel) const;
-    Own<ram::Statement> generateStratumPostamble(const ast::RelationSet& scc) const;
-    Own<ram::Statement> generateStratumLoopBody(const ast::RelationSet& scc) const;
-    Own<ram::Statement> generateStratumTableUpdates(const ast::RelationSet& scc) const;
-    Own<ram::Statement> generateStratumExitSequence(const ast::RelationSet& scc) const;
-    Own<ram::Statement> generateStratumLubSequence(const ast::Relation& rel, bool inRecursiveLoop) const;
+    Own<ram::Statement> generateStratumPreamble(const std::set<const ast::Relation*>& scc) const;
+    Own<ram::Statement> generateNonRecursiveDelete(const std::set<const ast::Relation*>& scc) const;
+    Own<ram::Statement> generateStratumPostamble(const std::set<const ast::Relation*>& scc) const;
+    Own<ram::Statement> generateStratumLoopBody(const std::set<const ast::Relation*>& scc) const;
+    Own<ram::Statement> generateStratumTableUpdates(const std::set<const ast::Relation*>& scc) const;
+    Own<ram::Statement> generateStratumExitSequence(const std::set<const ast::Relation*>& scc) const;
 
     /** Other helper generations */
-    virtual Own<ram::Statement> generateClearExpiredRelations(const ast::RelationSet& expiredRelations) const;
+    virtual Own<ram::Statement> generateClearExpiredRelations(
+            const std::set<const ast::Relation*>& expiredRelations) const;
     Own<ram::Statement> generateClearRelation(const ast::Relation* relation) const;
     virtual Own<ram::Statement> generateMergeRelations(
             const ast::Relation* rel, const std::string& destRelation, const std::string& srcRelation) const;
@@ -97,14 +93,9 @@ protected:
             const std::string& filterRelation) const;
     virtual Own<ram::Statement> generateEraseTuples(
             const ast::Relation* rel, const std::string& destRelation, const std::string& srcRelation) const;
-    virtual Own<ram::Statement> generateDebugRelation(const ast::Relation* rel,
-            const std::string& destRelation, const std::string& srcRelation,
-            Own<ram::Expression> iteration) const;
 
 private:
     std::map<std::string, Own<ram::Statement>> ramSubroutines;
-
-    Global* glb;
 };
 
 }  // namespace souffle::ast2ram::seminaive
diff --git a/src/ast2ram/seminaive/ValueTranslator.cpp b/src/ast2ram/seminaive/ValueTranslator.cpp
index 0f150f9..4dbfffd 100644
--- a/src/ast2ram/seminaive/ValueTranslator.cpp
+++ b/src/ast2ram/seminaive/ValueTranslator.cpp
@@ -33,7 +33,6 @@
 #include "ram/UndefValue.h"
 #include "ram/UnsignedConstant.h"
 #include "ram/UserDefinedOperator.h"
-#include "ram/Variable.h"
 #include "ram/utility/Utils.h"
 #include "souffle/utility/StringUtil.h"
 
@@ -111,11 +110,6 @@ Own<ram::Expression> ValueTranslator::visit_(type_identity<ast::Counter>, const
     return mk<ram::AutoIncrement>();
 }
 
-Own<ram::Expression> ValueTranslator::visit_(
-        type_identity<ast::IterationCounter>, const ast::IterationCounter&) {
-    return mk<ram::Variable>("loop_counter");
-}
-
 Own<ram::Expression> ValueTranslator::visit_(type_identity<ast::RecordInit>, const ast::RecordInit& init) {
     VecOwn<ram::Expression> values;
     for (const auto& cur : init.getArguments()) {
diff --git a/src/ast2ram/seminaive/ValueTranslator.h b/src/ast2ram/seminaive/ValueTranslator.h
index 8e99120..a4774bc 100644
--- a/src/ast2ram/seminaive/ValueTranslator.h
+++ b/src/ast2ram/seminaive/ValueTranslator.h
@@ -62,8 +62,6 @@ public:
     Own<ram::Expression> visit_(
             type_identity<ast::UserDefinedFunctor>, const ast::UserDefinedFunctor& udf) override;
     Own<ram::Expression> visit_(type_identity<ast::Counter>, const ast::Counter& ctr) override;
-    Own<ram::Expression> visit_(
-            type_identity<ast::IterationCounter>, const ast::IterationCounter& ctr) override;
     Own<ram::Expression> visit_(type_identity<ast::RecordInit>, const ast::RecordInit& init) override;
     Own<ram::Expression> visit_(type_identity<ast::BranchInit>, const ast::BranchInit& init) override;
     Own<ram::Expression> visit_(type_identity<ast::Aggregator>, const ast::Aggregator& agg) override;
diff --git a/src/ast2ram/utility/TranslatorContext.cpp b/src/ast2ram/utility/TranslatorContext.cpp
index 9bbf576..2cb0bdc 100644
--- a/src/ast2ram/utility/TranslatorContext.cpp
+++ b/src/ast2ram/utility/TranslatorContext.cpp
@@ -14,53 +14,41 @@
 
 #include "ast2ram/utility/TranslatorContext.h"
 #include "Global.h"
-#include "ast/Aggregator.h"
 #include "ast/Atom.h"
 #include "ast/BranchInit.h"
 #include "ast/Directive.h"
-#include "ast/Functor.h"
-#include "ast/IntrinsicFunctor.h"
 #include "ast/QualifiedName.h"
 #include "ast/SubsumptiveClause.h"
 #include "ast/TranslationUnit.h"
-#include "ast/UserDefinedAggregator.h"
 #include "ast/analysis/Functor.h"
 #include "ast/analysis/IOType.h"
-#include "ast/analysis/JoinSize.h"
 #include "ast/analysis/RecursiveClauses.h"
 #include "ast/analysis/RelationSchedule.h"
 #include "ast/analysis/SCCGraph.h"
+#include "ast/analysis/UniqueKeys.h"
 #include "ast/analysis/typesystem/PolymorphicObjects.h"
 #include "ast/analysis/typesystem/SumTypeBranches.h"
 #include "ast/analysis/typesystem/Type.h"
 #include "ast/analysis/typesystem/TypeEnvironment.h"
 #include "ast/analysis/typesystem/TypeSystem.h"
+#include "ast/utility/SipsMetric.h"
 #include "ast/utility/Utils.h"
 #include "ast2ram/ClauseTranslator.h"
 #include "ast2ram/ConstraintTranslator.h"
 #include "ast2ram/ValueTranslator.h"
 #include "ast2ram/provenance/TranslationStrategy.h"
 #include "ast2ram/seminaive/TranslationStrategy.h"
-#include "ast2ram/utility/SipsMetric.h"
-#include "ram/AbstractOperator.h"
 #include "ram/Condition.h"
 #include "ram/Expression.h"
-#include "ram/IntrinsicAggregator.h"
-#include "ram/IntrinsicOperator.h"
 #include "ram/Statement.h"
-#include "ram/UndefValue.h"
-#include "ram/UserDefinedAggregator.h"
-#include "ram/UserDefinedOperator.h"
 #include "souffle/utility/FunctionalUtil.h"
 #include "souffle/utility/StringUtil.h"
-#include <optional>
 #include <set>
 
 namespace souffle::ast2ram {
 
 TranslatorContext::TranslatorContext(const ast::TranslationUnit& tu) {
     program = &tu.getProgram();
-    global = &tu.global();
 
     // Set up analyses
     functorAnalysis = &tu.getAnalysis<ast::analysis::FunctorAnalysis>();
@@ -72,7 +60,7 @@ TranslatorContext::TranslatorContext(const ast::TranslationUnit& tu) {
     typeEnv = &tu.getAnalysis<ast::analysis::TypeEnvironmentAnalysis>().getTypeEnvironment();
     sumTypeBranches = &tu.getAnalysis<ast::analysis::SumTypeBranchesAnalysis>();
     polyAnalysis = &tu.getAnalysis<ast::analysis::PolymorphicObjectsAnalysis>();
-    joinSizeAnalysis = &tu.getAnalysis<ast::analysis::JoinSizeAnalysis>();
+    uniqueKeysAnalysis = &tu.getAnalysis<ast::analysis::UniqueKeysAnalysis>();
 
     // Set up clause nums
     for (const ast::Relation* rel : program->getRelations()) {
@@ -87,30 +75,17 @@ TranslatorContext::TranslatorContext(const ast::TranslationUnit& tu) {
 
     // Set up SIPS metric
     std::string sipsChosen = "all-bound";
-    if (global->config().has("RamSIPS")) {
-        sipsChosen = global->config().get("RamSIPS");
+    if (Global::config().has("RamSIPS")) {
+        sipsChosen = Global::config().get("RamSIPS");
     }
     sipsMetric = ast::SipsMetric::create(sipsChosen, tu);
 
     // Set up the correct strategy
-    if (global->config().has("provenance")) {
+    if (Global::config().has("provenance")) {
         translationStrategy = mk<provenance::TranslationStrategy>();
     } else {
         translationStrategy = mk<seminaive::TranslationStrategy>();
     }
-
-    // populates deltaRel
-    for (const ast::Relation* rel : program->getRelations()) {
-        const auto delta = rel->getIsDeltaDebug();
-        if (delta.has_value()) {
-            deltaRel[program->getRelation(delta.value())] = rel;
-        }
-    }
-
-    // populates map type name -> lattice
-    for (const ast::Lattice* lattice : program->getLattices()) {
-        lattices.emplace(lattice->getQualifiedName(), lattice);
-    }
 }
 
 TranslatorContext::~TranslatorContext() = default;
@@ -128,40 +103,6 @@ std::string TranslatorContext::getAttributeTypeQualifier(const ast::QualifiedNam
     return getTypeQualifier(typeEnv->getType(name));
 }
 
-Own<ram::AbstractOperator> TranslatorContext::getLatticeTypeLubFunctor(
-        const ast::QualifiedName& typeName, VecOwn<ram::Expression> args) const {
-    const ast::Lattice* lattice = lattices.at(typeName);
-    if (const auto* lub = as<ast::UserDefinedFunctor>(lattice->getLub())) {
-        const auto typeAttributes = getFunctorParamTypeAtributes(*lub);
-        const auto returnAttribute = getFunctorReturnTypeAttribute(*lub);
-        bool stateful = isStatefulFunctor(*lub);
-        return mk<ram::UserDefinedOperator>(
-                lub->getName(), typeAttributes, returnAttribute, stateful, std::move(args));
-    } else if (const auto* lub = as<ast::IntrinsicFunctor>(lattice->getLub())) {
-        assert(false && lub && "intrinsic functors not yet supported in lattice");
-        // return mk<ram::IntrinsicOperator>(getOverloadedFunctorOp(lub->getBaseFunctionOp()),
-        // std::move(args));
-    }
-    assert(false);
-    return {};
-}
-
-Own<ram::Aggregator> TranslatorContext::getLatticeTypeLubAggregator(
-        const ast::QualifiedName& typeName, Own<ram::Expression> init) const {
-    const ast::Lattice* lattice = lattices.at(typeName);
-    if (const auto* lub = as<ast::UserDefinedFunctor>(lattice->getLub())) {
-        const auto typeAttributes = getFunctorParamTypeAtributes(*lub);
-        const auto returnAttribute = getFunctorReturnTypeAttribute(*lub);
-        bool stateful = isStatefulFunctor(*lub);
-        return mk<ram::UserDefinedAggregator>(
-                lub->getName(), std::move(init), typeAttributes, returnAttribute, stateful);
-    } else if (const auto* lub = as<ast::IntrinsicFunctor>(lattice->getLub())) {
-        assert(false && lub && "intrinsic aggregators not yet supported in lattice");
-    }
-    assert(false);
-    return {};
-}
-
 std::size_t TranslatorContext::getNumberOfSCCs() const {
     return sccGraph->getNumberOfSCCs();
 }
@@ -170,14 +111,6 @@ bool TranslatorContext::isRecursiveSCC(std::size_t scc) const {
     return sccGraph->isRecursive(scc);
 }
 
-const ast::Relation* TranslatorContext::getDeltaDebugRelation(const ast::Relation* rel) const {
-    const auto res = deltaRel.find(rel);
-    if (res != deltaRel.end()) {
-        return res->second;
-    }
-    return nullptr;
-}
-
 std::vector<ast::Directive*> TranslatorContext::getStoreDirectives(const ast::QualifiedName& name) const {
     return filter(program->getDirectives(name), [&](const ast::Directive* dir) {
         return dir->getType() == ast::DirectiveType::printsize ||
@@ -199,21 +132,21 @@ std::size_t TranslatorContext::getSizeLimit(const ast::Relation* relation) const
     return ioType->getLimitSize(relation);
 }
 
-ast::RelationSet TranslatorContext::getRelationsInSCC(std::size_t scc) const {
+std::set<const ast::Relation*> TranslatorContext::getRelationsInSCC(std::size_t scc) const {
     return sccGraph->getInternalRelations(scc);
 }
 
-ast::RelationSet TranslatorContext::getInputRelationsInSCC(std::size_t scc) const {
+std::set<const ast::Relation*> TranslatorContext::getInputRelationsInSCC(std::size_t scc) const {
     return sccGraph->getInternalInputRelations(scc);
 }
 
-ast::RelationSet TranslatorContext::getOutputRelationsInSCC(std::size_t scc) const {
+std::set<const ast::Relation*> TranslatorContext::getOutputRelationsInSCC(std::size_t scc) const {
     return sccGraph->getInternalOutputRelations(scc);
 }
 
-VecOwn<ram::Statement> TranslatorContext::getRecursiveJoinSizeStatementsInSCC(std::size_t scc) const {
+VecOwn<ram::Statement> TranslatorContext::getRecursiveUniqueKeyStatementsInSCC(std::size_t scc) const {
     VecOwn<ram::Statement> res;
-    for (auto&& s : joinSizeAnalysis->getJoinSizeStatementsInSCC(scc)) {
+    for (auto&& s : uniqueKeysAnalysis->getUniqueKeyStatementsInSCC(scc)) {
         if (s->isRecursiveRelation()) {
             res.push_back(clone(s));
         }
@@ -221,9 +154,9 @@ VecOwn<ram::Statement> TranslatorContext::getRecursiveJoinSizeStatementsInSCC(st
     return res;
 }
 
-VecOwn<ram::Statement> TranslatorContext::getNonRecursiveJoinSizeStatementsInSCC(std::size_t scc) const {
+VecOwn<ram::Statement> TranslatorContext::getNonRecursiveUniqueKeyStatementsInSCC(std::size_t scc) const {
     VecOwn<ram::Statement> res;
-    for (auto&& s : joinSizeAnalysis->getJoinSizeStatementsInSCC(scc)) {
+    for (auto&& s : uniqueKeysAnalysis->getUniqueKeyStatementsInSCC(scc)) {
         if (!s->isRecursiveRelation()) {
             res.push_back(clone(s));
         }
@@ -231,7 +164,7 @@ VecOwn<ram::Statement> TranslatorContext::getNonRecursiveJoinSizeStatementsInSCC
     return res;
 }
 
-ast::RelationSet TranslatorContext::getExpiredRelations(std::size_t scc) const {
+std::set<const ast::Relation*> TranslatorContext::getExpiredRelations(std::size_t scc) const {
     return relationSchedule->schedule().at(scc).expired();
 }
 
@@ -262,30 +195,12 @@ bool TranslatorContext::isStatefulFunctor(const ast::UserDefinedFunctor& udf) co
     return functorAnalysis->isStatefulFunctor(udf);
 }
 
-TypeAttribute TranslatorContext::getFunctorReturnTypeAttribute(const ast::UserDefinedAggregator& uda) const {
-    return typeAnalysis->getAggregatorReturnTypeAttribute(uda);
-}
-
-TypeAttribute TranslatorContext::getFunctorParamTypeAtribute(
-        const ast::UserDefinedAggregator& uda, std::size_t idx) const {
-    return typeAnalysis->getAggregatorParamTypeAttribute(uda, idx);
-}
-
-std::vector<TypeAttribute> TranslatorContext::getFunctorParamTypeAtributes(
-        const ast::UserDefinedAggregator& uda) const {
-    return typeAnalysis->getAggregatorParamTypeAttributes(uda);
-}
-
-bool TranslatorContext::isStatefulFunctor(const ast::UserDefinedAggregator& uda) const {
-    return functorAnalysis->isStatefulFunctor(uda);
-}
-
 ast::NumericConstant::Type TranslatorContext::getInferredNumericConstantType(
         const ast::NumericConstant& nc) const {
     return polyAnalysis->getInferredType(nc);
 }
 
-AggregateOp TranslatorContext::getOverloadedAggregatorOperator(const ast::IntrinsicAggregator& aggr) const {
+AggregateOp TranslatorContext::getOverloadedAggregatorOperator(const ast::Aggregator& aggr) const {
     return polyAnalysis->getOverloadedOperator(aggr);
 }
 
@@ -309,7 +224,7 @@ int TranslatorContext::getADTBranchId(const ast::BranchInit* adt) const {
     auto iterToBranch = std::lower_bound(branches.begin(), branches.end(), searchDummy,
             [](const ast::analysis::AlgebraicDataType::Branch& left,
                     const ast::analysis::AlgebraicDataType::Branch& right) {
-                return left.name.lexicalLess(right.name);
+                return left.name < right.name;
             });
     return static_cast<int>(std::distance(std::begin(branches), iterToBranch));
 }
@@ -326,7 +241,7 @@ Own<ram::Statement> TranslatorContext::translateNonRecursiveClause(
 }
 
 Own<ram::Statement> TranslatorContext::translateRecursiveClause(const ast::Clause& clause,
-        const ast::RelationSet& scc, std::size_t version, TranslationMode mode) const {
+        const std::set<const ast::Relation*>& scc, std::size_t version, TranslationMode mode) const {
     auto clauseTranslator = Own<ClauseTranslator>(translationStrategy->createClauseTranslator(*this, mode));
     return clauseTranslator->translateRecursiveClause(clause, scc, version);
 }
diff --git a/src/ast2ram/utility/TranslatorContext.h b/src/ast2ram/utility/TranslatorContext.h
index 50b718c..1f5c404 100644
--- a/src/ast2ram/utility/TranslatorContext.h
+++ b/src/ast2ram/utility/TranslatorContext.h
@@ -18,12 +18,10 @@
 #include "FunctorOps.h"
 #include "ast/NumericConstant.h"
 #include "ast/QualifiedName.h"
-#include "ast/UserDefinedAggregator.h"
-#include "ast/analysis/JoinSize.h"
 #include "ast/analysis/ProfileUse.h"
+#include "ast/analysis/UniqueKeys.h"
 #include "ast/analysis/typesystem/Type.h"
 #include "ast2ram/ClauseTranslator.h"
-#include "ram/Aggregator.h"
 #include "souffle/BinaryConstraintOps.h"
 #include "souffle/TypeAttribute.h"
 #include "souffle/utility/ContainerUtil.h"
@@ -31,10 +29,6 @@
 #include <set>
 #include <vector>
 
-namespace souffle {
-class Global;
-}
-
 namespace souffle::ast {
 class Aggregator;
 class Atom;
@@ -69,7 +63,7 @@ class RelationScheduleAnalysis;
 class SumTypeBranchesAnalysis;
 class SCCGraphAnalysis;
 class TypeEnvironment;
-class JoinSizeAnalysis;
+class UniqueKeysAnalysis;
 }  // namespace souffle::ast::analysis
 
 namespace souffle::ast2ram {
@@ -82,10 +76,6 @@ public:
     TranslatorContext(const ast::TranslationUnit& tu);
     ~TranslatorContext();
 
-    const Global* getGlobal() const {
-        return global;
-    }
-
     const ast::Program* getProgram() const {
         return program;
     }
@@ -97,14 +87,6 @@ public:
     bool hasSizeLimit(const ast::Relation* relation) const;
     std::size_t getSizeLimit(const ast::Relation* relation) const;
 
-    Own<ram::Aggregator> getLatticeTypeLubAggregator(
-            const ast::QualifiedName& typeName, Own<ram::Expression> init) const;
-    Own<ram::AbstractOperator> getLatticeTypeLubFunctor(
-            const ast::QualifiedName& typeName, VecOwn<ram::Expression> args) const;
-
-    /** Associates a relation with its delta_debug relation if present */
-    const ast::Relation* getDeltaDebugRelation(const ast::Relation* rel) const;
-
     /** Clause methods */
     bool hasSubsumptiveClause(const ast::QualifiedName& name) const;
     bool isRecursiveClause(const ast::Clause* clause) const;
@@ -113,14 +95,14 @@ public:
     /** SCC methods */
     std::size_t getNumberOfSCCs() const;
     bool isRecursiveSCC(std::size_t scc) const;
-    ast::RelationSet getExpiredRelations(std::size_t scc) const;
-    ast::RelationSet getRelationsInSCC(std::size_t scc) const;
-    ast::RelationSet getInputRelationsInSCC(std::size_t scc) const;
-    ast::RelationSet getOutputRelationsInSCC(std::size_t scc) const;
+    std::set<const ast::Relation*> getExpiredRelations(std::size_t scc) const;
+    std::set<const ast::Relation*> getRelationsInSCC(std::size_t scc) const;
+    std::set<const ast::Relation*> getInputRelationsInSCC(std::size_t scc) const;
+    std::set<const ast::Relation*> getOutputRelationsInSCC(std::size_t scc) const;
 
-    /** JoinSize methods */
-    VecOwn<ram::Statement> getRecursiveJoinSizeStatementsInSCC(std::size_t scc) const;
-    VecOwn<ram::Statement> getNonRecursiveJoinSizeStatementsInSCC(std::size_t scc) const;
+    /** UniqueKeys methods */
+    VecOwn<ram::Statement> getRecursiveUniqueKeyStatementsInSCC(std::size_t scc) const;
+    VecOwn<ram::Statement> getNonRecursiveUniqueKeyStatementsInSCC(std::size_t scc) const;
 
     /** Functor methods */
     TypeAttribute getFunctorReturnTypeAttribute(const ast::Functor& functor) const;
@@ -128,13 +110,6 @@ public:
     std::vector<TypeAttribute> getFunctorParamTypeAtributes(const ast::UserDefinedFunctor& udf) const;
     bool isStatefulFunctor(const ast::UserDefinedFunctor& functor) const;
 
-    /** Functor methods */
-    TypeAttribute getFunctorReturnTypeAttribute(const ast::UserDefinedAggregator& aggregator) const;
-    TypeAttribute getFunctorParamTypeAtribute(
-            const ast::UserDefinedAggregator& aggregator, std::size_t idx) const;
-    std::vector<TypeAttribute> getFunctorParamTypeAtributes(const ast::UserDefinedAggregator& udf) const;
-    bool isStatefulFunctor(const ast::UserDefinedAggregator& aggregator) const;
-
     /** ADT methods */
     bool isADTEnum(const ast::BranchInit* adt) const;
     int getADTBranchId(const ast::BranchInit* adt) const;
@@ -142,7 +117,7 @@ public:
 
     /** Polymorphic objects methods */
     ast::NumericConstant::Type getInferredNumericConstantType(const ast::NumericConstant& nc) const;
-    AggregateOp getOverloadedAggregatorOperator(const ast::IntrinsicAggregator& aggr) const;
+    AggregateOp getOverloadedAggregatorOperator(const ast::Aggregator& aggr) const;
     BinaryConstraintOp getOverloadedBinaryConstraintOperator(const ast::BinaryConstraint& bc) const;
     FunctorOp getOverloadedFunctorOp(const ast::IntrinsicFunctor& inf) const;
 
@@ -154,8 +129,9 @@ public:
     /** Translation strategy */
     Own<ram::Statement> translateNonRecursiveClause(
             const ast::Clause& clause, TranslationMode mode = DEFAULT) const;
-    Own<ram::Statement> translateRecursiveClause(const ast::Clause& clause, const ast::RelationSet& scc,
-            std::size_t version, TranslationMode mode = DEFAULT) const;
+    Own<ram::Statement> translateRecursiveClause(const ast::Clause& clause,
+            const std::set<const ast::Relation*>& scc, std::size_t version,
+            TranslationMode mode = DEFAULT) const;
 
     Own<ram::Condition> translateConstraint(const ValueIndex& index, const ast::Literal* lit) const;
 
@@ -163,7 +139,6 @@ public:
 
 private:
     const ast::Program* program;
-    const Global* global;
     const ast::analysis::RecursiveClausesAnalysis* recursiveClauses;
     const ast::analysis::RelationScheduleAnalysis* relationSchedule;
     const ast::analysis::SCCGraphAnalysis* sccGraph;
@@ -173,12 +148,10 @@ private:
     const ast::analysis::TypeEnvironment* typeEnv;
     const ast::analysis::SumTypeBranchesAnalysis* sumTypeBranches;
     const ast::analysis::PolymorphicObjectsAnalysis* polyAnalysis;
-    const ast::analysis::JoinSizeAnalysis* joinSizeAnalysis;
+    const ast::analysis::UniqueKeysAnalysis* uniqueKeysAnalysis;
     std::map<const ast::Clause*, std::size_t> clauseNums;
     Own<ast::SipsMetric> sipsMetric;
     Own<TranslationStrategy> translationStrategy;
-    std::map<const ast::Relation*, const ast::Relation*> deltaRel;
-    ast::UnorderedQualifiedNameMap<const ast::Lattice*> lattices;
 };
 
 }  // namespace souffle::ast2ram
diff --git a/src/ast2ram/utility/Utils.cpp b/src/ast2ram/utility/Utils.cpp
index 24afdb6..8a554c5 100644
--- a/src/ast2ram/utility/Utils.cpp
+++ b/src/ast2ram/utility/Utils.cpp
@@ -19,11 +19,10 @@
 #include "ast/Clause.h"
 #include "ast/QualifiedName.h"
 #include "ast/Relation.h"
-#include "ast/SubsumptiveClause.h"
 #include "ast/UnnamedVariable.h"
 #include "ast/Variable.h"
+
 #include "ast/utility/Utils.h"
-#include "ast2ram/ClauseTranslator.h"
 #include "ast2ram/utility/Location.h"
 #include "ram/Clear.h"
 #include "ram/Condition.h"
@@ -36,62 +35,6 @@
 
 namespace souffle::ast2ram {
 
-std::string getAtomName(const ast::Clause& clause, const ast::Atom* atom,
-        const std::vector<ast::Atom*>& sccAtoms, std::size_t version, bool isRecursive,
-        TranslationMode mode) {
-    if (isA<ast::SubsumptiveClause>(clause)) {
-        // find the dominated / dominating heads
-        const auto& body = clause.getBodyLiterals();
-        auto dominatedHeadAtom = dynamic_cast<const ast::Atom*>(body[0]);
-        auto dominatingHeadAtom = dynamic_cast<const ast::Atom*>(body[1]);
-
-        if (clause.getHead() == atom) {
-            if (mode == SubsumeDeleteCurrentDelta || mode == SubsumeDeleteCurrentCurrent) {
-                return getDeleteRelationName(atom->getQualifiedName());
-            }
-            return getRejectRelationName(atom->getQualifiedName());
-        }
-
-        if (dominatedHeadAtom == atom) {
-            if (mode == SubsumeDeleteCurrentDelta || mode == SubsumeDeleteCurrentCurrent) {
-                return getConcreteRelationName(atom->getQualifiedName());
-            }
-            return getNewRelationName(atom->getQualifiedName());
-        }
-
-        if (dominatingHeadAtom == atom) {
-            switch (mode) {
-                case SubsumeRejectNewCurrent:
-                case SubsumeDeleteCurrentCurrent: return getConcreteRelationName(atom->getQualifiedName());
-                case SubsumeDeleteCurrentDelta: return getDeltaRelationName(atom->getQualifiedName());
-                default: return getNewRelationName(atom->getQualifiedName());
-            }
-        }
-
-        if (isRecursive) {
-            if (sccAtoms.at(version + 1) == atom) {
-                return getDeltaRelationName(atom->getQualifiedName());
-            }
-        }
-
-        return getConcreteRelationName(atom->getQualifiedName());
-    }
-
-    if (!isRecursive) {
-        if (mode == Auxiliary && clause.getHead() == atom) {
-            return getNewRelationName(atom->getQualifiedName());
-        }
-        return getConcreteRelationName(atom->getQualifiedName());
-    }
-    if (clause.getHead() == atom) {
-        return getNewRelationName(atom->getQualifiedName());
-    }
-    if (sccAtoms.at(version) == atom) {
-        return getDeltaRelationName(atom->getQualifiedName());
-    }
-    return getConcreteRelationName(atom->getQualifiedName());
-}
-
 std::string getConcreteRelationName(const ast::QualifiedName& name, const std::string prefix) {
     return prefix + getRelationName(name);
 }
@@ -104,10 +47,6 @@ std::string getNewRelationName(const ast::QualifiedName& name) {
     return getConcreteRelationName(name, "@new_");
 }
 
-std::string getLubRelationName(const ast::QualifiedName& name) {
-    return getConcreteRelationName(name, "@lub_");
-}
-
 std::string getRejectRelationName(const ast::QualifiedName& name) {
     return getConcreteRelationName(name, "@reject_");
 }
@@ -116,8 +55,8 @@ std::string getDeleteRelationName(const ast::QualifiedName& name) {
     return getConcreteRelationName(name, "@delete_");
 }
 
-const std::string& getRelationName(const ast::QualifiedName& name) {
-    return name.toString();
+std::string getRelationName(const ast::QualifiedName& name) {
+    return toString(join(name.getQualifiers(), "."));
 }
 
 std::string getBaseRelationName(const ast::QualifiedName& name) {
diff --git a/src/ast2ram/utility/Utils.h b/src/ast2ram/utility/Utils.h
index 46e4e9b..0738b68 100644
--- a/src/ast2ram/utility/Utils.h
+++ b/src/ast2ram/utility/Utils.h
@@ -16,7 +16,6 @@
 
 #pragma once
 
-#include "ast2ram/seminaive/ClauseTranslator.h"
 #include "souffle/utility/ContainerUtil.h"
 #include <string>
 
@@ -38,15 +37,11 @@ namespace souffle::ast2ram {
 
 struct Location;
 
-/** Get the corresponding atom name given the clause and other state */
-std::string getAtomName(const ast::Clause& clause, const ast::Atom* atom,
-        const std::vector<ast::Atom*>& sccAtoms, std::size_t version, bool isRecursive, TranslationMode mode);
-
 /** Get the corresponding concretised RAM relation name for the relation */
 std::string getConcreteRelationName(const ast::QualifiedName& name, const std::string prefix = "");
 
 /** converts the given relation identifier into a relation name */
-const std::string& getRelationName(const ast::QualifiedName& name);
+std::string getRelationName(const ast::QualifiedName& name);
 
 /** Get the corresponding RAM delta relation name for the relation */
 std::string getDeltaRelationName(const ast::QualifiedName& name);
@@ -54,9 +49,6 @@ std::string getDeltaRelationName(const ast::QualifiedName& name);
 /** Get the corresponding RAM 'new' relation name for the relation */
 std::string getNewRelationName(const ast::QualifiedName& name);
 
-/** Get the corresponding RAM 'lub' relation name for the relation */
-std::string getLubRelationName(const ast::QualifiedName& name);
-
 /** Get the corresponding RAM 'reject' relation name for the relation */
 std::string getRejectRelationName(const ast::QualifiedName& name);
 
diff --git a/src/include/souffle/CompiledOptions.h b/src/include/souffle/CompiledOptions.h
index 9de6c86..ea007e7 100644
--- a/src/include/souffle/CompiledOptions.h
+++ b/src/include/souffle/CompiledOptions.h
@@ -151,7 +151,7 @@ public:
                     break;
                 /* Output directory for resulting .csv files */
                 case 'D':
-                    if (*optarg && !existDir(optarg) && !dirIsStdout(optarg)) {
+                    if (*optarg && !existDir(optarg)) {
                         printf("Output directory %s does not exists!\n", optarg);
                         ok = false;
                     }
@@ -222,11 +222,6 @@ private:
 #endif
         std::cerr << "    -h                           -- prints this help page.\n";
         std::cerr << "--------------------------------------------------------------------\n";
-#ifdef SOUFFLE_GENERATOR_VERSION
-        std::cerr << " Version: " << SOUFFLE_GENERATOR_VERSION << std::endl;
-#endif
-        std::cerr << " Word size: " << RAM_DOMAIN_SIZE << " bits" << std::endl;
-        std::cerr << "--------------------------------------------------------------------\n";
         std::cerr << " Copyright (c) 2016-22 The Souffle Developers." << std::endl;
         std::cerr << " Copyright (c) 2013-16 Oracle and/or its affiliates." << std::endl;
         std::cerr << " All rights reserved.\n";
@@ -258,13 +253,6 @@ private:
         }
         return false;
     }
-
-    /**
-     *  Check whether the output is "-", for which the output should be stdout
-     */
-    bool dirIsStdout(const std::string& name) const {
-        return name == "-";
-    }
 };
 
 }  // end of namespace souffle
diff --git a/src/include/souffle/CompiledSouffle.h b/src/include/souffle/CompiledSouffle.h
index 9183e98..01008a7 100644
--- a/src/include/souffle/CompiledSouffle.h
+++ b/src/include/souffle/CompiledSouffle.h
@@ -23,16 +23,16 @@
 #include "souffle/SymbolTable.h"
 #include "souffle/datastructure/BTreeDelete.h"
 #include "souffle/datastructure/Brie.h"
-#include "souffle/datastructure/ConcurrentCache.h"
-#include "souffle/datastructure/EqRel.h"
-#include "souffle/datastructure/Info.h"
-#include "souffle/datastructure/Nullaries.h"
+#include "souffle/datastructure/EquivalenceRelation.h"
 #include "souffle/datastructure/RecordTableImpl.h"
 #include "souffle/datastructure/SymbolTableImpl.h"
 #include "souffle/datastructure/Table.h"
 #include "souffle/io/IOSystem.h"
 #include "souffle/io/WriteStream.h"
 #include "souffle/utility/EvaluatorUtil.h"
+#ifndef __EMBEDDED_SOUFFLE__
+#include "souffle/CompiledOptions.h"
+#endif
 
 #if defined(_OPENMP)
 #include <omp.h>
@@ -155,4 +155,328 @@ public:
     }
 };
 
+/** Nullary relations */
+class t_nullaries {
+private:
+    std::atomic<bool> data{false};
+
+public:
+    static constexpr Relation::arity_type Arity = 0;
+
+    t_nullaries() = default;
+    using t_tuple = Tuple<RamDomain, 0>;
+    struct context {};
+    context createContext() {
+        return context();
+    }
+    class iterator {
+        bool value;
+
+    public:
+        using iterator_category = std::forward_iterator_tag;
+        using value_type = RamDomain*;
+        using difference_type = ptrdiff_t;
+        using pointer = value_type*;
+        using reference = value_type&;
+
+        iterator(bool v = false) : value(v) {}
+
+        const RamDomain* operator*() {
+            return nullptr;
+        }
+
+        bool operator==(const iterator& other) const {
+            return other.value == value;
+        }
+
+        bool operator!=(const iterator& other) const {
+            return other.value != value;
+        }
+
+        iterator& operator++() {
+            if (value) {
+                value = false;
+            }
+            return *this;
+        }
+    };
+    iterator begin() const {
+        return iterator(data);
+    }
+    iterator end() const {
+        return iterator();
+    }
+    void insert(const t_tuple& /* t */) {
+        data = true;
+    }
+    void insert(const t_tuple& /* t */, context& /* ctxt */) {
+        data = true;
+    }
+    void insert(const RamDomain* /* ramDomain */) {
+        data = true;
+    }
+    bool insert() {
+        bool result = data;
+        data = true;
+        return !result;
+    }
+    bool contains(const t_tuple& /* t */) const {
+        return data;
+    }
+    bool contains(const t_tuple& /* t */, context& /* ctxt */) const {
+        return data;
+    }
+    std::size_t size() const {
+        return data ? 1 : 0;
+    }
+    bool empty() const {
+        return !data;
+    }
+    void purge() {
+        data = false;
+    }
+    void printStatistics(std::ostream& /* o */) const {}
+};
+
+/** Info relations */
+template <Relation::arity_type Arity_>
+class t_info {
+public:
+    static constexpr Relation::arity_type Arity = Arity_;
+
+    t_info() = default;
+    using t_tuple = Tuple<RamDomain, Arity>;
+    struct context {};
+    context createContext() {
+        return context();
+    }
+    class iterator : public std::iterator<std::forward_iterator_tag, Tuple<RamDomain, Arity>> {
+        typename std::vector<Tuple<RamDomain, Arity>>::const_iterator it;
+
+    public:
+        iterator(const typename std::vector<t_tuple>::const_iterator& o) : it(o) {}
+
+        const t_tuple operator*() {
+            return *it;
+        }
+
+        bool operator==(const iterator& other) const {
+            return other.it == it;
+        }
+
+        bool operator!=(const iterator& other) const {
+            return !(*this == other);
+        }
+
+        iterator& operator++() {
+            it++;
+            return *this;
+        }
+    };
+    iterator begin() const {
+        return iterator(data.begin());
+    }
+    iterator end() const {
+        return iterator(data.end());
+    }
+    void insert(const t_tuple& t) {
+        insert_lock.lock();
+        if (!contains(t)) {
+            data.push_back(t);
+        }
+        insert_lock.unlock();
+    }
+    void insert(const t_tuple& t, context& /* ctxt */) {
+        insert(t);
+    }
+    void insert(const RamDomain* ramDomain) {
+        insert_lock.lock();
+        t_tuple t;
+        for (std::size_t i = 0; i < Arity; ++i) {
+            t.data[i] = ramDomain[i];
+        }
+        data.push_back(t);
+        insert_lock.unlock();
+    }
+    bool contains(const t_tuple& t) const {
+        for (const auto& o : data) {
+            if (t == o) {
+                return true;
+            }
+        }
+        return false;
+    }
+    bool contains(const t_tuple& t, context& /* ctxt */) const {
+        return contains(t);
+    }
+    std::size_t size() const {
+        return data.size();
+    }
+    bool empty() const {
+        return data.size() == 0;
+    }
+    void purge() {
+        data.clear();
+    }
+    void printStatistics(std::ostream& /* o */) const {}
+
+private:
+    std::vector<Tuple<RamDomain, Arity>> data;
+    Lock insert_lock;
+};
+
+/** Equivalence relations */
+struct t_eqrel {
+    static constexpr Relation::arity_type Arity = 2;
+    using t_tuple = Tuple<RamDomain, 2>;
+    using t_ind = EquivalenceRelation<t_tuple>;
+    t_ind ind;
+    class iterator_0 : public std::iterator<std::forward_iterator_tag, t_tuple> {
+        using nested_iterator = typename t_ind::iterator;
+        nested_iterator nested;
+        t_tuple value;
+
+    public:
+        iterator_0(const nested_iterator& iter) : nested(iter), value(*iter) {}
+        iterator_0(const iterator_0& other) = default;
+        iterator_0& operator=(const iterator_0& other) = default;
+        bool operator==(const iterator_0& other) const {
+            return nested == other.nested;
+        }
+        bool operator!=(const iterator_0& other) const {
+            return !(*this == other);
+        }
+        const t_tuple& operator*() const {
+            return value;
+        }
+        const t_tuple* operator->() const {
+            return &value;
+        }
+        iterator_0& operator++() {
+            ++nested;
+            value = *nested;
+            return *this;
+        }
+    };
+    class iterator_1 : public std::iterator<std::forward_iterator_tag, t_tuple> {
+        using nested_iterator = typename t_ind::iterator;
+        nested_iterator nested;
+        t_tuple value;
+
+    public:
+        iterator_1(const nested_iterator& iter) : nested(iter), value(reorder(*iter)) {}
+        iterator_1(const iterator_1& other) = default;
+        iterator_1& operator=(const iterator_1& other) = default;
+        bool operator==(const iterator_1& other) const {
+            return nested == other.nested;
+        }
+        bool operator!=(const iterator_1& other) const {
+            return !(*this == other);
+        }
+        const t_tuple& operator*() const {
+            return value;
+        }
+        const t_tuple* operator->() const {
+            return &value;
+        }
+        iterator_1& operator++() {
+            ++nested;
+            value = reorder(*nested);
+            return *this;
+        }
+    };
+    using iterator = iterator_0;
+    struct context {
+        t_ind::operation_hints hints;
+    };
+    context createContext() {
+        return context();
+    }
+    bool insert(const t_tuple& t) {
+        return ind.insert(t[0], t[1]);
+    }
+    bool insert(const t_tuple& t, context& h) {
+        return ind.insert(t[0], t[1], h.hints);
+    }
+    bool insert(const RamDomain* ramDomain) {
+        RamDomain data[2];
+        std::copy(ramDomain, ramDomain + 2, data);
+        auto& tuple = reinterpret_cast<const t_tuple&>(data);
+        context h;
+        return insert(tuple, h);
+    }
+    bool insert(RamDomain a1, RamDomain a2) {
+        RamDomain data[2] = {a1, a2};
+        return insert(data);
+    }
+    void extendAndInsert(t_eqrel& other) {
+        ind.extendAndInsert(other.ind);
+    }
+    bool contains(const t_tuple& t) const {
+        return ind.contains(t[0], t[1]);
+    }
+    bool contains(const t_tuple& t, context&) const {
+        return ind.contains(t[0], t[1]);
+    }
+    std::size_t size() const {
+        return ind.size();
+    }
+    iterator find(const t_tuple& t) const {
+        return ind.find(t);
+    }
+    iterator find(const t_tuple& t, context&) const {
+        return ind.find(t);
+    }
+    range<iterator> lowerUpperRange_10(const t_tuple& lower, const t_tuple& /*upper*/, context& h) const {
+        auto r = ind.template getBoundaries<1>((lower), h.hints);
+        return make_range(iterator(r.begin()), iterator(r.end()));
+    }
+    range<iterator> lowerUpperRange_10(const t_tuple& lower, const t_tuple& upper) const {
+        context h;
+        return lowerUpperRange_10(lower, upper, h);
+    }
+    range<iterator_1> lowerUpperRange_01(const t_tuple& lower, const t_tuple& /*upper*/, context& h) const {
+        auto r = ind.template getBoundaries<1>(reorder(lower), h.hints);
+        return make_range(iterator_1(r.begin()), iterator_1(r.end()));
+    }
+    range<iterator_1> lowerUpperRange_01(const t_tuple& lower, const t_tuple& upper) const {
+        context h;
+        return lowerUpperRange_01(lower, upper, h);
+    }
+    range<iterator> lowerUpperRange_11(const t_tuple& lower, const t_tuple& /*upper*/, context& h) const {
+        auto r = ind.template getBoundaries<2>((lower), h.hints);
+        return make_range(iterator(r.begin()), iterator(r.end()));
+    }
+    range<iterator> lowerUpperRange_11(const t_tuple& lower, const t_tuple& upper) const {
+        context h;
+        return lowerUpperRange_11(lower, upper, h);
+    }
+    bool empty() const {
+        return ind.size() == 0;
+    }
+    std::vector<range<iterator>> partition() const {
+        std::vector<range<iterator>> res;
+        for (const auto& cur : ind.partition(10000)) {
+            res.push_back(make_range(iterator(cur.begin()), iterator(cur.end())));
+        }
+        return res;
+    }
+    void purge() {
+        ind.clear();
+    }
+    iterator begin() const {
+        return iterator(ind.begin());
+    }
+    iterator end() const {
+        return iterator(ind.end());
+    }
+    static t_tuple reorder(const t_tuple& t) {
+        t_tuple res;
+        res[0] = t[1];
+        res[1] = t[0];
+        return res;
+    }
+    void printStatistics(std::ostream& /* o */) const {}
+};
+
 }  // namespace souffle
diff --git a/src/include/souffle/RamTypes.h b/src/include/souffle/RamTypes.h
index d46063c..76c5145 100644
--- a/src/include/souffle/RamTypes.h
+++ b/src/include/souffle/RamTypes.h
@@ -95,7 +95,4 @@ constexpr RamUnsigned MAX_RAM_UNSIGNED = std::numeric_limits<RamUnsigned>::max()
 
 constexpr RamFloat MIN_RAM_FLOAT = std::numeric_limits<RamFloat>::lowest();
 constexpr RamFloat MAX_RAM_FLOAT = std::numeric_limits<RamFloat>::max();
-
-constexpr RamDomain RAM_BIT_SHIFT_MASK = RAM_DOMAIN_SIZE - 1;
-
 }  // end of namespace souffle
diff --git a/src/include/souffle/RecordTable.h b/src/include/souffle/RecordTable.h
index 2a6c1dd..5c173cb 100644
--- a/src/include/souffle/RecordTable.h
+++ b/src/include/souffle/RecordTable.h
@@ -19,8 +19,6 @@
 
 #include "souffle/RamTypes.h"
 #include "souffle/utility/span.h"
-
-#include <functional>
 #include <initializer_list>
 
 namespace souffle {
@@ -37,10 +35,6 @@ public:
     virtual RamDomain pack(const std::initializer_list<RamDomain>& List) = 0;
 
     virtual const RamDomain* unpack(const RamDomain Ref, const std::size_t Arity) const = 0;
-
-    /// Enumerate each record.
-    virtual void enumerate(const std::function<void(const RamDomain* /*tuple*/, std::size_t /* arity*/,
-                    RamDomain /* key */)>& Callback) const = 0;
 };
 
 /** @brief helper to convert tuple to record reference for the synthesiser */
diff --git a/src/include/souffle/SignalHandler.h b/src/include/souffle/SignalHandler.h
index d42897f..3e9beec 100644
--- a/src/include/souffle/SignalHandler.h
+++ b/src/include/souffle/SignalHandler.h
@@ -16,8 +16,6 @@
 
 #pragma once
 
-#include "souffle/profile/ProfileEvent.h"
-
 #include <atomic>
 #include <csignal>
 #include <cstdio>
@@ -54,15 +52,6 @@ public:
     void enableLogging() {
         logMessages = true;
     }
-
-    void enableProfiling() {
-        profileEnabled = true;
-    }
-
-    bool profilingEnabled() const {
-        return profileEnabled;
-    }
-
     // set signal message
     void setMsg(const char* m) {
         if (logMessages && m != nullptr) {
@@ -115,9 +104,7 @@ public:
     }
 
     /***
-     * Reset signal handlers.
-     *
-     * Disable profiling.
+     * reset signal handlers
      */
     void reset() {
         if (isSet) {
@@ -138,7 +125,6 @@ public:
             }
             isSet = false;
         }
-        profileEnabled = false;
     }
 
     /***
@@ -164,8 +150,6 @@ private:
 
     bool logMessages = false;
 
-    bool profileEnabled = false;
-
     // previous signal handler routines
     void (*prevFpeHandler)(int) = nullptr;
     void (*prevIntHandler)(int) = nullptr;
@@ -212,12 +196,6 @@ private:
         else
             write({error, " signal.\n"});
 
-        if (instance()->profilingEnabled()) {
-            write({error, "dumping profiling data...\n"});
-            ProfileEventSingleton::instance().stopTimer();
-            ProfileEventSingleton::instance().dump();
-        }
-
         std::_Exit(EXIT_FAILURE);
     }
 
diff --git a/src/include/souffle/SouffleInterface.h b/src/include/souffle/SouffleInterface.h
index be9a3f5..2087b38 100644
--- a/src/include/souffle/SouffleInterface.h
+++ b/src/include/souffle/SouffleInterface.h
@@ -19,7 +19,6 @@
 #include "souffle/RamTypes.h"
 #include "souffle/RecordTable.h"
 #include "souffle/SymbolTable.h"
-#include "souffle/datastructure/ConcurrentCache.h"
 #include "souffle/utility/MiscUtil.h"
 #include <algorithm>
 #include <cassert>
@@ -30,7 +29,6 @@
 #include <map>
 #include <memory>
 #include <optional>
-#include <regex>
 #include <string>
 #include <tuple>
 #include <utility>
diff --git a/src/include/souffle/datastructure/BTree.h b/src/include/souffle/datastructure/BTree.h
index 5adc0b5..47d2bc8 100644
--- a/src/include/souffle/datastructure/BTree.h
+++ b/src/include/souffle/datastructure/BTree.h
@@ -91,8 +91,8 @@ protected:
     /* -------------- updater utilities ------------- */
 
     mutable Updater upd;
-    bool update(Key& old_k, const Key& new_k) {
-        return upd.update(old_k, new_k);
+    void update(Key& old_k, const Key& new_k) {
+        upd.update(old_k, new_k);
     }
 
     /* -------------- the node type ----------------- */
@@ -1225,14 +1225,14 @@ public:
                     }
 
                     // update provenance information
-                    if (typeid(Comparator) != typeid(WeakComparator)) {
+                    if (typeid(Comparator) != typeid(WeakComparator) && less(k, *pos)) {
                         if (!cur->lock.try_upgrade_to_write(cur_lease)) {
                             // start again
                             return insert(k, hints);
                         }
-                        bool updated = update(*pos, k);
+                        update(*pos, k);
                         cur->lock.end_write();
-                        return updated;
+                        return true;
                     }
 
                     // we found the element => no check of lock necessary
@@ -1280,14 +1280,14 @@ public:
                 }
 
                 // update provenance information
-                if (typeid(Comparator) != typeid(WeakComparator)) {
+                if (typeid(Comparator) != typeid(WeakComparator) && less(k, *(pos - 1))) {
                     if (!cur->lock.try_upgrade_to_write(cur_lease)) {
                         // start again
                         return insert(k, hints);
                     }
-                    bool updated = update(*(pos - 1), k);
+                    update(*(pos - 1), k);
                     cur->lock.end_write();
-                    return updated;
+                    return true;
                 }
 
                 // we found the element => done
@@ -1432,8 +1432,9 @@ public:
                 // early exit for sets
                 if (isSet && pos != b && weak_equal(*pos, k)) {
                     // update provenance information
-                    if (typeid(Comparator) != typeid(WeakComparator)) {
-                        return update(*pos, k);
+                    if (typeid(Comparator) != typeid(WeakComparator) && less(k, *pos)) {
+                        update(*pos, k);
+                        return true;
                     }
 
                     return false;
@@ -1457,8 +1458,9 @@ public:
             // early exit for sets
             if (isSet && pos != a && weak_equal(*(pos - 1), k)) {
                 // update provenance information
-                if (typeid(Comparator) != typeid(WeakComparator)) {
-                    return update(*(pos - 1), k);
+                if (typeid(Comparator) != typeid(WeakComparator) && less(k, *(pos - 1))) {
+                    update(*(pos - 1), k);
+                    return true;
                 }
 
                 return false;
@@ -1857,11 +1859,9 @@ public:
         out << "  Size of inner node: " << sizeof(inner_node) << "\n";
         out << "  Size of leaf node:  " << sizeof(leaf_node) << "\n";
         out << "  Size of Key:        " << sizeof(Key) << "\n";
-        out << "  max keys / node:    " << node::maxKeys << "\n";
-        out << "  avg keys / node:    " << (nodes == 0 ? 0 : ((double)size() / (double)nodes)) << "\n";
-        out << "  avg filling rate:   "
-            << (nodes == 0 ? 0 : (((double)size() / (double)nodes) / node::maxKeys)) << "\n";
-        out << "  Memory usage:       " << (getMemoryUsage() / 1'000'000) << "MB\n";
+        out << "  max keys / node:  " << node::maxKeys << "\n";
+        out << "  avg keys / node:  " << (size() / (double)nodes) << "\n";
+        out << "  avg filling rate: " << ((size() / (double)nodes) / node::maxKeys) << "\n";
         out << " ---------------------------------\n";
         out << "  insert-hint (hits/misses/total): " << hint_stats.inserts.getHits() << "/"
             << hint_stats.inserts.getMisses() << "/" << hint_stats.inserts.getAccesses() << "\n";
diff --git a/src/include/souffle/datastructure/BTreeDelete.h b/src/include/souffle/datastructure/BTreeDelete.h
index 13bdfad..be970ad 100644
--- a/src/include/souffle/datastructure/BTreeDelete.h
+++ b/src/include/souffle/datastructure/BTreeDelete.h
@@ -92,8 +92,8 @@ protected:
     /* -------------- updater utilities ------------- */
 
     mutable Updater upd;
-    bool update(Key& old_k, const Key& new_k) {
-        return upd.update(old_k, new_k);
+    void update(Key& old_k, const Key& new_k) {
+        upd.update(old_k, new_k);
     }
 
     /* -------------- the node type ----------------- */
@@ -1278,14 +1278,14 @@ public:
                     }
 
                     // update provenance information
-                    if (typeid(Comparator) != typeid(WeakComparator)) {
+                    if (typeid(Comparator) != typeid(WeakComparator) && less(k, *pos)) {
                         if (!cur->lock.try_upgrade_to_write(cur_lease)) {
                             // start again
                             return insert(k, hints);
                         }
-                        bool updated = update(*pos, k);
+                        update(*pos, k);
                         cur->lock.end_write();
-                        return updated;
+                        return true;
                     }
 
                     // we found the element => no check of lock necessary
@@ -1333,14 +1333,14 @@ public:
                 }
 
                 // update provenance information
-                if (typeid(Comparator) != typeid(WeakComparator)) {
+                if (typeid(Comparator) != typeid(WeakComparator) && less(k, *(pos - 1))) {
                     if (!cur->lock.try_upgrade_to_write(cur_lease)) {
                         // start again
                         return insert(k, hints);
                     }
-                    bool updated = update(*(pos - 1), k);
+                    update(*(pos - 1), k);
                     cur->lock.end_write();
-                    return updated;
+                    return true;
                 }
 
                 // we found the element => done
@@ -1485,8 +1485,9 @@ public:
                 // early exit for sets
                 if (isSet && pos != b && weak_equal(*pos, k)) {
                     // update provenance information
-                    if (typeid(Comparator) != typeid(WeakComparator)) {
-                        return update(*pos, k);
+                    if (typeid(Comparator) != typeid(WeakComparator) && less(k, *pos)) {
+                        update(*pos, k);
+                        return true;
                     }
 
                     return false;
@@ -1510,8 +1511,9 @@ public:
             // early exit for sets
             if (isSet && pos != a && weak_equal(*(pos - 1), k)) {
                 // update provenance information
-                if (typeid(Comparator) != typeid(WeakComparator)) {
-                    return update(*(pos - 1), k);
+                if (typeid(Comparator) != typeid(WeakComparator) && less(k, *(pos - 1))) {
+                    update(*(pos - 1), k);
+                    return true;
                 }
 
                 return false;
@@ -1658,16 +1660,12 @@ public:
                         leftmost = nullptr;
                         res.cur = nullptr;
                         res.pos = 0;
-                        delete static_cast<leaf_node*>(iter.cur);
                     } else {
                         // Whole tree now contained in child at position 0
                         root = iter.cur->getChild(0);
                         root->parent = nullptr;
-                        for (unsigned i = 0; i <= iter.cur->asInnerNode().numElements; ++i) {
-                            iter.cur->asInnerNode().children[i] = nullptr;
-                        }
-                        delete static_cast<inner_node*>(iter.cur);
                     }
+                    delete iter.cur;
                 }
                 break;
             }
@@ -1915,14 +1913,7 @@ private:
         left->numElements += right->getNumElements() + 1;
 
         // Delete the right node
-        if (right->isLeaf()) {
-            delete static_cast<leaf_node*>(right);
-        } else {
-            for (unsigned i = 0; i <= right->asInnerNode().numElements; ++i) {
-                right->asInnerNode().children[i] = nullptr;
-            }
-            delete static_cast<inner_node*>(right);
-        }
+        delete right;
     }
 
     /**
@@ -2418,11 +2409,9 @@ public:
         out << "  Size of inner node: " << sizeof(inner_node) << "\n";
         out << "  Size of leaf node:  " << sizeof(leaf_node) << "\n";
         out << "  Size of Key:        " << sizeof(Key) << "\n";
-        out << "  max keys / node:    " << node::maxKeys << "\n";
-        out << "  avg keys / node:    " << (nodes == 0 ? 0 : ((double)size() / (double)nodes)) << "\n";
-        out << "  avg filling rate:   "
-            << (nodes == 0 ? 0 : (((double)size() / (double)nodes) / node::maxKeys)) << "\n";
-        out << "  Memory usage:       " << (getMemoryUsage() / 1'000'000) << "MB\n";
+        out << "  max keys / node:  " << node::maxKeys << "\n";
+        out << "  avg keys / node:  " << (size() / (double)nodes) << "\n";
+        out << "  avg filling rate: " << ((size() / (double)nodes) / node::maxKeys) << "\n";
         out << " ---------------------------------\n";
         out << "  insert-hint (hits/misses/total): " << hint_stats.inserts.getHits() << "/"
             << hint_stats.inserts.getMisses() << "/" << hint_stats.inserts.getAccesses() << "\n";
diff --git a/src/include/souffle/datastructure/BTreeUtil.h b/src/include/souffle/datastructure/BTreeUtil.h
index 1640060..421149c 100644
--- a/src/include/souffle/datastructure/BTreeUtil.h
+++ b/src/include/souffle/datastructure/BTreeUtil.h
@@ -16,8 +16,6 @@
 
 #pragma once
 
-#include <tuple>
-
 namespace souffle {
 
 namespace detail {
@@ -217,9 +215,7 @@ struct default_strategy<std::tuple<Ts...>> : public linear {};
  */
 template <typename T>
 struct updater {
-    bool update(T& /* old_t */, const T& /* new_t */) {
-        return false;
-    }
+    void update(T& /* old_t */, const T& /* new_t */) {}
 };
 
 }  // end of namespace detail
diff --git a/src/include/souffle/datastructure/ConcurrentFlyweight.h b/src/include/souffle/datastructure/ConcurrentFlyweight.h
index afba416..ed41d11 100644
--- a/src/include/souffle/datastructure/ConcurrentFlyweight.h
+++ b/src/include/souffle/datastructure/ConcurrentFlyweight.h
@@ -190,15 +190,10 @@ public:
             static_assert(NONE == std::numeric_limits<slot_type>::max(),
                     "required for wrap around to 0 for begin-iterator-scan");
             static_assert(NONE + 1 == 0, "required for wrap around to 0 for begin-iterator-scan");
-
             while (Slot != END) {
                 assert(Slot + 1 < SLOT_MAX);
-
                 if (Slot + 1 < NextMaybeUnassignedSlot) {  // next unassigned slot not reached
                     Slot = Slot + 1;
-                    if (Slot == 0 && This->FirstSlotIsReserved) {
-                        continue;
-                    }
                     return true;
                 }
 
@@ -231,11 +226,10 @@ public:
             const bool ReserveFirst, const Hash& hash = Hash(), const KeyEqual& key_equal = KeyEqual(),
             const KeyFactory& key_factory = KeyFactory())
             : Lanes(LaneCount), HandleCount(LaneCount),
-              Mapping(LaneCount, InitialCapacity, hash, key_equal, key_factory),
-              FirstSlotIsReserved(ReserveFirst) {
+              Mapping(LaneCount, InitialCapacity, hash, key_equal, key_factory) {
         Slots = std::make_unique<const value_type*[]>(InitialCapacity);
         Handles = std::make_unique<Handle[]>(HandleCount);
-        NextSlot = (FirstSlotIsReserved ? 1 : 0);
+        NextSlot = (ReserveFirst ? 1 : 0);
         SlotCount = InitialCapacity;
     }
 
@@ -400,9 +394,6 @@ private:
     // Number of slots.
     std::atomic<slot_type> SlotCount;
 
-    /// If true, the first slot (index 0) is not a valid entry.
-    const bool FirstSlotIsReserved;
-
     /// Grow the datastructure if needed.
     bool tryGrow(const lane_id H) {
         // This call may release and re-acquire the lane to
diff --git a/src/include/souffle/datastructure/ConcurrentInsertOnlyHashMap.h b/src/include/souffle/datastructure/ConcurrentInsertOnlyHashMap.h
index ed51ef6..d9f0746 100644
--- a/src/include/souffle/datastructure/ConcurrentInsertOnlyHashMap.h
+++ b/src/include/souffle/datastructure/ConcurrentInsertOnlyHashMap.h
@@ -38,7 +38,7 @@ static constexpr uint64_t LargestPrime64 = 18446744073709551557UL;
 
 // Return a prime greater or equal to the lower bound.
 // Return 0 if the next prime would not fit in 64 bits.
-inline static uint64_t GreaterOrEqualPrime(const uint64_t LowerBound) {
+static uint64_t GreaterOrEqualPrime(const uint64_t LowerBound) {
     if (LowerBound > LargestPrime64) {
         return 0;
     }
@@ -177,15 +177,15 @@ public:
         return static_cast<node_type>(BL);
     }
 
-    /**
-     * @brief Lookup a value associated with a key.
+    /** @brief Checks if the map contains an element with the given key.
      *
      * The search is done concurrently with possible insertion of the
-     * searched key. If the a nullpointer is returned, then the key
-     * was not associated with a value when the search began.
+     * searched key. If return true, then there is definitely an element
+     * with the specified key, if return false then there was no such
+     * element when the search began.
      */
     template <class K>
-    const value_type* weakFind(const lane_id H, const K& X) const {
+    bool weakContains(const lane_id H, const K& X) const {
         const size_t HashValue = Hasher(X);
         const auto Guard = Lanes.guard(H);
         const size_t Bucket = HashValue % BucketCount;
@@ -194,23 +194,11 @@ public:
         while (L != nullptr) {
             if (EqualTo(L->Value.first, X)) {
                 // found the key
-                return &L->Value;
+                return true;
             }
             L = L->Next;
         }
-        return nullptr;
-    }
-
-    /** @brief Checks if the map contains an element with the given key.
-     *
-     * The search is done concurrently with possible insertion of the
-     * searched key. If return true, then there is definitely an element
-     * with the specified key, if return false then there was no such
-     * element when the search began.
-     */
-    template <class K>
-    inline bool weakContains(const lane_id H, const K& X) const {
-        return weakFind(H, X) != nullptr;
+        return false;
     }
 
     /**
diff --git a/src/include/souffle/datastructure/EquivalenceRelation.h b/src/include/souffle/datastructure/EquivalenceRelation.h
index 07651c1..1eddfe5 100644
--- a/src/include/souffle/datastructure/EquivalenceRelation.h
+++ b/src/include/souffle/datastructure/EquivalenceRelation.h
@@ -54,7 +54,7 @@ class EquivalenceRelation {
 public:
     using element_type = TupleType;
 
-    EquivalenceRelation() : statesMapStale(false) {}
+    EquivalenceRelation() : statesMapStale(false){};
     ~EquivalenceRelation() {
         emptyPartition();
     }
@@ -79,7 +79,7 @@ public:
     bool insert(value_type x, value_type y) {
         operation_hints z;
         return insert(x, y, z);
-    }
+    };
 
     /**
      * Insert the tuple symbolically.
@@ -89,7 +89,7 @@ public:
     bool insert(const TupleType& tuple) {
         operation_hints hints;
         return insert(tuple[0], tuple[1], hints);
-    }
+    };
 
     /**
      * Insert the two values symbolically as a binary relation
@@ -208,11 +208,11 @@ public:
      */
     bool contains(const TupleType& tuple, operation_hints&) const {
         return contains(tuple[0], tuple[1]);
-    }
+    };
 
     bool contains(const TupleType& tuple) const {
         return contains(tuple[0], tuple[1]);
-    }
+    };
 
     void emptyPartition() const {
         // delete the beautiful values inside (they're raw ptrs, so they need to be.)
@@ -270,7 +270,7 @@ public:
 
         // one iterator for signalling the end (simplifies)
         explicit iterator(const EquivalenceRelation* br, bool /* signalIsEndIterator */)
-                : br(br), isEndVal(true) {}
+                : br(br), isEndVal(true){};
 
         explicit iterator(const EquivalenceRelation* br)
                 : br(br), ityp(IterType::ALL), djSetMapListIt(br->equivalencePartition.begin()),
@@ -695,7 +695,7 @@ public:
         for (const auto& itp : equivalencePartition) {
             const std::size_t s = itp.second->size();
             if (s * s > perchunk) {
-                for (const auto& i : *itp.second) {
+                for (auto i : *itp.second) {
                     ret.push_back(souffle::make_range(anteriorIt(i), end()));
                 }
             } else {
@@ -716,8 +716,6 @@ public:
         return find(t, context);
     }
 
-    void printStats(std::ostream& /* o */) const {}
-
 protected:
     bool containsElement(value_type e) const {
         return this->sds.nodeExists(e);
diff --git a/src/include/souffle/datastructure/PiggyList.h b/src/include/souffle/datastructure/PiggyList.h
index 88c4e5c..91efd5b 100644
--- a/src/include/souffle/datastructure/PiggyList.h
+++ b/src/include/souffle/datastructure/PiggyList.h
@@ -16,11 +16,7 @@
  */
 #if defined(_MSC_VER)
 int __inline __builtin_clzll(unsigned long long value) {
-#if _WIN64
     return static_cast<int>(__lzcnt64(value));
-#else
-    return static_cast<int>(__lzcnt(value));
-#endif
 }
 #endif  // _MSC_VER
 #endif  // _WIN32
diff --git a/src/include/souffle/datastructure/RecordTableImpl.h b/src/include/souffle/datastructure/RecordTableImpl.h
index c96fda9..2e7b965 100644
--- a/src/include/souffle/datastructure/RecordTableImpl.h
+++ b/src/include/souffle/datastructure/RecordTableImpl.h
@@ -344,8 +344,6 @@ public:
     virtual RamDomain pack(const RamDomain* Tuple) = 0;
     virtual RamDomain pack(const std::initializer_list<RamDomain>& List) = 0;
     virtual const RamDomain* unpack(RamDomain index) const = 0;
-    virtual void enumerate(const std::function<void(const RamDomain* /*tuple*/, std::size_t /* arity*/,
-                    RamDomain /* key */)>& Callback) const = 0;
 };
 
 /** @brief Bidirectional mappping between records and record references, for any record arity. */
@@ -390,16 +388,6 @@ public:
     const RamDomain* unpack(RamDomain Index) const override {
         return fetch(Index).data();
     }
-
-    void enumerate(const std::function<void(const RamDomain* /*tuple*/, std::size_t /* arity*/,
-                    RamDomain /* key */)>& Callback) const override {
-        const auto End = end();
-        for (auto It = begin(); It != End; ++It) {
-            RamDomain key = It->second;
-            const std::vector<RamDomain>& tuple = It->first;
-            Callback(tuple.data(), Arity, key);
-        }
-    }
 };
 
 /** @brief Bidirectional mappping between records and record references, specialized for a record arity. */
@@ -449,16 +437,6 @@ public:
     const RamDomain* unpack(RamDomain Index) const override {
         return Base::fetch(Index).data();
     }
-
-    void enumerate(const std::function<void(const RamDomain* /*tuple*/, std::size_t /* arity*/,
-                    RamDomain /* key */)>& Callback) const override {
-        const auto End = Base::end();
-        for (auto It = Base::begin(); It != End; ++It) {
-            RamDomain key = It->second;
-            const auto& tuple = It->first;
-            Callback(tuple.data(), Arity, key);
-        }
-    }
 };
 
 /** Record map specialized for arity 0 */
@@ -501,9 +479,6 @@ public:
         assert(Index == EmptyRecordIndex);
         return EmptyRecordData;
     }
-
-    void enumerate(const std::function<void(const RamDomain* /*tuple*/, std::size_t /* arity*/,
-                    RamDomain /* key */)>&) const override {}
 };
 
 /** A concurrent Record Table with some specialized record maps. */
@@ -577,17 +552,6 @@ public:
         return lookupMap(Arity).unpack(Ref);
     }
 
-    void enumerate(const std::function<void(const RamDomain* /*tuple*/, std::size_t /* arity*/,
-                    RamDomain /* key */)>& Callback) const override {
-        auto Guard = Lanes.guard();
-        for (std::size_t Arity = 0; Arity < Maps.size(); ++Arity) {
-            const RecordMap* Map = Maps.at(Arity);
-            if (Map != nullptr) {
-                Map->enumerate(Callback);
-            }
-        }
-    }
-
 private:
     /** @brief lookup RecordMap for a given arity; the map for that arity must exist. */
     RecordMap& lookupMap(const std::size_t Arity) const {
diff --git a/src/include/souffle/io/IOSystem.h b/src/include/souffle/io/IOSystem.h
index d3d2a86..79649aa 100644
--- a/src/include/souffle/io/IOSystem.h
+++ b/src/include/souffle/io/IOSystem.h
@@ -88,6 +88,7 @@ private:
         registerWriteStreamFactory(std::make_shared<WriteCoutJSONFactory>());
 #ifdef USE_SQLITE
         registerReadStreamFactory(std::make_shared<ReadSQLiteFactory>());
+        registerReadStreamFactory(std::make_shared<ReadSQLiteCacheFactory>());
         registerWriteStreamFactory(std::make_shared<WriteSQLiteFactory>());
 #endif
     };
diff --git a/src/include/souffle/io/ReadStream.h b/src/include/souffle/io/ReadStream.h
index 576a5c0..4ec4261 100644
--- a/src/include/souffle/io/ReadStream.h
+++ b/src/include/souffle/io/ReadStream.h
@@ -149,7 +149,7 @@ protected:
 
         // Consume initial character
         consumeChar(source, '$', pos);
-        std::string constructor = readQualifiedName(source, pos);
+        std::string constructor = readIdentifier(source, pos);
 
         json11::Json branchInfo = [&]() -> json11::Json {
             for (auto branch : branches.array_items()) {
@@ -250,7 +250,7 @@ protected:
      * Consume preceding whitespace.
      * TODO (darth_tytus): use std::string_view?
      */
-    std::string readQualifiedName(const std::string& source, std::size_t& pos) {
+    std::string readIdentifier(const std::string& source, std::size_t& pos) {
         consumeWhiteSpace(source, pos);
         if (pos >= source.length()) {
             throw std::invalid_argument("Unexpected end of input");
@@ -259,7 +259,7 @@ protected:
         const std::size_t bgn = pos;
         while (pos < source.length()) {
             unsigned char ch = static_cast<unsigned char>(source[pos]);
-            bool valid = std::isalnum(ch) || ch == '_' || ch == '?' || ch == '.';
+            bool valid = std::isalnum(ch) || ch == '_' || ch == '?';
             if (!valid) break;
             ++pos;
         }
diff --git a/src/include/souffle/io/ReadStreamCSV.h b/src/include/souffle/io/ReadStreamCSV.h
index a90d63e..5d96b75 100644
--- a/src/include/souffle/io/ReadStreamCSV.h
+++ b/src/include/souffle/io/ReadStreamCSV.h
@@ -63,19 +63,6 @@ public:
     }
 
 protected:
-    bool readNextLine(std::string& line, bool& isCRLF) {
-        if (!getline(file, line)) {
-            return false;
-        }
-        // Handle Windows line endings on non-Windows systems
-        isCRLF = !line.empty() && line.back() == '\r';
-        if (isCRLF) {
-            line.pop_back();
-        }
-        ++lineNumber;
-        return true;
-    }
-
     /**
      * Read and return the next tuple.
      *
@@ -88,16 +75,21 @@ protected:
         }
         std::string line;
         Own<RamDomain[]> tuple = mk<RamDomain[]>(typeAttributes.size());
-        bool wasCRLF = false;
-        if (!readNextLine(line, wasCRLF)) {
+
+        if (!getline(file, line)) {
             return nullptr;
         }
+        // Handle Windows line endings on non-Windows systems
+        if (!line.empty() && line.back() == '\r') {
+            line = line.substr(0, line.length() - 1);
+        }
+        ++lineNumber;
 
         std::size_t start = 0;
         std::size_t columnsFilled = 0;
         for (uint32_t column = 0; columnsFilled < arity; column++) {
             std::size_t charactersRead = 0;
-            std::string element = nextElement(line, start, wasCRLF);
+            std::string element = nextElement(line, start);
             if (inputMap.count(column) == 0) {
                 continue;
             }
@@ -170,43 +162,16 @@ protected:
         return value;
     }
 
-    std::string nextElement(std::string& line, std::size_t& start, bool& wasCRLF) {
+    std::string nextElement(const std::string& line, std::size_t& start) {
         std::string element;
 
         if (rfc4180) {
             if (line[start] == '"') {
                 // quoted field
-                std::size_t end = line.length();
+                const std::size_t end = line.length();
                 std::size_t pos = start + 1;
                 bool foundEndQuote = false;
-                while (!foundEndQuote) {
-                    if (pos == end) {
-                        bool newWasCRLF = false;
-                        if (!readNextLine(line, newWasCRLF)) {
-                            break;
-                        }
-                        // account for \r\n or \n that we had previously
-                        // read and thrown out.
-                        // since we're in a quote, we should restore
-                        // what the user provided
-                        if (wasCRLF) {
-                            element.push_back('\r');
-                        }
-                        element.push_back('\n');
-
-                        // remember if we just read a CRLF sequence
-                        wasCRLF = newWasCRLF;
-
-                        // start over
-                        pos = 0;
-                        end = line.length();
-                    }
-                    if (pos == end) {
-                        // this means we've got a blank line and we need to read
-                        // more
-                        continue;
-                    }
-
+                while (pos < end) {
                     char c = line[pos++];
                     if (c == '"' && (pos < end) && line[pos] == '"') {
                         // two double-quote => one double-quote
@@ -214,6 +179,7 @@ protected:
                         ++pos;
                     } else if (c == '"') {
                         foundEndQuote = true;
+                        break;
                     } else {
                         element.push_back(c);
                     }
diff --git a/src/include/souffle/io/ReadStreamSQLite.h b/src/include/souffle/io/ReadStreamSQLite.h
index 9cac3e3..875ab68 100644
--- a/src/include/souffle/io/ReadStreamSQLite.h
+++ b/src/include/souffle/io/ReadStreamSQLite.h
@@ -35,9 +35,10 @@ namespace souffle {
 class ReadStreamSQLite : public ReadStream {
 public:
     ReadStreamSQLite(const std::map<std::string, std::string>& rwOperation, SymbolTable& symbolTable,
-            RecordTable& recordTable)
+            RecordTable& recordTable, bool needEmptyStringTransform)
             : ReadStream(rwOperation, symbolTable, recordTable), dbFilename(getFileName(rwOperation)),
-              relationName(rwOperation.at("name")) {
+              relationName(rwOperation.at("name")),
+              flagNeedEmptyStringTransform(needEmptyStringTransform) {
         openDB();
         checkTableExists();
         prepareSelectStatement();
@@ -66,12 +67,12 @@ protected:
         for (column = 0; column < arity; column++) {
             std::string element;
             if (0 == sqlite3_column_bytes(selectStatement, column)) {
-                element = "";
+                element = flagNeedEmptyStringTransform? "n/a":"";
             } else {
                 element = reinterpret_cast<const char*>(sqlite3_column_text(selectStatement, column));
 
                 if (element.empty()) {
-                    element = "";
+                    element = flagNeedEmptyStringTransform? "n/a":"";
                 }
             }
 
@@ -186,13 +187,14 @@ protected:
     const std::string relationName;
     sqlite3_stmt* selectStatement = nullptr;
     sqlite3* db = nullptr;
+    bool flagNeedEmptyStringTransform = true;
 };
 
 class ReadSQLiteFactory : public ReadStreamFactory {
 public:
     Own<ReadStream> getReader(const std::map<std::string, std::string>& rwOperation, SymbolTable& symbolTable,
             RecordTable& recordTable) override {
-        return mk<ReadStreamSQLite>(rwOperation, symbolTable, recordTable);
+        return mk<ReadStreamSQLite>(rwOperation, symbolTable, recordTable, true);
     }
 
     const std::string& getName() const override {
@@ -202,4 +204,18 @@ public:
     ~ReadSQLiteFactory() override = default;
 };
 
+class ReadSQLiteCacheFactory : public ReadStreamFactory {
+public:
+    Own<ReadStream> getReader(const std::map<std::string, std::string>& rwOperation, SymbolTable& symbolTable,
+            RecordTable& recordTable) override {
+        return mk<ReadStreamSQLite>(rwOperation, symbolTable, recordTable, false);
+    }
+
+    const std::string& getName() const override {
+        static const std::string name = "sqlite-cache";
+        return name;
+    }
+    ~ReadSQLiteCacheFactory() override = default;
+};
+
 } /* namespace souffle */
diff --git a/src/include/souffle/io/SerialisationStream.h b/src/include/souffle/io/SerialisationStream.h
index d13d06c..6a609ea 100644
--- a/src/include/souffle/io/SerialisationStream.h
+++ b/src/include/souffle/io/SerialisationStream.h
@@ -17,7 +17,7 @@
 #pragma once
 
 #include "souffle/RamTypes.h"
-#include "souffle/utility/ContainerUtil.h"
+
 #include "souffle/utility/StringUtil.h"
 #include "souffle/utility/json11.h"
 #include <cassert>
diff --git a/src/include/souffle/io/WriteStream.h b/src/include/souffle/io/WriteStream.h
index 555ce8a..06449cd 100644
--- a/src/include/souffle/io/WriteStream.h
+++ b/src/include/souffle/io/WriteStream.h
@@ -50,7 +50,7 @@ public:
             }
             return;
         }
-        for (const auto& current : relation) {
+        for (auto current : relation) {
             writeNext(current);
         }
     }
diff --git a/src/include/souffle/io/WriteStreamSQLite.h b/src/include/souffle/io/WriteStreamSQLite.h
index 240b6da..c51a180 100644
--- a/src/include/souffle/io/WriteStreamSQLite.h
+++ b/src/include/souffle/io/WriteStreamSQLite.h
@@ -58,20 +58,27 @@ protected:
     void writeNextTuple(const RamDomain* tuple) override {
         for (std::size_t i = 0; i < arity; i++) {
             RamDomain value = 0;  // Silence warning
+            const char* symvalue = nullptr; // Directly insert string into db
 
             switch (typeAttributes.at(i)[0]) {
-                case 's': value = getSymbolTableID(tuple[i]); break;
+                case 's': symvalue = symbolTable.decode(tuple[i]).c_str(); break;
                 default: value = tuple[i]; break;
             }
-
+            if (symvalue) {
+                if (sqlite3_bind_text(insertStatement, static_cast<int>(i + 1), symvalue, -1, SQLITE_TRANSIENT) !=
+                    SQLITE_OK) {
+                    throwError("SQLite error in sqlite3_bind_text: ");
+                }
+            } else {
 #if RAM_DOMAIN_SIZE == 64
-            if (sqlite3_bind_int64(insertStatement, static_cast<int>(i + 1),
-                        static_cast<sqlite3_int64>(value)) != SQLITE_OK) {
+                if (sqlite3_bind_int64(insertStatement, static_cast<int>(i + 1),
+                            static_cast<sqlite3_int64>(value)) != SQLITE_OK) {
 #else
-            if (sqlite3_bind_int(insertStatement, static_cast<int>(i + 1), static_cast<int>(value)) !=
-                    SQLITE_OK) {
+                if (sqlite3_bind_int(insertStatement, static_cast<int>(i + 1), static_cast<int>(value)) !=
+                        SQLITE_OK) {
 #endif
-                throwError("SQLite error in sqlite3_bind_text: ");
+                    throwError("SQLite error in sqlite3_bind_text: ");
+                }
             }
         }
         if (sqlite3_step(insertStatement) != SQLITE_DONE) {
@@ -153,8 +160,8 @@ private:
 
     void prepareStatements() {
         prepareInsertStatement();
-        prepareSymbolInsertStatement();
-        prepareSymbolSelectStatement();
+        // prepareSymbolInsertStatement();
+        // prepareSymbolSelectStatement();
     }
     void prepareSymbolInsertStatement() {
         std::stringstream insertSQL;
@@ -178,7 +185,7 @@ private:
 
     void prepareInsertStatement() {
         std::stringstream insertSQL;
-        insertSQL << "INSERT INTO '_" << relationName << "' VALUES ";
+        insertSQL << "INSERT INTO '" << relationName << "' VALUES ";
         insertSQL << "(@V0";
         for (unsigned int i = 1; i < arity; i++) {
             insertSQL << ",@V" << i;
@@ -192,23 +199,30 @@ private:
 
     void createTables() {
         createRelationTable();
-        createRelationView();
-        createSymbolTable();
+        // createSymbolTable();
+        // createRelationView();
     }
 
     void createRelationTable() {
+        const auto columnNames = params["relation"]["params"].array_items();
+
         std::stringstream createTableText;
-        createTableText << "CREATE TABLE IF NOT EXISTS '_" << relationName << "' (";
+        createTableText << "CREATE TABLE IF NOT EXISTS '" << relationName << "' (";
         if (arity > 0) {
-            createTableText << "'0' INTEGER";
-            for (unsigned int i = 1; i < arity; i++) {
-                createTableText << ",'" << std::to_string(i) << "' ";
-                createTableText << "INTEGER";
+            for (unsigned int i = 0; i < arity; i++) {
+                const std::string tableColumnName = std::to_string(i);
+                const auto& realColumnName =
+                        (columnNames[i].is_string() ? columnNames[i].string_value() : tableColumnName);
+                if (i) {
+                    createTableText << ",";
+                }
+                createTableText << "'" << realColumnName << "' ";
+                createTableText << (typeAttributes.at(i)[0] == 's'? "TEXT":"INTEGER");
             }
         }
         createTableText << ");";
         executeSQL(createTableText.str(), db);
-        executeSQL("DELETE FROM '_" + relationName + "';", db);
+        executeSQL("DELETE FROM '" + relationName + "';", db);
     }
 
     void createRelationView() {
diff --git a/src/include/souffle/profile/Cell.h b/src/include/souffle/profile/Cell.h
index 0ebd83e..a759495 100644
--- a/src/include/souffle/profile/Cell.h
+++ b/src/include/souffle/profile/Cell.h
@@ -37,7 +37,7 @@ public:
     double getDoubleVal() const override {
         return value.count() / 1000000.0;
     }
-    int64_t getLongVal() const override {
+    long getLongVal() const override {
         std::cerr << "getting long on time cell\n";
         throw this;
     }
@@ -62,7 +62,7 @@ public:
     double getDoubleVal() const override {
         return value;
     }
-    int64_t getLongVal() const override {
+    long getLongVal() const override {
         std::cerr << "getting long on double cell\n";
         throw this;
     }
@@ -89,7 +89,7 @@ public:
         std::cerr << "getting double on string cell\n";
         throw this;
     }
-    int64_t getLongVal() const override {
+    long getLongVal() const override {
         std::cerr << "getting long on string cell\n";
         throw this;
     }
@@ -106,11 +106,11 @@ public:
 };
 
 template <>
-class Cell<int64_t> : public CellInterface {
-    const int64_t value;
+class Cell<long> : public CellInterface {
+    const long value;
 
 public:
-    Cell(int64_t value) : value(value){};
+    Cell(long value) : value(value){};
     double getDoubleVal() const override {
         std::cerr << "getting double on long cell\n";
         throw this;
@@ -119,7 +119,7 @@ public:
         std::cerr << "getting string on long cell\n";
         throw this;
     }
-    int64_t getLongVal() const override {
+    long getLongVal() const override {
         return value;
     }
     std::chrono::microseconds getTimeVal() const override {
@@ -139,7 +139,7 @@ public:
         std::cerr << "getting double on void cell";
         throw this;
     }
-    int64_t getLongVal() const override {
+    long getLongVal() const override {
         std::cerr << "getting long on void cell";
         throw this;
     }
diff --git a/src/include/souffle/profile/CellInterface.h b/src/include/souffle/profile/CellInterface.h
index 8194b77..38cc8eb 100644
--- a/src/include/souffle/profile/CellInterface.h
+++ b/src/include/souffle/profile/CellInterface.h
@@ -20,7 +20,7 @@ public:
 
     virtual double getDoubleVal() const = 0;
 
-    virtual int64_t getLongVal() const = 0;
+    virtual long getLongVal() const = 0;
 
     virtual std::string getStringVal() const = 0;
 
diff --git a/src/include/souffle/profile/Cli.h b/src/include/souffle/profile/Cli.h
index 0558324..45a5c1e 100644
--- a/src/include/souffle/profile/Cli.h
+++ b/src/include/souffle/profile/Cli.h
@@ -15,12 +15,7 @@
 #include <map>
 #include <string>
 #include <vector>
-
-#ifdef USE_CUSTOM_GETOPTLONG
-#include "souffle/utility/GetOptLongImpl.h"
-#else
 #include <getopt.h>
-#endif
 
 namespace souffle {
 namespace profile {
@@ -57,10 +52,10 @@ public:
         }
     }
 
-    int parse() {
+    void parse() {
         if (args.size() == 0) {
             std::cout << "No arguments provided.\nTry souffleprof -h for help.\n";
-            return (EXIT_FAILURE);
+            exit(EXIT_FAILURE);
         }
 
         if (args.count('h') != 0 || args.count('f') == 0) {
@@ -75,7 +70,7 @@ public:
                       << std::endl
                       << "                      Default filename is profiler_html/[num].html" << std::endl
                       << "-h                    Print this help message." << std::endl;
-            return (0);
+            exit(0);
         }
         std::string filename = args['f'];
 
@@ -86,15 +81,13 @@ public:
             }
         } else if (args.count('j') != 0) {
             if (args['j'] == "j") {
-                return Tui(filename, false, true).outputHtml();
+                Tui(filename, false, true).outputHtml();
             } else {
-                return Tui(filename, false, true).outputHtml(args['j']);
+                Tui(filename, false, true).outputHtml(args['j']);
             }
         } else {
             Tui(filename, true, false).runProf();
         }
-
-        return 0;
     }
 };
 
diff --git a/src/include/souffle/profile/EventProcessor.h b/src/include/souffle/profile/EventProcessor.h
index 468a6e5..72fa546 100644
--- a/src/include/souffle/profile/EventProcessor.h
+++ b/src/include/souffle/profile/EventProcessor.h
@@ -224,45 +224,45 @@ public:
 } nonRecursiveRuleNumberProcessor;
 
 /**
- * Non-Recursive Estimate Join Size Profile Event Processor
+ * Non-Recursive Count Unique Keys Profile Event Processor
  */
-const class NonRecursiveEstimateJoinSizeProcessor : public EventProcessor {
+const class NonRecursiveCountUniqueKeysProcessor : public EventProcessor {
 public:
-    NonRecursiveEstimateJoinSizeProcessor() {
-        EventProcessorSingleton::instance().registerEventProcessor("@non-recursive-estimate-join-size", this);
+    NonRecursiveCountUniqueKeysProcessor() {
+        EventProcessorSingleton::instance().registerEventProcessor("@non-recursive-count-unique-keys", this);
     }
     /** process event input */
     void process(ProfileDatabase& db, const std::vector<std::string>& signature, va_list& args) override {
         const std::string& relation = signature[1];
         const std::string& attributes = signature[2];
         const std::string& constants = signature[3];
-        std::string joinSize = std::to_string(va_arg(args, double));
-        db.addTextEntry({"program", "statistics", "relation", relation, "attributes", attributes, "constants",
+        std::size_t uniqueKeys = va_arg(args, std::size_t);
+        db.addSizeEntry({"program", "statistics", "relation", relation, "attributes", attributes, "constants",
                                 constants},
-                joinSize);
+                uniqueKeys);
     }
-} nonRecursiveEstimateJoinSizeProcessor;
+} nonRecursiveCountUniqueKeysProcessor;
 
 /**
- * Recursive Estimate Join Size Profile Event Processor
+ * Recursive Count Unique Keys Profile Event Processor
  */
-const class RecursiveEstimateJoinSizeProcessor : public EventProcessor {
+const class RecursiveCountUniqueKeysProcessor : public EventProcessor {
 public:
-    RecursiveEstimateJoinSizeProcessor() {
-        EventProcessorSingleton::instance().registerEventProcessor("@recursive-estimate-join-size", this);
+    RecursiveCountUniqueKeysProcessor() {
+        EventProcessorSingleton::instance().registerEventProcessor("@recursive-count-unique-keys", this);
     }
     /** process event input */
     void process(ProfileDatabase& db, const std::vector<std::string>& signature, va_list& args) override {
         const std::string& relation = signature[1];
         const std::string& attributes = signature[2];
         const std::string& constants = signature[3];
-        std::string joinSize = std::to_string(va_arg(args, double));
+        std::size_t uniqueKeys = va_arg(args, std::size_t);
         std::string iteration = std::to_string(va_arg(args, std::size_t));
-        db.addTextEntry({"program", "statistics", "relation", relation, "iteration", iteration, "attributes",
+        db.addSizeEntry({"program", "statistics", "relation", relation, "iteration", iteration, "attributes",
                                 attributes, "constants", constants},
-                joinSize);
+                uniqueKeys);
     }
-} recursiveEstimateJoinSizeProcessor;
+} recursiveCountUniqueKeysProcessor;
 
 /**
  * Recursive Rule Timing Profile Event Processor
diff --git a/src/include/souffle/profile/OutputProcessor.h b/src/include/souffle/profile/OutputProcessor.h
index 09a1c6d..745a3d7 100644
--- a/src/include/souffle/profile/OutputProcessor.h
+++ b/src/include/souffle/profile/OutputProcessor.h
@@ -86,20 +86,19 @@ Table inline OutputProcessor::getRelTable() const {
         row[1] = std::make_shared<Cell<std::chrono::microseconds>>(r->getNonRecTime());
         row[2] = std::make_shared<Cell<std::chrono::microseconds>>(r->getRecTime());
         row[3] = std::make_shared<Cell<std::chrono::microseconds>>(r->getCopyTime());
-        row[4] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(r->size()));
+        row[4] = std::make_shared<Cell<long>>(r->size());
         row[5] = std::make_shared<Cell<std::string>>(r->getName());
         row[6] = std::make_shared<Cell<std::string>>(r->getId());
         row[7] = std::make_shared<Cell<std::string>>(r->getLocator());
         if (total_time.count() != 0) {
-            row[8] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(
-                    static_cast<double>(r->size()) / (static_cast<double>(total_time.count()) / 1000000.0)));
+            row[8] = std::make_shared<Cell<long>>(r->size() / (total_time.count() / 1000000.0));
         } else {
-            row[8] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(r->size()));
+            row[8] = std::make_shared<Cell<long>>(r->size());
         }
         row[9] = std::make_shared<Cell<std::chrono::microseconds>>(r->getLoadtime());
         row[10] = std::make_shared<Cell<std::chrono::microseconds>>(r->getSavetime());
-        row[11] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(r->getMaxRSSDiff()));
-        row[12] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(r->getReads()));
+        row[11] = std::make_shared<Cell<long>>(r->getMaxRSSDiff());
+        row[12] = std::make_shared<Cell<long>>(r->getReads());
 
         table.addRow(std::make_shared<Row>(row));
     }
@@ -132,11 +131,11 @@ Table inline OutputProcessor::getRulTable() const {
             row[1] = std::make_shared<Cell<std::chrono::microseconds>>(rule->getRuntime());
             row[2] = std::make_shared<Cell<std::chrono::microseconds>>(std::chrono::microseconds(0));
             row[3] = std::make_shared<Cell<std::chrono::microseconds>>(std::chrono::microseconds(0));
-            row[4] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(rule->size()));
+            row[4] = std::make_shared<Cell<long>>(rule->size());
             row[5] = std::make_shared<Cell<std::string>>(rule->getName());
             row[6] = std::make_shared<Cell<std::string>>(rule->getId());
             row[7] = std::make_shared<Cell<std::string>>(rel.second->getName());
-            row[8] = std::make_shared<Cell<int64_t>>(0);
+            row[8] = std::make_shared<Cell<long>>(0);
             row[10] = std::make_shared<Cell<std::string>>(rule->getLocator());
             ruleMap.emplace(rule->getName(), std::make_shared<Row>(row));
         }
@@ -147,8 +146,7 @@ Table inline OutputProcessor::getRulTable() const {
                     Row row = *ruleMap[rule->getName()];
                     row[2] = std::make_shared<Cell<std::chrono::microseconds>>(
                             row[2]->getTimeVal() + rule->getRuntime());
-                    row[4] = std::make_shared<Cell<int64_t>>(
-                            row[4]->getLongVal() + static_cast<int64_t>(rule->size()));
+                    row[4] = std::make_shared<Cell<long>>(row[4]->getLongVal() + rule->size());
                     row[0] = std::make_shared<Cell<std::chrono::microseconds>>(
                             row[0]->getTimeVal() + rule->getRuntime());
                     ruleMap[rule->getName()] = std::make_shared<Row>(row);
@@ -158,11 +156,11 @@ Table inline OutputProcessor::getRulTable() const {
                     row[1] = std::make_shared<Cell<std::chrono::microseconds>>(std::chrono::microseconds(0));
                     row[2] = std::make_shared<Cell<std::chrono::microseconds>>(rule->getRuntime());
                     row[3] = std::make_shared<Cell<std::chrono::microseconds>>(std::chrono::microseconds(0));
-                    row[4] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(rule->size()));
+                    row[4] = std::make_shared<Cell<long>>(rule->size());
                     row[5] = std::make_shared<Cell<std::string>>(rule->getName());
                     row[6] = std::make_shared<Cell<std::string>>(rule->getId());
                     row[7] = std::make_shared<Cell<std::string>>(rel.second->getName());
-                    row[8] = std::make_shared<Cell<int64_t>>(rule->getVersion());
+                    row[8] = std::make_shared<Cell<long>>(rule->getVersion());
                     row[10] = std::make_shared<Cell<std::string>>(rule->getLocator());
                     ruleMap[rule->getName()] = std::make_shared<Row>(row);
                 }
@@ -219,8 +217,8 @@ Table inline OutputProcessor::getAtomTable(std::string strRel, std::string strRu
                 Row row(4);
                 row[0] = std::make_shared<Cell<std::string>>(atom.rule);
                 row[1] = std::make_shared<Cell<std::string>>(atom.identifier);
-                row[2] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(atom.level));
-                row[3] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(atom.frequency));
+                row[2] = std::make_shared<Cell<long>>(atom.level);
+                row[3] = std::make_shared<Cell<long>>(atom.frequency);
 
                 table.addRow(std::make_shared<Row>(row));
             }
@@ -303,8 +301,7 @@ Table inline OutputProcessor::getVersions(std::string strRel, std::string strRul
                     Row row = *ruleMap[strTemp];
                     row[2] = std::make_shared<Cell<std::chrono::microseconds>>(
                             row[2]->getTimeVal() + rule->getRuntime());
-                    row[4] = std::make_shared<Cell<int64_t>>(
-                            row[4]->getLongVal() + static_cast<int64_t>(rule->size()));
+                    row[4] = std::make_shared<Cell<long>>(row[4]->getLongVal() + rule->size());
                     row[0] = std::make_shared<Cell<std::chrono::microseconds>>(rule->getRuntime());
                     ruleMap[strTemp] = std::make_shared<Row>(row);
                 } else {
@@ -312,11 +309,11 @@ Table inline OutputProcessor::getVersions(std::string strRel, std::string strRul
                     row[1] = std::make_shared<Cell<std::chrono::microseconds>>(std::chrono::microseconds(0));
                     row[2] = std::make_shared<Cell<std::chrono::microseconds>>(rule->getRuntime());
                     row[3] = std::make_shared<Cell<std::chrono::microseconds>>(std::chrono::microseconds(0));
-                    row[4] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(rule->size()));
+                    row[4] = std::make_shared<Cell<long>>(rule->size());
                     row[5] = std::make_shared<Cell<std::string>>(rule->getName());
                     row[6] = std::make_shared<Cell<std::string>>(rule->getId());
                     row[7] = std::make_shared<Cell<std::string>>(rel->getName());
-                    row[8] = std::make_shared<Cell<int64_t>>(rule->getVersion());
+                    row[8] = std::make_shared<Cell<long>>(rule->getVersion());
                     row[9] = std::make_shared<Cell<std::string>>(rule->getLocator());
                     row[0] = std::make_shared<Cell<std::chrono::microseconds>>(rule->getRuntime());
                     ruleMap[strTemp] = std::make_shared<Row>(row);
@@ -369,8 +366,8 @@ Table inline OutputProcessor::getVersionAtoms(std::string strRel, std::string sr
                     Row row(4);
                     row[0] = std::make_shared<Cell<std::string>>(atom.rule);
                     row[1] = std::make_shared<Cell<std::string>>(atom.identifier);
-                    row[2] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(atom.level));
-                    row[3] = std::make_shared<Cell<int64_t>>(static_cast<int64_t>(atom.frequency));
+                    row[2] = std::make_shared<Cell<long>>(atom.level);
+                    row[3] = std::make_shared<Cell<long>>(atom.frequency);
                     table.addRow(std::make_shared<Row>(row));
                 }
             }
diff --git a/src/include/souffle/profile/ProfileEvent.h b/src/include/souffle/profile/ProfileEvent.h
index 4106680..59ff34c 100644
--- a/src/include/souffle/profile/ProfileEvent.h
+++ b/src/include/souffle/profile/ProfileEvent.h
@@ -85,12 +85,12 @@ public:
         profile::EventProcessorSingleton::instance().process(database, txt.c_str(), number, iteration);
     }
 
-    void makeNonRecursiveCountEvent(const std::string& txt, double joinSize) {
-        profile::EventProcessorSingleton::instance().process(database, txt.c_str(), joinSize);
+    void makeNonRecursiveCountEvent(const std::string& txt, std::size_t uniqueKeys) {
+        profile::EventProcessorSingleton::instance().process(database, txt.c_str(), uniqueKeys);
     }
 
-    void makeRecursiveCountEvent(const std::string& txt, double joinSize, std::size_t iteration) {
-        profile::EventProcessorSingleton::instance().process(database, txt.c_str(), joinSize, iteration);
+    void makeRecursiveCountEvent(const std::string& txt, std::size_t uniqueKeys, std::size_t iteration) {
+        profile::EventProcessorSingleton::instance().process(database, txt.c_str(), uniqueKeys, iteration);
     }
 
     /** create utilisation event */
diff --git a/src/include/souffle/profile/ProgramRun.h b/src/include/souffle/profile/ProgramRun.h
index b4422a9..a2e2e7f 100644
--- a/src/include/souffle/profile/ProgramRun.h
+++ b/src/include/souffle/profile/ProgramRun.h
@@ -138,8 +138,6 @@ public:
         for (auto& cur : relationMap) {
             if (cur.second->getStarttime() <= end && cur.second->getEndtime() >= start) {
                 result.insert(cur.second);
-            } else if (cur.second->getLoadStarttime() <= end && cur.second->getLoadEndtime() >= start) {
-                result.insert(cur.second);
             }
         }
         return result;
@@ -149,7 +147,7 @@ public:
         return Tools::formatTime(runtime);
     }
 
-    inline std::string formatNum(int precision, int64_t number) const {
+    inline std::string formatNum(int precision, long number) const {
         return Tools::formatNum(precision, number);
     }
 
diff --git a/src/include/souffle/profile/Reader.h b/src/include/souffle/profile/Reader.h
index 5d8cc36..0dbbf35 100644
--- a/src/include/souffle/profile/Reader.h
+++ b/src/include/souffle/profile/Reader.h
@@ -230,7 +230,8 @@ public:
     RelationVisitor(Relation& relation) : DSNVisitor(relation) {}
     void visit(DurationEntry& duration) override {
         if (duration.getKey() == "loadtime") {
-            base.setLoadtime(duration.getStart(), duration.getEnd());
+            auto loadtime = (duration.getEnd() - duration.getStart());
+            base.setLoadtime(loadtime);
         } else if (duration.getKey() == "savetime") {
             auto savetime = (duration.getEnd() - duration.getStart());
             base.setSavetime(savetime);
@@ -277,8 +278,9 @@ private:
     bool online{true};
 
     std::unordered_map<std::string, std::shared_ptr<Relation>> relationMap{};
-    std::unordered_map<std::string, std::unordered_map<std::string, double>> countRecursiveJoinSizeMap{};
-    std::unordered_map<std::string, double> countNonRecursiveJoinSizeMap{};
+    std::unordered_map<std::string, std::unordered_map<std::string, std::size_t>>
+            countRecursiveUniqueKeysMap{};
+    std::unordered_map<std::string, std::size_t> countNonRecursiveUniqueKeysMap{};
     int rel_id{0};
 
 public:
@@ -327,12 +329,12 @@ public:
                             continue;
                         }
                         for (const auto& constants : prefixWithAttributes->getKeys()) {
-                            auto fullKey = as<TextEntry>(db.lookupEntry({"program", "statistics", "relation",
+                            auto fullKey = as<SizeEntry>(db.lookupEntry({"program", "statistics", "relation",
                                     rel, "attributes", attributes, "constants", constants}));
                             if (fullKey != nullptr) {
-                                double joinSize = std::stod(fullKey->getText());
+                                std::size_t uniqueKeys = fullKey->getSize();
                                 std::string key = rel + " " + attributes + " " + constants;
-                                countNonRecursiveJoinSizeMap[key] = joinSize;
+                                countNonRecursiveUniqueKeysMap[key] = uniqueKeys;
                             }
                         }
                     }
@@ -356,13 +358,13 @@ public:
                                 continue;
                             }
                             for (const auto& constants : prefixWithAttributes->getKeys()) {
-                                auto fullKey = as<TextEntry>(db.lookupEntry(
+                                auto fullKey = as<SizeEntry>(db.lookupEntry(
                                         {"program", "statistics", "relation", rel, "iteration", iteration,
                                                 "attributes", attributes, "constants", constants}));
-                                double joinSize = std::stod(fullKey->getText());
+                                std::size_t uniqueKeys = fullKey->getSize();
                                 if (fullKey != nullptr) {
                                     std::string key = rel + " " + attributes + " " + constants;
-                                    countRecursiveJoinSizeMap[key][iteration] = joinSize;
+                                    countRecursiveUniqueKeysMap[key][iteration] = uniqueKeys;
                                 }
                             }
                         }
@@ -417,17 +419,17 @@ public:
     }
 
     bool hasAutoSchedulerStats() {
-        return !countNonRecursiveJoinSizeMap.empty() || !countRecursiveJoinSizeMap.empty();
+        return !countNonRecursiveUniqueKeysMap.empty() || !countRecursiveUniqueKeysMap.empty();
     }
 
-    double getNonRecursiveEstimateJoinSize(
+    std::size_t getNonRecursiveCountUniqueKeys(
             const std::string& rel, const std::string& attributes, const std::string& constants) {
         auto key = rel + " " + attributes + " " + constants;
-        return countNonRecursiveJoinSizeMap.at(key);
+        return countNonRecursiveUniqueKeysMap.at(key);
     }
 
     std::size_t getIterations(const std::string& rel) {
-        for (auto& [key, m] : countRecursiveJoinSizeMap) {
+        for (auto& [key, m] : countRecursiveUniqueKeysMap) {
             std::string token = key.substr(0, key.find(" "));
             if (token == rel) {
                 return m.size();
@@ -437,11 +439,11 @@ public:
         return 0;
     }
 
-    double getRecursiveEstimateJoinSize(const std::string& rel, const std::string& attributes,
+    std::size_t getRecursiveCountUniqueKeys(const std::string& rel, const std::string& attributes,
             const std::string& constants, const std::string& iteration) {
         auto key = rel + " " + attributes + " " + constants;
-        auto& m = countRecursiveJoinSizeMap.at(key);
-        return m.at(iteration);
+        auto& m = countRecursiveUniqueKeysMap.at(key);
+        return static_cast<std::size_t>(m.at(iteration));
     }
 
     void addRelation(const DirectoryEntry& relation) {
diff --git a/src/include/souffle/profile/Relation.h b/src/include/souffle/profile/Relation.h
index 0a16d96..b0bffd1 100644
--- a/src/include/souffle/profile/Relation.h
+++ b/src/include/souffle/profile/Relation.h
@@ -31,8 +31,7 @@ private:
     const std::string name;
     std::chrono::microseconds starttime{};
     std::chrono::microseconds endtime{};
-    std::chrono::microseconds loadstarttime{};
-    std::chrono::microseconds loadendtime{};
+    std::chrono::microseconds loadtime{};
     std::chrono::microseconds savetime{};
     std::size_t nonRecTuples = 0;
     std::size_t preMaxRSS = 0;
@@ -71,15 +70,7 @@ public:
     }
 
     std::chrono::microseconds getLoadtime() const {
-        return loadendtime - loadstarttime;
-    }
-
-    std::chrono::microseconds getLoadStarttime() const {
-        return loadstarttime;
-    }
-
-    std::chrono::microseconds getLoadEndtime() const {
-        return loadendtime;
+        return loadtime;
     }
 
     std::chrono::microseconds getSavetime() const {
@@ -136,9 +127,8 @@ public:
         return result;
     }
 
-    void setLoadtime(std::chrono::microseconds loadstarttime, std::chrono::microseconds loadendtime) {
-        this->loadstarttime = loadstarttime;
-        this->loadendtime = loadendtime;
+    void setLoadtime(std::chrono::microseconds loadtime) {
+        this->loadtime = loadtime;
     }
 
     void setSavetime(std::chrono::microseconds savetime) {
diff --git a/src/include/souffle/profile/Tui.h b/src/include/souffle/profile/Tui.h
index 6de9147..8ef1210 100644
--- a/src/include/souffle/profile/Tui.h
+++ b/src/include/souffle/profile/Tui.h
@@ -28,7 +28,6 @@
 #include <cstdint>
 #include <cstdio>
 #include <cstdlib>
-#include <filesystem>
 #include <iostream>
 #include <iterator>
 #include <map>
@@ -40,11 +39,9 @@
 #include <unordered_map>
 #include <utility>
 #include <vector>
-#ifndef _MSC_VER
 #include <dirent.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
-#endif
 
 namespace souffle {
 namespace profile {
@@ -216,11 +213,10 @@ public:
         }
     }
 
-    /// Return an exit status equal to 0 on success.
-    int runProf() {
+    void runProf() {
         if (!loaded && !f_name.empty()) {
             std::cout << "Error: File cannot be loaded\n";
-            return 1;
+            return;
         }
         if (loaded) {
             std::cout << "SouffleProf\n";
@@ -257,8 +253,6 @@ public:
                 runCommand(c);
             }
         }
-
-        return 0;
     }
 
     std::stringstream& genJsonTop(std::stringstream& ss) {
@@ -639,50 +633,47 @@ public:
         return ss.str();
     }
 
-    /// Return an exit status equal to 0 on success.
-    int outputHtml(std::string filename = "profiler_html/") {
+    void outputHtml(std::string filename = "profiler_html/") {
         std::cout << "SouffleProf\n";
         std::cout << "Generating HTML files...\n";
 
-        std::filesystem::path filepath(filename);
-        if (filepath.has_parent_path()) {
-            std::error_code ec;
-            std::filesystem::create_directories(filepath.parent_path(), ec);
-            if (ec != std::error_code{}) {
-                std::cerr << "directory " << filepath.parent_path()
-                          << " could not be created. Please create it and try again.\n";
-                return 2;
-            }
-        }
-
-        if (!filepath.has_filename()) {
-            // create a fresh filename
-            bool notfound = true;
-            unsigned i = 1;
-            while (i < 1000) {
-                std::filesystem::path freshPath = filepath;
-                freshPath /= std::to_string(i);
-                freshPath.replace_extension(".html");
-                if (!std::filesystem::exists(freshPath)) {
-                    filepath = freshPath;
-                    notfound = false;
-                    break;
-                }
-                ++i;
+        DIR* dir;
+        bool exists = false;
+
+        if (filename.find('/') != std::string::npos) {
+            std::string path = filename.substr(0, filename.find('/'));
+            if ((dir = opendir(path.c_str())) != nullptr) {
+                exists = true;
+                closedir(dir);
             }
-            if (notfound) {
-                std::cerr << "Could not generate a fresh file name (1000 tested).\n";
-                return 2;
+            if (!exists) {
+                mode_t nMode = 0733;  // UNIX style permissions
+                int nError = 0;
+                nError = mkdir(path.c_str(), nMode);
+                if (nError != 0) {
+                    std::cerr << "directory " << path
+                              << " could not be created. Please create it and try again.";
+                    exit(2);
+                }
             }
         }
+        std::string filetype = ".html";
+        std::string newFile = filename;
 
-        std::ofstream outfile(filepath);
+        if (filename.size() <= filetype.size() ||
+                !std::equal(filetype.rbegin(), filetype.rend(), filename.rbegin())) {
+            int i = 0;
+            do {
+                ++i;
+                newFile = filename + std::to_string(i) + ".html";
+            } while (Tools::file_exists(newFile));
+        }
 
-        outfile << HtmlGenerator::getHtml(genJson());
+        std::ofstream outfile(newFile);
 
-        std::cout << "file output to: " << filepath << std::endl;
+        outfile << HtmlGenerator::getHtml(genJson());
 
-        return 0;
+        std::cout << "file output to: " << newFile << std::endl;
     }
 
     void quit() {
@@ -892,13 +883,11 @@ public:
         std::printf("%11s\n", Tools::formatTime(usages.rbegin()->usertime).c_str());
 
         // Add columns to the graph
-        // char grid[height][width];
-        std::vector<std::vector<char>> grid;
-        grid.reserve(height);
-        grid.resize(height);
+        char grid[height][width];
         for (uint32_t i = 0; i < height; ++i) {
-            grid[i].reserve(width);
-            grid[i].resize(width, ' ');
+            for (uint32_t j = 0; j < width; ++j) {
+                grid[i][j] = ' ';
+            }
         }
 
         previousUsage = {{}, 0, {}, {}};
@@ -955,13 +944,11 @@ public:
         uint64_t maxMaxRSS = 0;
 
         std::set<Usage> usages = getUsageStats(width);
-        // char grid[height][width];
-        std::vector<std::vector<char>> grid;
-        grid.reserve(height);
-        grid.resize(height);
+        char grid[height][width];
         for (uint32_t i = 0; i < height; ++i) {
-            grid[i].reserve(width);
-            grid[i].resize(width, ' ');
+            for (uint32_t j = 0; j < width; ++j) {
+                grid[i][j] = ' ';
+            }
         }
 
         for (auto& usage : usages) {
@@ -1484,14 +1471,10 @@ protected:
     }
 
     uint32_t getTermWidth() {
-#ifdef _MSC_VER
-        return 80;
-#else
         struct winsize w {};
         ioctl(0, TIOCGWINSZ, &w);
         uint32_t width = w.ws_col > 0 ? w.ws_col : 80;
         return width;
-#endif
     }
 };
 
diff --git a/src/include/souffle/profile/UserInputReader.h b/src/include/souffle/profile/UserInputReader.h
index 767f612..0130e25 100644
--- a/src/include/souffle/profile/UserInputReader.h
+++ b/src/include/souffle/profile/UserInputReader.h
@@ -12,11 +12,8 @@
 #include <iterator>  // for end, begin
 #include <string>
 #include <vector>
-
-#ifndef _MSC_VER
 #include <termios.h>  // for termios, tcsetattr, tcgetattr, ECHO, ICANON, cc_t
 #include <unistd.h>   // for read
-#endif
 
 namespace souffle {
 namespace profile {
@@ -57,7 +54,6 @@ public:
     }
 
     void readchar() {
-#ifndef _MSC_VER
         char buf = 0;
         struct termios old = {};
         if (tcgetattr(0, &old) < 0) {
@@ -80,13 +76,6 @@ public:
         }
 
         current_char = buf;
-#else
-        char buf = 0;
-        if (_read(0, &buf, 1) < 0) {
-            perror("read()");
-        }
-        current_char = buf;
-#endif
     }
     std::string getInput() {
         output = "";
@@ -150,7 +139,6 @@ public:
 
         return output;
     }
-
     void setPrompt(std::string prompt) {
         this->prompt = prompt;
     }
diff --git a/src/include/souffle/profile/htmlJsMain.h b/src/include/souffle/profile/htmlJsMain.h
index e1ce7b7..0f43d2e 100644
--- a/src/include/souffle/profile/htmlJsMain.h
+++ b/src/include/souffle/profile/htmlJsMain.h
@@ -25,14 +25,6 @@ function changeSelectedRul(id) {
     genAtomVer();
 }
 
-function goBack() {
-    if (came_from==="rel") {
-        document.getElementById("rel_tab").click();
-    } else if (came_from==="rul") {
-        document.getElementById("rul_tab").click();
-    }
-}
-
 function highlightRow() {
     var i;
     for (i=0;i<document.getElementsByClassName("rel_row").length;i++) {
@@ -59,13 +51,13 @@ function graphRel() {
     graph_vals.labels = [];
     graph_vals.tot_t = [];
     graph_vals.tuples = [];
-    for (var j = 0; j < data.rel[selected.rel][10].tot_t.length; j++) {
+    for (j = 0; j < data.rel[selected.rel][9].tot_t.length; j++) {
         graph_vals.labels.push(j.toString());
         graph_vals.tot_t.push(
-            data.rel[selected.rel][10].tot_t[j]
+            data.rel[selected.rel][9].tot_t[j]
         );
         graph_vals.tuples.push(
-            data.rel[selected.rel][10].tuples[j]
+            data.rel[selected.rel][9].tuples[j]
         )
     }
 
@@ -84,13 +76,13 @@ function graphIterRul() {
     graph_vals.labels = [];
     graph_vals.tot_t = [];
     graph_vals.tuples = [];
-    for (var j = 0; j < data.rul[selected.rul][10].tot_t.length; j++) {
+    for (j = 0; j < data.rul[selected.rul][9].tot_t.length; j++) {
         graph_vals.labels.push(j.toString());
         graph_vals.tot_t.push(
-            data.rul[selected.rul][10].tot_t[j]
+            data.rul[selected.rul][9].tot_t[j]
         );
         graph_vals.tuples.push(
-            data.rul[selected.rul][10].tuples[j]
+            data.rul[selected.rul][9].tuples[j]
         )
     }
 
@@ -104,7 +96,7 @@ function graphUsages() {
     graph_vals.cpu = [];
     graph_vals.rss = [];
     var interval = Math.ceil(data.usage.length / 8);
-    for (var j = 0; j < data.usage.length; j++) {
+    for (j = 0; j < data.usage.length; j++) {
         graph_vals.labels.push(
             j % interval == 0 ? data.usage[j][0] : "");
         graph_vals.cpu.push(
@@ -157,7 +149,7 @@ function drawGraph() {
         height: "calc((100vh - 167px) / 2)",
         axisY: {
             labelInterpolationFnc: function (value) {
-                return humanise_time(value/1000000.0);
+                return humanise_time(value);
             }
         },
         axisX: {
@@ -172,11 +164,7 @@ function drawGraph() {
                 return value;
             }
         },
-        plugins: [Chartist.plugins.tooltip({
-                  tooltipFnc: function(meta, value) {
-                    return humanise_time(value / 1000000.0);
-                  }
-                  })]
+        plugins: [Chartist.plugins.tooltip()]
     };
 
     new Chartist.Bar(".ct-chart1", {
@@ -189,11 +177,6 @@ function drawGraph() {
             return minify_numbers(value);
         }
     };
-    options.plugins = [Chartist.plugins.tooltip({
-                  tooltipFnc: function(meta, value) {
-                    return minify_numbers(value) + " tuples";
-                  }
-                  })]
 
     new Chartist.Bar(".ct-chart2", {
         labels: graph_vals.labels,
@@ -569,7 +552,6 @@ function gen_code(highlight_row) {
     var list, row, text, target_row;
     list = document.getElementById("code-list");
     list.innerHTML = "";
-    if (!data.code) return;
     for (var i=0; i<data.code.length; i++) {
         row = document.createElement("li");
         row.className = "code-li";
diff --git a/src/include/souffle/utility/ContainerUtil.h b/src/include/souffle/utility/ContainerUtil.h
index 768469b..6e250db 100644
--- a/src/include/souffle/utility/ContainerUtil.h
+++ b/src/include/souffle/utility/ContainerUtil.h
@@ -237,8 +237,8 @@ bool equal_targets(const std::vector<T>& a, const std::vector<T>& b) {
  * A function testing whether two maps of unique pointers are referencing to equivalent
  * targets.
  */
-template <typename Key, typename Value, typename Cmp>
-bool equal_targets(const std::map<Key, Own<Value>, Cmp>& a, const std::map<Key, Own<Value>, Cmp>& b) {
+template <typename Key, typename Value>
+bool equal_targets(const std::map<Key, Own<Value>>& a, const std::map<Key, Own<Value>>& b) {
     auto comp = comp_deref<Own<Value>>();
     return equal_targets(
             a, b, [&comp](auto& a, auto& b) { return a.first == b.first && comp(a.second, b.second); });
@@ -247,8 +247,8 @@ bool equal_targets(const std::map<Key, Own<Value>, Cmp>& a, const std::map<Key,
 /**
  * A function testing whether two maps are equivalent using projected values.
  */
-template <typename Key, typename Value, typename Cmp, typename F>
-bool equal_targets_map(const std::map<Key, Value, Cmp>& a, const std::map<Key, Value, Cmp>& b, F&& comp) {
+template <typename Key, typename Value, typename F>
+bool equal_targets_map(const std::map<Key, Value>& a, const std::map<Key, Value>& b, F&& comp) {
     return equal_targets(
             a, b, [&](auto& a, auto& b) { return a.first == b.first && comp(a.second, b.second); });
 }
diff --git a/src/include/souffle/utility/DynamicCasting.h b/src/include/souffle/utility/DynamicCasting.h
index 50506dd..61fc020 100644
--- a/src/include/souffle/utility/DynamicCasting.h
+++ b/src/include/souffle/utility/DynamicCasting.h
@@ -30,114 +30,50 @@ namespace souffle {
 class AllowCrossCast {};
 
 namespace detail {
-
-/// Tels if A is a valid cross-cast option
 template <typename A>
 constexpr bool is_valid_cross_cast_option = std::is_same_v<A, void> || std::is_same_v<A, AllowCrossCast>;
-
-/// Tells if there is a function `To::classof(From*)`
-template <typename From, typename To, typename = void>
-struct has_classof : std::false_type {};
-
-template <typename From, typename To>
-struct has_classof<From, To, std::void_t<decltype(remove_cvref_t<To>::classof(std::declval<From*>()))>>
-        : std::true_type {};
-}  // namespace detail
-
-/// Takes a non-null pointer and return whether it is pointing to a derived class of `To`.
-template <typename To, typename CastType = void, typename From,
-        typename = std::enable_if_t<detail::is_valid_cross_cast_option<CastType>>>
-inline bool isA(From* p) noexcept {
-    if constexpr (detail::has_classof<From, To>::value) {
-        // use classof when available
-        return remove_cvref_t<To>::classof(p);
-    } else {
-        // fallback to dynamic_cast
-        return dynamic_cast<std::add_pointer_t<copy_const<From, To>>>(p) != nullptr;
-    }
-}
-
-/// forward isA when From is not a pointer
-template <typename To, typename CastType = void, typename From,
-        typename = std::enable_if_t<detail::is_valid_cross_cast_option<CastType>>,
-        typename = std::enable_if_t<std::is_same_v<CastType, AllowCrossCast> || std::is_base_of_v<From, To>>,
-        typename = std::enable_if_t<std::is_class_v<From> && !is_pointer_like<From>>>
-inline bool isA(From& p) noexcept {
-    return isA<To>(&p);
 }
 
-/// forward isA when From is supposed to be a unique or shared pointer
-template <typename To, typename CastType = void, typename From,
-        typename = std::enable_if_t<is_pointer_like<From>>>
-inline bool isA(const From& p) noexcept {
-    return isA<To, CastType>(p.get());
-}
-
-/// Takes a non-null pointer and dynamic-cast to `To`.
-///
-/// Leverage `To::classof` when available to avoid costly `dynamic_cast`.
-template <typename To, typename CastType = void, typename From,
+/**
+ * Helpers for `dynamic_cast`ing without having to specify redundant type qualifiers.
+ * e.g. `as<AstLiteral>(p)` instead of `as<AstLiteral>(p)`.
+ */
+template <typename B, typename CastType = void, typename A,
         typename = std::enable_if_t<detail::is_valid_cross_cast_option<CastType>>>
-inline auto as(From* p) noexcept {
-    using ToClass = remove_cvref_t<To>;
-    using FromClass = remove_cvref_t<From>;
-    if constexpr (std::is_base_of_v<ToClass, FromClass>) {
-        // trivial conversion from pointer to derived class to pointer to base class
-        return static_cast<std::add_pointer_t<copy_const<From, ToClass>>>(p);
-    } else if constexpr (std::is_base_of_v<FromClass, ToClass> &&
-                         can_static_cast<FromClass*, ToClass*>::value) {
-        // cast using isA when converting from pointer to non-virtual base class to pointer to derived class
-        using ResultType = remove_cvref_t<To>;
-        return isA<ResultType>(p) ? static_cast<std::add_pointer_t<copy_const<From, ToClass>>>(p) : nullptr;
-    } else if constexpr (std::is_same_v<CastType, AllowCrossCast> ||
-                         !can_static_cast<FromClass*, ToClass*>::value) {
-        // dynamic cast when converting across type hierarchies or
-        // converting from pointer to virtual base class to pointer to derived class
-        return dynamic_cast<std::add_pointer_t<copy_const<From, ToClass>>>(p);
-    } else {
-        // cross-hierarchy dynamic cast not allowed unless CastType = AllowCrossCast
-        static_assert(std::is_base_of_v<FromClass, ToClass>,
+auto as(A* x) {
+    if constexpr (!std::is_same_v<CastType, AllowCrossCast> &&
+                  !std::is_base_of_v<std::remove_const_t<B>, std::remove_const_t<A>>) {
+        static_assert(std::is_base_of_v<std::remove_const_t<A>, std::remove_const_t<B>>,
                 "`as<B, A>` does not allow cross-type dyn casts. "
                 "(i.e. `as<B, A>` where `B <: A` is not true.) "
                 "Such a cast is likely a mistake or typo.");
     }
+    return dynamic_cast<copy_const<A, B>*>(x);
 }
 
-/// Takes a possibly null pointer and dynamic-cast to `To`.
-template <typename To, typename CastType = void, typename From,
-        typename = std::enable_if_t<detail::is_valid_cross_cast_option<CastType>>>
-inline auto as_or_null(From* p) noexcept {
-    using ToClass = remove_cvref_t<To>;
-    if (p == nullptr) {
-        return static_cast<std::add_pointer_t<copy_const<From, ToClass>>>(nullptr);
-    }
-    return as<To, CastType, From>(p);
-}
-
-template <typename To, typename CastType = void, typename From,
-        typename = std::enable_if_t<detail::is_valid_cross_cast_option<CastType>>,
-        typename = std::enable_if_t<std::is_same_v<CastType, AllowCrossCast> || std::is_base_of_v<From, To>>,
-        typename = std::enable_if_t<std::is_class_v<From> && !is_pointer_like<From>>>
-inline auto as(From& x) {
-    return as<To, CastType>(&x);
+template <typename B, typename CastType = void, typename A,
+        typename = std::enable_if_t<std::is_same_v<CastType, AllowCrossCast> || std::is_base_of_v<A, B>>,
+        typename = std::enable_if_t<std::is_class_v<A> && !is_pointer_like<A>>>
+auto as(A& x) {
+    return as<B, CastType>(&x);
 }
 
-template <typename To, typename CastType = void, typename From>
-inline auto as(const std::unique_ptr<From>& x) {
-    return as<To, CastType>(x.get());
+template <typename B, typename CastType = void, typename A, typename = std::enable_if_t<is_pointer_like<A>>>
+auto as(const A& x) {
+    return as<B, CastType>(x.get());
 }
 
-template <typename To, typename CastType = void, typename From>
-inline auto as(const std::reference_wrapper<From>& x) {
-    return as<To, CastType>(x.get());
+template <typename B, typename CastType = void, typename A>
+auto as(const std::reference_wrapper<A>& x) {
+    return as<B, CastType>(x.get());
 }
 
 /**
  * Down-casts and checks the cast has succeeded
  */
-template <typename To, typename CastType = void, typename From>
-auto& asAssert(From&& a) {
-    auto* cast = as<To, CastType>(std::forward<From>(a));
+template <typename B, typename CastType = void, typename A>
+auto& asAssert(A&& a) {
+    auto* cast = as<B, CastType>(std::forward<A>(a));
     assert(cast && "Invalid cast");
     return *cast;
 }
@@ -156,13 +92,13 @@ Own<B> UNSAFE_cast(Own<A> x) {
     }
 }
 
-///**
-// * Checks if the object of type Source can be casted to type Destination.
-// */
-// template <typename B, typename CastType = void, typename A>
-//// [[deprecated("Use `as` and implicit boolean conversion instead.")]]
-// bool isA(A&& src) {
-//     return as<B, CastType>(std::forward<A>(src));
-// }
+/**
+ * Checks if the object of type Source can be casted to type Destination.
+ */
+template <typename B, typename CastType = void, typename A>
+// [[deprecated("Use `as` and implicit boolean conversion instead.")]]
+bool isA(A&& src) {
+    return as<B, CastType>(std::forward<A>(src));
+}
 
 }  // namespace souffle
diff --git a/src/include/souffle/utility/EvaluatorUtil.h b/src/include/souffle/utility/EvaluatorUtil.h
index 5cbb2a8..7d21a9f 100644
--- a/src/include/souffle/utility/EvaluatorUtil.h
+++ b/src/include/souffle/utility/EvaluatorUtil.h
@@ -70,9 +70,9 @@ A symbol2numeric(const std::string& src) {
         if constexpr (std::is_same_v<RamFloat, A>) {
             return RamFloatFromString(src);
         } else if constexpr (std::is_same_v<RamSigned, A>) {
-            return RamSignedFromString(src, nullptr, 0);
+            return RamSignedFromString(src);
         } else if constexpr (std::is_same_v<RamUnsigned, A>) {
-            return RamUnsignedFromString(src, nullptr, 0);
+            return RamUnsignedFromString(src);
         } else {
             static_assert(sizeof(A) == 0, "Invalid type specified for symbol2Numeric");
         }
diff --git a/src/include/souffle/utility/FileUtil.h b/src/include/souffle/utility/FileUtil.h
index 24b40b9..fbb3497 100644
--- a/src/include/souffle/utility/FileUtil.h
+++ b/src/include/souffle/utility/FileUtil.h
@@ -17,7 +17,6 @@
 #pragma once
 
 #include <algorithm>
-#include <array>
 #include <climits>
 #include <cstdio>
 #include <cstdlib>
@@ -323,20 +322,19 @@ inline std::string tempFile() {
 }
 
 inline std::stringstream execStdOut(char const* cmd) {
+    FILE* in = popen(cmd, "r");
     std::stringstream data;
-    std::shared_ptr<FILE> command_pipe(popen(cmd, "r"), pclose);
 
-    if (command_pipe.get() == nullptr) {
+    if (in == nullptr) {
         return data;
     }
 
-    std::array<char, 256> buffer;
-    while (!feof(command_pipe.get())) {
-        if (fgets(buffer.data(), 256, command_pipe.get()) != nullptr) {
-            data << buffer.data();
-        }
+    while (!feof(in)) {
+        int c = fgetc(in);
+        data << static_cast<char>(c);
     }
 
+    pclose(in);
     return data;
 }
 
diff --git a/src/include/souffle/utility/FunctionalUtil.h b/src/include/souffle/utility/FunctionalUtil.h
index 047e29d..64d0450 100644
--- a/src/include/souffle/utility/FunctionalUtil.h
+++ b/src/include/souffle/utility/FunctionalUtil.h
@@ -386,7 +386,7 @@ void append(std::vector<A>& xs, B&& y) {
 // -------------------------------------------------------------------------------
 
 template <typename A>
-std::set<A> operator&(const std::set<A, std::less<A>>& lhs, const std::set<A, std::less<A>>& rhs) {
+std::set<A> operator&(const std::set<A>& lhs, const std::set<A>& rhs) {
     std::set<A> result;
     std::set_intersection(
             lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), std::inserter(result, result.begin()));
@@ -394,14 +394,14 @@ std::set<A> operator&(const std::set<A, std::less<A>>& lhs, const std::set<A, st
 }
 
 template <typename A>
-std::set<A> operator|(const std::set<A, std::less<A>>& lhs, const std::set<A, std::less<A>>& rhs) {
+std::set<A> operator|(const std::set<A>& lhs, const std::set<A>& rhs) {
     std::set<A> result;
     std::set_union(lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), std::inserter(result, result.begin()));
     return result;
 }
 
 template <typename A>
-std::set<A> operator-(const std::set<A, std::less<A>>& lhs, const std::set<A, std::less<A>>& rhs) {
+std::set<A> operator-(const std::set<A>& lhs, const std::set<A>& rhs) {
     std::set<A> result;
     std::set_difference(
             lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), std::inserter(result, result.begin()));
diff --git a/src/include/souffle/utility/MiscUtil.h b/src/include/souffle/utility/MiscUtil.h
index 15b1efc..c405e65 100644
--- a/src/include/souffle/utility/MiscUtil.h
+++ b/src/include/souffle/utility/MiscUtil.h
@@ -27,7 +27,6 @@
 #include <memory>
 #include <optional>
 #include <type_traits>
-#include <unordered_map>
 #include <utility>
 
 #ifdef _WIN32
@@ -47,11 +46,7 @@
  * windows equivalents.  However ctz is used in a constexpr context, and we can't
  * use BitScanForward, so we implement it ourselves.
  */
-#if _WIN64
 #define __builtin_popcountll __popcnt64
-#else
-#define __builtin_popcountll __popcnt
-#endif
 
 #if defined(_MSC_VER)
 // return the number of trailing zeroes in value, or 32 if value is zero.
@@ -78,11 +73,7 @@ inline constexpr int __builtin_ctzll_constexpr(unsigned long long value) {
 inline int __builtin_ctzll(unsigned long long value) {
     unsigned long trailing_zeroes = 0;
 
-#if _WIN64
     if (_BitScanForward64(&trailing_zeroes, value)) {
-#else
-    if (_BitScanForward(&trailing_zeroes, value)) {
-#endif
         return static_cast<int>(trailing_zeroes);
     } else {
         return 64;  // return 64 like GCC would when value == 0
@@ -97,34 +88,23 @@ inline int __builtin_ctzll(unsigned long long value) {
 
 namespace souffle {
 
-/// select the most precise and steady clock to measure durations
-using steady_clock = std::conditional<std::chrono::high_resolution_clock::is_steady,
-        std::chrono::high_resolution_clock, std::chrono::steady_clock>::type;
-
-static_assert(steady_clock::is_steady, "clock is not monotonically-increasing");
-
 // a type def for a time point
-using time_point = steady_clock::time_point;
-using microseconds = std::chrono::microseconds;
+using time_point = std::chrono::high_resolution_clock::time_point;
+using std::chrono::microseconds;
 
 // a shortcut for taking the current time
 inline time_point now() {
-    return steady_clock::now();
+    return std::chrono::high_resolution_clock::now();
 }
 
 // a shortcut for obtaining the time difference in milliseconds
-inline int64_t duration_in_ms(const time_point& start, const time_point& end) {
-    return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count());
-}
-
-// a shortcut for obtaining the time difference in microseconds
-inline int64_t duration_in_us(const time_point& start, const time_point& end) {
-    return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::microseconds>(end - start).count());
+inline long duration_in_us(const time_point& start, const time_point& end) {
+    return static_cast<long>(std::chrono::duration_cast<std::chrono::microseconds>(end - start).count());
 }
 
 // a shortcut for obtaining the time difference in nanoseconds
-inline int64_t duration_in_ns(const time_point& start, const time_point& end) {
-    return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count());
+inline long duration_in_ns(const time_point& start, const time_point& end) {
+    return static_cast<long>(std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count());
 }
 
 // -------------------------------------------------------------------------------
@@ -167,17 +147,9 @@ Own<A> clone(const Own<A>& node) {
     return clone(node.get());
 }
 
-template <typename K, typename V, typename C>
-auto clone(const std::map<K, V, C>& xs) {
-    std::map<K, decltype(clone(std::declval<const V&>())), C> ys;
-    for (auto&& [k, v] : xs)
-        ys.insert({k, clone(v)});
-    return ys;
-}
-
-template <typename K, typename V, typename H>
-auto clone(const std::unordered_map<K, V, H>& xs) {
-    std::unordered_map<K, decltype(clone(std::declval<const V&>())), H> ys;
+template <typename K, typename V>
+auto clone(const std::map<K, V>& xs) {
+    std::map<K, decltype(clone(std::declval<const V&>()))> ys;
     for (auto&& [k, v] : xs)
         ys.insert({k, clone(v)});
     return ys;
diff --git a/src/include/souffle/utility/StreamUtil.h b/src/include/souffle/utility/StreamUtil.h
index 8c899ab..e2eafb0 100644
--- a/src/include/souffle/utility/StreamUtil.h
+++ b/src/include/souffle/utility/StreamUtil.h
@@ -22,8 +22,6 @@
 #include <set>
 #include <string>
 #include <type_traits>
-#include <unordered_map>
-#include <unordered_set>
 #include <utility>
 #include <vector>
 
@@ -300,18 +298,6 @@ ostream& operator<<(ostream& out, const map<K, T, C, A>& m) {
     }) << "}";
 }
 
-template <typename K, typename H, typename A>
-ostream& operator<<(ostream& out, const unordered_set<K, H, A>& s) {
-    return out << "{" << souffle::join(s) << "}";
-}
-
-template <typename K, typename T, typename H, typename E, typename A>
-ostream& operator<<(ostream& out, const unordered_map<K, T, H, E, A>& m) {
-    return out << "{" << souffle::join(m, ",", [](ostream& out, const pair<K, T>& cur) {
-        out << cur.first << "->" << cur.second;
-    }) << "}";
-}
-
 }  // end namespace std
 
 #endif
diff --git a/src/include/souffle/utility/StringUtil.h b/src/include/souffle/utility/StringUtil.h
index 7e87d44..0c1483b 100644
--- a/src/include/souffle/utility/StringUtil.h
+++ b/src/include/souffle/utility/StringUtil.h
@@ -247,15 +247,6 @@ template <typename T>
 struct is_printable<T, typename std::conditional<false,
                                decltype(std::declval<std::ostream&>() << std::declval<T>()), void>::type>
         : public std::true_type {};
-
-template <typename T, typename filter = void>
-struct is_html_printable : public std::false_type {};
-
-template <typename T>
-struct is_html_printable<T,
-        typename std::conditional<false, decltype(std::declval<T>().printHTML(std::declval<std::ostream&>())),
-                void>::type> : public std::true_type {};
-
 }  // namespace detail
 
 /**
@@ -286,20 +277,6 @@ typename std::enable_if<!detail::is_printable<T>::value, std::string>::type toSt
     return ss.str();
 }
 
-template <typename T>
-auto toHtml(const T& obj) -> typename std::enable_if<detail::is_html_printable<T>::value, std::string>::type {
-    std::stringstream out;
-    obj.printHTML(out);
-    return out.str();
-}
-
-/** Fallback to `toString` */
-template <typename T>
-auto toHtml(const T& obj) ->
-        typename std::enable_if<not detail::is_html_printable<T>::value, std::string>::type {
-    return toString(obj);
-}
-
 // -------------------------------------------------------------------------------
 //                              String Utils
 // -------------------------------------------------------------------------------
diff --git a/src/include/souffle/utility/SubProcess.h b/src/include/souffle/utility/SubProcess.h
index 93b4eb7..7c17548 100644
--- a/src/include/souffle/utility/SubProcess.h
+++ b/src/include/souffle/utility/SubProcess.h
@@ -70,7 +70,7 @@ std::optional<detail::LinuxWaitStatus> execute(
 
     auto pid = ::fork();
     switch (pid) {
-        case -1: return std::nullopt;  // unable to fork. likely hit a resource limit of some kind.
+        case -1: return {};  // unable to fork. likely hit a resource limit of some kind.
 
         case 0: {  // child
             // thankfully we're a fork. we can trash this proc's `::environ` w/o reprocussions
@@ -100,14 +100,14 @@ std::optional<detail::LinuxWaitStatus> execute(
             // check that the fork child successfully `exec`'d
             if (WIFEXITED(status)) {
                 switch (WEXITSTATUS(status)) {
-                    default: return WEXITSTATUS(status);
+                    default: break;
 
-                    case EC::cannot_execute:                          // FALL THRU: command_not_found
-                    case EC::command_not_found: return std::nullopt;  // fork couldn't execute the program
+                    case EC::cannot_execute:                // FALL THRU: command_not_found
+                    case EC::command_not_found: return {};  // fork couldn't execute the program
                 }
             }
-            // what should be returned on signal? Treat as error
-            return EXIT_FAILURE;
+
+            return status;
         }
     }
 #else
@@ -128,7 +128,7 @@ std::optional<detail::LinuxWaitStatus> execute(
     int64_t Found = (int64_t)FindExecutableW(program_w.c_str(), nullptr, FoundPath);
     if (Found <= 32) {
         std::cerr << "Cannot find executable '" << program << "'.\n";
-        return std::nullopt;
+        return {};
     }
 
     std::wstringstream args_w;
@@ -152,13 +152,13 @@ std::optional<detail::LinuxWaitStatus> execute(
 
     if (!CreateProcessW(FoundPath, args_w.str().data(), NULL, NULL, FALSE, 0, /*envir.data()*/ nullptr, NULL,
                 &si, &pi)) {
-        return std::nullopt;
+        return {};
     }
 
     WaitForSingleObject(pi.hProcess, INFINITE);
 
     if (!GetExitCodeProcess(pi.hProcess, &exit_code)) {
-        return std::nullopt;
+        return {};
     }
 
     CloseHandle(pi.hProcess);
diff --git a/src/include/souffle/utility/Types.h b/src/include/souffle/utility/Types.h
index 01d7841..dd09242 100644
--- a/src/include/souffle/utility/Types.h
+++ b/src/include/souffle/utility/Types.h
@@ -152,19 +152,4 @@ constexpr bool is_set = detail::is_set<A>::value;
 template <typename A>
 constexpr bool unhandled_dispatch_type = !std::is_same_v<A, A>;
 
-// Tells if we can static_cast<From,To>
-template <typename From, typename To, typename = void>
-struct can_static_cast : std::false_type {};
-
-template <typename From, typename To>
-struct can_static_cast<From, To, std::void_t<decltype(static_cast<To>(std::declval<From>()))>>
-        : std::true_type {};
-
-// A virtual base is first and foremost a base,
-// that, however, cannot be static_casted to its derived class.
-template <typename Base, typename Derived>
-struct is_virtual_base_of
-        : std::conjunction<std::is_base_of<Base, Derived>, std::negation<can_static_cast<Base*, Derived*>>> {
-};
-
 }  // namespace souffle
diff --git a/src/include/souffle/utility/Visitor.h b/src/include/souffle/utility/Visitor.h
index f51d9fb..80b9543 100644
--- a/src/include/souffle/utility/Visitor.h
+++ b/src/include/souffle/utility/Visitor.h
@@ -113,12 +113,7 @@ struct VisitorBase : visitor_tag {
 
     /** The base case for all visitors -- if no more specific overload was defined */
     virtual R visit_(type_identity<RootNoConstQual>, NodeType& /*node*/, Params const&... /*args*/) {
-        if constexpr (std::is_same_v<void, R>) {
-            return;
-        } else {
-            R res{};
-            return res;
-        }
+        return R();
     }
 };
 
diff --git a/src/include/souffle/utility/json11.h b/src/include/souffle/utility/json11.h
index 98aa33a..bc335c1 100644
--- a/src/include/souffle/utility/json11.h
+++ b/src/include/souffle/utility/json11.h
@@ -66,7 +66,6 @@
 #include <vector>
 
 #ifdef _MSC_VER
-#pragma warning(push)
 #pragma warning(disable : 4244)
 #if _MSC_VER <= 1800  // VS 2013
 #ifndef noexcept
@@ -79,11 +78,6 @@
 #endif
 #endif
 
-#if defined(__GNUC__) && (__GNUC__ >= 7)
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Woverloaded-virtual"
-#endif
-
 namespace json11 {
 
 enum JsonParse { STANDARD, COMMENTS };
@@ -1112,11 +1106,7 @@ inline std::vector<Json> parse_multi(const std::string& in, std::string::size_ty
 }
 
 #ifdef _MSC_VER
-#pragma warning(pop)
+#pragma warning(default : 4244)
 #endif  // _MSC_VER
 
 }  // namespace json11
-
-#if defined(__GNUC__) && (__GNUC__ >= 7)
-#pragma GCC diagnostic pop
-#endif
\ No newline at end of file
diff --git a/src/interpreter/BTreeDeleteIndex.cpp b/src/interpreter/BTreeDeleteIndex.cpp
index 7275e37..9a108ae 100644
--- a/src/interpreter/BTreeDeleteIndex.cpp
+++ b/src/interpreter/BTreeDeleteIndex.cpp
@@ -21,15 +21,23 @@
 
 namespace souffle::interpreter {
 
-#define CREATE_BTREE_DELETE_REL(Structure, Arity, AuxiliaryArity, ...)                       \
-    if (id.getArity() == Arity && id.getAuxiliaryArity() == AuxiliaryArity) {                \
-        return mk<BtreeDeleteRelation<Arity, AuxiliaryArity>>(id.getName(), indexSelection); \
+#define CREATE_BTREE_DELETE_REL(Structure, Arity, ...)                                               \
+    case (Arity): {                                                                                  \
+        return mk<BtreeDeleteRelation<Arity>>(id.getAuxiliaryArity(), id.getName(), indexSelection); \
     }
 
 Own<RelationWrapper> createBTreeDeleteRelation(
         const ram::Relation& id, const ram::analysis::IndexCluster& indexSelection) {
-    FOR_EACH_BTREE_DELETE(CREATE_BTREE_DELETE_REL);
-    fatal("Requested arity not yet supported. Feel free to add it.");
+    switch (id.getArity()) {
+        FOR_EACH_BTREE_DELETE(CREATE_BTREE_DELETE_REL);
+
+        default:
+            fatal((
+                "createBTreeDeleteRelation: Requested arity " +
+                std::to_string(id.getArity()) +
+                " not yet supported. Feel free to add it."
+            ).c_str());
+    }
 }
 
 }  // namespace souffle::interpreter
diff --git a/src/interpreter/BTreeIndex.cpp b/src/interpreter/BTreeIndex.cpp
index 5a42aa6..7c5af5f 100644
--- a/src/interpreter/BTreeIndex.cpp
+++ b/src/interpreter/BTreeIndex.cpp
@@ -21,15 +21,24 @@
 
 namespace souffle::interpreter {
 
-#define CREATE_BTREE_REL(Structure, Arity, AuxiliaryArity, ...)                                       \
-    if (id.getArity() == Arity && id.getAuxiliaryArity() == AuxiliaryArity) {                         \
-        return mk<Relation<Arity, AuxiliaryArity, interpreter::Btree>>(id.getName(), indexSelection); \
+#define CREATE_BTREE_REL(Structure, Arity, ...)                        \
+    case (Arity): {                                                    \
+        return mk<Relation<Arity, interpreter::Btree>>(                \
+                id.getAuxiliaryArity(), id.getName(), indexSelection); \
     }
 
 Own<RelationWrapper> createBTreeRelation(
         const ram::Relation& id, const ram::analysis::IndexCluster& indexSelection) {
-    FOR_EACH_BTREE(CREATE_BTREE_REL);
-    fatal("Requested arity not yet supported. Feel free to add it.");
+    switch (id.getArity()) {
+        FOR_EACH_BTREE(CREATE_BTREE_REL);
+
+        default:
+            fatal((
+                "createBTreeRelation: Requested arity " +
+                std::to_string(id.getArity()) +
+                " not yet supported. Feel free to add it."
+            ).c_str());
+    }
 }
 
 }  // namespace souffle::interpreter
diff --git a/src/interpreter/Context.h b/src/interpreter/Context.h
index 6b9a0fd..efba119 100644
--- a/src/interpreter/Context.h
+++ b/src/interpreter/Context.h
@@ -109,14 +109,6 @@ public:
         return views[id].get();
     }
 
-    RamDomain getVariable(const std::string& name) {
-        return variables[name];
-    }
-
-    void setVariable(const std::string& name, RamDomain value) {
-        variables[name] = value;
-    }
-
 private:
     /** @brief Run-time value */
     std::vector<const RamDomain*> data;
@@ -128,7 +120,6 @@ private:
     VecOwn<RamDomain[]> allocatedDataContainer;
     /** @brief Views */
     VecOwn<ViewWrapper> views;
-    std::map<std::string, RamDomain> variables;
 };
 
 }  // namespace souffle::interpreter
diff --git a/src/interpreter/Engine.cpp b/src/interpreter/Engine.cpp
index 41683d3..f46ba08 100644
--- a/src/interpreter/Engine.cpp
+++ b/src/interpreter/Engine.cpp
@@ -23,18 +23,16 @@
 #include "interpreter/Relation.h"
 #include "interpreter/ViewContext.h"
 #include "ram/Aggregate.h"
-#include "ram/Aggregator.h"
-#include "ram/Assign.h"
 #include "ram/AutoIncrement.h"
 #include "ram/Break.h"
 #include "ram/Call.h"
 #include "ram/Clear.h"
 #include "ram/Conjunction.h"
 #include "ram/Constraint.h"
+#include "ram/CountUniqueKeys.h"
 #include "ram/DebugInfo.h"
 #include "ram/EmptinessCheck.h"
 #include "ram/Erase.h"
-#include "ram/EstimateJoinSize.h"
 #include "ram/ExistenceCheck.h"
 #include "ram/Exit.h"
 #include "ram/False.h"
@@ -45,7 +43,6 @@
 #include "ram/IndexIfExists.h"
 #include "ram/IndexScan.h"
 #include "ram/Insert.h"
-#include "ram/IntrinsicAggregator.h"
 #include "ram/IntrinsicOperator.h"
 #include "ram/LogRelationTimer.h"
 #include "ram/LogSize.h"
@@ -80,9 +77,7 @@
 #include "ram/TupleElement.h"
 #include "ram/TupleOperation.h"
 #include "ram/UnpackRecord.h"
-#include "ram/UserDefinedAggregator.h"
 #include "ram/UserDefinedOperator.h"
-#include "ram/Variable.h"
 #include "ram/utility/Visitor.h"
 #include "souffle/BinaryConstraintOps.h"
 #include "souffle/RamTypes.h"
@@ -90,7 +85,6 @@
 #include "souffle/SignalHandler.h"
 #include "souffle/SymbolTable.h"
 #include "souffle/TypeAttribute.h"
-#include "souffle/datastructure/RecordTableImpl.h"
 #include "souffle/datastructure/SymbolTableImpl.h"
 #include "souffle/io/IOSystem.h"
 #include "souffle/io/ReadStream.h"
@@ -98,9 +92,9 @@
 #include "souffle/profile/Logger.h"
 #include "souffle/profile/ProfileEvent.h"
 #include "souffle/utility/EvaluatorUtil.h"
+#include "souffle/utility/MiscUtil.h"
 #include "souffle/utility/ParallelUtil.h"
 #include "souffle/utility/StringUtil.h"
-
 #include <algorithm>
 #include <array>
 #include <atomic>
@@ -194,17 +188,6 @@ RamDomain callStateful(ExecuteFn&& execute, Context& ctxt, Shadow& shadow, void
     return callWithTuple<RamDomain>(userFunctor, argsTuple);
 }
 
-/** Call a stateful aggregate functor. */
-template <typename AnyFunctor>
-RamDomain callStatefulAggregate(AnyFunctor&& userFunctor, souffle::SymbolTable* symbolTable,
-        souffle::RecordTable* recordTable, souffle::RamDomain arg1, souffle::RamDomain arg2) {
-    std::array<RamDomain, 2> args;
-    args[0] = arg1;
-    args[1] = arg2;
-    auto argsTuple = statefulCallTuple(symbolTable, recordTable, args, std::make_index_sequence<2>{});
-    return callWithTuple<RamDomain>(std::forward<AnyFunctor>(userFunctor), argsTuple);
-}
-
 /**
  * Governs the maximum supported arity for stateless functors.
  *
@@ -302,12 +285,12 @@ RamDomain callStateless(ExecuteFn&& execute, Context& ctxt, Shadow& shadow, souf
 
 }  // namespace
 
-Engine::Engine(ram::TranslationUnit& tUnit, const std::size_t numberOfThreadsOrZero)
-        : tUnit(tUnit), global(tUnit.global()), profileEnabled(global.config().has("profile")),
-          frequencyCounterEnabled(global.config().has("profile-frequency")),
-          numOfThreads(number_of_threads(numberOfThreadsOrZero)),
+Engine::Engine(ram::TranslationUnit& tUnit)
+        : profileEnabled(Global::config().has("profile")),
+          frequencyCounterEnabled(Global::config().has("profile-frequency")),
+          numOfThreads(number_of_threads(std::stoi(Global::config().get("jobs")))), tUnit(tUnit),
           isa(tUnit.getAnalysis<ram::analysis::IndexAnalysis>()), recordTable(numOfThreads),
-          symbolTable(numOfThreads), regexCache(numOfThreads) {}
+          symbolTable(numOfThreads) {}
 
 Engine::RelationHandle& Engine::getRelationHandle(const std::size_t idx) {
     return *relations[idx];
@@ -323,14 +306,6 @@ RamDomain Engine::incCounter() {
     return counter++;
 }
 
-Global& Engine::getGlobal() {
-    return global;
-}
-
-SymbolTable& Engine::getSymbolTable() {
-    return symbolTable;
-}
-
 RecordTable& Engine::getRecordTable() {
     return recordTable;
 }
@@ -339,6 +314,86 @@ ram::TranslationUnit& Engine::getTranslationUnit() {
     return tUnit;
 }
 
+// TODO: Given from Gödel
+static souffle::RamDomain get_field_by_index(souffle::SymbolTable* symbolTable, souffle::RecordTable* recordTable, souffle::RamDomain arg, souffle::RamDomain total, souffle::RamDomain index) {
+    assert(symbolTable && "NULL symbol table");
+    assert(recordTable && "NULL record table");
+    assert(arg != 0);
+    const souffle::RamDomain* myTuple = recordTable->unpack(arg, total);
+    return myTuple[index];
+}
+
+static const char* godel_lang_builtin_string_getMatchResult(const char *self, const char *pattern, int index) {
+    static std::unordered_map<std::string, std::regex> mapper;
+
+    std::string str(self);
+    if (!mapper.count(pattern)) {
+        mapper[pattern] = std::regex(
+            pattern,
+            std::regex_constants::ECMAScript|std::regex_constants::optimize
+        );
+    }
+    const std::regex& re = mapper.at(pattern);
+    std::smatch sm;
+    auto r = std::regex_match(str, sm, re);
+    if (r && sm.size() > static_cast<size_t>(index)) {
+        const auto& x = sm[index].str();
+        auto buffer = new char[x.size() + 1]();
+        std::strncpy(buffer, x.data(), x.size());
+        return buffer;
+    }
+    return "";
+}
+
+static const char* godel_lang_builtin_string_to_upper(const char *self) {
+    auto buffer = new char[strlen(self) + 1]();
+    std::transform(self, self + strlen(self), buffer, toupper);
+    return buffer;
+}
+
+static const char* godel_lang_builtin_string_to_lower(const char *self) {
+    auto buffer = new char[strlen(self) + 1]();
+    std::transform(self, self + strlen(self), buffer, tolower);
+    return buffer;
+}
+
+static const char* godel_lang_builtin_string_replace_all(const char *self, const char *pattern, const char* replacement) {
+    std::regex re(pattern);
+    std::stringstream ss;
+    std::regex_replace(std::ostreambuf_iterator<char>(ss), self, self + strlen(self), re, replacement);
+
+    const auto& res = ss.str();
+    auto buffer = new char[res.length() + 1]();
+    std::strncpy(buffer, res.c_str(), res.length());
+    buffer[res.length()] = 0;
+    return buffer;
+}
+
+static const char* godel_lang_builtin_string_replace_once(const char *self, const char *pattern, const char* replacement, int index) {
+    std::regex re(pattern);
+    std::string result = self;
+
+    std::string temp = result;
+    std::smatch match;
+
+    size_t offset = 0;
+    size_t matched_index = 0;
+    while (std::regex_search(temp, match, re)) {
+        if (matched_index == static_cast<size_t>(index)) {
+            result.replace(offset + match.position(), match.length(), replacement);
+            break;
+        }
+        ++matched_index;
+        offset += match.position() + match.length();
+        temp = match.suffix().str();
+    }
+
+    auto buffer = new char[result.length() + 1]();
+    std::strncpy(buffer, result.c_str(), result.length());
+    buffer[result.length()] = 0;
+    return buffer;
+}
+
 void* Engine::getMethodHandle(const std::string& method) {
     for (void* libHandle : dll) {
         auto* methodHandle = dlsym(libHandle, method.c_str());
@@ -346,6 +401,19 @@ void* Engine::getMethodHandle(const std::string& method) {
             return methodHandle;
         }
     }
+
+    // TODO: Given from Gödel
+    static std::unordered_map<std::string, void*> mapper = {
+        {"get_field_by_index", reinterpret_cast<void*>(get_field_by_index)},
+        {"godel_lang_builtin_string_getMatchResult", reinterpret_cast<void*>(godel_lang_builtin_string_getMatchResult)},
+        {"godel_lang_builtin_string_to_upper", reinterpret_cast<void*>(godel_lang_builtin_string_to_upper)},
+        {"godel_lang_builtin_string_to_lower", reinterpret_cast<void*>(godel_lang_builtin_string_to_lower)},
+        {"godel_lang_builtin_string_replace_all", reinterpret_cast<void*>(godel_lang_builtin_string_replace_all)},
+        {"godel_lang_builtin_string_replace_once", reinterpret_cast<void*>(godel_lang_builtin_string_replace_once)}
+    };
+    if (mapper.count(method)) {
+        return mapper.at(method);
+    }
     return nullptr;
 }
 
@@ -359,13 +427,13 @@ void Engine::createRelation(const ram::Relation& id, const std::size_t idx) {
     }
 
     RelationHandle res;
-    bool hasProvenance = id.getArity() > 0 && id.getAttributeNames().back() == "@level_number";
-    if (hasProvenance) {
-        res = createProvenanceRelation(id, isa.getIndexSelection(id.getName()));
-    } else if (id.getRepresentation() == RelationRepresentation::EQREL) {
+
+    if (id.getRepresentation() == RelationRepresentation::EQREL) {
         res = createEqrelRelation(id, isa.getIndexSelection(id.getName()));
     } else if (id.getRepresentation() == RelationRepresentation::BTREE_DELETE) {
         res = createBTreeDeleteRelation(id, isa.getIndexSelection(id.getName()));
+    } else if (id.getRepresentation() == RelationRepresentation::PROVENANCE) {
+        res = createProvenanceRelation(id, isa.getIndexSelection(id.getName()));
     } else {
         res = createBTreeRelation(id, isa.getIndexSelection(id.getName()));
     }
@@ -377,19 +445,19 @@ const std::vector<void*>& Engine::loadDLL() {
         return dll;
     }
 
-    if (!global.config().has("libraries")) {
-        global.config().set("libraries", "functors");
+    if (!Global::config().has("libraries")) {
+        Global::config().set("libraries", "functors");
     }
-    if (!global.config().has("library-dir")) {
-        global.config().set("library-dir", ".");
+    if (!Global::config().has("library-dir")) {
+        Global::config().set("library-dir", ".");
     }
 
-    for (auto&& library : global.config().getMany("libraries")) {
+    for (auto&& library : Global::config().getMany("libraries")) {
         // The library may be blank
         if (library.empty()) {
             continue;
         }
-        auto paths = global.config().getMany("library-dir");
+        auto paths = Global::config().getMany("library-dir");
         // Set up our paths to have a library appended
         for (std::string& path : paths) {
             if (path.back() != pathSeparator) {
@@ -406,11 +474,7 @@ const std::vector<void*>& Engine::loadDLL() {
         void* tmp = nullptr;
         for (const std::string& path : paths) {
             std::string fullpath = path + "lib" + library + dynamicLibSuffix;
-#ifndef EMSCRIPTEN
             tmp = dlopen(fullpath.c_str(), RTLD_LAZY);
-#else
-            tmp = nullptr;
-#endif
             if (tmp != nullptr) {
                 dll.push_back(tmp);
                 break;
@@ -424,18 +488,16 @@ const std::vector<void*>& Engine::loadDLL() {
 std::size_t Engine::getIterationNumber() const {
     return iteration;
 }
-
 void Engine::incIterationNumber() {
     ++iteration;
 }
-
 void Engine::resetIterationNumber() {
     iteration = 0;
 }
 
 void Engine::executeMain() {
     SignalHandler::instance()->set();
-    if (global.config().has("verbose")) {
+    if (Global::config().has("verbose")) {
         SignalHandler::instance()->enableLogging();
     }
 
@@ -450,7 +512,7 @@ void Engine::executeMain() {
         Context ctxt;
         execute(main.get(), ctxt);
     } else {
-        ProfileEventSingleton::instance().setOutputFile(global.config().get("profile"));
+        ProfileEventSingleton::instance().setOutputFile(Global::config().get("profile"));
         // Prepare the frequency table for threaded use
         const ram::Program& program = tUnit.getProgram();
         visit(program, [&](const ram::TupleOperation& node) {
@@ -463,7 +525,7 @@ void Engine::executeMain() {
         ProfileEventSingleton::instance().startTimer();
         ProfileEventSingleton::instance().makeTimeEvent("@time;starttime");
         // Store configuration
-        for (auto&& [k, vs] : global.config().data())
+        for (auto&& [k, vs] : Global::config().data())
             for (auto&& v : vs)
                 ProfileEventSingleton::instance().makeConfigRecord(k, v);
 
@@ -482,8 +544,6 @@ void Engine::executeMain() {
         visit(program, [&](const ram::Query&) { ++ruleCount; });
         ProfileEventSingleton::instance().makeConfigRecord("ruleCount", std::to_string(ruleCount));
 
-        SignalHandler::instance()->enableProfiling();
-
         Context ctxt;
         execute(main.get(), ctxt);
         ProfileEventSingleton::instance().stopTimer();
@@ -506,7 +566,7 @@ void Engine::generateIR() {
     NodeGenerator generator(*this);
     if (subroutine.empty()) {
         for (const auto& sub : program.getSubroutines()) {
-            subroutine.emplace(std::make_pair("stratum_" + sub.first, generator.generateTree(*sub.second)));
+            subroutine.push_back(generator.generateTree(*sub.second));
         }
     }
     if (main == nullptr) {
@@ -520,7 +580,10 @@ void Engine::executeSubroutine(
     ctxt.setReturnValues(ret);
     ctxt.setArguments(args);
     generateIR();
-    execute(subroutine["stratum_" + name].get(), ctxt);
+    const ram::Program& program = tUnit.getProgram();
+    auto subs = program.getSubroutines();
+    std::size_t i = distance(subs.begin(), subs.find(name));
+    execute(subroutine[i].get(), ctxt);
 }
 
 RamDomain Engine::execute(const Node* node, Context& ctxt) {
@@ -531,9 +594,9 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
 
 // Overload CASE based on number of arguments.
 // CASE(Kind) -> BASE_CASE(Kind)
-// CASE(Kind, Structure, Arity, AuxiliaryArity) -> EXTEND_CASE(Kind, Structure, Arity, AuxiliaryArity)
-#define GET_MACRO(_1, _2, _3, _4, NAME, ...) NAME
-#define CASE(...) GET_MACRO(__VA_ARGS__, EXTEND_CASE, _Dummy, _Dummy2, BASE_CASE)(__VA_ARGS__)
+// CASE(Kind, Structure, Arity) -> EXTEND_CASE(Kind, Structure, Arity)
+#define GET_MACRO(_1, _2, _3, NAME, ...) NAME
+#define CASE(...) GET_MACRO(__VA_ARGS__, EXTEND_CASE, _Dummy, BASE_CASE)(__VA_ARGS__)
 
 #define BASE_CASE(Kind) \
     case (I_##Kind): {  \
@@ -541,12 +604,12 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
             [[maybe_unused]] const auto& shadow = *static_cast<const interpreter::Kind*>(node); \
             [[maybe_unused]] const auto& cur = *static_cast<const ram::Kind*>(node->getShadow());
 // EXTEND_CASE also defer the relation type
-#define EXTEND_CASE(Kind, Structure, Arity, AuxiliaryArity)       \
-    case (I_##Kind##_##Structure##_##Arity##_##AuxiliaryArity): { \
+#define EXTEND_CASE(Kind, Structure, Arity)    \
+    case (I_##Kind##_##Structure##_##Arity): { \
         return [&]() -> RamDomain { \
             [[maybe_unused]] const auto& shadow = *static_cast<const interpreter::Kind*>(node); \
             [[maybe_unused]] const auto& cur = *static_cast<const ram::Kind*>(node->getShadow());\
-            using RelType = Relation<Arity, AuxiliaryArity, interpreter::Structure>;
+            using RelType = Relation<Arity, interpreter::Structure>;
 #define ESAC(Kind) \
     }              \
     ();            \
@@ -580,10 +643,6 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
             return cur.getConstant();
         ESAC(NumericConstant)
 
-        CASE(Variable)
-            return ctxt.getVariable(cur.getName());
-        ESAC(Variable)
-
         CASE(StringConstant)
             return shadow.getConstant();
         ESAC(StringConstant)
@@ -597,7 +656,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         ESAC(AutoIncrement)
 
         CASE(IntrinsicOperator)
-        // clang-format off
+// clang-format off
 #define BINARY_OP_TYPED(ty, op) return ramBitCast(static_cast<ty>(EVAL_CHILD(ty, 0) op EVAL_CHILD(ty, 1)))
 
 #define BINARY_OP_LOGICAL(opcode, op) BINARY_OP_INTEGRAL(opcode, op)
@@ -618,7 +677,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
     {                                                            \
         auto result = EVAL_CHILD(RamDomain, 0);                  \
         auto* result_val = &getSymbolTable().decode(result);     \
-        for (std::size_t i = 1; i < numArgs; i++) {          \
+        for (std::size_t i = 1; i < args.size(); i++) {          \
             auto alt = EVAL_CHILD(RamDomain, i);                 \
             if (alt == result) continue;                         \
                                                                  \
@@ -633,7 +692,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
 #define MINMAX_OP(ty, op)                           \
     {                                               \
         auto result = EVAL_CHILD(ty, 0);            \
-        for (std::size_t i = 1; i < numArgs; i++) {  \
+        for (std::size_t i = 1; i < args.size(); i++) {  \
             result = op(result, EVAL_CHILD(ty, i)); \
         }                                           \
         return ramBitCast(result);                  \
@@ -655,7 +714,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         getSymbolTable().decode(EVAL_CHILD(RamDomain, 0))));
             // clang-format on
 
-            const auto numArgs = cur.getNumArgs();
+            const auto& args = cur.getArguments();
             switch (cur.getOperator()) {
                 /** Unary Functor Operators */
                 case FunctorOp::ORD: return execute(shadow.getChild(0), ctxt);
@@ -763,7 +822,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
 
                 case FunctorOp::CAT: {
                     std::stringstream ss;
-                    for (std::size_t i = 0; i < numArgs; i++) {
+                    for (std::size_t i = 0; i < args.size(); i++) {
                         ss << getSymbolTable().decode(execute(shadow.getChild(i), ctxt));
                     }
                     return getSymbolTable().encode(ss.str());
@@ -777,7 +836,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
                     std::string sub_str;
                     try {
                         sub_str = str.substr(idx, len);
-                    } catch (std::out_of_range&) {
+                    } catch (...) {
                         std::cerr << "warning: wrong index position provided by substr(\"";
                         std::cerr << str << "\"," << (int32_t)idx << "," << (int32_t)len << ") functor.\n";
                     }
@@ -788,17 +847,9 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
                 case FunctorOp::URANGE:
                 case FunctorOp::FRANGE:
                     fatal("ICE: functor `%s` must map onto `NestedIntrinsicOperator`", cur.getOperator());
-
-                case FunctorOp::SSADD: {
-                    auto sleft = execute(shadow.getChild(0), ctxt);
-                    auto sright = execute(shadow.getChild(1), ctxt);
-                    const std::string& strleft = getSymbolTable().decode(sleft);
-                    const std::string& strright = getSymbolTable().decode(sright);
-                    return getSymbolTable().encode(strleft + strright);
-                }
             }
 
-        {UNREACHABLE_BAD_CASE_ANALYSIS}
+            { UNREACHABLE_BAD_CASE_ANALYSIS }
 
 #undef BINARY_OP_LOGICAL
 #undef BINARY_OP_INTEGRAL
@@ -814,8 +865,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         ESAC(IntrinsicOperator)
 
         CASE(NestedIntrinsicOperator)
-            const auto numArgs = cur.getNumArgs();
-            const auto runNested = [&](auto&& tuple) {
+            auto numArgs = cur.getArguments().size();
+            auto runNested = [&](auto&& tuple) {
                 ctxt[cur.getTupleId()] = tuple.data();
                 execute(shadow.getChild(numArgs), ctxt);
             };
@@ -832,7 +883,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
                 case ram::NestedIntrinsicOp::FRANGE: return RUN_RANGE(RamFloat);
             }
 
-        {UNREACHABLE_BAD_CASE_ANALYSIS}
+            { UNREACHABLE_BAD_CASE_ANALYSIS }
 #undef RUN_RANGE
         ESAC(NestedIntrinsicOperator)
 
@@ -841,7 +892,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
 
             auto userFunctor = reinterpret_cast<void (*)()>(shadow.getFunctionPointer());
             if (userFunctor == nullptr) fatal("cannot find user-defined operator `%s`", name);
-            std::size_t arity = cur.getNumArgs();
+            std::size_t arity = cur.getArguments().size();
 
             if (cur.isStateful()) {
                 auto exec = std::bind(&Engine::execute, this, std::placeholders::_1, std::placeholders::_2);
@@ -961,7 +1012,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         ESAC(UserDefinedOperator)
 
         CASE(PackRecord)
-            const std::size_t arity = cur.getNumArgs();
+            auto values = cur.getArguments();
+            std::size_t arity = values.size();
             std::unique_ptr<RamDomain[]> data = std::make_unique<RamDomain[]>(arity);
             for (std::size_t i = 0; i < arity; ++i) {
                 data[i] = execute(shadow.getChild(i), ctxt);
@@ -989,8 +1041,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
             return !execute(shadow.getChild(), ctxt);
         ESAC(Negation)
 
-#define EMPTINESS_CHECK(Structure, Arity, AuxiliaryArity, ...)          \
-    CASE(EmptinessCheck, Structure, Arity, AuxiliaryArity)              \
+#define EMPTINESS_CHECK(Structure, Arity, ...)                          \
+    CASE(EmptinessCheck, Structure, Arity)                              \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return rel.empty();                                             \
     ESAC(EmptinessCheck)
@@ -998,8 +1050,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(EMPTINESS_CHECK)
 #undef EMPTINESS_CHECK
 
-#define RELATION_SIZE(Structure, Arity, AuxiliaryArity, ...)            \
-    CASE(RelationSize, Structure, Arity, AuxiliaryArity)                \
+#define RELATION_SIZE(Structure, Arity, ...)                            \
+    CASE(RelationSize, Structure, Arity)                                \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return rel.size();                                              \
     ESAC(RelationSize)
@@ -1007,17 +1059,17 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(RELATION_SIZE)
 #undef RELATION_SIZE
 
-#define EXISTENCE_CHECK(Structure, Arity, AuxiliaryArity, ...) \
-    CASE(ExistenceCheck, Structure, Arity, AuxiliaryArity)     \
-        return evalExistenceCheck<RelType>(shadow, ctxt);      \
+#define EXISTENCE_CHECK(Structure, Arity, ...)            \
+    CASE(ExistenceCheck, Structure, Arity)                \
+        return evalExistenceCheck<RelType>(shadow, ctxt); \
     ESAC(ExistenceCheck)
 
         FOR_EACH(EXISTENCE_CHECK)
 #undef EXISTENCE_CHECK
 
-#define PROVENANCE_EXISTENCE_CHECK(Structure, Arity, AuxiliaryArity, ...) \
-    CASE(ProvenanceExistenceCheck, Structure, Arity, AuxiliaryArity)      \
-        return evalProvenanceExistenceCheck<RelType>(shadow, ctxt);       \
+#define PROVENANCE_EXISTENCE_CHECK(Structure, Arity, ...)           \
+    CASE(ProvenanceExistenceCheck, Structure, Arity)                \
+        return evalProvenanceExistenceCheck<RelType>(shadow, ctxt); \
     ESAC(ProvenanceExistenceCheck)
 
         FOR_EACH_PROVENANCE(PROVENANCE_EXISTENCE_CHECK)
@@ -1049,53 +1101,30 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
                 COMPARE(GE, >=)
 
                 case BinaryConstraintOp::MATCH: {
-                    bool result = false;
+                    RamDomain left = execute(shadow.getLhs(), ctxt);
                     RamDomain right = execute(shadow.getRhs(), ctxt);
+                    const std::string& pattern = getSymbolTable().decode(left);
                     const std::string& text = getSymbolTable().decode(right);
-
-                    const Node* patternNode = shadow.getLhs();
-                    if (const RegexConstant* regexNode = dynamic_cast<const RegexConstant*>(patternNode);
-                            regexNode) {
-                        const auto& regex = regexNode->getRegex();
-                        if (regex) {
-                            result = std::regex_match(text, *regex);
-                        }
-                    } else {
-                        RamDomain left = execute(patternNode, ctxt);
-                        const std::string& pattern = getSymbolTable().decode(left);
-                        try {
-                            const std::regex& regex = regexCache.getOrCreate(pattern);
-                            result = std::regex_match(text, regex);
-                        } catch (...) {
-                            std::cerr << "warning: wrong pattern provided for match(\"" << pattern << "\",\""
-                                      << text << "\").\n";
-                        }
+                    bool result = false;
+                    try {
+                        result = std::regex_match(text, std::regex(pattern));
+                    } catch (...) {
+                        std::cerr << "warning: wrong pattern provided for match(\"" << pattern << "\",\""
+                                  << text << "\").\n";
                     }
-
                     return result;
                 }
                 case BinaryConstraintOp::NOT_MATCH: {
-                    bool result = false;
+                    RamDomain left = execute(shadow.getLhs(), ctxt);
                     RamDomain right = execute(shadow.getRhs(), ctxt);
+                    const std::string& pattern = getSymbolTable().decode(left);
                     const std::string& text = getSymbolTable().decode(right);
-
-                    const Node* patternNode = shadow.getLhs();
-                    if (const RegexConstant* regexNode = dynamic_cast<const RegexConstant*>(patternNode);
-                            regexNode) {
-                        const auto& regex = regexNode->getRegex();
-                        if (regex) {
-                            result = !std::regex_match(text, *regex);
-                        }
-                    } else {
-                        RamDomain left = execute(patternNode, ctxt);
-                        const std::string& pattern = getSymbolTable().decode(left);
-                        try {
-                            const std::regex& regex = regexCache.getOrCreate(pattern);
-                            result = !std::regex_match(text, regex);
-                        } catch (...) {
-                            std::cerr << "warning: wrong pattern provided for !match(\"" << pattern << "\",\""
-                                      << text << "\").\n";
-                        }
+                    bool result = false;
+                    try {
+                        result = !std::regex_match(text, std::regex(pattern));
+                    } catch (...) {
+                        std::cerr << "warning: wrong pattern provided for !match(\"" << pattern << "\",\""
+                                  << text << "\").\n";
                     }
                     return result;
                 }
@@ -1115,7 +1144,7 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
                 }
             }
 
-        {UNREACHABLE_BAD_CASE_ANALYSIS}
+            { UNREACHABLE_BAD_CASE_ANALYSIS }
 
 #undef COMPARE_NUMERIC
 #undef COMPARE_STRING
@@ -1138,8 +1167,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
             return result;
         ESAC(TupleOperation)
 
-#define SCAN(Structure, Arity, AuxiliaryArity, ...)                     \
-    CASE(Scan, Structure, Arity, AuxiliaryArity)                        \
+#define SCAN(Structure, Arity, ...)                                     \
+    CASE(Scan, Structure, Arity)                                        \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalScan(rel, cur, shadow, ctxt);                        \
     ESAC(Scan)
@@ -1147,24 +1176,24 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(SCAN)
 #undef SCAN
 
-#define PARALLEL_SCAN(Structure, Arity, AuxiliaryArity, ...)            \
-    CASE(ParallelScan, Structure, Arity, AuxiliaryArity)                \
+#define PARALLEL_SCAN(Structure, Arity, ...)                            \
+    CASE(ParallelScan, Structure, Arity)                                \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalParallelScan(rel, cur, shadow, ctxt);                \
     ESAC(ParallelScan)
         FOR_EACH(PARALLEL_SCAN)
 #undef PARALLEL_SCAN
 
-#define INDEX_SCAN(Structure, Arity, AuxiliaryArity, ...) \
-    CASE(IndexScan, Structure, Arity, AuxiliaryArity)     \
+#define INDEX_SCAN(Structure, Arity, ...)                 \
+    CASE(IndexScan, Structure, Arity)                     \
         return evalIndexScan<RelType>(cur, shadow, ctxt); \
     ESAC(IndexScan)
 
         FOR_EACH(INDEX_SCAN)
 #undef INDEX_SCAN
 
-#define PARALLEL_INDEX_SCAN(Structure, Arity, AuxiliaryArity, ...)      \
-    CASE(ParallelIndexScan, Structure, Arity, AuxiliaryArity)           \
+#define PARALLEL_INDEX_SCAN(Structure, Arity, ...)                      \
+    CASE(ParallelIndexScan, Structure, Arity)                           \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalParallelIndexScan(rel, cur, shadow, ctxt);           \
     ESAC(ParallelIndexScan)
@@ -1172,8 +1201,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(PARALLEL_INDEX_SCAN)
 #undef PARALLEL_INDEX_SCAN
 
-#define IFEXISTS(Structure, Arity, AuxiliaryArity, ...)                 \
-    CASE(IfExists, Structure, Arity, AuxiliaryArity)                    \
+#define IFEXISTS(Structure, Arity, ...)                                 \
+    CASE(IfExists, Structure, Arity)                                    \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalIfExists(rel, cur, shadow, ctxt);                    \
     ESAC(IfExists)
@@ -1181,8 +1210,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(IFEXISTS)
 #undef IFEXISTS
 
-#define PARALLEL_IFEXISTS(Structure, Arity, AuxiliaryArity, ...)        \
-    CASE(ParallelIfExists, Structure, Arity, AuxiliaryArity)            \
+#define PARALLEL_IFEXISTS(Structure, Arity, ...)                        \
+    CASE(ParallelIfExists, Structure, Arity)                            \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalParallelIfExists(rel, cur, shadow, ctxt);            \
     ESAC(ParallelIfExists)
@@ -1190,16 +1219,16 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(PARALLEL_IFEXISTS)
 #undef PARALLEL_IFEXISTS
 
-#define INDEX_IFEXISTS(Structure, Arity, AuxiliaryArity, ...) \
-    CASE(IndexIfExists, Structure, Arity, AuxiliaryArity)     \
+#define INDEX_IFEXISTS(Structure, Arity, ...)                 \
+    CASE(IndexIfExists, Structure, Arity)                     \
         return evalIndexIfExists<RelType>(cur, shadow, ctxt); \
     ESAC(IndexIfExists)
 
         FOR_EACH(INDEX_IFEXISTS)
 #undef INDEX_IFEXISTS
 
-#define PARALLEL_INDEX_IFEXISTS(Structure, Arity, AuxiliaryArity, ...)  \
-    CASE(ParallelIndexIfExists, Structure, Arity, AuxiliaryArity)       \
+#define PARALLEL_INDEX_IFEXISTS(Structure, Arity, ...)                  \
+    CASE(ParallelIndexIfExists, Structure, Arity)                       \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalParallelIndexIfExists(rel, cur, shadow, ctxt);       \
     ESAC(ParallelIndexIfExists)
@@ -1226,8 +1255,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
             return execute(shadow.getNestedOperation(), ctxt);
         ESAC(UnpackRecord)
 
-#define PARALLEL_AGGREGATE(Structure, Arity, AuxiliaryArity, ...)       \
-    CASE(ParallelAggregate, Structure, Arity, AuxiliaryArity)           \
+#define PARALLEL_AGGREGATE(Structure, Arity, ...)                       \
+    CASE(ParallelAggregate, Structure, Arity)                           \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalParallelAggregate(rel, cur, shadow, ctxt);           \
     ESAC(ParallelAggregate)
@@ -1235,25 +1264,26 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(PARALLEL_AGGREGATE)
 #undef PARALLEL_AGGREGATE
 
-#define AGGREGATE(Structure, Arity, AuxiliaryArity, ...)                \
-    CASE(Aggregate, Structure, Arity, AuxiliaryArity)                   \
-        const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
-        return evalAggregate(cur, shadow, rel.scan(), ctxt);            \
+#define AGGREGATE(Structure, Arity, ...)                                                                  \
+    CASE(Aggregate, Structure, Arity)                                                                     \
+        const auto& rel = *static_cast<RelType*>(shadow.getRelation());                                   \
+        return evalAggregate(cur, *shadow.getCondition(), shadow.getExpr(), *shadow.getNestedOperation(), \
+                rel.scan(), ctxt);                                                                        \
     ESAC(Aggregate)
 
         FOR_EACH(AGGREGATE)
 #undef AGGREGATE
 
-#define PARALLEL_INDEX_AGGREGATE(Structure, Arity, AuxiliaryArity, ...) \
-    CASE(ParallelIndexAggregate, Structure, Arity, AuxiliaryArity)      \
-        return evalParallelIndexAggregate<RelType>(cur, shadow, ctxt);  \
+#define PARALLEL_INDEX_AGGREGATE(Structure, Arity, ...)                \
+    CASE(ParallelIndexAggregate, Structure, Arity)                     \
+        return evalParallelIndexAggregate<RelType>(cur, shadow, ctxt); \
     ESAC(ParallelIndexAggregate)
 
         FOR_EACH(PARALLEL_INDEX_AGGREGATE)
 #undef PARALLEL_INDEX_AGGREGATE
 
-#define INDEX_AGGREGATE(Structure, Arity, AuxiliaryArity, ...) \
-    CASE(IndexAggregate, Structure, Arity, AuxiliaryArity)     \
+#define INDEX_AGGREGATE(Structure, Arity, ...)                 \
+    CASE(IndexAggregate, Structure, Arity)                     \
         return evalIndexAggregate<RelType>(cur, shadow, ctxt); \
     ESAC(IndexAggregate)
 
@@ -1286,8 +1316,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
             return result;
         ESAC(Filter)
 
-#define GUARDED_INSERT(Structure, Arity, AuxiliaryArity, ...)     \
-    CASE(GuardedInsert, Structure, Arity, AuxiliaryArity)         \
+#define GUARDED_INSERT(Structure, Arity, ...)                     \
+    CASE(GuardedInsert, Structure, Arity)                         \
         auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalGuardedInsert(rel, shadow, ctxt);              \
     ESAC(GuardedInsert)
@@ -1295,8 +1325,8 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(GUARDED_INSERT)
 #undef GUARDED_INSERT
 
-#define INSERT(Structure, Arity, AuxiliaryArity, ...)             \
-    CASE(Insert, Structure, Arity, AuxiliaryArity)                \
+#define INSERT(Structure, Arity, ...)                             \
+    CASE(Insert, Structure, Arity)                                \
         auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
         return evalInsert(rel, shadow, ctxt);                     \
     ESAC(Insert)
@@ -1304,18 +1334,18 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
         FOR_EACH(INSERT)
 #undef INSERT
 
-#define ERASE(Structure, Arity, AuxiliaryArity, ...)                                                 \
-    CASE(Erase, Structure, Arity, AuxiliaryArity)                                                    \
-        void(static_cast<RelType*>(shadow.getRelation()));                                           \
-        auto& rel = *static_cast<BtreeDeleteRelation<Arity, AuxiliaryArity>*>(shadow.getRelation()); \
-        return evalErase(rel, shadow, ctxt);                                                         \
+#define ERASE(Structure, Arity, ...)                                                 \
+    CASE(Erase, Structure, Arity)                                                    \
+        void(static_cast<RelType*>(shadow.getRelation()));                           \
+        auto& rel = *static_cast<BtreeDeleteRelation<Arity>*>(shadow.getRelation()); \
+        return evalErase(rel, shadow, ctxt);                                         \
     ESAC(Erase)
 
         FOR_EACH_BTREE_DELETE(ERASE)
 #undef ERASE
 
         CASE(SubroutineReturn)
-            for (std::size_t i = 0; i < cur.getNumValues(); ++i) {
+            for (std::size_t i = 0; i < cur.getValues().size(); ++i) {
                 if (shadow.getChild(i) == nullptr) {
                     ctxt.addReturnValue(0);
                 } else {
@@ -1345,11 +1375,9 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
 
         CASE(Loop)
             resetIterationNumber();
-
             while (execute(shadow.getChild(), ctxt)) {
                 incIterationNumber();
             }
-
             resetIterationNumber();
             return true;
         ESAC(Loop)
@@ -1374,23 +1402,27 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
             return execute(shadow.getChild(), ctxt);
         ESAC(DebugInfo)
 
-        CASE(Clear)
-            auto* rel = shadow.getRelation();
-            rel->purge();
-            return true;
-        ESAC(Clear)
+#define CLEAR(Structure, Arity, ...)                              \
+    CASE(Clear, Structure, Arity)                                 \
+        auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
+        rel.__purge();                                            \
+        return true;                                              \
+    ESAC(Clear)
+
+        FOR_EACH(CLEAR)
+#undef CLEAR
 
-#define ESTIMATEJOINSIZE(Structure, Arity, AuxiliaryArity, ...)         \
-    CASE(EstimateJoinSize, Structure, Arity, AuxiliaryArity)            \
+#define COUNTUNIQUEKEYS(Structure, Arity, ...)                          \
+    CASE(CountUniqueKeys, Structure, Arity)                             \
         const auto& rel = *static_cast<RelType*>(shadow.getRelation()); \
-        return evalEstimateJoinSize<RelType>(rel, cur, shadow, ctxt);   \
-    ESAC(EstimateJoinSize)
+        return evalCountUniqueKeys<RelType>(rel, cur, shadow, ctxt);    \
+    ESAC(CountUniqueKeys)
 
-        FOR_EACH(ESTIMATEJOINSIZE)
-#undef ESTIMATEJOINSIZE
+        FOR_EACH(COUNTUNIQUEKEYS)
+#undef COUNTUNIQUEKEYS
 
         CASE(Call)
-            execute(subroutine[shadow.getSubroutineName()].get(), ctxt);
+            execute(subroutine[shadow.getSubroutineId()].get(), ctxt);
             return true;
         ESAC(Call)
 
@@ -1413,7 +1445,6 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
                             ->readAll(rel);
                 } catch (std::exception& e) {
                     std::cerr << "Error loading " << rel.getName() << " data: " << e.what() << "\n";
-                    exit(EXIT_FAILURE);
                 }
                 return true;
             } else if (op == "output" || op == "printsize") {
@@ -1481,13 +1512,6 @@ RamDomain Engine::execute(const Node* node, Context& ctxt) {
             swapRelation(shadow.getSourceId(), shadow.getTargetId());
             return true;
         ESAC(Swap)
-
-        CASE(Assign)
-            const std::string& name = cur.getVariable().getName();
-            const RamDomain val = execute(shadow.getRhs(), ctxt);
-            ctxt.setVariable(name, val);
-            return true;
-        ESAC(Assign)
     }
 
     UNREACHABLE_BAD_CASE_ANALYSIS
@@ -1602,7 +1626,7 @@ RamDomain Engine::evalParallelScan(
         const Rel& rel, const ram::ParallelScan& cur, const ParallelScan& shadow, Context& ctxt) {
     auto viewContext = shadow.getViewContext();
 
-    auto pStream = rel.partitionScan(numOfThreads * 20);
+    auto pStream = rel.partitionScan(numOfThreads);
 
     PARALLEL_START
         Context newCtxt(ctxt);
@@ -1630,8 +1654,8 @@ RamDomain Engine::evalParallelScan(
 }
 
 template <typename Rel>
-RamDomain Engine::evalEstimateJoinSize(
-        const Rel& rel, const ram::EstimateJoinSize& cur, const EstimateJoinSize& shadow, Context& ctxt) {
+RamDomain Engine::evalCountUniqueKeys(
+        const Rel& rel, const ram::CountUniqueKeys& cur, const CountUniqueKeys& shadow, Context& ctxt) {
     (void)ctxt;
     constexpr std::size_t Arity = Rel::Arity;
     bool onlyConstants = true;
@@ -1681,8 +1705,8 @@ RamDomain Engine::evalEstimateJoinSize(
     // ensure range is non-empty
     auto* index = rel.getIndex(indexPos);
     // initial values
-    double total = 0;
-    double duplicates = 0;
+    std::size_t total = 0;
+    std::size_t duplicates = 0;
 
     if (!index->scan().empty()) {
         // assign first tuple as prev as a dummy
@@ -1710,14 +1734,14 @@ RamDomain Engine::evalEstimateJoinSize(
             ++total;
         }
     }
-    double joinSize = (onlyConstants ? total : total / std::max(1.0, (total - duplicates)));
+    std::size_t uniqueKeys = (onlyConstants ? total : total - duplicates);
 
     std::stringstream columnsStream;
     columnsStream << cur.getKeyColumns();
     std::string columns = columnsStream.str();
 
     std::stringstream constantsStream;
-    constantsStream << "{";
+    constantsStream << "[";
     bool first = true;
     for (auto& [k, constant] : cur.getConstantsMap()) {
         if (first) {
@@ -1727,18 +1751,18 @@ RamDomain Engine::evalEstimateJoinSize(
         }
         constantsStream << k << "->" << *constant;
     }
-    constantsStream << "}";
+    constantsStream << "]";
 
     std::string constants = stringify(constantsStream.str());
 
     if (cur.isRecursiveRelation()) {
         std::string txt =
-                "@recursive-estimate-join-size;" + cur.getRelation() + ";" + columns + ";" + constants;
-        ProfileEventSingleton::instance().makeRecursiveCountEvent(txt, joinSize, getIterationNumber());
+                "@recursive-count-unique-keys;" + cur.getRelation() + ";" + columns + ";" + constants;
+        ProfileEventSingleton::instance().makeRecursiveCountEvent(txt, uniqueKeys, getIterationNumber());
     } else {
         std::string txt =
-                "@non-recursive-estimate-join-size;" + cur.getRelation() + ";" + columns + ";" + constants;
-        ProfileEventSingleton::instance().makeNonRecursiveCountEvent(txt, joinSize);
+                "@non-recursive-count-unique-keys;" + cur.getRelation() + ";" + columns + ";" + constants;
+        ProfileEventSingleton::instance().makeNonRecursiveCountEvent(txt, uniqueKeys);
     }
     return true;
 }
@@ -1777,7 +1801,7 @@ RamDomain Engine::evalParallelIndexScan(
     CAL_SEARCH_BOUND(superInfo, low, high);
 
     std::size_t indexPos = shadow.getViewId();
-    auto pStream = rel.partitionRange(indexPos, low, high, numOfThreads * 20);
+    auto pStream = rel.partitionRange(indexPos, low, high, numOfThreads);
     PARALLEL_START
         Context newCtxt(ctxt);
         auto viewInfo = viewContext->getViewInfoForNested();
@@ -1822,7 +1846,7 @@ RamDomain Engine::evalParallelIfExists(
         const Rel& rel, const ram::ParallelIfExists& cur, const ParallelIfExists& shadow, Context& ctxt) {
     auto viewContext = shadow.getViewContext();
 
-    auto pStream = rel.partitionScan(numOfThreads * 20);
+    auto pStream = rel.partitionScan(numOfThreads);
     auto viewInfo = viewContext->getViewInfoForNested();
     PARALLEL_START
         Context newCtxt(ctxt);
@@ -1886,7 +1910,7 @@ RamDomain Engine::evalParallelIndexIfExists(const Rel& rel, const ram::ParallelI
     CAL_SEARCH_BOUND(superInfo, low, high);
 
     std::size_t indexPos = shadow.getViewId();
-    auto pStream = rel.partitionRange(indexPos, low, high, numOfThreads * 20);
+    auto pStream = rel.partitionRange(indexPos, low, high, numOfThreads);
 
     PARALLEL_START
         Context newCtxt(ctxt);
@@ -1914,68 +1938,49 @@ RamDomain Engine::evalParallelIndexIfExists(const Rel& rel, const ram::ParallelI
     return true;
 }
 
-template <typename Shadow>
-RamDomain Engine::initValue(const ram::Aggregator& aggregator, const Shadow& shadow, Context& ctxt) {
-    if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-        switch (ia->getFunction()) {
-            case AggregateOp::MIN: return ramBitCast(MAX_RAM_SIGNED);
-            case AggregateOp::UMIN: return ramBitCast(MAX_RAM_UNSIGNED);
-            case AggregateOp::FMIN: return ramBitCast(MAX_RAM_FLOAT);
-            case AggregateOp::MAX: return ramBitCast(MIN_RAM_SIGNED);
-            case AggregateOp::UMAX: return ramBitCast(MIN_RAM_UNSIGNED);
-            case AggregateOp::FMAX: return ramBitCast(MIN_RAM_FLOAT);
-            case AggregateOp::SUM: return ramBitCast(static_cast<RamSigned>(0));
-            case AggregateOp::USUM: return ramBitCast(static_cast<RamUnsigned>(0));
-            case AggregateOp::FSUM: return ramBitCast(static_cast<RamFloat>(0));
-            case AggregateOp::MEAN: return 0;
-            case AggregateOp::COUNT: return 0;
-        }
-    } else if (isA<ram::UserDefinedAggregator>(aggregator)) {
-        return execute(shadow.getInit(), ctxt);
-    }
-    fatal("Unhandled aggregator");
-}
-
-bool runNested(const ram::Aggregator& aggregator) {
-    if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-        switch (ia->getFunction()) {
-            case AggregateOp::COUNT:
-            case AggregateOp::FSUM:
-            case AggregateOp::USUM:
-            case AggregateOp::SUM: return true;
-            default: return false;
-        }
-    } else if (isA<ram::UserDefinedAggregator>(aggregator)) {
-        return true;
-    }
-    return false;
-}
-
-void ifIntrinsic(const ram::Aggregator& aggregator, AggregateOp op, std::function<void()> fn) {
-    if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-        if (ia->getFunction() == op) {
-            fn();
-        };
-    }
-}
-
-template <typename Aggregate, typename Shadow, typename Iter>
-RamDomain Engine::evalAggregate(
-        const Aggregate& aggregate, const Shadow& shadow, const Iter& ranges, Context& ctxt) {
+template <typename Aggregate, typename Iter>
+RamDomain Engine::evalAggregate(const Aggregate& aggregate, const Node& filter, const Node* expression,
+        const Node& nestedOperation, const Iter& ranges, Context& ctxt) {
     bool shouldRunNested = false;
 
-    const Node& filter = *shadow.getCondition();
-    const Node* expression = shadow.getExpr();
-    const Node& nestedOperation = *shadow.getNestedOperation();
     // initialize result
     RamDomain res = 0;
 
     // Use for calculating mean.
-    std::pair<RamFloat, RamFloat> accumulateMean = {0, 0};
+    std::pair<RamFloat, RamFloat> accumulateMean;
+
+    switch (aggregate.getFunction()) {
+        case AggregateOp::MIN: res = ramBitCast(MAX_RAM_SIGNED); break;
+        case AggregateOp::UMIN: res = ramBitCast(MAX_RAM_UNSIGNED); break;
+        case AggregateOp::FMIN: res = ramBitCast(MAX_RAM_FLOAT); break;
+
+        case AggregateOp::MAX: res = ramBitCast(MIN_RAM_SIGNED); break;
+        case AggregateOp::UMAX: res = ramBitCast(MIN_RAM_UNSIGNED); break;
+        case AggregateOp::FMAX: res = ramBitCast(MIN_RAM_FLOAT); break;
+
+        case AggregateOp::SUM:
+            res = ramBitCast(static_cast<RamSigned>(0));
+            shouldRunNested = true;
+            break;
+        case AggregateOp::USUM:
+            res = ramBitCast(static_cast<RamUnsigned>(0));
+            shouldRunNested = true;
+            break;
+        case AggregateOp::FSUM:
+            res = ramBitCast(static_cast<RamFloat>(0));
+            shouldRunNested = true;
+            break;
 
-    const ram::Aggregator& aggregator = aggregate.getAggregator();
-    res = initValue(aggregator, shadow, ctxt);
-    shouldRunNested = runNested(aggregator);
+        case AggregateOp::MEAN:
+            res = 0;
+            accumulateMean = {0, 0};
+            break;
+
+        case AggregateOp::COUNT:
+            res = 0;
+            shouldRunNested = true;
+            break;
+    }
 
     for (const auto& tuple : ranges) {
         ctxt[aggregate.getTupleId()] = tuple.data();
@@ -1986,11 +1991,8 @@ RamDomain Engine::evalAggregate(
 
         shouldRunNested = true;
 
-        bool isCount = false;
-        ifIntrinsic(aggregator, AggregateOp::COUNT, [&]() { isCount = true; });
-
         // count is a special case.
-        if (isCount) {
+        if (aggregate.getFunction() == AggregateOp::COUNT) {
             ++res;
             continue;
         }
@@ -1999,56 +2001,43 @@ RamDomain Engine::evalAggregate(
         assert(expression);  // only case where this is null is `COUNT`
         RamDomain val = execute(expression, ctxt);
 
-        if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-            switch (ia->getFunction()) {
-                case AggregateOp::MIN: res = std::min(res, val); break;
-                case AggregateOp::FMIN:
-                    res = ramBitCast(std::min(ramBitCast<RamFloat>(res), ramBitCast<RamFloat>(val)));
-                    break;
-                case AggregateOp::UMIN:
-                    res = ramBitCast(std::min(ramBitCast<RamUnsigned>(res), ramBitCast<RamUnsigned>(val)));
-                    break;
+        switch (aggregate.getFunction()) {
+            case AggregateOp::MIN: res = std::min(res, val); break;
+            case AggregateOp::FMIN:
+                res = ramBitCast(std::min(ramBitCast<RamFloat>(res), ramBitCast<RamFloat>(val)));
+                break;
+            case AggregateOp::UMIN:
+                res = ramBitCast(std::min(ramBitCast<RamUnsigned>(res), ramBitCast<RamUnsigned>(val)));
+                break;
 
-                case AggregateOp::MAX: res = std::max(res, val); break;
-                case AggregateOp::FMAX:
-                    res = ramBitCast(std::max(ramBitCast<RamFloat>(res), ramBitCast<RamFloat>(val)));
-                    break;
-                case AggregateOp::UMAX:
-                    res = ramBitCast(std::max(ramBitCast<RamUnsigned>(res), ramBitCast<RamUnsigned>(val)));
-                    break;
+            case AggregateOp::MAX: res = std::max(res, val); break;
+            case AggregateOp::FMAX:
+                res = ramBitCast(std::max(ramBitCast<RamFloat>(res), ramBitCast<RamFloat>(val)));
+                break;
+            case AggregateOp::UMAX:
+                res = ramBitCast(std::max(ramBitCast<RamUnsigned>(res), ramBitCast<RamUnsigned>(val)));
+                break;
 
-                case AggregateOp::SUM: res += val; break;
-                case AggregateOp::FSUM:
-                    res = ramBitCast(ramBitCast<RamFloat>(res) + ramBitCast<RamFloat>(val));
-                    break;
-                case AggregateOp::USUM:
-                    res = ramBitCast(ramBitCast<RamUnsigned>(res) + ramBitCast<RamUnsigned>(val));
-                    break;
+            case AggregateOp::SUM: res += val; break;
+            case AggregateOp::FSUM:
+                res = ramBitCast(ramBitCast<RamFloat>(res) + ramBitCast<RamFloat>(val));
+                break;
+            case AggregateOp::USUM:
+                res = ramBitCast(ramBitCast<RamUnsigned>(res) + ramBitCast<RamUnsigned>(val));
+                break;
 
-                case AggregateOp::MEAN:
-                    accumulateMean.first += ramBitCast<RamFloat>(val);
-                    accumulateMean.second++;
-                    break;
+            case AggregateOp::MEAN:
+                accumulateMean.first += ramBitCast<RamFloat>(val);
+                accumulateMean.second++;
+                break;
 
-                case AggregateOp::COUNT: fatal("This should never be executed");
-            }
-        } else if (const auto* uda = as<ram::UserDefinedAggregator>(aggregator)) {
-            auto userFunctorPtr = reinterpret_cast<void (*)()>(shadow.getFunctionPointer());
-            if (uda->isStateful() && userFunctorPtr) {
-                res = callStatefulAggregate(userFunctorPtr, &getSymbolTable(), &getRecordTable(), res, val);
-            } else {
-                fatal("stateless functors not supported in user-defined aggregates");
-            }
-        } else {
-            fatal("Unhandled aggregator");
+            case AggregateOp::COUNT: fatal("This should never be executed");
         }
     }
 
-    ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() {
-        if (accumulateMean.second != 0) {
-            res = ramBitCast(accumulateMean.first / accumulateMean.second);
-        }
-    });
+    if (aggregate.getFunction() == AggregateOp::MEAN && accumulateMean.second != 0) {
+        res = ramBitCast(accumulateMean.first / accumulateMean.second);
+    }
 
     // write result to environment
     souffle::Tuple<RamDomain, 1> tuple;
@@ -2072,7 +2061,8 @@ RamDomain Engine::evalParallelAggregate(
     for (const auto& info : viewInfo) {
         newCtxt.createView(*getRelationHandle(info[0]), info[1], info[2]);
     }
-    return evalAggregate(cur, shadow, rel.scan(), newCtxt);
+    return evalAggregate(
+            cur, *shadow.getCondition(), shadow.getExpr(), *shadow.getNestedOperation(), rel.scan(), newCtxt);
 }
 
 template <typename Rel>
@@ -2097,7 +2087,8 @@ RamDomain Engine::evalParallelIndexAggregate(
     std::size_t viewId = shadow.getViewId();
     auto view = Rel::castView(newCtxt.getView(viewId));
 
-    return evalAggregate(cur, shadow, view->range(low, high), newCtxt);
+    return evalAggregate(cur, *shadow.getCondition(), shadow.getExpr(), *shadow.getNestedOperation(),
+            view->range(low, high), newCtxt);
 }
 
 template <typename Rel>
@@ -2113,7 +2104,8 @@ RamDomain Engine::evalIndexAggregate(
     std::size_t viewId = shadow.getViewId();
     auto view = Rel::castView(ctxt.getView(viewId));
 
-    return evalAggregate(cur, shadow, view->range(low, high), ctxt);
+    return evalAggregate(cur, *shadow.getCondition(), shadow.getExpr(), *shadow.getNestedOperation(),
+            view->range(low, high), ctxt);
 }
 
 template <typename Rel>
diff --git a/src/interpreter/Engine.h b/src/interpreter/Engine.h
index 22293f1..1e3ab30 100644
--- a/src/interpreter/Engine.h
+++ b/src/interpreter/Engine.h
@@ -27,7 +27,6 @@
 #include "souffle/RamTypes.h"
 #include "souffle/RecordTable.h"
 #include "souffle/SymbolTable.h"
-#include "souffle/datastructure/ConcurrentCache.h"
 #include "souffle/datastructure/RecordTableImpl.h"
 #include "souffle/datastructure/SymbolTableImpl.h"
 #include "souffle/utility/ContainerUtil.h"
@@ -36,7 +35,6 @@
 #include <deque>
 #include <map>
 #include <memory>
-#include <regex>
 #include <string>
 #include <vector>
 #ifdef _OPENMP
@@ -57,24 +55,14 @@ class Engine {
     friend NodeGenerator;
 
 public:
-    Engine(ram::TranslationUnit& tUnit, const std::size_t numThreads);
+    Engine(ram::TranslationUnit& tUnit);
 
     /** @brief Execute the main program */
     void executeMain();
-
     /** @brief Execute the subroutine program */
     void executeSubroutine(
             const std::string& name, const std::vector<RamDomain>& args, std::vector<RamDomain>& ret);
 
-    /** @brief Return the global object this engine uses */
-    Global& getGlobal();
-
-    /** @brief Return the string symbol table */
-    SymbolTable& getSymbolTable();
-
-    /** @brief Return the record table */
-    RecordTable& getRecordTable();
-
 private:
     /** @brief Generate intermediate representation from RAM */
     void generateIR();
@@ -84,9 +72,15 @@ private:
     void swapRelation(const std::size_t ramRel1, const std::size_t ramRel2);
     /** @brief Return a reference to the relation on the given index */
     RelationHandle& getRelationHandle(const std::size_t idx);
+    /** @brief Return the string symbol table */
+    SymbolTable& getSymbolTable() {
+        return symbolTable;
+    }
+    /** @brief Return the record table */
+    RecordTable& getRecordTable();
     /** @brief Return the ram::TranslationUnit */
     ram::TranslationUnit& getTranslationUnit();
-    /** @brief Execute a specific node program */
+    /** @brief Execute the program */
     RamDomain execute(const Node*, Context&);
     /** @brief Return method handler */
     void* getMethodHandle(const std::string& method);
@@ -120,8 +114,8 @@ private:
             const Rel& rel, const ram::ParallelScan& cur, const ParallelScan& shadow, Context& ctxt);
 
     template <typename Rel>
-    RamDomain evalEstimateJoinSize(
-            const Rel& rel, const ram::EstimateJoinSize& cur, const EstimateJoinSize& shadow, Context& ctxt);
+    RamDomain evalCountUniqueKeys(
+            const Rel& rel, const ram::CountUniqueKeys& cur, const CountUniqueKeys& shadow, Context& ctxt);
 
     template <typename Rel>
     RamDomain evalIndexScan(const ram::IndexScan& cur, const IndexScan& shadow, Context& ctxt);
@@ -144,12 +138,9 @@ private:
     RamDomain evalParallelIndexIfExists(const Rel& rel, const ram::ParallelIndexIfExists& cur,
             const ParallelIndexIfExists& shadow, Context& ctxt);
 
-    template <typename Shadow>
-    RamDomain initValue(const ram::Aggregator& aggregator, const Shadow& shadow, Context& ctxt);
-
-    template <typename Aggregate, typename Shadow, typename Iter>
-    RamDomain evalAggregate(
-            const Aggregate& aggregate, const Shadow& shadow, const Iter& ranges, Context& ctxt);
+    template <typename Aggregate, typename Iter>
+    RamDomain evalAggregate(const Aggregate& aggregate, const Node& filter, const Node* expression,
+            const Node& nestedOperation, const Iter& ranges, Context& ctxt);
 
     template <typename Rel>
     RamDomain evalParallelAggregate(const Rel& rel, const ram::ParallelAggregate& cur,
@@ -171,15 +162,11 @@ private:
     template <typename Rel>
     RamDomain evalErase(Rel& rel, const Erase& shadow, Context& ctxt);
 
-    /** Program */
-    ram::TranslationUnit& tUnit;
-    /** Global */
-    Global& global;
     /** If profile is enable in this program */
     const bool profileEnabled;
     const bool frequencyCounterEnabled;
     /** subroutines */
-    std::map<std::string /*name*/, Own<Node>> subroutine;
+    VecOwn<Node> subroutine;
     /** main program */
     Own<Node> main;
     /** Number of threads enabled for this program */
@@ -194,6 +181,8 @@ private:
     std::map<std::string, std::atomic<std::size_t>> reads;
     /** DLL */
     std::vector<void*> dll;
+    /** Program */
+    ram::TranslationUnit& tUnit;
     /** IndexAnalysis */
     ram::analysis::IndexAnalysis& isa;
     /** Record Table Implementation*/
@@ -202,8 +191,6 @@ private:
     VecOwn<RelationHandle> relations;
     /** Symbol table */
     SymbolTableImpl symbolTable;
-    /** A cache for regexes */
-    ConcurrentCache<std::string, std::regex> regexCache;
 };
 
 }  // namespace souffle::interpreter
diff --git a/src/interpreter/EqrelIndex.cpp b/src/interpreter/EqrelIndex.cpp
index b6aeef1..7a368c1 100644
--- a/src/interpreter/EqrelIndex.cpp
+++ b/src/interpreter/EqrelIndex.cpp
@@ -23,8 +23,7 @@ namespace souffle::interpreter {
 Own<RelationWrapper> createEqrelRelation(
         const ram::Relation& id, const ram::analysis::IndexCluster& indexSelection) {
     assert(id.getArity() == 2 && "Eqivalence relation must have arity size 2.");
-    assert(id.getAuxiliaryArity() == 0 && "Equivalence relation must have auxiliary arity size 0.");
-    return mk<EqrelRelation>(id.getName(), indexSelection);
+    return mk<EqrelRelation>(id.getAuxiliaryArity(), id.getName(), indexSelection);
 }
 
 }  // namespace souffle::interpreter
diff --git a/src/interpreter/Generator.cpp b/src/interpreter/Generator.cpp
index 07e134a..4dbbdd7 100644
--- a/src/interpreter/Generator.cpp
+++ b/src/interpreter/Generator.cpp
@@ -15,7 +15,6 @@
 
 #include "interpreter/Generator.h"
 #include "interpreter/Engine.h"
-#include "ram/UserDefinedAggregator.h"
 
 namespace souffle::interpreter {
 
@@ -23,7 +22,7 @@ using NodePtr = Own<Node>;
 using NodePtrVec = std::vector<NodePtr>;
 using RelationHandle = Own<RelationWrapper>;
 
-NodeGenerator::NodeGenerator(Engine& engine) : engine(engine), global(engine.getGlobal()) {
+NodeGenerator::NodeGenerator(Engine& engine) : engine(engine) {
     visit(engine.tUnit.getProgram(), [&](const ram::Relation& relation) {
         assert(relationMap.find(relation.getName()) == relationMap.end() && "double-naming of relations");
         relationMap[relation.getName()] = &relation;
@@ -36,9 +35,9 @@ NodePtr NodeGenerator::generateTree(const ram::Node& root) {
         if (isA<ram::Query>(&node)) {
             newQueryBlock();
         }
-        if (const auto* estimateJoinSize = as<ram::EstimateJoinSize>(node)) {
-            encodeIndexPos(*estimateJoinSize);
-            encodeView(estimateJoinSize);
+        if (const auto* countUniqueKeys = as<ram::CountUniqueKeys>(node)) {
+            encodeIndexPos(*countUniqueKeys);
+            encodeView(countUniqueKeys);
         } else if (const auto* indexSearch = as<ram::IndexOperation>(node)) {
             encodeIndexPos(*indexSearch);
             encodeView(indexSearch);
@@ -63,10 +62,6 @@ NodePtr NodeGenerator::visit_(type_identity<ram::NumericConstant>, const ram::Nu
     return mk<NumericConstant>(I_NumericConstant, &num);
 }
 
-NodePtr NodeGenerator::visit_(type_identity<ram::Variable>, const ram::Variable& var) {
-    return mk<Variable>(I_Variable, &var);
-}
-
 NodePtr NodeGenerator::visit_(type_identity<ram::TupleElement>, const ram::TupleElement& access) {
     auto tupleId = access.getTupleId();
     auto elementId = access.getElement();
@@ -210,14 +205,14 @@ NodePtr NodeGenerator::visit_(type_identity<ram::Negation>, const ram::Negation&
 NodePtr NodeGenerator::visit_(type_identity<ram::EmptinessCheck>, const ram::EmptinessCheck& emptiness) {
     std::size_t relId = encodeRelation(emptiness.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "EmptinessCheck", lookup(emptiness.getRelation()));
+    NodeType type = constructNodeType("EmptinessCheck", lookup(emptiness.getRelation()));
     return mk<EmptinessCheck>(type, &emptiness, rel);
 }
 
 NodePtr NodeGenerator::visit_(type_identity<ram::RelationSize>, const ram::RelationSize& size) {
     std::size_t relId = encodeRelation(size.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "RelationSize", lookup(size.getRelation()));
+    NodeType type = constructNodeType("RelationSize", lookup(size.getRelation()));
     return mk<RelationSize>(type, &size, rel);
 }
 
@@ -231,7 +226,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::ExistenceCheck>, const ram::Exi
         }
     }
     const auto& ramRelation = lookup(exists.getRelation());
-    NodeType type = constructNodeType(global, "ExistenceCheck", ramRelation);
+    NodeType type = constructNodeType("ExistenceCheck", ramRelation);
     return mk<ExistenceCheck>(type, &exists, isTotal, encodeView(&exists), std::move(superOp),
             ramRelation.isTemp(), ramRelation.getName());
 }
@@ -239,35 +234,13 @@ NodePtr NodeGenerator::visit_(type_identity<ram::ExistenceCheck>, const ram::Exi
 NodePtr NodeGenerator::visit_(
         type_identity<ram::ProvenanceExistenceCheck>, const ram::ProvenanceExistenceCheck& provExists) {
     SuperInstruction superOp = getExistenceSuperInstInfo(provExists);
-    NodeType type = constructNodeType(global, "ProvenanceExistenceCheck", lookup(provExists.getRelation()));
+    NodeType type = constructNodeType("ProvenanceExistenceCheck", lookup(provExists.getRelation()));
     return mk<ProvenanceExistenceCheck>(type, &provExists, dispatch(*(--provExists.getChildNodes().end())),
             encodeView(&provExists), std::move(superOp));
 }
 
 NodePtr NodeGenerator::visit_(type_identity<ram::Constraint>, const ram::Constraint& relOp) {
-    auto left = dispatch(relOp.getLHS());
-    auto right = dispatch(relOp.getRHS());
-    switch (relOp.getOperator()) {
-        case BinaryConstraintOp::MATCH:
-        case BinaryConstraintOp::NOT_MATCH:
-            if (const StringConstant* str = dynamic_cast<const StringConstant*>(left.get()); str) {
-                const std::string& pattern = engine.getSymbolTable().unsafeDecode(str->getConstant());
-                try {
-                    std::regex regex(pattern);
-                    // treat the string constant as a regex
-                    left = mk<RegexConstant>(*str, std::move(regex));
-                } catch (const std::exception&) {
-                    std::cerr << "warning: wrong pattern provided \"" << pattern << "\"\n";
-
-                    // we could not compile the pattern
-                    left = mk<RegexConstant>(*str, std::nullopt);
-                }
-            }
-            break;
-        default: break;
-    }
-
-    return mk<Constraint>(I_Constraint, &relOp, std::move(left), std::move(right));
+    return mk<Constraint>(I_Constraint, &relOp, dispatch(relOp.getLHS()), dispatch(relOp.getRHS()));
 }
 
 NodePtr NodeGenerator::visit_(type_identity<ram::NestedOperation>, const ram::NestedOperation& nested) {
@@ -285,7 +258,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::Scan>, const ram::Scan& scan) {
     orderingContext.addTupleWithDefaultOrder(scan.getTupleId(), scan);
     std::size_t relId = encodeRelation(scan.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "Scan", lookup(scan.getRelation()));
+    NodeType type = constructNodeType("Scan", lookup(scan.getRelation()));
     return mk<Scan>(type, &scan, rel, visit_(type_identity<ram::TupleOperation>(), scan));
 }
 
@@ -293,7 +266,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::ParallelScan>, const ram::Paral
     orderingContext.addTupleWithDefaultOrder(pScan.getTupleId(), pScan);
     std::size_t relId = encodeRelation(pScan.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "ParallelScan", lookup(pScan.getRelation()));
+    NodeType type = constructNodeType("ParallelScan", lookup(pScan.getRelation()));
     auto res = mk<ParallelScan>(type, &pScan, rel, visit_(type_identity<ram::TupleOperation>(), pScan));
     res->setViewContext(parentQueryViewContext);
     return res;
@@ -302,7 +275,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::ParallelScan>, const ram::Paral
 NodePtr NodeGenerator::visit_(type_identity<ram::IndexScan>, const ram::IndexScan& iScan) {
     orderingContext.addTupleWithIndexOrder(iScan.getTupleId(), iScan);
     SuperInstruction indexOperation = getIndexSuperInstInfo(iScan);
-    NodeType type = constructNodeType(global, "IndexScan", lookup(iScan.getRelation()));
+    NodeType type = constructNodeType("IndexScan", lookup(iScan.getRelation()));
     return mk<IndexScan>(type, &iScan, nullptr, visit_(type_identity<ram::TupleOperation>(), iScan),
             encodeView(&iScan), std::move(indexOperation));
 }
@@ -312,7 +285,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::ParallelIndexScan>, const ram::
     SuperInstruction indexOperation = getIndexSuperInstInfo(piscan);
     std::size_t relId = encodeRelation(piscan.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "ParallelIndexScan", lookup(piscan.getRelation()));
+    NodeType type = constructNodeType("ParallelIndexScan", lookup(piscan.getRelation()));
     auto res = mk<ParallelIndexScan>(type, &piscan, rel, visit_(type_identity<ram::TupleOperation>(), piscan),
             encodeIndexPos(piscan), std::move(indexOperation));
     res->setViewContext(parentQueryViewContext);
@@ -323,7 +296,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::IfExists>, const ram::IfExists&
     orderingContext.addTupleWithDefaultOrder(ifexists.getTupleId(), ifexists);
     std::size_t relId = encodeRelation(ifexists.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "IfExists", lookup(ifexists.getRelation()));
+    NodeType type = constructNodeType("IfExists", lookup(ifexists.getRelation()));
     return mk<IfExists>(type, &ifexists, rel, dispatch(ifexists.getCondition()),
             visit_(type_identity<ram::TupleOperation>(), ifexists));
 }
@@ -332,7 +305,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::ParallelIfExists>, const ram::P
     orderingContext.addTupleWithDefaultOrder(pIfExists.getTupleId(), pIfExists);
     std::size_t relId = encodeRelation(pIfExists.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "ParallelIfExists", lookup(pIfExists.getRelation()));
+    NodeType type = constructNodeType("ParallelIfExists", lookup(pIfExists.getRelation()));
     auto res = mk<ParallelIfExists>(type, &pIfExists, rel, dispatch(pIfExists.getCondition()),
             visit_(type_identity<ram::TupleOperation>(), pIfExists));
     res->setViewContext(parentQueryViewContext);
@@ -342,7 +315,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::ParallelIfExists>, const ram::P
 NodePtr NodeGenerator::visit_(type_identity<ram::IndexIfExists>, const ram::IndexIfExists& iIfExists) {
     orderingContext.addTupleWithIndexOrder(iIfExists.getTupleId(), iIfExists);
     SuperInstruction indexOperation = getIndexSuperInstInfo(iIfExists);
-    NodeType type = constructNodeType(global, "IndexIfExists", lookup(iIfExists.getRelation()));
+    NodeType type = constructNodeType("IndexIfExists", lookup(iIfExists.getRelation()));
     return mk<IndexIfExists>(type, &iIfExists, nullptr, dispatch(iIfExists.getCondition()),
             visit_(type_identity<ram::TupleOperation>(), iIfExists), encodeView(&iIfExists),
             std::move(indexOperation));
@@ -354,7 +327,7 @@ NodePtr NodeGenerator::visit_(
     SuperInstruction indexOperation = getIndexSuperInstInfo(piIfExists);
     std::size_t relId = encodeRelation(piIfExists.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "ParallelIndexIfExists", lookup(piIfExists.getRelation()));
+    NodeType type = constructNodeType("ParallelIndexIfExists", lookup(piIfExists.getRelation()));
     auto res = mk<ParallelIndexIfExists>(type, &piIfExists, rel, dispatch(piIfExists.getCondition()),
             dispatch(piIfExists.getOperation()), encodeIndexPos(piIfExists), std::move(indexOperation));
     res->setViewContext(parentQueryViewContext);
@@ -368,65 +341,33 @@ NodePtr NodeGenerator::visit_(
             visit_(type_identity<ram::TupleOperation>(), unpack));
 }
 
-NodePtr NodeGenerator::mkInit(const ram::AbstractAggregate& aggregate) {
-    const ram::Aggregator& aggregator = aggregate.getAggregator();
-    if (const auto* uda = as<ram::UserDefinedAggregator>(aggregator)) {
-        return dispatch(*uda->getInitValue());
-    } else {
-        return nullptr;
-    }
-};
-
-void* NodeGenerator::resolveFunctionPointers(const ram::AbstractAggregate& aggregate) {
-    const ram::Aggregator& aggregator = aggregate.getAggregator();
-    if (const auto* uda = as<ram::UserDefinedAggregator>(aggregator)) {
-        void* functionPtr = engine.getMethodHandle(uda->getName());
-        if (functionPtr == nullptr) {
-            fatal("cannot find user-defined operator `%s`", uda->getName());
-        }
-        return functionPtr;
-    } else {
-        // Intrinsic aggregates do not need function pointers.
-        return nullptr;
-    }
-}
-
 NodePtr NodeGenerator::visit_(type_identity<ram::Aggregate>, const ram::Aggregate& aggregate) {
     // Notice: Aggregate is sensitive to the visiting order of the subexprs in order to make
     // orderCtxt consistent. The order of visiting should be the same as the order of execution during
     // runtime.
     orderingContext.addTupleWithDefaultOrder(aggregate.getTupleId(), aggregate);
-    NodePtr init = mkInit(aggregate);
     NodePtr expr = dispatch(aggregate.getExpression());
     NodePtr cond = dispatch(aggregate.getCondition());
     orderingContext.addNewTuple(aggregate.getTupleId(), 1);
     NodePtr nested = visit_(type_identity<ram::TupleOperation>(), aggregate);
     std::size_t relId = encodeRelation(aggregate.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "Aggregate", lookup(aggregate.getRelation()));
-
-    /* Resolve functor to actual function pointer now */
-    void* functionPtr = resolveFunctionPointers(aggregate);
-
-    return mk<Aggregate>(type, &aggregate, rel, std::move(expr), std::move(cond), std::move(nested),
-            std::move(init), functionPtr);
+    NodeType type = constructNodeType("Aggregate", lookup(aggregate.getRelation()));
+    return mk<Aggregate>(type, &aggregate, rel, std::move(expr), std::move(cond), std::move(nested));
 }
 
 NodePtr NodeGenerator::visit_(
         type_identity<ram::ParallelAggregate>, const ram::ParallelAggregate& pAggregate) {
     orderingContext.addTupleWithDefaultOrder(pAggregate.getTupleId(), pAggregate);
-    NodePtr init = mkInit(pAggregate);
     NodePtr expr = dispatch(pAggregate.getExpression());
     NodePtr cond = dispatch(pAggregate.getCondition());
     orderingContext.addNewTuple(pAggregate.getTupleId(), 1);
     NodePtr nested = visit_(type_identity<ram::TupleOperation>(), pAggregate);
     std::size_t relId = encodeRelation(pAggregate.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "ParallelAggregate", lookup(pAggregate.getRelation()));
-    /* Resolve functor to actual function pointer now */
-    void* functionPtr = resolveFunctionPointers(pAggregate);
-    auto res = mk<ParallelAggregate>(type, &pAggregate, rel, std::move(expr), std::move(cond),
-            std::move(nested), std::move(init), functionPtr);
+    NodeType type = constructNodeType("ParallelAggregate", lookup(pAggregate.getRelation()));
+    auto res = mk<ParallelAggregate>(
+            type, &pAggregate, rel, std::move(expr), std::move(cond), std::move(nested));
     res->setViewContext(parentQueryViewContext);
 
     return res;
@@ -435,37 +376,30 @@ NodePtr NodeGenerator::visit_(
 NodePtr NodeGenerator::visit_(type_identity<ram::IndexAggregate>, const ram::IndexAggregate& iAggregate) {
     orderingContext.addTupleWithIndexOrder(iAggregate.getTupleId(), iAggregate);
     SuperInstruction indexOperation = getIndexSuperInstInfo(iAggregate);
-    NodePtr init = mkInit(iAggregate);
     NodePtr expr = dispatch(iAggregate.getExpression());
     NodePtr cond = dispatch(iAggregate.getCondition());
     orderingContext.addNewTuple(iAggregate.getTupleId(), 1);
     NodePtr nested = visit_(type_identity<ram::TupleOperation>(), iAggregate);
     std::size_t relId = encodeRelation(iAggregate.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "IndexAggregate", lookup(iAggregate.getRelation()));
-    /* Resolve functor to actual function pointer now */
-    void* functionPtr = resolveFunctionPointers(iAggregate);
+    NodeType type = constructNodeType("IndexAggregate", lookup(iAggregate.getRelation()));
     return mk<IndexAggregate>(type, &iAggregate, rel, std::move(expr), std::move(cond), std::move(nested),
-            std::move(init), functionPtr, encodeView(&iAggregate), std::move(indexOperation));
+            encodeView(&iAggregate), std::move(indexOperation));
 }
 
 NodePtr NodeGenerator::visit_(
         type_identity<ram::ParallelIndexAggregate>, const ram::ParallelIndexAggregate& piAggregate) {
     orderingContext.addTupleWithIndexOrder(piAggregate.getTupleId(), piAggregate);
     SuperInstruction indexOperation = getIndexSuperInstInfo(piAggregate);
-    NodePtr init = mkInit(piAggregate);
     NodePtr expr = dispatch(piAggregate.getExpression());
     NodePtr cond = dispatch(piAggregate.getCondition());
     orderingContext.addNewTuple(piAggregate.getTupleId(), 1);
     NodePtr nested = visit_(type_identity<ram::TupleOperation>(), piAggregate);
     std::size_t relId = encodeRelation(piAggregate.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "ParallelIndexAggregate", lookup(piAggregate.getRelation()));
-    /* Resolve functor to actual function pointer now */
-    void* functionPtr = resolveFunctionPointers(piAggregate);
+    NodeType type = constructNodeType("ParallelIndexAggregate", lookup(piAggregate.getRelation()));
     auto res = mk<ParallelIndexAggregate>(type, &piAggregate, rel, std::move(expr), std::move(cond),
-            std::move(nested), std::move(init), functionPtr, encodeView(&piAggregate),
-            std::move(indexOperation));
+            std::move(nested), encodeView(&piAggregate), std::move(indexOperation));
     res->setViewContext(parentQueryViewContext);
     return res;
 }
@@ -482,7 +416,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::GuardedInsert>, const ram::Guar
     SuperInstruction superOp = getInsertSuperInstInfo(guardedInsert);
     std::size_t relId = encodeRelation(guardedInsert.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "GuardedInsert", lookup(guardedInsert.getRelation()));
+    NodeType type = constructNodeType("GuardedInsert", lookup(guardedInsert.getRelation()));
     auto condition = guardedInsert.getCondition();
     return mk<GuardedInsert>(type, &guardedInsert, rel, std::move(superOp), dispatch(*condition));
 }
@@ -491,7 +425,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::Insert>, const ram::Insert& ins
     SuperInstruction superOp = getInsertSuperInstInfo(insert);
     std::size_t relId = encodeRelation(insert.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "Insert", lookup(insert.getRelation()));
+    NodeType type = constructNodeType("Insert", lookup(insert.getRelation()));
     return mk<Insert>(type, &insert, rel, std::move(superOp));
 }
 
@@ -499,7 +433,7 @@ NodePtr NodeGenerator::visit_(type_identity<ram::Erase>, const ram::Erase& erase
     SuperInstruction superOp = getEraseSuperInstInfo(erase);
     std::size_t relId = encodeRelation(erase.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "Erase", lookup(erase.getRelation()));
+    NodeType type = constructNodeType("Erase", lookup(erase.getRelation()));
     return mk<Erase>(type, &erase, rel, std::move(superOp));
 }
 
@@ -542,7 +476,9 @@ NodePtr NodeGenerator::visit_(type_identity<ram::Call>, const ram::Call& call) {
     // in the interpreter. The index is stored in the
     // data array of the Node as the first
     // entry.
-    return mk<Call>(I_Call, &call, call.getName());
+    auto subs = engine.tUnit.getProgram().getSubroutines();
+    std::size_t subroutineId = distance(subs.begin(), subs.find(call.getName()));
+    return mk<Call>(I_Call, &call, subroutineId);
 }
 
 NodePtr NodeGenerator::visit_(type_identity<ram::LogRelationTimer>, const ram::LogRelationTimer& timer) {
@@ -562,15 +498,15 @@ NodePtr NodeGenerator::visit_(type_identity<ram::DebugInfo>, const ram::DebugInf
 NodePtr NodeGenerator::visit_(type_identity<ram::Clear>, const ram::Clear& clear) {
     std::size_t relId = encodeRelation(clear.getRelation());
     auto rel = getRelationHandle(relId);
-    return mk<Clear>(I_Clear, &clear, rel);
+    NodeType type = constructNodeType("Clear", lookup(clear.getRelation()));
+    return mk<Clear>(type, &clear, rel);
 }
 
-NodePtr NodeGenerator::visit_(
-        type_identity<ram::EstimateJoinSize>, const ram::EstimateJoinSize& estimateJoinSize) {
-    std::size_t relId = encodeRelation(estimateJoinSize.getRelation());
+NodePtr NodeGenerator::visit_(type_identity<ram::CountUniqueKeys>, const ram::CountUniqueKeys& count) {
+    std::size_t relId = encodeRelation(count.getRelation());
     auto rel = getRelationHandle(relId);
-    NodeType type = constructNodeType(global, "EstimateJoinSize", lookup(estimateJoinSize.getRelation()));
-    return mk<EstimateJoinSize>(type, &estimateJoinSize, rel, encodeIndexPos(estimateJoinSize));
+    NodeType type = constructNodeType("CountUniqueKeys", lookup(count.getRelation()));
+    return mk<CountUniqueKeys>(type, &count, rel, encodeIndexPos(count));
 }
 
 NodePtr NodeGenerator::visit_(type_identity<ram::LogSize>, const ram::LogSize& size) {
@@ -644,10 +580,6 @@ NodePtr NodeGenerator::visit_(type_identity<ram::Swap>, const ram::Swap& swap) {
     return mk<Swap>(I_Swap, &swap, src, target);
 }
 
-NodePtr NodeGenerator::visit_(type_identity<ram::Assign>, const ram::Assign& assign) {
-    return mk<Assign>(I_Assign, &assign, dispatch(assign.getVariable()), dispatch(assign.getValue()));
-}
-
 NodePtr NodeGenerator::visit_(type_identity<ram::UndefValue>, const ram::UndefValue&) {
     return nullptr;
 }
diff --git a/src/interpreter/Generator.h b/src/interpreter/Generator.h
index 731d645..9850629 100644
--- a/src/interpreter/Generator.h
+++ b/src/interpreter/Generator.h
@@ -32,9 +32,9 @@
 #include "ram/Condition.h"
 #include "ram/Conjunction.h"
 #include "ram/Constraint.h"
+#include "ram/CountUniqueKeys.h"
 #include "ram/DebugInfo.h"
 #include "ram/EmptinessCheck.h"
-#include "ram/EstimateJoinSize.h"
 #include "ram/ExistenceCheck.h"
 #include "ram/Exit.h"
 #include "ram/Expression.h"
@@ -128,8 +128,6 @@ public:
 
     NodePtr visit_(type_identity<ram::NumericConstant>, const ram::NumericConstant& num) override;
 
-    NodePtr visit_(type_identity<ram::Variable>, const ram::Variable& var) override;
-
     NodePtr visit_(type_identity<ram::StringConstant>, const ram::StringConstant& num) override;
 
     NodePtr visit_(type_identity<ram::TupleElement>, const ram::TupleElement& access) override;
@@ -228,8 +226,7 @@ public:
 
     NodePtr visit_(type_identity<ram::Clear>, const ram::Clear& clear) override;
 
-    NodePtr visit_(
-            type_identity<ram::EstimateJoinSize>, const ram::EstimateJoinSize& estimateJoinSize) override;
+    NodePtr visit_(type_identity<ram::CountUniqueKeys>, const ram::CountUniqueKeys& count) override;
 
     NodePtr visit_(type_identity<ram::LogSize>, const ram::LogSize& size) override;
 
@@ -241,8 +238,6 @@ public:
 
     NodePtr visit_(type_identity<ram::Swap>, const ram::Swap& swap) override;
 
-    NodePtr visit_(type_identity<ram::Assign>, const ram::Assign& assign) override;
-
     NodePtr visit_(type_identity<ram::UndefValue>, const ram::UndefValue&) override;
 
     NodePtr visit_(type_identity<ram::Node>, const ram::Node& node) override;
@@ -347,9 +342,6 @@ private:
     SuperInstruction getInsertSuperInstInfo(const ram::Insert& exist);
     SuperInstruction getEraseSuperInstInfo(const ram::Erase& exist);
 
-    NodePtr mkInit(const ram::AbstractAggregate& aggregate);
-    void* resolveFunctionPointers(const ram::AbstractAggregate& aggregate);
-
     /** Environment encoding, store a mapping from ram::Node to its operation index id. */
     std::unordered_map<const ram::Node*, std::size_t> indexTable;
     /** Points to the current viewContext during the generation.
@@ -370,7 +362,5 @@ private:
     OrderingContext orderingContext = OrderingContext(*this);
     /** Reference to the engine instance */
     Engine& engine;
-    /** Reference to global */
-    Global& global;
 };
 }  // namespace souffle::interpreter
diff --git a/src/interpreter/Index.h b/src/interpreter/Index.h
index 734a9e4..3fc693d 100644
--- a/src/interpreter/Index.h
+++ b/src/interpreter/Index.h
@@ -142,13 +142,11 @@ struct ViewWrapper {
 /**
  * An index is an abstraction of a data structure
  */
-template <std::size_t _Arity, std::size_t _AuxiliaryArity,
-        template <std::size_t, std::size_t> typename Structure>
+template <std::size_t _Arity, template <std::size_t> typename Structure>
 class Index {
 public:
     static constexpr std::size_t Arity = _Arity;
-    static constexpr std::size_t AuxiliaryArity = _AuxiliaryArity;
-    using Data = Structure<Arity, AuxiliaryArity>;
+    using Data = Structure<Arity>;
     using Tuple = typename souffle::Tuple<RamDomain, Arity>;
     using iterator = typename Data::iterator;
     using Hints = typename Data::operation_hints;
@@ -241,7 +239,7 @@ public:
     /**
      * Inserts all elements of the given index.
      */
-    void insert(const Index<Arity, AuxiliaryArity, Structure>& src) {
+    void insert(const Index<Arity, Structure>& src) {
         for (const auto& tuple : src) {
             this->insert(tuple);
         }
@@ -312,18 +310,14 @@ public:
     void clear() {
         data.clear();
     }
-
-    void printStats(std::ostream& o) const {
-        data.printStats(o);
-    }
 };
 
 /**
  * A partial specialize template for nullary indexes.
  * No complex data structure is required.
  */
-template <template <std::size_t, std::size_t> typename Structure>
-class Index<0, 0, Structure> {
+template <template <std::size_t> typename Structure>
+class Index<0, Structure> {
 public:
     static constexpr std::size_t Arity = 0;
     using Tuple = typename souffle::Tuple<RamDomain, 0>;
@@ -453,16 +447,14 @@ public:
     void clear() {
         data = false;
     }
-
-    void printStats(std::ostream&) const {}
 };
 
 /**
  * For EqrelIndex we do inheritence since EqrelIndex only diff with one extra function.
  */
-class EqrelIndex : public interpreter::Index<2, 0, Eqrel> {
+class EqrelIndex : public interpreter::Index<2, Eqrel> {
 public:
-    using Index<2, 0, Eqrel>::Index;
+    using Index<2, Eqrel>::Index;
 
     /**
      * Extend this relation with another index, expanding this index and
@@ -483,12 +475,12 @@ public:
 /**
  * A BtreeDelete index
  */
-template <std::size_t _Arity, std::size_t _AuxiliaryArity>
-class BtreeDeleteIndex : public interpreter::Index<_Arity, _AuxiliaryArity, BtreeDelete> {
+template <std::size_t _Arity>
+class BtreeDeleteIndex : public interpreter::Index<_Arity, BtreeDelete> {
 public:
-    using Index<_Arity, _AuxiliaryArity, BtreeDelete>::Index;
-    using Index<_Arity, _AuxiliaryArity, BtreeDelete>::data;
-    using Index<_Arity, _AuxiliaryArity, BtreeDelete>::order;
+    using Index<_Arity, BtreeDelete>::Index;
+    using Index<_Arity, BtreeDelete>::data;
+    using Index<_Arity, BtreeDelete>::order;
     using Tuple = typename souffle::Tuple<RamDomain, _Arity>;
 
     /**
diff --git a/src/interpreter/Node.h b/src/interpreter/Node.h
index 6150344..6604418 100644
--- a/src/interpreter/Node.h
+++ b/src/interpreter/Node.h
@@ -37,7 +37,6 @@
 #include <cassert>
 #include <cstddef>
 #include <memory>
-#include <regex>
 #include <string>
 #include <unordered_map>
 #include <utility>
@@ -54,13 +53,12 @@ struct RelationWrapper;
 
 // clang-format off
 
-/* This macro defines all the interpreterNode token.
- * For common operation, pass to Forward.
+/* This macro defines all the interpreterNode token. 
+ * For common operation, pass to Forward. 
  * For specialized operation, pass to FOR_EACH(Expand, tok)
  */
 #define FOR_EACH_INTERPRETER_TOKEN(Forward, Expand)\
     Forward(NumericConstant)\
-    Forward(Variable)\
     Forward(StringConstant)\
     Forward(TupleElement)\
     Forward(AutoIncrement)\
@@ -101,13 +99,12 @@ struct RelationWrapper;
     Forward(Sequence)\
     Forward(Parallel)\
     Forward(Loop)\
-    Forward(Assign)\
     Forward(Exit)\
     Forward(LogRelationTimer)\
     Forward(LogTimer)\
     Forward(DebugInfo)\
-    Forward(Clear)\
-    FOR_EACH(Expand, EstimateJoinSize)\
+    FOR_EACH(Expand, Clear)\
+    FOR_EACH(Expand, CountUniqueKeys)\
     Forward(LogSize)\
     Forward(IO)\
     Forward(Query)\
@@ -117,10 +114,10 @@ struct RelationWrapper;
 
 #define SINGLE_TOKEN(tok) I_##tok,
 
-#define EXPAND_TOKEN(structure, arity, auxiliaryArity, tok)\
-    I_##tok##_##structure##_##arity##_##auxiliaryArity,
+#define EXPAND_TOKEN(structure, arity, tok)\
+    I_##tok##_##structure##_##arity,
 
-/*
+/* 
  * Declares all the tokens.
  * For Forward token OP, creates I_OP
  * For Extended token OP, generate I_OP_Structure_Arity for each data structure and supported arity.
@@ -134,31 +131,30 @@ enum NodeType {
 
 #define __TO_STRING(a) #a
 #define SINGLE_TOKEN_ENTRY(tok) {__TO_STRING(I_##tok), I_##tok},
-#define EXPAND_TOKEN_ENTRY(Structure, arity, auxiliaryArity, tok) \
-    {__TO_STRING(I_##tok##_##Structure##_##arity##_##auxiliaryArity), I_##tok##_##Structure##_##arity##_##auxiliaryArity},
+#define EXPAND_TOKEN_ENTRY(Structure, arity, tok) \
+    {__TO_STRING(I_##tok##_##Structure##_##arity), I_##tok##_##Structure##_##arity},
 
 /**
  * Construct interpreterNodeType by looking at the representation and the arity of the given rel.
  *
  * Add reflective from string to NodeType.
  */
-inline NodeType constructNodeType(Global&, std::string tokBase, const ram::Relation& rel) {
+inline NodeType constructNodeType(std::string tokBase, const ram::Relation& rel) {
+    static bool isProvenance = Global::config().has("provenance");
 
     static const std::unordered_map<std::string, NodeType> map = {
             FOR_EACH_INTERPRETER_TOKEN(SINGLE_TOKEN_ENTRY, EXPAND_TOKEN_ENTRY)
     };
 
     std::string arity = std::to_string(rel.getArity());
-    std::string auxiliaryArity = std::to_string(rel.getAuxiliaryArity());
-    bool hasProvenance = rel.getArity() > 0 && rel.getAttributeNames().back() == "@level_number";
-    if (hasProvenance) {
-        return map.at("I_" + tokBase + "_Provenance_" + arity + "_" + auxiliaryArity);
-    } else if (rel.getRepresentation() == RelationRepresentation::EQREL) {
-        return map.at("I_" + tokBase + "_Eqrel_" + arity + "_" + auxiliaryArity);
-    } else if(rel.getRepresentation() == RelationRepresentation::BTREE_DELETE) {
-        return map.at("I_" + tokBase + "_BtreeDelete_" + arity + "_" + auxiliaryArity);
+    if (rel.getRepresentation() == RelationRepresentation::EQREL) {
+        return map.at("I_" + tokBase + "_Eqrel_" + arity);
+    } else if(rel.getRepresentation() == RelationRepresentation::BTREE_DELETE) { 
+        return map.at("I_" + tokBase + "_BtreeDelete_" + arity);
+    } else if (isProvenance) {
+        return map.at("I_" + tokBase + "_Provenance_" + arity);
     } else  {
-        return map.at("I_" + tokBase + "_Btree_" + arity + "_" + auxiliaryArity);
+        return map.at("I_" + tokBase + "_Btree_" + arity);
     }
 
     fatal("Unrecognized node type: base:%s arity:%s.", tokBase, arity);
@@ -428,13 +424,6 @@ class NumericConstant : public Node {
     using Node::Node;
 };
 
-/**
- * @class Variable
- */
-class Variable : public Node {
-    using Node::Node;
-};
-
 /**
  * @class StringConstant
  */
@@ -450,22 +439,6 @@ private:
     std::size_t constant;
 };
 
-/**
- * @class RegexConstant
- */
-class RegexConstant : public StringConstant {
-public:
-    RegexConstant(const StringConstant& c, std::optional<std::regex> r)
-            : StringConstant(c.getType(), c.getShadow(), c.getConstant()), regex(std::move(r)) {}
-
-    inline const std::optional<std::regex>& getRegex() const {
-        return regex;
-    }
-
-private:
-    const std::optional<std::regex> regex;
-};
-
 /**
  * @class TupleElement
  */
@@ -501,9 +474,13 @@ class IntrinsicOperator : public CompoundNode {
     using CompoundNode::CompoundNode;
 };
 
-class FunctorNode {
+/**
+ * @class UserDefinedOperator
+ */
+class UserDefinedOperator : public CompoundNode {
 public:
-    FunctorNode(void* functionPointer) : functionPointer(functionPointer) {
+    UserDefinedOperator(NodeType ty, const ram::Node* sdw, VecOwn<Node> children, void* functionPointer)
+            : CompoundNode(ty, sdw, std::move(children)), functionPointer(functionPointer) {
 #ifdef USE_LIBFFI
         cif = mk<ffi_cif>();
 #endif
@@ -532,15 +509,6 @@ private:
 #endif
 };
 
-/**
- * @class UserDefinedOperator
- */
-class UserDefinedOperator : public CompoundNode, public FunctorNode {
-public:
-    UserDefinedOperator(NodeType ty, const ram::Node* sdw, VecOwn<Node> children, void* functionPointer)
-            : CompoundNode(ty, sdw, std::move(children)), FunctorNode(functionPointer) {}
-};
-
 /**
  * @class NestedIntrinsicOperator
  */
@@ -757,26 +725,19 @@ protected:
 class Aggregate : public Node,
                   public ConditionalOperation,
                   public NestedOperation,
-                  public RelationalOperation,
-                  public FunctorNode {
+                  public RelationalOperation {
 public:
     Aggregate(enum NodeType ty, const ram::Node* sdw, RelationHandle* relHandle, Own<Node> expr,
-            Own<Node> filter, Own<Node> nested, Own<Node> init, void*& functorPtr)
+            Own<Node> filter, Own<Node> nested)
             : Node(ty, sdw), ConditionalOperation(std::move(filter)), NestedOperation(std::move(nested)),
-              RelationalOperation(relHandle), FunctorNode(functorPtr), expr(std::move(expr)),
-              init(std::move(init)) {}
+              RelationalOperation(relHandle), expr(std::move(expr)) {}
 
     inline const Node* getExpr() const {
         return expr.get();
     }
 
-    inline const Node* getInit() const {
-        return init.get();
-    }
-
 protected:
     Own<Node> expr;
-    Own<Node> init;
 };
 
 /**
@@ -792,10 +753,8 @@ class ParallelAggregate : public Aggregate, public AbstractParallel {
 class IndexAggregate : public Aggregate, public SuperOperation, public ViewOperation {
 public:
     IndexAggregate(enum NodeType ty, const ram::Node* sdw, RelationHandle* relHandle, Own<Node> expr,
-            Own<Node> filter, Own<Node> nested, Own<Node> init, void*& functorPtr, std::size_t viewId,
-            SuperInstruction superInst)
-            : Aggregate(ty, sdw, relHandle, std::move(expr), std::move(filter), std::move(nested),
-                      std::move(init), functorPtr),
+            Own<Node> filter, Own<Node> nested, std::size_t viewId, SuperInstruction superInst)
+            : Aggregate(ty, sdw, relHandle, std::move(expr), std::move(filter), std::move(nested)),
               SuperOperation(std::move(superInst)), ViewOperation(viewId) {}
 };
 
@@ -866,13 +825,6 @@ class Sequence : public CompoundNode {
     using CompoundNode::CompoundNode;
 };
 
-/**
- * @class Assign
- */
-class Assign : public BinaryNode {
-    using BinaryNode::BinaryNode;
-};
-
 /**
  * @class Parallel
  */
@@ -927,11 +879,11 @@ public:
 };
 
 /**
- * @class EstimateJoinSize
+ * @class CountUniqueKeys
  */
-class EstimateJoinSize : public Node, public RelationalOperation, public ViewOperation {
+class CountUniqueKeys : public Node, public RelationalOperation, public ViewOperation {
 public:
-    EstimateJoinSize(enum NodeType ty, const ram::Node* sdw, RelationHandle* handle, std::size_t viewId)
+    CountUniqueKeys(enum NodeType ty, const ram::Node* sdw, RelationHandle* handle, std::size_t viewId)
             : Node(ty, sdw), RelationalOperation(handle), ViewOperation(viewId) {}
 };
 
@@ -940,15 +892,15 @@ public:
  */
 class Call : public Node {
 public:
-    Call(enum NodeType ty, const ram::Node* sdw, std::string subroutineName)
-            : Node(ty, sdw), subroutineName(subroutineName) {}
+    Call(enum NodeType ty, const ram::Node* sdw, std::size_t subroutineId)
+            : Node(ty, sdw), subroutineId(subroutineId) {}
 
-    const std::string& getSubroutineName() const {
-        return subroutineName;
+    std::size_t getSubroutineId() const {
+        return subroutineId;
     }
 
 private:
-    const std::string subroutineName;
+    const std::size_t subroutineId;
 };
 
 /**
diff --git a/src/interpreter/ProvenanceIndex.cpp b/src/interpreter/ProvenanceIndex.cpp
index 3b77071..b1711f7 100644
--- a/src/interpreter/ProvenanceIndex.cpp
+++ b/src/interpreter/ProvenanceIndex.cpp
@@ -18,15 +18,24 @@
 
 namespace souffle::interpreter {
 
-#define CREATE_PROVENANCE_REL(Structure, Arity, AuxiliaryArity, ...)                                       \
-    if (id.getArity() == Arity && id.getAuxiliaryArity() == AuxiliaryArity) {                              \
-        return mk<Relation<Arity, AuxiliaryArity, interpreter::Provenance>>(id.getName(), indexSelection); \
+#define CREATE_PROVENANCE_REL(Structure, Arity, ...)                   \
+    case (Arity): {                                                    \
+        return mk<Relation<Arity, interpreter::Provenance>>(           \
+                id.getAuxiliaryArity(), id.getName(), indexSelection); \
     }
 
 Own<RelationWrapper> createProvenanceRelation(
         const ram::Relation& id, const ram::analysis::IndexCluster& indexSelection) {
-    FOR_EACH_PROVENANCE(CREATE_PROVENANCE_REL);
-    fatal("Requested arity not yet supported. Feel free to add it.");
+    switch (id.getArity()) {
+        FOR_EACH_PROVENANCE(CREATE_PROVENANCE_REL);
+
+        default:
+            fatal((
+                "createProvenanceRelation: Requested arity " +
+                std::to_string(id.getArity()) +
+                " not yet supported. Feel free to add it."
+            ).c_str());
+    }
 }
 
 }  // namespace souffle::interpreter
diff --git a/src/interpreter/Relation.h b/src/interpreter/Relation.h
index 7c06ea9..8f0189b 100644
--- a/src/interpreter/Relation.h
+++ b/src/interpreter/Relation.h
@@ -125,8 +125,6 @@ public:
         return auxiliaryArity;
     }
 
-    virtual void printStats(std::ostream& o) const = 0;
-
     // -- Defines methods and interfaces for Interpreter execution. --
 public:
     using IndexViewPtr = Own<ViewWrapper>;
@@ -153,15 +151,13 @@ protected:
 /**
  * A relation, composed of a collection of indexes.
  */
-template <std::size_t _Arity, std::size_t _AuxiliaryArity,
-        template <std::size_t, std::size_t> typename Structure>
+template <std::size_t _Arity, template <std::size_t> typename Structure>
 class Relation : public RelationWrapper {
 public:
     static constexpr std::size_t Arity = _Arity;
-    static constexpr std::size_t AuxiliaryArity = _AuxiliaryArity;
     using Attribute = std::size_t;
     using AttributeSet = std::set<Attribute>;
-    using Index = interpreter::Index<Arity, AuxiliaryArity, Structure>;
+    using Index = interpreter::Index<Arity, Structure>;
     using Tuple = souffle::Tuple<RamDomain, Arity>;
     using View = typename Index::View;
     using iterator = typename Index::iterator;
@@ -185,8 +181,9 @@ public:
     /**
      * Creates a relation, build all necessary indexes.
      */
-    Relation(const std::string& name, const ram::analysis::IndexCluster& indexSelection)
-            : RelationWrapper(Arity, AuxiliaryArity, name) {
+    Relation(std::size_t auxiliaryArity, const std::string& name,
+            const ram::analysis::IndexCluster& indexSelection)
+            : RelationWrapper(Arity, auxiliaryArity, name) {
         for (const auto& order : indexSelection.getAllOrders()) {
             ram::analysis::LexOrder fullOrder = order;
             // Expand the order to a total order
@@ -302,7 +299,7 @@ public:
     /**
      * Add all entries of the given relation to this relation.
      */
-    void insert(const Relation<Arity, AuxiliaryArity, Structure>& other) {
+    void insert(const Relation<Arity, Structure>& other) {
         for (const auto& tuple : other.scan()) {
             this->insert(tuple);
         }
@@ -357,7 +354,7 @@ public:
      * Swaps the content of this and the given relation, including the
      * installed indexes.
      */
-    void swap(Relation<Arity, AuxiliaryArity, Structure>& other) {
+    void swap(Relation<Arity, Structure>& other) {
         indexes.swap(other.indexes);
     }
 
@@ -395,14 +392,10 @@ public:
         return indexes.at(idx).get();
     }
 
-    void printStats(std::ostream& o) const override {
-        for (std::size_t i = 0; i < indexes.size(); ++i) {
-            o << "Index " << i << ":\n";
-            indexes[i]->printStats(o);
-        }
-    }
-
 protected:
+    // Number of height parameters of relation
+    std::size_t auxiliaryArity;
+
     // a map of managed indexes
     VecOwn<Index> indexes;
 
@@ -410,19 +403,19 @@ protected:
     Index* main;
 };
 
-template <std::size_t _Arity, std::size_t _AuxiliaryArity>
-class BtreeDeleteRelation : public Relation<_Arity, _AuxiliaryArity, BtreeDelete> {
+template <std::size_t _Arity>
+class BtreeDeleteRelation : public Relation<_Arity, BtreeDelete> {
 public:
-    using Relation<_Arity, _AuxiliaryArity, BtreeDelete>::Relation;
-    using Relation<_Arity, _AuxiliaryArity, BtreeDelete>::main;
-    using Relation<_Arity, _AuxiliaryArity, BtreeDelete>::indexes;
+    using Relation<_Arity, BtreeDelete>::Relation;
+    using Relation<_Arity, BtreeDelete>::main;
+    using Relation<_Arity, BtreeDelete>::indexes;
     using Tuple = souffle::Tuple<RamDomain, _Arity>;
 
     /**
      * Erase the given tuple from this relation.
      */
     bool erase(const Tuple& tuple) {
-        using DeleteIndex = BtreeDeleteIndex<_Arity, _AuxiliaryArity>;
+        using DeleteIndex = BtreeDeleteIndex<_Arity>;
         if (!(static_cast<DeleteIndex*>(main))->erase(tuple)) {
             return false;
         }
@@ -433,9 +426,9 @@ public:
     }
 };
 
-class EqrelRelation : public Relation<2, 0, Eqrel> {
+class EqrelRelation : public Relation<2, Eqrel> {
 public:
-    using Relation<2, 0, Eqrel>::Relation;
+    using Relation<2, Eqrel>::Relation;
 
     void extendAndInsert(const EqrelRelation& rel) {
         auto src = static_cast<EqrelIndex*>(this->main);
diff --git a/src/interpreter/Util.h b/src/interpreter/Util.h
index 60ea5e6..adaebe9 100644
--- a/src/interpreter/Util.h
+++ b/src/interpreter/Util.h
@@ -27,91 +27,132 @@
 namespace souffle::interpreter {
 // clang-format off
 
-
 #define FOR_EACH_PROVENANCE(func, ...) \
-    func(Provenance, 2, 2, __VA_ARGS__)   \
-    func(Provenance, 3, 2, __VA_ARGS__)   \
-    func(Provenance, 4, 2, __VA_ARGS__)   \
-    func(Provenance, 5, 2, __VA_ARGS__)   \
-    func(Provenance, 6, 2, __VA_ARGS__)   \
-    func(Provenance, 7, 2, __VA_ARGS__)   \
-    func(Provenance, 8, 2, __VA_ARGS__)   \
-    func(Provenance, 9, 2, __VA_ARGS__)   \
-    func(Provenance, 10, 2, __VA_ARGS__)  \
-    func(Provenance, 11, 2, __VA_ARGS__)  \
-    func(Provenance, 12, 2, __VA_ARGS__)  \
-    func(Provenance, 13, 2, __VA_ARGS__)  \
-    func(Provenance, 14, 2, __VA_ARGS__)  \
-    func(Provenance, 15, 2, __VA_ARGS__)  \
-    func(Provenance, 16, 2, __VA_ARGS__)  \
-    func(Provenance, 17, 2, __VA_ARGS__)  \
-    func(Provenance, 18, 2, __VA_ARGS__)  \
-    func(Provenance, 19, 2, __VA_ARGS__)  \
-    func(Provenance, 20, 2, __VA_ARGS__)  \
-    func(Provenance, 21, 2, __VA_ARGS__)  \
-    func(Provenance, 22, 2, __VA_ARGS__)
+    func(Provenance, 2, __VA_ARGS__)   \
+    func(Provenance, 3, __VA_ARGS__)   \
+    func(Provenance, 4, __VA_ARGS__)   \
+    func(Provenance, 5, __VA_ARGS__)   \
+    func(Provenance, 6, __VA_ARGS__)   \
+    func(Provenance, 7, __VA_ARGS__)   \
+    func(Provenance, 8, __VA_ARGS__)   \
+    func(Provenance, 9, __VA_ARGS__)   \
+    func(Provenance, 10, __VA_ARGS__)  \
+    func(Provenance, 11, __VA_ARGS__)  \
+    func(Provenance, 12, __VA_ARGS__)  \
+    func(Provenance, 13, __VA_ARGS__)  \
+    func(Provenance, 14, __VA_ARGS__)  \
+    func(Provenance, 15, __VA_ARGS__)  \
+    func(Provenance, 16, __VA_ARGS__)  \
+    func(Provenance, 17, __VA_ARGS__)  \
+    func(Provenance, 18, __VA_ARGS__)  \
+    func(Provenance, 19, __VA_ARGS__)  \
+    func(Provenance, 20, __VA_ARGS__)  \
+    func(Provenance, 21, __VA_ARGS__)  \
+    func(Provenance, 22, __VA_ARGS__)  \
+    func(Provenance, 23, __VA_ARGS__)  \
+    func(Provenance, 24, __VA_ARGS__)  \
+    func(Provenance, 25, __VA_ARGS__)  \
+    func(Provenance, 26, __VA_ARGS__)  \
+    func(Provenance, 27, __VA_ARGS__)  \
+    func(Provenance, 28, __VA_ARGS__)  \
+    func(Provenance, 29, __VA_ARGS__)  \
+    func(Provenance, 30, __VA_ARGS__)
+
 
 #define FOR_EACH_BTREE(func, ...)\
-    func(Btree, 0, 0, __VA_ARGS__) \
-    func(Btree, 1, 0, __VA_ARGS__) \
-    func(Btree, 2, 0, __VA_ARGS__) \
-    func(Btree, 3, 0, __VA_ARGS__) \
-    func(Btree, 4, 0, __VA_ARGS__) \
-    func(Btree, 5, 0, __VA_ARGS__) \
-    func(Btree, 6, 0, __VA_ARGS__) \
-    func(Btree, 7, 0, __VA_ARGS__) \
-    func(Btree, 8, 0, __VA_ARGS__) \
-    func(Btree, 9, 0, __VA_ARGS__) \
-    func(Btree, 10, 0, __VA_ARGS__) \
-    func(Btree, 11, 0, __VA_ARGS__) \
-    func(Btree, 12, 0, __VA_ARGS__) \
-    func(Btree, 13, 0, __VA_ARGS__) \
-    func(Btree, 14, 0, __VA_ARGS__) \
-    func(Btree, 15, 0, __VA_ARGS__) \
-    func(Btree, 16, 0, __VA_ARGS__) \
-    func(Btree, 17, 0, __VA_ARGS__) \
-    func(Btree, 18, 0, __VA_ARGS__) \
-    func(Btree, 19, 0, __VA_ARGS__) \
-    func(Btree, 20, 0, __VA_ARGS__) \
-    func(Btree, 1, 1, __VA_ARGS__)  \
-    func(Btree, 2, 1, __VA_ARGS__)  \
-    func(Btree, 2, 2, __VA_ARGS__)  \
-    func(Btree, 3, 1, __VA_ARGS__)  \
-    func(Btree, 3, 2, __VA_ARGS__)  \
-    func(Btree, 4, 1, __VA_ARGS__)  \
-    func(Btree, 4, 2, __VA_ARGS__)  \
-    func(Btree, 5, 1, __VA_ARGS__)  \
-    func(Btree, 5, 2, __VA_ARGS__)  \
-    func(Btree, 6, 1, __VA_ARGS__)  \
-    func(Btree, 6, 2, __VA_ARGS__)  \
-    func(Btree, 7, 1, __VA_ARGS__)  \
-    func(Btree, 7, 2, __VA_ARGS__)  \
-    func(Btree, 8, 1, __VA_ARGS__)  \
-    func(Btree, 8, 2, __VA_ARGS__)  \
-    func(Btree, 9, 1, __VA_ARGS__)  \
-    func(Btree, 9, 2, __VA_ARGS__)
+    func(Btree, 0, __VA_ARGS__) \
+    func(Btree, 1, __VA_ARGS__) \
+    func(Btree, 2, __VA_ARGS__) \
+    func(Btree, 3, __VA_ARGS__) \
+    func(Btree, 4, __VA_ARGS__) \
+    func(Btree, 5, __VA_ARGS__) \
+    func(Btree, 6, __VA_ARGS__) \
+    func(Btree, 7, __VA_ARGS__) \
+    func(Btree, 8, __VA_ARGS__) \
+    func(Btree, 9, __VA_ARGS__) \
+    func(Btree, 10, __VA_ARGS__) \
+    func(Btree, 11, __VA_ARGS__) \
+    func(Btree, 12, __VA_ARGS__) \
+    func(Btree, 13, __VA_ARGS__) \
+    func(Btree, 14, __VA_ARGS__) \
+    func(Btree, 15, __VA_ARGS__) \
+    func(Btree, 16, __VA_ARGS__) \
+    func(Btree, 17, __VA_ARGS__) \
+    func(Btree, 18, __VA_ARGS__) \
+    func(Btree, 19, __VA_ARGS__) \
+    func(Btree, 20, __VA_ARGS__) \
+    func(Btree, 21, __VA_ARGS__) \
+    func(Btree, 22, __VA_ARGS__) \
+    func(Btree, 23, __VA_ARGS__) \
+    func(Btree, 24, __VA_ARGS__) \
+    func(Btree, 25, __VA_ARGS__) \
+    func(Btree, 26, __VA_ARGS__) \
+    func(Btree, 27, __VA_ARGS__) \
+    func(Btree, 28, __VA_ARGS__) \
+    func(Btree, 29, __VA_ARGS__) \
+    func(Btree, 30, __VA_ARGS__) \
+    func(Btree, 31, __VA_ARGS__) \
+    func(Btree, 32, __VA_ARGS__) \
+    func(Btree, 33, __VA_ARGS__) \
+    func(Btree, 34, __VA_ARGS__) \
+    func(Btree, 35, __VA_ARGS__) \
+    func(Btree, 36, __VA_ARGS__) \
+    func(Btree, 37, __VA_ARGS__) \
+    func(Btree, 38, __VA_ARGS__) \
+    func(Btree, 39, __VA_ARGS__) \
+    func(Btree, 40, __VA_ARGS__) \
+    func(Btree, 41, __VA_ARGS__) \
+    func(Btree, 42, __VA_ARGS__) \
+    func(Btree, 43, __VA_ARGS__) \
+    func(Btree, 44, __VA_ARGS__) \
+    func(Btree, 45, __VA_ARGS__) \
+    func(Btree, 46, __VA_ARGS__) \
+    func(Btree, 47, __VA_ARGS__) \
+    func(Btree, 48, __VA_ARGS__) \
+    func(Btree, 49, __VA_ARGS__) \
+    func(Btree, 50, __VA_ARGS__) \
+    func(Btree, 51, __VA_ARGS__) \
+    func(Btree, 52, __VA_ARGS__) \
+    func(Btree, 53, __VA_ARGS__) \
+    func(Btree, 54, __VA_ARGS__) \
+    func(Btree, 55, __VA_ARGS__) \
+    func(Btree, 56, __VA_ARGS__) \
+    func(Btree, 57, __VA_ARGS__) \
+    func(Btree, 58, __VA_ARGS__) \
+    func(Btree, 59, __VA_ARGS__) \
+    func(Btree, 60, __VA_ARGS__) \
+    func(Btree, 61, __VA_ARGS__) \
+    func(Btree, 62, __VA_ARGS__) \
+    func(Btree, 63, __VA_ARGS__) \
+    func(Btree, 64, __VA_ARGS__) \
+    func(Btree, 65, __VA_ARGS__) \
+    func(Btree, 66, __VA_ARGS__) \
+    func(Btree, 67, __VA_ARGS__) \
+    func(Btree, 68, __VA_ARGS__) \
+    func(Btree, 69, __VA_ARGS__) \
+    func(Btree, 70, __VA_ARGS__)
 
 #define FOR_EACH_BTREE_DELETE(func, ...)\
-    func(BtreeDelete, 1, 0, __VA_ARGS__) \
-    func(BtreeDelete, 2, 0, __VA_ARGS__) \
-    func(BtreeDelete, 3, 0, __VA_ARGS__) \
-    func(BtreeDelete, 4, 0, __VA_ARGS__) \
-    func(BtreeDelete, 5, 0, __VA_ARGS__) \
-    func(BtreeDelete, 6, 0, __VA_ARGS__) \
-    func(BtreeDelete, 7, 0, __VA_ARGS__) \
-    func(BtreeDelete, 8, 0, __VA_ARGS__) \
-    func(BtreeDelete, 9, 0, __VA_ARGS__) \
-    func(BtreeDelete, 10, 0, __VA_ARGS__) \
-    func(BtreeDelete, 11, 0, __VA_ARGS__) \
-    func(BtreeDelete, 12, 0, __VA_ARGS__) \
-    func(BtreeDelete, 13, 0, __VA_ARGS__) \
-    func(BtreeDelete, 14, 0, __VA_ARGS__) \
-    func(BtreeDelete, 15, 0, __VA_ARGS__) \
-    func(BtreeDelete, 16, 0, __VA_ARGS__) \
-    func(BtreeDelete, 17, 0, __VA_ARGS__) \
-    func(BtreeDelete, 18, 0, __VA_ARGS__) \
-    func(BtreeDelete, 19, 0, __VA_ARGS__) \
-    func(BtreeDelete, 20, 0, __VA_ARGS__)
+    func(BtreeDelete, 1, __VA_ARGS__) \
+    func(BtreeDelete, 2, __VA_ARGS__) \
+    func(BtreeDelete, 3, __VA_ARGS__) \
+    func(BtreeDelete, 4, __VA_ARGS__) \
+    func(BtreeDelete, 5, __VA_ARGS__) \
+    func(BtreeDelete, 6, __VA_ARGS__) \
+    func(BtreeDelete, 7, __VA_ARGS__) \
+    func(BtreeDelete, 8, __VA_ARGS__) \
+    func(BtreeDelete, 9, __VA_ARGS__) \
+    func(BtreeDelete, 10, __VA_ARGS__) \
+    func(BtreeDelete, 11, __VA_ARGS__) \
+    func(BtreeDelete, 12, __VA_ARGS__) \
+    func(BtreeDelete, 13, __VA_ARGS__) \
+    func(BtreeDelete, 14, __VA_ARGS__) \
+    func(BtreeDelete, 15, __VA_ARGS__) \
+    func(BtreeDelete, 16, __VA_ARGS__) \
+    func(BtreeDelete, 17, __VA_ARGS__) \
+    func(BtreeDelete, 18, __VA_ARGS__) \
+    func(BtreeDelete, 19, __VA_ARGS__) \
+    func(BtreeDelete, 20, __VA_ARGS__)
 
 // Brie is disabled for now.
 #define FOR_EACH_BRIE(func, ...)
@@ -138,11 +179,11 @@ namespace souffle::interpreter {
     /* func(Brie, 20, __VA_ARGS__)   */
 
 #define FOR_EACH_EQREL(func, ...)\
-    func(Eqrel, 2, 0, __VA_ARGS__)
+    func(Eqrel, 2, __VA_ARGS__)
 
 #define FOR_EACH(func, ...)                 \
     FOR_EACH_BTREE(func, __VA_ARGS__)       \
-    FOR_EACH_BTREE_DELETE(func, __VA_ARGS__)\
+    FOR_EACH_BTREE_DELETE(func, __VA_ARGS__)       \
     FOR_EACH_BRIE(func, __VA_ARGS__)        \
     FOR_EACH_PROVENANCE(func, __VA_ARGS__)  \
     FOR_EACH_EQREL(func, __VA_ARGS__)
@@ -234,6 +275,13 @@ struct get_full_index<0> {
     using type = index<>;
 };
 
+// -- obtains a full provenance index for a given arity --
+template <unsigned arity>
+struct get_full_prov_index {
+    using type = typename extend<typename extend<typename get_full_index<arity - 2>::type, arity - 1>::type,
+            arity - 2>::type;
+};
+
 }  // namespace index_utils
 
 template <std::size_t Arity>
@@ -243,64 +291,39 @@ using t_tuple = typename souffle::Tuple<RamDomain, Arity>;
 template <std::size_t Arity>
 using comparator = typename index_utils::get_full_index<Arity>::type::comparator;
 
-// Updater
-template <std::size_t Arity, std::size_t AuxiliaryArity>
-struct Updater {
-    bool update(t_tuple<Arity>& old_t, const t_tuple<Arity>& new_t) {
-        bool changed = false;
-        // todo: expand for loop using templates
-        constexpr std::size_t firstAux = Arity - AuxiliaryArity - 1;
-        for (std::size_t i = firstAux; i < Arity; i++) {
-            if (old_t[i] != new_t[i]) {
-                changed = true;
-                old_t[i] = new_t[i];
-            }
-        }
-        return changed;
-    }
-};
-
-// ProvenanceUpdater
-template <std::size_t Arity, std::size_t AuxiliaryArity>
-struct ProvenanceUpdater {
-    bool update(t_tuple<Arity>& old_t, const t_tuple<Arity>& new_t) {
-        constexpr std::size_t level = Arity - 1;
-        constexpr std::size_t rule = Arity - 2;
-        if (ramBitCast<RamSigned>(new_t[level]) < ramBitCast<RamSigned>(old_t[level]) ||
-                (ramBitCast<RamSigned>(new_t[level]) == ramBitCast<RamSigned>(old_t[level]) &&
-                        ramBitCast<RamSigned>(new_t[rule]) < ramBitCast<RamSigned>(old_t[rule]))) {
-            old_t[level] = new_t[level];
-            old_t[rule] = new_t[rule];
-            return true;
-        }
-        return false;
-    }
-};
+template <std::size_t Arity>
+using prov_comparator = typename index_utils::get_full_prov_index<Arity>::type::comparator;
 
 // Alias for btree_set
-template <std::size_t Arity, std::size_t AuxiliaryArity>
-using Btree = btree_set<t_tuple<Arity>, comparator<Arity>, std::allocator<t_tuple<Arity>>, 256,
-        typename detail::default_strategy<t_tuple<Arity>>::type, comparator<Arity - AuxiliaryArity>,
-        Updater<Arity, AuxiliaryArity>>;
+template <std::size_t Arity>
+using Btree = btree_set<t_tuple<Arity>, comparator<Arity>>;
 
-// Alias for btree_delete_set
-template <std::size_t Arity, std::size_t AuxiliaryArity>
-using BtreeDelete = btree_delete_set<t_tuple<Arity>, comparator<Arity>, std::allocator<t_tuple<Arity>>, 256,
-        typename detail::default_strategy<t_tuple<Arity>>::type, comparator<Arity - AuxiliaryArity>,
-        Updater<Arity, AuxiliaryArity>>;
+// Alias for btree_set
+template <std::size_t Arity>
+using BtreeDelete = btree_delete_set<t_tuple<Arity>, comparator<Arity>>;
 
 // Alias for Trie
-template <std::size_t Arity, std::size_t AuxiliaryArity>
+template <std::size_t Arity>
 using Brie = Trie<Arity>;
 
-template <std::size_t Arity, std::size_t AuxiliaryArity>
-using Provenance = btree_set<t_tuple<Arity>, comparator<Arity>, std::allocator<t_tuple<Arity>>, 256,
-        typename detail::default_strategy<t_tuple<Arity>>::type, comparator<Arity - AuxiliaryArity>,
-        ProvenanceUpdater<Arity, AuxiliaryArity>>;
+// Updater for Provenance
+template <std::size_t Arity>
+struct ProvenanceUpdater {
+    void update(t_tuple<Arity>& old_t, const t_tuple<Arity>& new_t) {
+        old_t[Arity - 2] = new_t[Arity - 2];
+        old_t[Arity - 1] = new_t[Arity - 1];
+    }
+};
+
+// Alias for Provenance
+template <std::size_t Arity>
+using Provenance = btree_set<t_tuple<Arity>, prov_comparator<Arity>, std::allocator<t_tuple<Arity>>, 256,
+        typename detail::default_strategy<t_tuple<Arity>>::type, comparator<Arity - 2>,
+        ProvenanceUpdater<Arity>>;
 
 // Alias for Eqrel
 // Note: require Arity = 2.
-template <std::size_t Arity, std::size_t AuxiliaryArity>
+template <std::size_t Arity>
 using Eqrel = EquivalenceRelation<t_tuple<Arity>>;
 
 };  // namespace souffle::interpreter
diff --git a/src/interpreter/tests/interpreter_relation_test.cpp b/src/interpreter/tests/interpreter_relation_test.cpp
index 4b788bb..6d7bfdf 100644
--- a/src/interpreter/tests/interpreter_relation_test.cpp
+++ b/src/interpreter/tests/interpreter_relation_test.cpp
@@ -20,7 +20,7 @@
 #include "interpreter/Relation.h"
 #include "ram/analysis/Index.h"
 #include "souffle/SouffleInterface.h"
-#include "souffle/datastructure/SymbolTableImpl.h"
+#include "souffle/SymbolTable.h"
 #include <iosfwd>
 #include <string>
 #include <utility>
@@ -46,7 +46,7 @@ TEST(Relation0, Construction) {
     OrderCollection orders = {emptyOrder};
     IndexCluster indexSelection(mapping, searches, orders);
 
-    Relation<0, 0, interpreter::Btree> rel("test", indexSelection);
+    Relation<0, interpreter::Btree> rel(0, "test", indexSelection);
 
     souffle::Tuple<RamDomain, 0> tuple;
     // add some values
@@ -68,7 +68,7 @@ TEST(Relation0, Iteration) {
     OrderCollection orders = {emptyOrder};
     IndexCluster indexSelection(mapping, searches, orders);
 
-    Relation<0, 0, interpreter::Btree> rel("test", indexSelection);
+    Relation<0, interpreter::Btree> rel(0, "test", indexSelection);
     RelationWrapper* wrapper = &rel;
 
     souffle::Tuple<RamDomain, 0> tuple;
@@ -95,7 +95,7 @@ TEST(Relation1, Construction) {
     mapping.insert({existenceCheck, fullOrder});
     IndexCluster indexSelection(mapping, searches, orders);
 
-    Relation<1, 0, interpreter::Btree> rel("test", indexSelection);
+    Relation<1, interpreter::Btree> rel(0, "test", indexSelection);
     RelInterface relInt(rel, symbolTable, "test", {"i"}, {"i"}, 0);
 
     tuple d1(&relInt, {1});
@@ -124,7 +124,7 @@ TEST(Basic, Iteration) {
     mapping.insert({existenceCheck, fullOrder});
     IndexCluster indexSelection(mapping, searches, orders);
 
-    Relation<1, 0, interpreter::Btree> rel("test", indexSelection);
+    Relation<1, interpreter::Btree> rel(0, "test", indexSelection);
     RelInterface relInt(rel, symbolTable, "test", {"i"}, {"i"}, 0);
 
     // add some values
@@ -159,7 +159,7 @@ TEST(Independence, Iteration) {
     mapping.insert({existenceCheck, fullOrder});
     IndexCluster indexSelection(mapping, searches, orders);
 
-    Relation<1, 0, interpreter::Btree> rel("test", indexSelection);
+    Relation<1, interpreter::Btree> rel(0, "test", indexSelection);
     RelInterface relInt(rel, symbolTable, "test", {"i"}, {"i"}, 0);
 
     // add a value
@@ -195,7 +195,7 @@ TEST(IndependentMoving, Iteration) {
     mapping.insert({existenceCheck, fullOrder});
     IndexCluster indexSelection(mapping, searches, orders);
 
-    Relation<1, 0, interpreter::Btree> rel("test", indexSelection);
+    Relation<1, interpreter::Btree> rel(0, "test", indexSelection);
     RelInterface relInt(rel, symbolTable, "test", {"i"}, {"i"}, 0);
 
     // add a value
@@ -226,7 +226,7 @@ TEST(IndependentCopying, Iteration) {
     mapping.insert({existenceCheck, fullOrder});
     IndexCluster indexSelection(mapping, searches, orders);
 
-    Relation<1, 0, interpreter::Btree> rel("test", indexSelection);
+    Relation<1, interpreter::Btree> rel(0, "test", indexSelection);
     RelInterface relInt(rel, symbolTable, "test", {"i"}, {"i"}, 0);
 
     // add a value
@@ -258,7 +258,7 @@ TEST(Reordering, Iteration) {
     mapping.insert({existenceCheck, fullOrder});
     IndexCluster indexSelection(mapping, searches, orders);
 
-    Relation<3, 0, interpreter::Btree> rel("test", indexSelection);
+    Relation<3, interpreter::Btree> rel(0, "test", indexSelection);
     souffle::Tuple<RamDomain, 3> tuple{0, 1, 2};
     rel.insert(tuple);
 
diff --git a/src/interpreter/tests/ram_arithmetic_test.cpp b/src/interpreter/tests/ram_arithmetic_test.cpp
index a79171d..728b56f 100644
--- a/src/interpreter/tests/ram_arithmetic_test.cpp
+++ b/src/interpreter/tests/ram_arithmetic_test.cpp
@@ -53,8 +53,7 @@ RamDomain evalExpression(Own<Expression> expression) {
     VecOwn<Expression> returnValues;
     returnValues.emplace_back(std::move(expression));
 
-    Global glb;
-    glb.config().set("jobs", "1");
+    Global::config().set("jobs", "1");
     Own<Statement> query = mk<ram::Query>(mk<ram::SubroutineReturn>(std::move(returnValues)));
     std::map<std::string, Own<Statement>> subs;
     subs.insert(std::make_pair("test", std::move(query)));
@@ -63,12 +62,12 @@ RamDomain evalExpression(Own<Expression> expression) {
     Own<Program> prog = mk<Program>(std::move(rels), mk<ram::Sequence>(), std::move(subs));
 
     ErrorReport errReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    TranslationUnit translationUnit(glb, std::move(prog), errReport, debugReport);
+    TranslationUnit translationUnit(std::move(prog), errReport, debugReport);
 
     // configure and execute interpreter
-    Own<Engine> interpreter = mk<Engine>(translationUnit, 1);
+    Own<Engine> interpreter = mk<Engine>(translationUnit);
 
     std::string name("test");
     std::vector<RamDomain> ret;
diff --git a/src/interpreter/tests/ram_relation_test.cpp b/src/interpreter/tests/ram_relation_test.cpp
index d8f2477..5fa0912 100644
--- a/src/interpreter/tests/ram_relation_test.cpp
+++ b/src/interpreter/tests/ram_relation_test.cpp
@@ -56,8 +56,7 @@ using json11::Json;
 
 const std::string testInterpreterStore(
         std::vector<std::string> attribs, std::vector<std::string> attribsTypes, VecOwn<Expression> exprs) {
-    Global glb;
-    glb.config().set("jobs", "1");
+    Global::config().set("jobs", "1");
 
     const std::size_t arity = attribs.size();
 
@@ -82,12 +81,12 @@ const std::string testInterpreterStore(
     Own<ram::Program> prog = mk<Program>(std::move(rels), std::move(main), std::move(subs));
 
     ErrorReport errReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    TranslationUnit translationUnit(glb, std::move(prog), errReport, debugReport);
+    TranslationUnit translationUnit(std::move(prog), errReport, debugReport);
 
     // configure and execute interpreter
-    Own<Engine> interpreter = mk<Engine>(translationUnit, 1);
+    Own<Engine> interpreter = mk<Engine>(translationUnit);
 
     std::streambuf* oldCoutStreambuf = std::cout.rdbuf();
     std::ostringstream sout;
@@ -238,8 +237,7 @@ TEST(IO_store, SignedChangedDelimiter) {
     const std::size_t len = randomNumbers.size();
     const std::string delimiter{", "};
 
-    Global glb;
-    glb.config().set("jobs", "1");
+    Global::config().set("jobs", "1");
 
     VecOwn<ram::Relation> rels;
 
@@ -277,12 +275,12 @@ TEST(IO_store, SignedChangedDelimiter) {
     Own<Program> prog = mk<Program>(std::move(rels), std::move(main), std::move(subs));
 
     ErrorReport errReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    TranslationUnit translationUnit(glb, std::move(prog), errReport, debugReport);
+    TranslationUnit translationUnit(std::move(prog), errReport, debugReport);
 
     // configure and execute interpreter
-    Own<Engine> interpreter = mk<Engine>(translationUnit, 1);
+    Own<Engine> interpreter = mk<Engine>(translationUnit);
 
     std::streambuf* oldCoutStreambuf = std::cout.rdbuf();
     std::ostringstream sout;
@@ -312,8 +310,7 @@ TEST(IO_store, SignedChangedDelimiter) {
 }
 
 TEST(IO_store, MixedTypes) {
-    Global glb;
-    glb.config().set("jobs", "1");
+    Global::config().set("jobs", "1");
 
     VecOwn<ram::Relation> rels;
 
@@ -333,7 +330,7 @@ TEST(IO_store, MixedTypes) {
     std::map<std::string, std::string> ioDirs = std::map<std::string, std::string>(dirs);
 
     ErrorReport errReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
     VecOwn<Expression> exprs;
     RamFloat floatValue = 27.75;
@@ -350,10 +347,10 @@ TEST(IO_store, MixedTypes) {
     std::map<std::string, Own<Statement>> subs;
     Own<Program> prog = mk<Program>(std::move(rels), std::move(main), std::move(subs));
 
-    TranslationUnit translationUnit(glb, std::move(prog), errReport, debugReport);
+    TranslationUnit translationUnit(std::move(prog), errReport, debugReport);
 
     // configure and execute interpreter
-    Own<Engine> interpreter = mk<Engine>(translationUnit, 1);
+    Own<Engine> interpreter = mk<Engine>(translationUnit);
 
     std::streambuf* oldCoutStreambuf = std::cout.rdbuf();
     std::ostringstream sout;
@@ -385,8 +382,7 @@ TEST(IO_load, Signed) {
     std::istringstream testInput("5	3");
     std::cin.rdbuf(testInput.rdbuf());
 
-    Global glb;
-    glb.config().set("jobs", "1");
+    Global::config().set("jobs", "1");
 
     VecOwn<ram::Relation> rels;
 
@@ -415,12 +411,12 @@ TEST(IO_load, Signed) {
     Own<Program> prog = mk<Program>(std::move(rels), std::move(main), std::move(subs));
 
     ErrorReport errReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    TranslationUnit translationUnit(glb, std::move(prog), errReport, debugReport);
+    TranslationUnit translationUnit(std::move(prog), errReport, debugReport);
 
     // configure and execute interpreter
-    Own<Engine> interpreter = mk<Engine>(translationUnit, 1);
+    Own<Engine> interpreter = mk<Engine>(translationUnit);
 
     std::streambuf* oldCoutStreambuf = std::cout.rdbuf();
     std::ostringstream sout;
@@ -446,8 +442,7 @@ TEST(IO_load, Float) {
     std::istringstream testInput("0.5	0.5");
     std::cin.rdbuf(testInput.rdbuf());
 
-    Global glb;
-    glb.config().set("jobs", "1");
+    Global::config().set("jobs", "1");
 
     VecOwn<ram::Relation> rels;
 
@@ -476,12 +471,12 @@ TEST(IO_load, Float) {
     Own<Program> prog = mk<Program>(std::move(rels), std::move(main), std::move(subs));
 
     ErrorReport errReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    TranslationUnit translationUnit(glb, std::move(prog), errReport, debugReport);
+    TranslationUnit translationUnit(std::move(prog), errReport, debugReport);
 
     // configure and execute interpreter
-    Own<Engine> interpreter = mk<Engine>(translationUnit, 1);
+    Own<Engine> interpreter = mk<Engine>(translationUnit);
 
     std::streambuf* oldCoutStreambuf = std::cout.rdbuf();
     std::ostringstream sout;
@@ -507,8 +502,7 @@ TEST(IO_load, Unsigned) {
     std::istringstream testInput("6	6");
     std::cin.rdbuf(testInput.rdbuf());
 
-    Global glb;
-    glb.config().set("jobs", "1");
+    Global::config().set("jobs", "1");
 
     VecOwn<ram::Relation> rels;
 
@@ -537,12 +531,12 @@ TEST(IO_load, Unsigned) {
     Own<Program> prog = mk<Program>(std::move(rels), std::move(main), std::move(subs));
 
     ErrorReport errReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    TranslationUnit translationUnit(glb, std::move(prog), errReport, debugReport);
+    TranslationUnit translationUnit(std::move(prog), errReport, debugReport);
 
     // configure and execute interpreter
-    Own<Engine> interpreter = mk<Engine>(translationUnit, 1);
+    Own<Engine> interpreter = mk<Engine>(translationUnit);
 
     std::streambuf* oldCoutStreambuf = std::cout.rdbuf();
     std::ostringstream sout;
@@ -568,8 +562,7 @@ TEST(IO_load, MixedTypesLoad) {
     std::istringstream testInput("meow	-3	3	0.5");
     std::cin.rdbuf(testInput.rdbuf());
 
-    Global glb;
-    glb.config().set("jobs", "1");
+    Global::config().set("jobs", "1");
 
     VecOwn<ram::Relation> rels;
 
@@ -598,12 +591,12 @@ TEST(IO_load, MixedTypesLoad) {
     Own<Program> prog = mk<Program>(std::move(rels), std::move(main), std::move(subs));
 
     ErrorReport errReport;
-    DebugReport debugReport(glb);
+    DebugReport debugReport;
 
-    TranslationUnit translationUnit(glb, std::move(prog), errReport, debugReport);
+    TranslationUnit translationUnit(std::move(prog), errReport, debugReport);
 
     // configure and execute interpreter
-    Own<Engine> interpreter = mk<Engine>(translationUnit, 1);
+    Own<Engine> interpreter = mk<Engine>(translationUnit);
 
     std::streambuf* oldCoutStreambuf = std::cout.rdbuf();
     std::ostringstream sout;
diff --git a/src/main.cpp b/src/main.cpp
new file mode 100644
index 0000000..cfaf890
--- /dev/null
+++ b/src/main.cpp
@@ -0,0 +1,985 @@
+/*
+ * Souffle - A Datalog Compiler
+ * Copyright (c) 2013, 2015, Oracle and/or its affiliates. All rights reserved
+ * Licensed under the Universal Permissive License v 1.0 as shown at:
+ * - https://opensource.org/licenses/UPL
+ * - <souffle root>/licenses/SOUFFLE-UPL.txt
+ */
+
+/************************************************************************
+ *
+ * @file main.cpp
+ *
+ * Main driver for Souffle
+ *
+ ***********************************************************************/
+
+#include "Global.h"
+#include "ast/Clause.h"
+#include "ast/Node.h"
+#include "ast/Program.h"
+#include "ast/TranslationUnit.h"
+#include "ast/analysis/PrecedenceGraph.h"
+#include "ast/analysis/SCCGraph.h"
+#include "ast/analysis/typesystem/Type.h"
+#include "ast/transform/AddNullariesToAtomlessAggregates.h"
+#include "ast/transform/ComponentChecker.h"
+#include "ast/transform/ComponentInstantiation.h"
+#include "ast/transform/Conditional.h"
+#include "ast/transform/ExecutionPlanChecker.h"
+#include "ast/transform/ExpandEqrels.h"
+#include "ast/transform/Fixpoint.h"
+#include "ast/transform/FoldAnonymousRecords.h"
+#include "ast/transform/GroundWitnesses.h"
+#include "ast/transform/GroundedTermsChecker.h"
+#include "ast/transform/IOAttributes.h"
+#include "ast/transform/IODefaults.h"
+#include "ast/transform/InlineRelations.h"
+#include "ast/transform/MagicSet.h"
+#include "ast/transform/MaterializeAggregationQueries.h"
+#include "ast/transform/MaterializeSingletonAggregation.h"
+#include "ast/transform/MinimiseProgram.h"
+#include "ast/transform/NameUnnamedVariables.h"
+#include "ast/transform/NormaliseGenerators.h"
+#include "ast/transform/PartitionBodyLiterals.h"
+#include "ast/transform/Pipeline.h"
+#include "ast/transform/PragmaChecker.h"
+#include "ast/transform/ReduceExistentials.h"
+#include "ast/transform/RemoveBooleanConstraints.h"
+#include "ast/transform/RemoveEmptyRelations.h"
+#include "ast/transform/RemoveRedundantRelations.h"
+#include "ast/transform/RemoveRedundantSums.h"
+#include "ast/transform/RemoveRelationCopies.h"
+#include "ast/transform/ReplaceSingletonVariables.h"
+#include "ast/transform/ResolveAliases.h"
+#include "ast/transform/ResolveAnonymousRecordAliases.h"
+#include "ast/transform/SemanticChecker.h"
+#include "ast/transform/SimplifyAggregateTargetExpression.h"
+#include "ast/transform/SubsumptionQualifier.h"
+#include "ast/transform/UniqueAggregationVariables.h"
+#include "ast2ram/TranslationStrategy.h"
+#include "ast2ram/UnitTranslator.h"
+#include "ast2ram/provenance/TranslationStrategy.h"
+#include "ast2ram/provenance/UnitTranslator.h"
+#include "ast2ram/seminaive/TranslationStrategy.h"
+#include "ast2ram/seminaive/UnitTranslator.h"
+#include "ast2ram/utility/TranslatorContext.h"
+#include "config.h"
+#include "interpreter/Engine.h"
+#include "interpreter/ProgInterface.h"
+#include "parser/ParserDriver.h"
+#include "ram/Node.h"
+#include "ram/Program.h"
+#include "ram/TranslationUnit.h"
+#include "ram/transform/CollapseFilters.h"
+#include "ram/transform/Conditional.h"
+#include "ram/transform/EliminateDuplicates.h"
+#include "ram/transform/ExpandFilter.h"
+#include "ram/transform/HoistAggregate.h"
+#include "ram/transform/HoistConditions.h"
+#include "ram/transform/IfConversion.h"
+#include "ram/transform/IfExistsConversion.h"
+#include "ram/transform/Loop.h"
+#include "ram/transform/MakeIndex.h"
+#include "ram/transform/Parallel.h"
+#include "ram/transform/ReorderConditions.h"
+#include "ram/transform/ReorderFilterBreak.h"
+#include "ram/transform/ReportIndex.h"
+#include "ram/transform/Sequence.h"
+#include "ram/transform/Transformer.h"
+#include "ram/transform/TupleId.h"
+#include "reports/DebugReport.h"
+#include "reports/ErrorReport.h"
+#include "souffle/RamTypes.h"
+#ifndef _MSC_VER
+#include "souffle/profile/Tui.h"
+#include "souffle/provenance/Explain.h"
+#endif
+#include "souffle/utility/ContainerUtil.h"
+#include "souffle/utility/FileUtil.h"
+#include "souffle/utility/MiscUtil.h"
+#include "souffle/utility/StreamUtil.h"
+#include "souffle/utility/StringUtil.h"
+#include "souffle/utility/SubProcess.h"
+#include "synthesiser/Synthesiser.h"
+#include <cassert>
+#include <chrono>
+#include <cstdio>
+#include <cstdlib>
+#include <ctime>
+#include <iomanip>
+#include <iostream>
+#include <map>
+#include <memory>
+#include <set>
+#include <sstream>
+#include <stdexcept>
+#include <string>
+#include <thread>
+#include <utility>
+#include <vector>
+
+#include "ExtraConfig.h"
+ExtraConfig extraConfig;
+
+namespace souffle {
+
+/**
+ * Executes a binary file.
+ */
+[[noreturn]] void executeBinaryAndExit(const std::string& binaryFilename) {
+    assert(!binaryFilename.empty() && "binary filename cannot be blank");
+
+    std::map<char const*, std::string> env;
+    if (Global::config().has("library-dir")) {
+        auto escapeLdPath = [](auto&& xs) { return escape(xs, {':', ' '}, "\\"); };
+        auto ld_path = toString(join(
+                map(Global::config().getMany("library-dir"), escapeLdPath), std::string(1, PATHdelimiter)));
+#if defined(_MSC_VER)
+        std::size_t l;
+        std::wstring env_path(ld_path.length() + 1, L' ');
+        ::mbstowcs_s(&l, env_path.data(), env_path.size(), ld_path.data(), ld_path.size());
+        env_path.resize(l - 1);
+
+        DWORD n = GetEnvironmentVariableW(L"PATH", nullptr, 0);
+        if (n > 0) {
+            // append path
+            std::unique_ptr<wchar_t[]> orig(new wchar_t[n]);
+            GetEnvironmentVariableW(L"PATH", orig.get(), n);
+            env_path = env_path + L";" + std::wstring(orig.get());
+        }
+        SetEnvironmentVariableW(L"PATH", env_path.c_str());
+
+#elif defined(__APPLE__)
+        env["DYLD_LIBRARY_PATH"] = ld_path;
+#else
+        env["LD_LIBRARY_PATH"] = ld_path;
+#endif
+    }
+
+    auto exit = execute(binaryFilename, {}, env);
+    if (!exit) throw std::invalid_argument("failed to execute `" + binaryFilename + "`");
+
+    if (!Global::config().has("dl-program")) {
+        remove(binaryFilename.c_str());
+        remove((binaryFilename + ".cpp").c_str());
+    }
+
+    std::exit(exit ? *exit : EXIT_FAILURE);
+}
+
+/**
+ * Compiles the given source file to a binary file.
+ */
+void compileToBinary(const std::string& command, std::string_view sourceFilename) {
+    std::vector<std::string> argv;
+
+    argv.push_back(command);
+
+    if (Global::config().has("swig")) {
+        argv.push_back("-s");
+        argv.push_back(Global::config().get("swig"));
+    }
+
+    for (auto&& path : Global::config().getMany("library-dir")) {
+        // The first entry may be blank
+        if (path.empty()) {
+            continue;
+        }
+        argv.push_back(tfm::format("-L%s", path));
+    }
+    for (auto&& library : Global::config().getMany("libraries")) {
+        // The first entry may be blank
+        if (library.empty()) {
+            continue;
+        }
+        argv.push_back(tfm::format("-l%s", library));
+    }
+
+    argv.push_back(std::string(sourceFilename));
+
+#if defined(_MSC_VER)
+    const char* interpreter = "python";
+#else
+    const char* interpreter = "python3";
+#endif
+    auto exit = execute(interpreter, argv);
+    if (!exit) throw std::invalid_argument(tfm::format("unable to execute tool <python3 %s>", command));
+    if (exit != 0)
+        throw std::invalid_argument(tfm::format("failed to compile C++ source <%s>", sourceFilename));
+}
+
+class InputProvider {
+public:
+    virtual ~InputProvider() {}
+    virtual FILE* getInputStream() = 0;
+    virtual bool endInput() = 0;
+};
+
+class FileInput : public InputProvider {
+public:
+    FileInput(const std::filesystem::path& path) : Path(path) {}
+
+    ~FileInput() {
+        if (Stream) {
+            fclose(Stream);
+        }
+    }
+
+    FILE* getInputStream() override {
+        if (std::filesystem::exists(Path)) {
+            Stream = fopen(Path.string().c_str(), "rb");
+            return Stream;
+        } else {
+            return nullptr;
+        }
+    }
+
+    bool endInput() override {
+        if (Stream == nullptr) {
+            return false;
+        } else {
+            fclose(Stream);
+            Stream = nullptr;
+            return true;
+        }
+    }
+
+private:
+    const std::filesystem::path Path;
+    FILE* Stream = nullptr;
+};
+
+class PreprocInput : public InputProvider {
+public:
+    PreprocInput(const std::filesystem::path& path, MainConfig& conf, const std::string& exec,
+            const std::string& options)
+            : Exec(which(exec)), Options(options), InitCmd(), Path(path), Conf(conf) {}
+
+    PreprocInput(const std::filesystem::path& path, MainConfig& conf, const std::string& cmd)
+            : Exec(), Options(), InitCmd(cmd), Path(path), Conf(conf) {}
+
+    virtual ~PreprocInput() {
+        if (Stream) {
+            pclose(Stream);
+        }
+    }
+
+    FILE* getInputStream() override {
+        Cmd.str("");
+
+        if (Exec) {
+            if (Exec->empty()) {
+                return nullptr;
+            }
+            Cmd << *Exec;
+        } else if (InitCmd) {
+            Cmd << *InitCmd;
+        } else {
+            return nullptr;
+        }
+
+        if (Options && !Options->empty()) {
+            Cmd << " ";
+            Cmd << *Options;
+        }
+
+        Cmd << " ";
+        Cmd << toString(join(Conf.getMany("include-dir"), " ",
+                [&](auto&& os, auto&& dir) { tfm::format(os, "-I \"%s\"", dir); }));
+
+        if (Conf.has("macro")) {
+            Cmd << " " << Conf.get("macro");
+        }
+        // Add RamDomain size as a macro
+        Cmd << " -DRAM_DOMAIN_SIZE=" << std::to_string(RAM_DOMAIN_SIZE);
+        Cmd << " \"" + Path.string() + "\"";
+
+#if defined(_MSC_VER)
+        // cl.exe prints the input file name on the standard error stream,
+        // we must silent it in order to preserve an empty error output
+        // because Souffle test-suite is sensible to error outputs.
+        Cmd << " 2> nul";
+#endif
+
+        Stream = popen(Cmd.str().c_str(), "r");
+        return Stream;
+    }
+
+    bool endInput() override {
+        const int Status = pclose(Stream);
+        Stream = nullptr;
+        if (Status == -1) {
+            perror(nullptr);
+            throw std::runtime_error("failed to close pre-processor pipe");
+        } else if (Status != 0) {
+            std::cerr << "Pre-processors command failed with code " << Status << ": '" << Cmd.str() << "'\n";
+            throw std::runtime_error("Pre-processor command failed");
+        }
+        return true;
+    }
+
+    static bool available(const std::string& Exec) {
+        return !which(Exec).empty();
+    }
+
+private:
+    std::optional<std::string> Exec;
+    std::optional<std::string> Options;
+    std::optional<std::string> InitCmd;
+    std::filesystem::path Path;
+    MainConfig& Conf;
+    std::stringstream Cmd;
+    FILE* Stream = nullptr;
+};
+
+class GCCPreprocInput : public PreprocInput {
+public:
+    GCCPreprocInput(const std::filesystem::path& mainSource, MainConfig& conf)
+            : PreprocInput(mainSource, conf, "gcc", "-x c -E") {}
+
+    virtual ~GCCPreprocInput() {}
+
+    static bool available() {
+        return PreprocInput::available("gcc");
+    }
+};
+
+class MCPPPreprocInput : public PreprocInput {
+public:
+    MCPPPreprocInput(const std::filesystem::path& mainSource, MainConfig& conf)
+            : PreprocInput(mainSource, conf, "mcpp", "-e utf8 -W0") {}
+
+    virtual ~MCPPPreprocInput() {}
+
+    static bool available() {
+        return PreprocInput::available("mcpp");
+    }
+};
+
+int main(int argc, char** argv) {
+    /* Time taking for overall runtime */
+    auto souffle_start = std::chrono::high_resolution_clock::now();
+
+    std::string versionFooter;
+
+    /* have all to do with command line arguments in its own scope, as these are accessible through the global
+     * configuration only */
+    try {
+        std::stringstream header;
+        header << "============================================================================" << std::endl;
+        header << "souffle -- A datalog engine." << std::endl;
+        header << "Usage: souffle [OPTION] FILE." << std::endl;
+        header << "----------------------------------------------------------------------------" << std::endl;
+        header << "Options:" << std::endl;
+
+        std::stringstream footer;
+        footer << "----------------------------------------------------------------------------" << std::endl;
+        footer << "Version: " << PACKAGE_VERSION << "" << std::endl;
+        footer << "----------------------------------------------------------------------------" << std::endl;
+        footer << "Copyright (c) 2016-22 The Souffle Developers." << std::endl;
+        footer << "Copyright (c) 2013-16 Oracle and/or its affiliates." << std::endl;
+        footer << "All rights reserved." << std::endl;
+        footer << "============================================================================" << std::endl;
+
+        versionFooter = footer.str();
+
+        // command line options, the environment will be filled with the arguments passed to them, or
+        // the empty string if they take none
+        // main option, the datalog program itself, has an empty key
+        std::vector<MainOption> options{{"", 0, "", "", false, ""},
+                {"auto-schedule", 'a', "FILE", "", false,
+                        "Use profile auto-schedule <FILE> for auto-scheduling."},
+                {"fact-dir", 'F', "DIR", ".", false, "Specify directory for fact files."},
+                {"include-dir", 'I', "DIR", ".", true, "Specify directory for include files."},
+                {"output-dir", 'D', "DIR", ".", false,
+                        "Specify directory for output files. If <DIR> is `-` then stdout is used."},
+                {"jobs", 'j', "N", "1", false,
+                        "Run interpreter/compiler in parallel using N threads, N=auto for system "
+                        "default."},
+                {"compile", 'c', "", "", false,
+                        "Generate C++ source code, compile to a binary executable, then run this "
+                        "executable."},
+                {"generate", 'g', "FILE", "", false,
+                        "Generate C++ source code for the given Datalog program and write it to "
+                        "<FILE>. If <FILE> is `-` then stdout is used."},
+                {"inline-exclude", '\x7', "RELATIONS", "", false,
+                        "Prevent the given relations from being inlined. Overrides any `inline` qualifiers."},
+                {"swig", 's', "LANG", "", false,
+                        "Generate SWIG interface for given language. The values <LANG> accepts is java and "
+                        "python. "},
+                {"library-dir", 'L', "DIR", "", true, "Specify directory for library files."},
+                {"libraries", 'l', "FILE", "", true, "Specify libraries."},
+                {"no-warn", 'w', "", "", false, "Disable warnings."},
+                {"magic-transform", 'm', "RELATIONS", "", false,
+                        "Enable magic set transformation changes on the given relations, use '*' "
+                        "for all."},
+                {"magic-transform-exclude", '\x8', "RELATIONS", "", false,
+                        "Disable magic set transformation changes on the given relations. Overrides "
+                        "`magic-transform`. Implies `inline-exclude` for the given relations."},
+                {"macro", 'M', "MACROS", "", false, "Set macro definitions for the pre-processor"},
+                {"disable-transformers", 'z', "TRANSFORMERS", "", false,
+                        "Disable the given AST transformers."},
+                {"dl-program", 'o', "FILE", "", false,
+                        "Generate C++ source code, written to <FILE>, and compile this to a "
+                        "binary executable (without executing it)."},
+                {"index-stats", '\x9', "", "", false, "Enable collection of index statistics"},
+                {"live-profile", '\1', "", "", false, "Enable live profiling."},
+                {"profile", 'p', "FILE", "", false, "Enable profiling, and write profile data to <FILE>."},
+                {"profile-frequency", '\2', "", "", false, "Enable the frequency counter in the profiler."},
+                {"debug-report", 'r', "FILE", "", false, "Write HTML debug report to <FILE>."},
+                {"pragma", 'P', "OPTIONS", "", true, "Set pragma options."},
+                {"provenance", 't', "[ none | explain | explore ]", "", false,
+                        "Enable provenance instrumentation and interaction."},
+                {"verbose", 'v', "", "", false, "Verbose output."},
+                {"version", '\3', "", "", false, "Version."},
+                {"show", '\4', "[ <see-list> ]", "", true,
+                        "Print selected program information.\n"
+                        "Modes:\n"
+                        "\tinitial-ast\n"
+                        "\tinitial-ram\n"
+                        "\tparse-errors\n"
+                        "\tprecedence-graph\n"
+                        "\tprecedence-graph-text\n"
+                        "\tscc-graph\n"
+                        "\tscc-graph-text\n"
+                        "\ttransformed-ast\n"
+                        "\ttransformed-ram\n"
+                        "\ttype-analysis"},
+                {"parse-errors", '\5', "", "", false, "Show parsing errors, if any, then exit."},
+                {"help", 'h', "", "", false, "Display this help message."},
+                {"legacy", '\6', "", "", false, "Enable legacy support."},
+                {"preprocessor", '\7', "CMD", "", false, "C preprocessor to use."},
+                {"no-preprocessor", 10, "", "", false, "Do not use a C preprocessor."}};
+        Global::config().processArgs(argc, argv, header.str(), versionFooter, options);
+
+        // ------ command line arguments -------------
+
+        // Take in pragma options from the command line
+        if (Global::config().has("pragma")) {
+            ast::transform::PragmaChecker::Merger merger;
+
+            for (auto&& option : Global::config().getMany("pragma")) {
+                // TODO: escape sequences for `:` to allow `:` in a pragma key?
+                std::size_t splitPoint = option.find(':');
+
+                std::string optionName = option.substr(0, splitPoint);
+                std::string optionValue = (splitPoint == std::string::npos)
+                                                  ? ""
+                                                  : option.substr(splitPoint + 1, option.length());
+
+                merger(optionName, optionValue);
+            }
+        }
+
+        /* for the version option, if given print the version text then exit */
+        if (Global::config().has("version")) {
+            std::cout << versionFooter << std::endl;
+            return 0;
+        }
+        Global::config().set("version", PACKAGE_VERSION);
+
+        /* for the help option, if given simply print the help text then exit */
+        if (Global::config().has("help")) {
+            std::cout << Global::config().help();
+            return 0;
+        }
+
+        if (!Global::config().has("")) {
+            std::cerr << "No datalog file specified.\n";
+            return 0;
+        }
+
+        /* check that datalog program exists */
+        if (!extraConfig.getContent() && !existFile(Global::config().get(""))) {
+            throw std::runtime_error("cannot open file " + std::string(Global::config().get("")));
+        }
+
+        /* for the jobs option, to determine the number of threads used */
+#ifdef _OPENMP
+        if (isNumber(Global::config().get("jobs").c_str())) {
+            if (std::stoi(Global::config().get("jobs")) < 1) {
+                throw std::runtime_error("-j/--jobs may only be set to 'auto' or an integer greater than 0.");
+            }
+        } else {
+            if (!Global::config().has("jobs", "auto")) {
+                throw std::runtime_error("-j/--jobs may only be set to 'auto' or an integer greater than 0.");
+            }
+            // set jobs to zero to indicate the synthesiser and interpreter to use the system default.
+            Global::config().set("jobs", "0");
+        }
+#else
+        // Check that -j option has not been changed from the default
+        if (Global::config().get("jobs") != "1" && !Global::config().has("no-warn")) {
+            std::cerr << "\nThis installation of Souffle does not support concurrent jobs.\n";
+        }
+#endif
+
+        /* if an output directory is given, check it exists */
+        if (Global::config().has("output-dir") && !Global::config().has("output-dir", "-") &&
+                !existDir(Global::config().get("output-dir")) &&
+                !(Global::config().has("generate") ||
+                        (Global::config().has("dl-program") && !Global::config().has("compile")))) {
+            throw std::runtime_error(
+                    "output directory " + Global::config().get("output-dir") + " does not exists");
+        }
+
+        /* verify all input directories exist (racey, but gives nicer error messages for common mistakes) */
+        for (auto&& dir : Global::config().getMany("include-dir")) {
+            if (!existDir(dir)) throw std::runtime_error("include directory `" + dir + "` does not exist");
+        }
+
+        /* collect all macro definitions for the pre-processor */
+        if (Global::config().has("macro")) {
+            std::string currentMacro = "";
+            std::string allMacros = "";
+            for (const char& ch : Global::config().get("macro")) {
+                if (ch == ' ') {
+                    allMacros += " -D";
+                    allMacros += currentMacro;
+                    currentMacro = "";
+                } else {
+                    currentMacro += ch;
+                }
+            }
+            allMacros += " -D" + currentMacro;
+            Global::config().set("macro", allMacros);
+        }
+
+        if (Global::config().has("live-profile") && !Global::config().has("profile")) {
+            Global::config().set("profile");
+        }
+
+        /* if index-stats is set then check that the profiler is also set */
+        if (Global::config().has("index-stats")) {
+            if (!Global::config().has("profile"))
+                throw std::runtime_error("must be profiling to collect index-stats");
+        }
+
+    } catch (std::exception& e) {
+        std::cerr << e.what() << std::endl;
+        exit(EXIT_FAILURE);
+    }
+
+    /**
+     * Ensure that code generation is enabled if using SWIG interface option.
+     */
+    if (Global::config().has("swig") && !Global::config().has("generate")) {
+        Global::config().set("generate", simpleName(Global::config().get("")));
+    }
+
+    // ------ start souffle -------------
+
+    const std::string souffleExecutable = which(argv[0]);
+
+    if (souffleExecutable.empty()) {
+        throw std::runtime_error("failed to determine souffle executable path");
+    }
+
+    const std::filesystem::path InputPath(Global::config().get(""));
+    std::unique_ptr<InputProvider> Input;
+    const bool use_preprocessor = !Global::config().has("no-preprocessor");
+    if (use_preprocessor) {
+        if (Global::config().has("preprocessor")) {
+            auto cmd = Global::config().get("preprocessor");
+            if (cmd == "gcc") {
+                Input = std::make_unique<GCCPreprocInput>(InputPath, Global::config());
+            } else if (cmd == "mcpp") {
+                Input = std::make_unique<MCPPPreprocInput>(InputPath, Global::config());
+            } else {
+                Input = std::make_unique<PreprocInput>(InputPath, Global::config(), cmd);
+            }
+        } else if (MCPPPreprocInput::available()) {  // mcpp fallback
+            Input = std::make_unique<MCPPPreprocInput>(InputPath, Global::config());
+        } else if (GCCPreprocInput::available()) {  // gcc fallback
+            Input = std::make_unique<GCCPreprocInput>(InputPath, Global::config());
+        } else {
+            throw std::runtime_error("failed to locate mcpp or gcc pre-processors");
+        }
+    } else {
+        Input = std::make_unique<FileInput>(Global::config().get(""));
+    }
+
+    /* Time taking for parsing */
+    auto parser_start = std::chrono::high_resolution_clock::now();
+
+    // ------- parse program -------------
+
+    // parse file
+    ErrorReport errReport(Global::config().has("no-warn"));
+    DebugReport debugReport;
+    Own<ast::TranslationUnit> astTranslationUnit =
+            (!extraConfig.getContent()
+                ? ParserDriver::parseTranslationUnit(
+                        InputPath.string(), Input->getInputStream(), errReport, debugReport)
+                : ParserDriver::parseTranslationUnit(
+                        *extraConfig.getContent(), errReport, debugReport));
+    Input->endInput();
+
+    /* Report run-time of the parser if verbose flag is set */
+    if (Global::config().has("verbose")) {
+        auto parser_end = std::chrono::high_resolution_clock::now();
+        std::cout << "Parse time: " << std::chrono::duration<double>(parser_end - parser_start).count()
+                  << "sec\n";
+    }
+
+    auto hasShowOpt = [&](auto&&... kind) { return (Global::config().has("show", kind) || ...); };
+
+    // `--show parse-errors` is special in that it (ab?)used the return code to specify the # of errors.
+    //  Other `--show` modes can be used in conjunction with each other.
+    if (hasShowOpt("parse-errors")) {
+        if (1 < Global::config().getMany("show").size()) {
+            std::cerr << "WARNING: `--show parse-errors` inhibits other `--show` actions.\n";
+        }
+
+        std::cout << astTranslationUnit->getErrorReport();
+        return static_cast<int>(astTranslationUnit->getErrorReport().getNumErrors());
+    }
+
+    // ------- check for parse errors -------------
+    astTranslationUnit->getErrorReport().exitIfErrors();
+
+    // ------- rewriting / optimizations -------------
+
+    /* set up additional global options based on pragma declaratives */
+    (mk<ast::transform::PragmaChecker>())->apply(*astTranslationUnit);
+
+    if (hasShowOpt("initial-ast", "initial-datalog")) {
+        std::cout << astTranslationUnit->getProgram() << std::endl;
+        // no other show options specified -> bail, we're done.
+        if (Global::config().getMany("show").size() == 1) return 0;
+    }
+
+    /* construct the transformation pipeline */
+
+    // Equivalence pipeline
+    auto equivalencePipeline =
+            mk<ast::transform::PipelineTransformer>(mk<ast::transform::NameUnnamedVariablesTransformer>(),
+                    mk<ast::transform::FixpointTransformer>(mk<ast::transform::MinimiseProgramTransformer>()),
+                    mk<ast::transform::ReplaceSingletonVariablesTransformer>(),
+                    mk<ast::transform::RemoveRelationCopiesTransformer>(),
+                    mk<ast::transform::RemoveEmptyRelationsTransformer>(),
+                    mk<ast::transform::RemoveRedundantRelationsTransformer>());
+
+    // Magic-Set pipeline
+    auto magicPipeline = mk<ast::transform::PipelineTransformer>(
+            mk<ast::transform::ConditionalTransformer>(
+                    Global::config().has("magic-transform"), mk<ast::transform::ExpandEqrelsTransformer>()),
+            mk<ast::transform::MagicSetTransformer>(), mk<ast::transform::ResolveAliasesTransformer>(),
+            mk<ast::transform::RemoveRelationCopiesTransformer>(),
+            mk<ast::transform::RemoveEmptyRelationsTransformer>(),
+            mk<ast::transform::RemoveRedundantRelationsTransformer>(), clone(equivalencePipeline));
+
+    // Partitioning pipeline
+    auto partitionPipeline =
+            mk<ast::transform::PipelineTransformer>(mk<ast::transform::NameUnnamedVariablesTransformer>(),
+                    mk<ast::transform::PartitionBodyLiteralsTransformer>(),
+                    mk<ast::transform::ReplaceSingletonVariablesTransformer>());
+
+    // Provenance pipeline
+    auto provenancePipeline = mk<ast::transform::ConditionalTransformer>(Global::config().has("provenance"),
+            mk<ast::transform::PipelineTransformer>(mk<ast::transform::ExpandEqrelsTransformer>(),
+                    mk<ast::transform::NameUnnamedVariablesTransformer>()));
+
+    // Main pipeline
+    auto pipeline = mk<ast::transform::PipelineTransformer>(mk<ast::transform::ComponentChecker>(),
+            mk<ast::transform::ComponentInstantiationTransformer>(),
+            mk<ast::transform::IODefaultsTransformer>(),
+            mk<ast::transform::SimplifyAggregateTargetExpressionTransformer>(),
+            mk<ast::transform::UniqueAggregationVariablesTransformer>(),
+            mk<ast::transform::FixpointTransformer>(mk<ast::transform::PipelineTransformer>(
+                    mk<ast::transform::ResolveAnonymousRecordAliasesTransformer>(),
+                    mk<ast::transform::FoldAnonymousRecords>())),
+            mk<ast::transform::SubsumptionQualifierTransformer>(), mk<ast::transform::SemanticChecker>(),
+            mk<ast::transform::GroundWitnessesTransformer>(),
+            mk<ast::transform::UniqueAggregationVariablesTransformer>(),
+            mk<ast::transform::MaterializeSingletonAggregationTransformer>(),
+            mk<ast::transform::FixpointTransformer>(
+                    mk<ast::transform::MaterializeAggregationQueriesTransformer>()),
+            mk<ast::transform::RemoveRedundantSumsTransformer>(),
+            mk<ast::transform::NormaliseGeneratorsTransformer>(),
+            mk<ast::transform::ResolveAliasesTransformer>(),
+            mk<ast::transform::RemoveBooleanConstraintsTransformer>(),
+            mk<ast::transform::ResolveAliasesTransformer>(), mk<ast::transform::MinimiseProgramTransformer>(),
+            mk<ast::transform::InlineUnmarkExcludedTransform>(),
+            mk<ast::transform::InlineRelationsTransformer>(), mk<ast::transform::GroundedTermsChecker>(),
+            mk<ast::transform::ResolveAliasesTransformer>(),
+            mk<ast::transform::RemoveRedundantRelationsTransformer>(),
+            mk<ast::transform::RemoveRelationCopiesTransformer>(),
+            mk<ast::transform::RemoveEmptyRelationsTransformer>(),
+            mk<ast::transform::ReplaceSingletonVariablesTransformer>(),
+            mk<ast::transform::FixpointTransformer>(mk<ast::transform::PipelineTransformer>(
+                    mk<ast::transform::ReduceExistentialsTransformer>(),
+                    mk<ast::transform::RemoveRedundantRelationsTransformer>())),
+            mk<ast::transform::RemoveRelationCopiesTransformer>(), std::move(partitionPipeline),
+            std::move(equivalencePipeline), mk<ast::transform::RemoveRelationCopiesTransformer>(),
+            std::move(magicPipeline), mk<ast::transform::RemoveEmptyRelationsTransformer>(),
+            mk<ast::transform::AddNullariesToAtomlessAggregatesTransformer>(),
+            mk<ast::transform::ExecutionPlanChecker>(), std::move(provenancePipeline),
+            mk<ast::transform::IOAttributesTransformer>());
+
+    // Disable unwanted transformations
+    if (Global::config().has("disable-transformers")) {
+        std::vector<std::string> givenTransformers =
+                splitString(Global::config().get("disable-transformers"), ',');
+        pipeline->disableTransformers(
+                std::set<std::string>(givenTransformers.begin(), givenTransformers.end()));
+    }
+
+    // Set up the debug report if necessary
+    if (Global::config().has("debug-report")) {
+        auto parser_end = std::chrono::high_resolution_clock::now();
+        std::stringstream ss;
+
+        // Add current time
+        std::time_t time = std::time(nullptr);
+        ss << "Executed at ";
+        ss << std::put_time(std::localtime(&time), "%F %T") << "\n";
+
+        // Add config
+        ss << "(\n";
+        ss << join(Global::config().data(), ",\n", [](std::ostream& out, const auto& arg) {
+            out << "  \"" << arg.first << "\" -> \"" << arg.second << '"';
+        });
+        ss << "\n)";
+
+        debugReport.addSection("Configuration", "Configuration", ss.str());
+
+        // Add parsing runtime
+        std::string runtimeStr =
+                "(" + std::to_string(std::chrono::duration<double>(parser_end - parser_start).count()) + "s)";
+        debugReport.addSection("Parsing", "Parsing " + runtimeStr, "");
+
+        pipeline->setDebugReport();
+    }
+
+    // Toggle pipeline verbosity
+    pipeline->setVerbosity(Global::config().has("verbose"));
+
+    // Apply all the transformations
+    pipeline->apply(*astTranslationUnit);
+
+    // Output the transformed datalog (support alias opt name of 'datalog')
+    if (hasShowOpt("transformed-ast", "transformed-datalog")) {
+        std::cout << astTranslationUnit->getProgram() << std::endl;
+    }
+
+    // Output the precedence graph in graphviz dot format
+    if (hasShowOpt("precedence-graph")) {
+        astTranslationUnit->getAnalysis<ast::analysis::PrecedenceGraphAnalysis>().printHTML(std::cout);
+        std::cout << std::endl;
+    }
+
+    // Output the precedence graph in text format
+    if (hasShowOpt("precedence-graph-text")) {
+        astTranslationUnit->getAnalysis<ast::analysis::PrecedenceGraphAnalysis>().print(std::cout);
+        std::cout << std::endl;
+    }
+
+    // Output the scc graph in graphviz dot format
+    if (hasShowOpt("scc-graph")) {
+        astTranslationUnit->getAnalysis<ast::analysis::SCCGraphAnalysis>().printHTML(std::cout);
+        std::cout << std::endl;
+    }
+
+    // Output the scc graph in text format
+    if (hasShowOpt("scc-graph-text")) {
+        astTranslationUnit->getAnalysis<ast::analysis::SCCGraphAnalysis>().print(std::cout);
+        std::cout << std::endl;
+    }
+
+    // Output the type analysis
+    if (hasShowOpt("type-analysis")) {
+        astTranslationUnit->getAnalysis<ast::analysis::TypeAnalysis>().print(std::cout);
+        std::cout << std::endl;
+    }
+
+    // bail if we've nothing else left to show
+    if (Global::config().has("show") && !hasShowOpt("initial-ram", "transformed-ram")) return 0;
+
+    // ------- execution -------------
+    /* translate AST to RAM */
+    debugReport.startSection();
+    auto translationStrategy =
+            Global::config().has("provenance")
+                    ? mk<ast2ram::TranslationStrategy, ast2ram::provenance::TranslationStrategy>()
+                    : mk<ast2ram::TranslationStrategy, ast2ram::seminaive::TranslationStrategy>();
+    auto unitTranslator = Own<ast2ram::UnitTranslator>(translationStrategy->createUnitTranslator());
+    auto ramTranslationUnit = unitTranslator->translateUnit(*astTranslationUnit);
+    debugReport.endSection("ast-to-ram", "Translate AST to RAM");
+
+    if (hasShowOpt("initial-ram")) {
+        std::cout << ramTranslationUnit->getProgram();
+        // bail if we've nothing else left to show
+        if (!hasShowOpt("transformed-ram")) return 0;
+    }
+
+    // Apply RAM transforms
+    {
+        using namespace ram::transform;
+        Own<Transformer> ramTransform = mk<TransformerSequence>(
+                mk<LoopTransformer>(mk<TransformerSequence>(mk<ExpandFilterTransformer>(),
+                        mk<HoistConditionsTransformer>(), mk<MakeIndexTransformer>())),
+                mk<IfConversionTransformer>(), mk<IfExistsConversionTransformer>(),
+                mk<CollapseFiltersTransformer>(), mk<TupleIdTransformer>(),
+                mk<LoopTransformer>(
+                        mk<TransformerSequence>(mk<HoistAggregateTransformer>(), mk<TupleIdTransformer>())),
+                mk<ExpandFilterTransformer>(), mk<HoistConditionsTransformer>(),
+                mk<CollapseFiltersTransformer>(), mk<EliminateDuplicatesTransformer>(),
+                mk<ReorderConditionsTransformer>(), mk<LoopTransformer>(mk<ReorderFilterBreak>()),
+                mk<ConditionalTransformer>(
+                        // job count of 0 means all cores are used.
+                        []() -> bool { return std::stoi(Global::config().get("jobs")) != 1; },
+                        mk<ParallelTransformer>()),
+                mk<ReportIndexTransformer>());
+
+        ramTransform->apply(*ramTranslationUnit);
+    }
+
+    if (ramTranslationUnit->getErrorReport().getNumIssues() != 0) {
+        std::cerr << ramTranslationUnit->getErrorReport();
+    }
+
+    // Output the transformed RAM program and return
+    if (hasShowOpt("transformed-ram")) {
+        std::cout << ramTranslationUnit->getProgram();
+        return 0;
+    }
+
+    const bool execute_mode = Global::config().has("compile");
+    const bool compile_mode = Global::config().has("dl-program");
+    const bool generate_mode = Global::config().has("generate");
+
+    const bool must_interpret =
+            !execute_mode && !compile_mode && !generate_mode && !Global::config().has("swig");
+    const bool must_execute = execute_mode;
+    const bool must_compile = must_execute || compile_mode || Global::config().has("swig");
+
+    try {
+        if (must_interpret) {
+            // ------- interpreter -------------
+
+            std::thread profiler;
+            // Start up profiler if needed
+            if (Global::config().has("live-profile")) {
+#ifdef _MSC_VER
+                throw("No live-profile on Windows\n.");
+#else
+                profiler = std::thread([]() { profile::Tui().runProf(); });
+#endif
+            }
+
+            // configure and execute interpreter
+            Own<interpreter::Engine> interpreter(mk<interpreter::Engine>(*ramTranslationUnit));
+            interpreter->executeMain();
+            // If the profiler was started, join back here once it exits.
+            if (profiler.joinable()) {
+                profiler.join();
+            }
+            if (Global::config().has("provenance")) {
+#ifdef _MSC_VER
+                throw("No explain/explore provenance on Windows\n.");
+#else
+                // only run explain interface if interpreted
+                interpreter::ProgInterface interface(*interpreter);
+                if (Global::config().get("provenance") == "explain") {
+                    explain(interface, false);
+                } else if (Global::config().get("provenance") == "explore") {
+                    explain(interface, true);
+                }
+#endif
+            }
+        } else {
+            // ------- compiler -------------
+            // int jobs = std::stoi(Global::config().get("jobs"));
+            // jobs = (jobs <= 0 ? MAX_THREADS : jobs);
+            auto synthesiser =
+                    mk<synthesiser::Synthesiser>(/*static_cast<std::size_t>(jobs),*/ *ramTranslationUnit);
+
+            // Find the base filename for code generation and execution
+            std::string baseFilename;
+            if (compile_mode) {
+                baseFilename = Global::config().get("dl-program");
+            } else if (generate_mode) {
+                baseFilename = Global::config().get("generate");
+
+                // trim .cpp extension if it exists
+                if (baseFilename.size() >= 4 && baseFilename.substr(baseFilename.size() - 4) == ".cpp") {
+                    baseFilename = baseFilename.substr(0, baseFilename.size() - 4);
+                }
+            } else {
+                baseFilename = tempFile();
+            }
+
+            if (baseName(baseFilename) == "/" || baseName(baseFilename) == ".") {
+                baseFilename = tempFile();
+            }
+
+            std::string baseIdentifier = identifier(simpleName(baseFilename));
+            std::string sourceFilename = baseFilename + ".cpp";
+
+            bool withSharedLibrary;
+            auto synthesisStart = std::chrono::high_resolution_clock::now();
+            const bool emitToStdOut = Global::config().has("generate", "-");
+            if (emitToStdOut)
+                synthesiser->generateCode(std::cout, baseIdentifier, withSharedLibrary);
+            else {
+                std::ofstream os{sourceFilename};
+                synthesiser->generateCode(os, baseIdentifier, withSharedLibrary);
+                os.close();
+            }
+            if (Global::config().has("verbose")) {
+                auto synthesisEnd = std::chrono::high_resolution_clock::now();
+                std::cout << "Synthesis time: "
+                          << std::chrono::duration<double>(synthesisEnd - synthesisStart).count() << "sec\n";
+            }
+
+            if (withSharedLibrary) {
+                if (!Global::config().has("libraries")) {
+                    Global::config().set("libraries", "functors");
+                }
+                if (!Global::config().has("library-dir")) {
+                    Global::config().set("library-dir", ".");
+                }
+            }
+
+            if (must_compile) {
+                /* Fail if a souffle-compile executable is not found */
+                const auto souffle_compile = findTool("souffle-compile.py", souffleExecutable, ".");
+                if (!souffle_compile) throw std::runtime_error("failed to locate souffle-compile.py");
+
+                auto t_bgn = std::chrono::high_resolution_clock::now();
+                compileToBinary(*souffle_compile, sourceFilename);
+                auto t_end = std::chrono::high_resolution_clock::now();
+
+                if (Global::config().has("verbose")) {
+                    std::cout << "Compilation time: " << std::chrono::duration<double>(t_end - t_bgn).count()
+                              << "sec\n";
+                }
+            }
+
+            // run compiled C++ program if requested.
+            if (must_execute) {
+                std::string binaryFilename = baseFilename;
+#if defined(_MSC_VER)
+                binaryFilename += ".exe";
+#endif
+                executeBinaryAndExit(binaryFilename);
+            }
+        }
+    } catch (std::exception& e) {
+        std::cerr << e.what() << std::endl;
+        std::exit(EXIT_FAILURE);
+    }
+
+    /* Report overall run-time in verbose mode */
+    if (Global::config().has("verbose")) {
+        auto souffle_end = std::chrono::high_resolution_clock::now();
+        std::cout << "Total time: " << std::chrono::duration<double>(souffle_end - souffle_start).count()
+                  << "sec\n";
+    }
+
+    return 0;
+}
+
+}  // end of namespace souffle
diff --git a/src/parser/Helper.h b/src/parser/Helper.h
new file mode 100644
index 0000000..658c5ea
--- /dev/null
+++ b/src/parser/Helper.h
@@ -0,0 +1,163 @@
+/*
+ * Souffle - A Datalog Compiler
+ * Copyright Copyright (c) 2021,, Souffle Developers. All rights reserved
+ * Licensed under the Universal Permissive License v 1.0 as shown at:
+ * - https://opensource.org/licenses/UPL
+ * - <souffle root>/licenses/SOUFFLE-UPL.txt
+ */
+
+/************************************************************************
+ *
+ * @file Helper.h
+ *
+ * Workaround for memory management in parsing
+ *
+ ***********************************************************************/
+
+#pragma once
+
+#include <cstddef>
+#include <utility>
+#include <vector>
+
+namespace souffle {
+
+class ParserDriver;
+
+namespace parser {
+// FIXME: (when we can finally use Bison 3.2) Expunge this abombination.
+// HACK:  Bison 3.0.2 is stupid and ugly and doesn't support move semantics
+//        with the `lalr1.cc` skeleton and that makes me very mad.
+//        Thankfully (or not) two can play stupid games:
+//          Behold! std::auto_ptr 2: The Revengening
+// NOTE:  Bison 3.2 came out in 2019. `std::unique_ptr` appeared in C++11.
+//        How timely.
+// NOTE:  There are specialisations wrappers that'll allow us to (almost)
+//        transparently remove `Mov` once we switch to Bison 3.2+.
+
+template <typename A>
+struct Mov {
+    mutable A value;
+
+    Mov() = default;
+    Mov(Mov&&) = default;
+    template <typename B>
+    Mov(B value) : value(std::move(value)) {}
+
+    // CRIMES AGAINST COMPUTING HAPPENS HERE
+    // HACK: Pretend you can copy it, but actually move it. Keeps Bison 3.0.2 happy.
+    Mov(const Mov& x) : value(std::move(x.value)) {}
+    Mov& operator=(Mov x) {
+        value = std::move(x.value);
+        return *this;
+    }
+    // detach/convert implicitly.
+    operator A() {
+        return std::move(value);
+    }
+
+    // support ptr-like behaviour
+    A* operator->() {
+        return &value;
+    }
+    A operator*() {
+        return std::move(value);
+    }
+};
+
+template <typename A>
+A unwrap(Mov<A> x) {
+    return *x;
+}
+
+template <typename A>
+A unwrap(A x) {
+    return x;
+}
+
+template <typename A>
+struct Mov<Own<A>> {
+    mutable Own<A> value;
+
+    Mov() = default;
+    Mov(Mov&&) = default;
+    template <typename B>
+    Mov(B value) : value(std::move(value)) {}
+
+    // CRIMES AGAINST COMPUTING HAPPENS HERE
+    // HACK: Pretend you can copy it, but actually move it. Keeps Bison 3.0.2 happy.
+    Mov(const Mov& x) : value(std::move(x.value)) {}
+    Mov& operator=(Mov x) {
+        value = std::move(x.value);
+        return *this;
+    }
+    // detach/convert implicitly.
+    operator Own<A>() {
+        return std::move(value);
+    }
+    Own<A> operator*() {
+        return std::move(value);
+    }
+
+    // support ptr-like behaviour
+    A* operator->() {
+        return value.get();
+    }
+};
+
+template <typename A>
+struct Mov<std::vector<A>> {
+    mutable std::vector<A> value;
+
+    Mov() = default;
+    Mov(Mov&&) = default;
+    template <typename B>
+    Mov(B value) : value(std::move(value)) {}
+
+    // CRIMES AGAINST COMPUTING HAPPENS HERE
+    // HACK: Pretend you can copy it, but actually move it. Keeps Bison 3.0.2 happy.
+    Mov(const Mov& x) : value(std::move(x.value)) {}
+    Mov& operator=(Mov x) {
+        value = std::move(x.value);
+        return *this;
+    }
+    // detach/convert implicitly.
+    operator std::vector<A>() {
+        return std::move(value);
+    }
+    auto operator*() {
+        std::vector<decltype(unwrap(std::declval<A>()))> ys;
+        for (auto&& x : value)
+            ys.push_back(unwrap(std::move(x)));
+        return ys;
+    }
+
+    // basic ops
+    using iterator = typename std::vector<A>::iterator;
+    typename std::vector<A>::value_type& operator[](std::size_t i) {
+        return value[i];
+    }
+    iterator begin() {
+        return value.begin();
+    }
+    iterator end() {
+        return value.end();
+    }
+    void push_back(A x) {
+        value.push_back(std::move(x));
+    }
+    std::size_t size() const {
+        return value.size();
+    }
+    bool empty() const {
+        return value.empty();
+    }
+};
+}  // namespace parser
+
+template <typename A>
+parser::Mov<A> clone(const parser::Mov<A>& x) {
+    return clone(x.value);
+}
+
+}  // namespace souffle
diff --git a/src/parser/ParserDriver.cpp b/src/parser/ParserDriver.cpp
index 0755d9d..e1a1937 100644
--- a/src/parser/ParserDriver.cpp
+++ b/src/parser/ParserDriver.cpp
@@ -39,86 +39,49 @@
 #include <memory>
 #include <utility>
 #include <vector>
-#ifndef _MSC_VER
-#include <unistd.h>
-#endif
 
+using YY_BUFFER_STATE = struct yy_buffer_state*;
 extern YY_BUFFER_STATE yy_scan_string(const char*, yyscan_t scanner);
 extern int yylex_destroy(yyscan_t scanner);
 extern int yylex_init_extra(ScannerInfo* data, yyscan_t* scanner);
+extern void yyset_in(FILE* in_str, yyscan_t scanner);
 extern void yyset_debug(int, yyscan_t scanner);
 
-namespace souffle {
-
-ParserDriver::ParserDriver(Global& g) : glb(g) {
-    vfs = std::make_shared<RealFileSystem>();
-}
-
-ParserDriver::ParserDriver(Global& g, std::shared_ptr<FileSystem> fs) : glb(g) {
-    if (fs) {
-        vfs = fs;
-    } else {
-        vfs = std::make_shared<RealFileSystem>();
-    }
-}
-
-Own<ast::TranslationUnit> ParserDriver::parse(const std::string& filename, const std::string& code,
-        bool reducedConsecutiveNonLeadingWhitespaces, ErrorReport& errorReport, DebugReport& debugReport) {
-    translationUnit = mk<ast::TranslationUnit>(glb, mk<ast::Program>(), errorReport, debugReport);
-    yyscan_t scanner;
-    ScannerInfo data(vfs);
-    SrcLocation emptyLoc;
-
-    std::filesystem::path filePath(filename);
-    if (vfs->exists(filename)) {
-        std::error_code ec;
-        filePath = vfs->canonical(filename, ec);
-    }
-    data.push(filePath, emptyLoc, reducedConsecutiveNonLeadingWhitespaces);
+struct yy_buffer_state {
+    void* yy_input_file;
+    void* yy_ch_buf;
+    void* yy_buf_pos;
+    int yy_buf_size;
+    int yy_n_chars;
+    int yy_is_our_buffer;
+    int yy_is_interactive;
+    int yy_at_bol;
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+};
+
+struct yyguts_t {
+    void *yyextra_r;
+    void *yyin_r, *yyout_r;
+    size_t yy_buffer_stack_top;       /**< index of top of stack. */
+    size_t yy_buffer_stack_max;       /**< capacity of stack. */
+    yy_buffer_state** yy_buffer_stack; /**< Stack as an array. */
+};
 
-    yylex_init_extra(&data, &scanner);
-    yyset_debug(0, scanner);
-
-    yy_scan_string(code.c_str(), scanner);
-    yy::parser parser(*this, scanner);
-    parser.set_debug_level(0);
-    parser.parse();
-
-    yylex_destroy(scanner);
-
-    return std::move(translationUnit);
-}
+namespace souffle {
 
-Own<ast::TranslationUnit> ParserDriver::parseFromFS(
-        const std::filesystem::path& path, ErrorReport& errorReport, DebugReport& debugReport) {
-    translationUnit = mk<ast::TranslationUnit>(glb, mk<ast::Program>(), errorReport, debugReport);
+Own<ast::TranslationUnit> ParserDriver::parse(
+        const std::string& filename, FILE* in, ErrorReport& errorReport, DebugReport& debugReport) {
+    translationUnit = mk<ast::TranslationUnit>(mk<ast::Program>(), errorReport, debugReport);
     yyscan_t scanner;
-    ScannerInfo data(vfs);
+    ScannerInfo data;
     SrcLocation emptyLoc;
-
-    std::filesystem::path filePath(path);
-    if (!vfs->exists(filePath)) {
-        throw std::runtime_error(std::string("File does not exist: ") + filePath.string());
-    }
-
-    std::error_code ec;
-    filePath = vfs->canonical(filePath, ec);
-
+    data.push(std::filesystem::weakly_canonical(filename).string(), emptyLoc);
     yylex_init_extra(&data, &scanner);
     yyset_debug(0, scanner);
-
-    auto code = readFile(filePath, ec);
-    if (ec) {
-        throw std::runtime_error(std::string("Cannot read file: ") + filePath.string());
-    }
-
-    data.push(filePath, emptyLoc);
-
-    yy_scan_string(code->c_str(), scanner);
+    yyset_in(in, scanner);
 
     yy::parser parser(*this, scanner);
-    parser.set_debug_level(0);
-
     parser.parse();
 
     yylex_destroy(scanner);
@@ -128,20 +91,21 @@ Own<ast::TranslationUnit> ParserDriver::parseFromFS(
 
 Own<ast::TranslationUnit> ParserDriver::parse(
         const std::string& code, ErrorReport& errorReport, DebugReport& debugReport) {
-    translationUnit = mk<ast::TranslationUnit>(glb, mk<ast::Program>(), errorReport, debugReport);
+    translationUnit = mk<ast::TranslationUnit>(mk<ast::Program>(), errorReport, debugReport);
 
-    ScannerInfo data(vfs);
+    ScannerInfo data;
     SrcLocation emptyLoc;
     data.push("<in-memory>", emptyLoc);
-    data.setReported("<in-memory>");
-
     yyscan_t scanner;
     yylex_init_extra(&data, &scanner);
     yyset_debug(0, scanner);
-
     yy_scan_string(code.c_str(), scanner);
+    // Fix the wrong line and column number with memory code.
+    auto yyg = (struct yyguts_t *)(scanner);
+    yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]->yy_bs_lineno = 1;
+    yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]->yy_bs_column = 1;
+
     yy::parser parser(*this, scanner);
-    parser.set_debug_level(0);
     parser.parse();
 
     yylex_destroy(scanner);
@@ -149,23 +113,15 @@ Own<ast::TranslationUnit> ParserDriver::parse(
     return std::move(translationUnit);
 }
 
-Own<ast::TranslationUnit> ParserDriver::parseTranslationUnit(Global& glb, const std::string& filename,
-        const std::string& code, bool reducedConsecutiveNonLeadingWhitespaces, ErrorReport& errorReport,
-        DebugReport& debugReport, std::shared_ptr<FileSystem> vfs) {
-    ParserDriver parser(glb, vfs);
-    return parser.parse(filename, code, reducedConsecutiveNonLeadingWhitespaces, errorReport, debugReport);
-}
-
-Own<ast::TranslationUnit> ParserDriver::parseTranslationUnitFromFS(Global& glb,
-        const std::filesystem::path& path, ErrorReport& errorReport, DebugReport& debugReport,
-        std::shared_ptr<FileSystem> vfs) {
-    ParserDriver parser(glb, vfs);
-    return parser.parseFromFS(path, errorReport, debugReport);
+Own<ast::TranslationUnit> ParserDriver::parseTranslationUnit(
+        const std::string& filename, FILE* in, ErrorReport& errorReport, DebugReport& debugReport) {
+    ParserDriver parser;
+    return parser.parse(filename, in, errorReport, debugReport);
 }
 
-Own<ast::TranslationUnit> ParserDriver::parseTranslationUnit(Global& glb, const std::string& code,
-        ErrorReport& errorReport, DebugReport& debugReport, std::shared_ptr<FileSystem> vfs) {
-    ParserDriver parser(glb, vfs);
+Own<ast::TranslationUnit> ParserDriver::parseTranslationUnit(
+        const std::string& code, ErrorReport& errorReport, DebugReport& debugReport) {
+    ParserDriver parser;
     return parser.parse(code, errorReport, debugReport);
 }
 
@@ -248,21 +204,6 @@ void ParserDriver::addType(Own<ast::Type> type) {
     }
 }
 
-void ParserDriver::addLattice(Own<ast::Lattice> lattice) {
-    ast::Program& program = translationUnit->getProgram();
-    const auto& name = lattice->getQualifiedName();
-    auto* existingLattice = getIf(program.getLattices(),
-            [&](const ast::Lattice* current) { return current->getQualifiedName() == name; });
-    if (existingLattice != nullptr) {
-        Diagnostic err(Diagnostic::Type::ERROR,
-                DiagnosticMessage("Redefinition of lattice " + toString(name), lattice->getSrcLoc()),
-                {DiagnosticMessage("Previous definition", existingLattice->getSrcLoc())});
-        translationUnit->getErrorReport().addDiagnostic(err);
-    } else {
-        program.addLattice(std::move(lattice));
-    }
-}
-
 void ParserDriver::addClause(Own<ast::Clause> c) {
     ast::Program& program = translationUnit->getProgram();
     program.addClause(std::move(c));
@@ -293,16 +234,15 @@ void ParserDriver::addIoFromDeprecatedTag(ast::Relation& rel) {
 
 std::set<RelationTag> ParserDriver::addDeprecatedTag(
         RelationTag tag, SrcLocation tagLoc, std::set<RelationTag> tags) {
-    if (!translationUnit->global().config().has("legacy")) {
-        warning(WarnType::DeprecatedQualifier, tagLoc, tfm::format("Deprecated %s qualifier was used", tag));
+    if (!Global::config().has("legacy")) {
+        warning(tagLoc, tfm::format("Deprecated %s qualifier was used", tag));
     }
     return addTag(tag, std::move(tagLoc), std::move(tags));
 }
 
 Own<ast::Counter> ParserDriver::addDeprecatedCounter(SrcLocation tagLoc) {
-    if (!translationUnit->global().config().has("legacy")) {
-        warning(WarnType::DollarSign, tagLoc,
-                "Deprecated $ symbol was used. Use functor 'autoinc()' instead.");
+    if (!Global::config().has("legacy")) {
+        warning(tagLoc, "Deprecated $ symbol was used. Use functor 'autoinc()' instead.");
     }
     return mk<ast::Counter>();
 }
@@ -329,20 +269,15 @@ std::set<RelationTag> ParserDriver::addTag(RelationTag tag, std::vector<Relation
 
 Own<ast::SubsetType> ParserDriver::mkDeprecatedSubType(
         ast::QualifiedName name, ast::QualifiedName baseTypeName, SrcLocation loc) {
-    if (!translationUnit->global().config().has("legacy")) {
-        warning(WarnType::DeprecatedTypeDecl, loc, "Deprecated type declaration used");
+    if (!Global::config().has("legacy")) {
+        warning(loc, "Deprecated type declaration used");
     }
     return mk<ast::SubsetType>(std::move(name), std::move(baseTypeName), std::move(loc));
 }
 
-void ParserDriver::warning(const WarnType type, const SrcLocation& loc, const std::string& msg) {
-    translationUnit->getErrorReport().addWarning(type, msg, loc);
+void ParserDriver::warning(const SrcLocation& loc, const std::string& msg) {
+    translationUnit->getErrorReport().addWarning(msg, loc);
 }
-
-ast::QualifiedName ParserDriver::mkQN(std::string_view s) {
-    return ast::QualifiedName::fromString(s);
-}
-
 void ParserDriver::error(const SrcLocation& loc, const std::string& msg) {
     translationUnit->getErrorReport().addError(msg, loc);
 }
@@ -351,77 +286,36 @@ void ParserDriver::error(const std::string& msg) {
             Diagnostic(Diagnostic::Type::ERROR, DiagnosticMessage(msg)));
 }
 
-std::unique_ptr<std::string> ParserDriver::readFile(const std::filesystem::path& path, std::error_code& ec) {
-    return std::make_unique<std::string>(vfs->readFile(path, ec));
-}
-
 std::optional<std::filesystem::path> ParserDriver::searchIncludePath(
         const std::string& IncludeString, const SrcLocation& Loc) {
-    std::error_code ec;
-    std::filesystem::path Request(IncludeString);
+    std::filesystem::path Candidate(IncludeString);
 
-    if (Request.is_absolute()) {
-        if (vfs->exists(Request)) {
-            return vfs->canonical(Request, ec);
+    if (Candidate.is_absolute()) {
+        if (std::filesystem::exists(Candidate)) {
+            return std::filesystem::canonical(Candidate);
         } else {
             return std::nullopt;
         }
     }
 
-    // search relative from current physical input file
-    std::filesystem::path Candidate = std::filesystem::path(Loc.file->Physical).parent_path() / Request;
-    if (vfs->exists(Candidate)) {
-        return vfs->canonical(Candidate, ec);
-    }
-
-#if defined(__APPLE__)
-    // work-around a bug in libcxx version <= 12, std::filesystem::current_path
-    // writes out of bound and corrupt memory.
-    char* cwd = ::getcwd(nullptr, 0);
-    if (cwd == nullptr) {
-        std::cerr << "Error: cannot get current working directory.\n";
+    // search relative from current input file
+    Candidate = std::filesystem::path(Loc.file->Physical).parent_path() / IncludeString;
+    if (std::filesystem::exists(Candidate)) {
+        return std::filesystem::canonical(Candidate);
+    } else if (Candidate.is_absolute()) {
         return std::nullopt;
     }
-    const std::filesystem::path CurrentWD = std::string(cwd);
-    free(cwd);
-#else
-    const std::filesystem::path CurrentWD = std::filesystem::current_path();
-#endif
-
-    // search relative from include directories
-    for (auto&& includeDir : glb.config().getMany("include-dir")) {
-        auto dir = std::filesystem::path(includeDir);
-        if (dir.is_relative()) {
-            dir = (CurrentWD / dir);
-        }
-        Candidate = std::filesystem::path(dir) / Request;
-        if (vfs->exists(Candidate)) {
-            return vfs->canonical(Candidate, ec);
-        }
-    }
 
     return std::nullopt;
 }
 
 bool ParserDriver::canEnterOnce(const SrcLocation& onceLoc) {
-    const auto Inserted = VisitedOnceLocations.emplace(onceLoc.file->Physical, onceLoc.start.line);
+    const auto Inserted = VisitedLocations.emplace(onceLoc.file->Physical, onceLoc.start.line);
     return Inserted.second;
 }
 
-void ParserDriver::addComment(const SrcLocation& Loc, CommentKind Kind, const std::stringstream& Content) {
-    ScannedComments.emplace_back(Loc, Kind, Content.str());
-}
-
-void ParserDriver::uselessAnnotations(const ast::AnnotationList& Annotations, const std::string& context) {
-    for (const auto& Ann : Annotations) {
-        if (Ann.getKind() == ast::Annotation::Kind::DocComment) {
-            warning(WarnType::UselessDocComment, Ann.getSrcLoc(),
-                    "doc comment found " + context + ", not attached to anything");
-        } else {
-            warning(WarnType::UselessAnnotation, Ann.getSrcLoc(),
-                    "annotation found " + context + ", not attached to anything");
-        }
-    }
+void ParserDriver::addComment(const SrcLocation& Loc, const std::stringstream& Content) {
+    ScannedComments.emplace_back(Loc, Content.str());
 }
 
 }  // end of namespace souffle
diff --git a/src/parser/ParserDriver.h b/src/parser/ParserDriver.h
index 9d7bcb1..9e7cc08 100644
--- a/src/parser/ParserDriver.h
+++ b/src/parser/ParserDriver.h
@@ -17,14 +17,12 @@
 #pragma once
 
 #include "RelationTag.h"
-#include "VirtualFileSystem.h"
 #include "ast/Clause.h"
 #include "ast/Component.h"
 #include "ast/ComponentInit.h"
 #include "ast/Counter.h"
 #include "ast/Directive.h"
 #include "ast/FunctorDeclaration.h"
-#include "ast/Lattice.h"
 #include "ast/Pragma.h"
 #include "ast/QualifiedName.h"
 #include "ast/Relation.h"
@@ -45,8 +43,6 @@ namespace souffle {
 
 class ParserDriver {
 public:
-    ParserDriver(Global& g);
-    ParserDriver(Global& g, std::shared_ptr<FileSystem> fs);
     virtual ~ParserDriver() = default;
 
     void addRelation(Own<ast::Relation> r);
@@ -55,14 +51,12 @@ public:
     void addType(Own<ast::Type> type);
     void addClause(Own<ast::Clause> c);
     void addComponent(Own<ast::Component> c);
-    void addLattice(Own<ast::Lattice> l);
     void addInstantiation(Own<ast::ComponentInit> ci);
     void addPragma(Own<ast::Pragma> p);
 
     void addIoFromDeprecatedTag(ast::Relation& r);
     Own<ast::SubsetType> mkDeprecatedSubType(
             ast::QualifiedName name, ast::QualifiedName attr, SrcLocation loc);
-    ast::QualifiedName mkQN(std::string_view);
 
     std::set<RelationTag> addReprTag(RelationTag tag, SrcLocation tagLoc, std::set<RelationTag> tags);
     std::set<RelationTag> addDeprecatedTag(RelationTag tag, SrcLocation tagLoc, std::set<RelationTag> tags);
@@ -72,59 +66,33 @@ public:
 
     Own<ast::Counter> addDeprecatedCounter(SrcLocation tagLoc);
 
-    Own<ast::TranslationUnit> parse(const std::string& filename, const std::string& codein,
-            bool reducedConsecutiveNonLeadingWhitespaces, ErrorReport& errorReport, DebugReport& debugReport);
     Own<ast::TranslationUnit> parse(
+            const std::string& filename, FILE* in, ErrorReport& errorReport, DebugReport& debugReport);
+    Own<ast::TranslationUnit> parse(
+            const std::string& code, ErrorReport& errorReport, DebugReport& debugReport);
+    static Own<ast::TranslationUnit> parseTranslationUnit(
+            const std::string& filename, FILE* in, ErrorReport& errorReport, DebugReport& debugReport);
+    static Own<ast::TranslationUnit> parseTranslationUnit(
             const std::string& code, ErrorReport& errorReport, DebugReport& debugReport);
-    Own<ast::TranslationUnit> parseFromFS(
-            const std::filesystem::path& path, ErrorReport& errorReport, DebugReport& debugReport);
-
-    static Own<ast::TranslationUnit> parseTranslationUnit(Global& glb, const std::string& filename,
-            const std::string& code, bool reducedConsecutiveNonLeadingWhitespaces, ErrorReport& errorReport,
-            DebugReport& debugReport, std::shared_ptr<FileSystem> vfs = nullptr);
-    static Own<ast::TranslationUnit> parseTranslationUnit(Global& glb, const std::string& code,
-            ErrorReport& errorReport, DebugReport& debugReport, std::shared_ptr<FileSystem> vfs = nullptr);
-    static Own<ast::TranslationUnit> parseTranslationUnitFromFS(Global& glb,
-            const std::filesystem::path& path, ErrorReport& errorReport, DebugReport& debugReport,
-            std::shared_ptr<FileSystem> vfs = nullptr);
-
-    void warning(const WarnType warn, const SrcLocation& loc, const std::string& msg);
+
+    void warning(const SrcLocation& loc, const std::string& msg);
     void error(const SrcLocation& loc, const std::string& msg);
     void error(const std::string& msg);
-    void uselessAnnotations(const ast::AnnotationList&, const std::string& context);
-
-    std::unique_ptr<std::string> readFile(const std::filesystem::path& path, std::error_code& ec);
 
     std::optional<std::filesystem::path> searchIncludePath(
             const std::string& IncludeString, const SrcLocation& IncludeLoc);
 
-    // Return true if the given source location is visited for the first time by `.once`
-    // and record that source location so that next calls will return false.
-    //
-    // The source location column number is non-significant.
     bool canEnterOnce(const SrcLocation& onceLoc);
 
-    // Add a scanned comment.
-    void addComment(const SrcLocation& Loc, CommentKind kind, const std::stringstream& Content);
+    void addComment(const SrcLocation& Loc, const std::stringstream& Content);
 
     Own<ast::TranslationUnit> translationUnit;
 
     bool trace_scanning = false;
 
-    // Canonical path and line number of location that have already been
-    // visited by `.once`.
-    std::set<std::pair<std::filesystem::path, int>> VisitedOnceLocations;
-
-    /// The type of a scanned comment.
-    using ScannedComment = std::tuple<SrcLocation, CommentKind, std::string>;
-
-    /// All the scanned comments.
-    std::deque<ScannedComment> ScannedComments;
-
-private:
-    Global& glb;
+    std::set<std::pair<std::filesystem::path, int>> VisitedLocations;
 
-    std::shared_ptr<FileSystem> vfs;
+    std::deque<std::pair<SrcLocation, std::string>> ScannedComments;
 };
 
 }  // end of namespace souffle
diff --git a/src/parser/ParserUtils.cpp b/src/parser/ParserUtils.cpp
index da4d958..e6a7731 100644
--- a/src/parser/ParserUtils.cpp
+++ b/src/parser/ParserUtils.cpp
@@ -93,7 +93,7 @@ VecOwn<ast::Clause> RuleBody::toClauseBodies() const {
     // collect clause results
     VecOwn<ast::Clause> bodies;
     for (const clause& cur : dnf) {
-        bodies.push_back(mk<ast::Clause>(ast::QualifiedName::fromString("*")));
+        bodies.push_back(mk<ast::Clause>("*"));
         ast::Clause& clause = *bodies.back();
 
         for (const literal& lit : cur) {
@@ -232,7 +232,7 @@ Own<ast::Atom> nameUnnamedVariables(Own<ast::Atom> atom) {
         if (isA<ast::UnnamedVariable>(args[i])) {
             std::stringstream varName;
             varName << "@var" << i;
-            newArgs.push_back(mk<ast::Variable>(varName.str(), args[i]->getSrcLoc()));
+            newArgs.push_back(mk<ast::Variable>(varName.str()));
         } else {
             newArgs.push_back(clone(args[i]));
         }
@@ -240,154 +240,4 @@ Own<ast::Atom> nameUnnamedVariables(Own<ast::Atom> atom) {
     return mk<ast::Atom>(atom->getQualifiedName(), std::move(newArgs), atom->getSrcLoc());
 }
 
-namespace parser {
-
-namespace {
-
-template <class... Ts>
-struct overloaded : Ts... {
-    using Ts::operator()...;
-};
-// explicit deduction guide (not needed as of C++20)
-template <class... Ts>
-overloaded(Ts...) -> overloaded<Ts...>;
-
-struct Cursor {
-    explicit Cursor(const ast::TokenStream& ts) : stream(ts), index(0) {}
-    Cursor(const Cursor& other) = default;
-    Cursor(Cursor&& other) = default;
-    Cursor& operator=(const Cursor& other) = default;
-    Cursor& operator=(Cursor&& other) = default;
-
-    /// Return the next token tree and advance.
-    std::optional<std::reference_wrapper<const ast::TokenTree>> maybeNext() {
-        if (index < stream.get().size()) {
-            return stream.get()[index++];
-        }
-        return std::nullopt;
-    }
-
-private:
-    std::reference_wrapper<const ast::TokenStream> stream;
-    std::size_t index;
-};
-
-struct TokenCursor {
-    using Frame = std::pair<ast::Delimiter, Cursor>;
-
-    TokenCursor(const ast::TokenStream& ts) : frame{ast::Delimiter::None, Cursor(ts)} {}
-
-    ast::Token next() {
-        while (true) {
-            auto optTT = frame.second.maybeNext();
-            if (optTT) {
-                const ast::TokenTree& tt = optTT->get();
-
-                if (std::holds_alternative<ast::Single>(tt)) {
-                    return std::get<ast::Single>(tt).token;
-                }
-
-                if (std::holds_alternative<ast::Delimited>(tt)) {
-                    const ast::Delimited& d = std::get<ast::Delimited>(tt);
-                    const ast::Delimiter delim = d.delim;
-                    Frame newframe = std::make_pair(delim, Cursor(d.tokens));
-                    this->frames.emplace(std::move(this->frame));
-                    std::swap(newframe, this->frame);
-                    if (delim != ast::Delimiter::None) {
-                        return openToken(delim);
-                    }
-                }
-            } else if (!frames.empty()) {
-                const ast::Delimiter delim = this->frame.first;
-                std::swap(this->frame, this->frames.top());
-                this->frames.pop();
-
-                if (delim != ast::Delimiter::None) {
-                    return closeToken(delim);
-                }
-            } else {
-                ast::Token t;
-                t.kind = ast::TokenKind::Eof;
-                t.text = "";
-                return t;
-            }
-        }
-    }
-
-private:
-    /// The top frame
-    Frame frame;
-
-    /// The remaining frames
-    std::stack<Frame> frames;
-};
-
-class ParserImpl : public Parser {
-public:
-    ParserImpl(const ast::TokenStream& ts) : cursor(ts) {
-        bump();
-    }
-
-    PResult<ast::QualifiedName> parseQualifiedName() override {
-        if (check(ast::TokenKind::Ident)) {
-            ast::QualifiedName qn = ast::QualifiedName::fromString(curToken.text);
-            bump();
-            while (eat(ast::TokenKind::Dot)) {
-                if (check(ast::TokenKind::Ident)) {
-                    qn.append(curToken.text);
-                    bump();
-                } else {
-                    return Err(std::string("expected identifier"));
-                }
-            }
-            return Ok(qn);
-        }
-
-        return Err(std::string("expected identifier"));
-    }
-
-    ast::Token token() const override {
-        return curToken;
-    }
-
-    bool check(const ast::TokenKind kind) override {
-        const bool result = (curToken.kind == kind);
-        if (!result) {
-            expectedTokens.emplace_back(kind);
-        }
-        return result;
-    }
-
-    bool eat(const ast::TokenKind kind) override {
-        if (check(kind)) {
-            bump();
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    void bump() override {
-        curToken = cursor.next();
-        expectedTokens.clear();
-    }
-
-private:
-    /// Current token.
-    ast::Token curToken;
-
-    /// Position in the token stream.
-    TokenCursor cursor;
-
-    /// Tokens that were expected but not found.
-    std::vector<ast::TokenKind> expectedTokens;
-};
-
-}  // namespace
-
-std::unique_ptr<Parser> Parser::make(const ast::TokenStream& ts) {
-    return std::make_unique<ParserImpl>(ts);
-}
-}  // namespace parser
-
 }  // end of namespace souffle
diff --git a/src/parser/ParserUtils.h b/src/parser/ParserUtils.h
index d5dd893..fcc2177 100644
--- a/src/parser/ParserUtils.h
+++ b/src/parser/ParserUtils.h
@@ -29,6 +29,10 @@ namespace souffle {
 
 class RuleBody {
 public:
+    RuleBody() = default;
+    RuleBody(RuleBody&&) = default;
+    RuleBody& operator=(RuleBody&&) = default;
+
     RuleBody negated() const;
 
     void conjunct(RuleBody other);
@@ -85,78 +89,4 @@ private:
  */
 Own<ast::Atom> nameUnnamedVariables(Own<ast::Atom> atom);
 
-namespace parser {
-
-template <typename K>
-struct Ok {
-    Ok(const K& k) : value(k) {}
-    Ok(K&& k) : value(std::forward<K>(k)) {}
-    std::decay_t<K> value;
-};
-
-template <typename E>
-struct Err {
-    Err(const E& e) : value(e) {}
-    Err(E&& e) : value(std::forward<E>(e)) {}
-    std::decay_t<E> value;
-};
-
-template <typename T, typename E>
-struct Result {
-    template <typename K>
-    Result(Ok<K>&& ok) : value(std::in_place_type<T>, std::forward<K>(ok.value)) {}
-
-    template <typename X>
-    Result(Err<X>&& err) : value(std::in_place_type<E>, std::forward<X>(err.value)) {}
-
-    T& result() {
-        return std::get<T>(value);
-    }
-    const T& result() const {
-        return std::get<T>(value);
-    }
-    E& error() {
-        return std::get<E>(value);
-    }
-    const E& error() const {
-        return std::get<E>(value);
-    }
-
-    operator bool() const {
-        return std::holds_alternative<T>(value);
-    }
-
-    std::variant<T, E> value;
-};
-
-template <typename T>
-using PResult = Result<T, std::string>;
-
-class Parser {
-public:
-    virtual ~Parser() = default;
-
-    /// Return a fresh parser over the given token stream
-    static std::unique_ptr<Parser> make(const ast::TokenStream& ts);
-
-    /// Parse a qualified name
-    virtual PResult<ast::QualifiedName> parseQualifiedName() = 0;
-
-    /// Return the current token without advancing
-    virtual ast::Token token() const = 0;
-
-    /// Return true if the current token is of the given type otherwise return
-    /// false.
-    virtual bool check(ast::TokenKind) = 0;
-
-    /// If the current token is of the given type then advance to the next
-    /// token and return true.  Otherwise return false.
-    virtual bool eat(ast::TokenKind) = 0;
-
-    /// Advance to next token
-    virtual void bump() = 0;
-};
-
-}  // namespace parser
-
-}  // namespace souffle
+}  // end of namespace souffle
diff --git a/src/parser/SrcLocation.cpp b/src/parser/SrcLocation.cpp
index 69c9520..a072831 100644
--- a/src/parser/SrcLocation.cpp
+++ b/src/parser/SrcLocation.cpp
@@ -29,6 +29,9 @@
 #include <sstream>
 #include <string>
 
+#include "ExtraConfig.h"
+extern ExtraConfig extraConfig;
+
 namespace souffle {
 
 std::string SrcLocation::getReportedFilename() const {
@@ -88,9 +91,9 @@ void SrcLocation::setFile(const std::shared_ptr<IncludeStack>& f) {
 }
 
 std::string SrcLocation::extloc() const {
-    std::ifstream in(file->Reported);
+    std::ifstream fin(file->Reported);
     std::stringstream s;
-    if (in.is_open()) {
+    auto handle = [&](std::istream &in) {
         s << "file " << getReportedFilename() << " at line " << start.line << "\n";
         for (int i = 0; i < start.line - 1; ++i) {
             in.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
@@ -107,8 +110,7 @@ std::string SrcLocation::extloc() const {
             // Offset column to account for C preprocessor having reduced
             // consecutive non-leading whitespace chars to a single space.
             if (std::isspace(c) != 0) {
-                if (file->ReducedConsecutiveNonLeadingWhitespaces &&
-                        (afterFirstNonSpace && prevWhitespace && offsetColumn >= lineLen)) {
+                if (afterFirstNonSpace && prevWhitespace && offsetColumn >= lineLen) {
                     offsetColumn++;
                 }
                 prevWhitespace = true;
@@ -118,13 +120,18 @@ std::string SrcLocation::extloc() const {
             }
         }
         lineLen++;  // Add new line
-        in.close();
         s << "\n";
         for (int i = 1; i <= lineLen; i++) {
             char ch = (i == offsetColumn) ? '^' : '-';
             s << ch;
         }
-        in.close();
+    };
+    if (fin.is_open()) {
+        handle(fin);
+        fin.close();
+    } else if (extraConfig.getContent()) {
+        std::istringstream sin(*extraConfig.getContent());
+        handle(sin);
     } else {
         s << getReportedFilename() << ":" << start.line << ":" << start.column;
     }
@@ -135,35 +142,21 @@ void SrcLocation::print(std::ostream& out) const {
     out << getReportedFilename() << " [" << start << "-" << end << "]";
 }
 
-void ScannerInfo::push(
-        const std::filesystem::path& Physical, const SrcLocation& IncludeLoc, bool reducedWhitespaces) {
-    auto NewFile = std::make_shared<IncludeStack>(
-            yylloc.file, IncludeLoc.start, Physical, Physical.u8string(), reducedWhitespaces);
-    Frames.push(yylloc);
-    yylloc.file = NewFile;
-    yylloc.start = yylloc.end = {1, 1};
+void ScannerInfo::push(const std::string& Physical, const SrcLocation& IncludeLoc) {
+    yyfilename = std::make_shared<IncludeStack>(yyfilename, IncludeLoc.start, Physical, Physical);
 }
 
 void ScannerInfo::pop() {
-    if (!Frames.empty()) {
-        yylloc = Frames.top();
-        Frames.pop();
+    if (yyfilename) {
+        yyfilename = yyfilename->ParentStack;
     }
 }
 
-bool ScannerInfo::inInputFile() const {
-    return Frames.size() == 1;
-}
-
 void ScannerInfo::setReported(const std::string& Reported) {
-    if (yylloc.file && yylloc.file->Reported != Reported) {
-        yylloc.file = std::make_shared<IncludeStack>(yylloc.file->ParentStack, yylloc.file->IncludePos,
-                yylloc.file->Physical, Reported, yylloc.file->ReducedConsecutiveNonLeadingWhitespaces);
+    if (yyfilename && yyfilename->Reported != Reported) {
+        yyfilename = std::make_shared<IncludeStack>(
+                yyfilename->ParentStack, yyfilename->IncludePos, yyfilename->Physical, Reported);
     }
 }
 
-void ScannerInfo::holdInputBuffer(std::unique_ptr<std::string> Buffer) {
-    InputBuffers.push_back(std::move(Buffer));
-}
-
 }  // end of namespace souffle
diff --git a/src/parser/SrcLocation.h b/src/parser/SrcLocation.h
index 44dc010..112021a 100644
--- a/src/parser/SrcLocation.h
+++ b/src/parser/SrcLocation.h
@@ -16,18 +16,11 @@
 
 #pragma once
 
-#include "VirtualFileSystem.h"
-
-#include <filesystem>
-#include <list>
 #include <memory>
 #include <ostream>
 #include <sstream>
-#include <stack>
 #include <string>
 
-using YY_BUFFER_STATE = struct yy_buffer_state*;
-
 namespace souffle {
 
 /** A class locating a single point in an input file */
@@ -60,11 +53,9 @@ struct Point {
 
 /** A recursive include stack. */
 struct IncludeStack {
-    explicit IncludeStack(std::shared_ptr<IncludeStack> parent, Point includePos,
-            const std::filesystem::path& physical, const std::string& reported,
-            bool reducedConsecutiveNonLeadingWhitespaces = false)
-            : ParentStack(parent), IncludePos(includePos), Physical(physical), Reported(reported),
-              ReducedConsecutiveNonLeadingWhitespaces(reducedConsecutiveNonLeadingWhitespaces) {}
+    explicit IncludeStack(std::shared_ptr<IncludeStack> parent, Point includePos, const std::string& physical,
+            const std::string& reported)
+            : ParentStack(parent), IncludePos(includePos), Physical(physical), Reported(reported) {}
 
     /** The parent file. */
     const std::shared_ptr<IncludeStack> ParentStack;
@@ -73,28 +64,23 @@ struct IncludeStack {
     const Point IncludePos;
 
     /** This file. */
-    const std::filesystem::path Physical;
+    const std::string Physical;
 
-    /** The reported path for this file in UTF-8 encoding. */
+    /** The reported path for this file. */
     const std::string Reported;
-
-    /** Indicate if this input had consecutive non-leading whitespace
-     * characters replaced by a single space. */
-    const bool ReducedConsecutiveNonLeadingWhitespaces;
 };
 
 /** A class describing a range in an input file */
 class SrcLocation {
 public:
-    /** Include stack of scanned files, top is the current scanned file. It's
-     * not necessarily reflecting the actual input buffers stack. */
+    /** The file referred to */
     std::shared_ptr<IncludeStack> file;
 
     /** The start location */
-    Point start = {1, 1};
+    Point start = {};
 
     /** The End location */
-    Point end = {1, 1};
+    Point end = {};
 
     /** Return the shortened reported file name */
     std::string getReportedFilename() const;
@@ -117,16 +103,6 @@ public:
 
     void print(std::ostream& out) const;
 
-    /** Return the source location that starts where `start` starts and ends where `this` ends. */
-    SrcLocation from(const SrcLocation& start) const {
-        return SrcLocation{file, start.start, end};
-    }
-
-    /** Return the source location that starts where `this` starts and ends where `end` ends. */
-    SrcLocation upto(const SrcLocation& end) const {
-        return SrcLocation{file, start, end.end};
-    }
-
     /** Enables ranges to be printed */
     friend std::ostream& operator<<(std::ostream& out, const SrcLocation& range) {
         range.print(out);
@@ -134,29 +110,13 @@ public:
     }
 };
 
-enum class CommentKind {
-    Inline,
-    Block,
-    DocOuter,
-    DocInner,
-};
-
 /** Information struct for scanner */
 struct ScannerInfo {
-    ScannerInfo(std::shared_ptr<FileSystem> fs) : FS(fs) {}
-
     /** Scanner's current location */
     SrcLocation yylloc;
 
-    /** Stack of source location cursors for each of the currently opened
-     * physical input sources. */
-    std::stack<SrcLocation> Frames;
-
-    /** Hold the input buffers for the lifetime of the scanner. */
-    std::list<std::shared_ptr<std::string>> InputBuffers;
-
-    /** File system abstraction for this parser. */
-    std::shared_ptr<FileSystem> FS;
+    /** Include stack of scanned files, top is the current scanned file */
+    std::shared_ptr<IncludeStack> yyfilename;
 
     /** Location of last .include directive */
     SrcLocation LastIncludeDirectiveLoc;
@@ -167,24 +127,14 @@ struct ScannerInfo {
     /** Content of the current comment */
     std::stringstream CommentContent;
 
-    /** Kind of the current comment */
-    CommentKind commentKind;
-
     /** Push a file on the include stack */
-    void push(const std::filesystem::path& PhysicalPath, const SrcLocation& IncludeLoc,
-            bool reducedWhitespaces = false);
+    void push(const std::string& NewFile, const SrcLocation& IncludeLoc);
 
     /** Pop a file from the include stack */
     void pop();
 
-    /** Return true if the top of the include stack is the input file */
-    bool inInputFile() const;
-
-    /** Set the reported path for the top of the include stack (current file) */
+    /** Set the reported path for the current file */
     void setReported(const std::string& Reported);
-
-    /** Hold the given input buffer for the lifetime of the scanner. */
-    void holdInputBuffer(std::unique_ptr<std::string> Buffer);
 };
 
 }  // end of namespace souffle
diff --git a/src/parser/parser.yy b/src/parser/parser.yy
index b52ed1e..39c7177 100644
--- a/src/parser/parser.yy
+++ b/src/parser/parser.yy
@@ -14,7 +14,7 @@
  *
  ***********************************************************************/
 %skeleton "lalr1.cc"
-%require "3.2"
+%require "3.0.2"
 
 %defines
 %define api.token.constructor
@@ -22,19 +22,21 @@
 %define parse.assert
 %define api.location.type {SrcLocation}
 
+// Defined in version 3.2. This would solve a lot of the verbose `std::move`s.
+// NOTE:  Turns out becaue of another unspeakable hack (see below),
+//        we dont need as many of these `std::move`s anymore.
+// %define api.value.automove
+
 %locations
 
 %define parse.trace
 %define parse.error verbose
-%define api.value.automove
 
 /* -- Dependencies -- */
 %code requires {
     #include "AggregateOp.h"
     #include "FunctorOps.h"
-    #include "ast/Annotation.h"
-    #include "ast/IntrinsicAggregator.h"
-    #include "ast/UserDefinedAggregator.h"
+    #include "ast/Aggregator.h"
     #include "ast/AliasType.h"
     #include "ast/AlgebraicDataType.h"
     #include "ast/Argument.h"
@@ -56,8 +58,6 @@
     #include "ast/FunctionalConstraint.h"
     #include "ast/FunctorDeclaration.h"
     #include "ast/IntrinsicFunctor.h"
-    #include "ast/IterationCounter.h"
-    #include "ast/Lattice.h"
     #include "ast/Literal.h"
     #include "ast/NilConstant.h"
     #include "ast/NumericConstant.h"
@@ -69,13 +69,13 @@
     #include "ast/StringConstant.h"
     #include "ast/SubsetType.h"
     #include "ast/SubsumptiveClause.h"
-    #include "ast/TokenTree.h"
     #include "ast/Type.h"
     #include "ast/TypeCast.h"
     #include "ast/UnionType.h"
     #include "ast/UnnamedVariable.h"
     #include "ast/UserDefinedFunctor.h"
     #include "ast/Variable.h"
+    #include "parser/Helper.h"
     #include "parser/ParserUtils.h"
     #include "souffle/RamTypes.h"
     #include "souffle/BinaryConstraintOps.h"
@@ -85,20 +85,13 @@
     #include <ostream>
     #include <string>
     #include <vector>
-    #include <list>
-    #include <map>
 
     using namespace souffle;
 
-    namespace souffle {
-        class ParserDriver;
-        namespace parser {
-        }
-    }
+    using namespace souffle::parser;
 
     using yyscan_t = void*;
 
-
     #define YY_NULLPTR nullptr
 
     /* Macro to update locations as parsing proceeds */
@@ -117,19 +110,16 @@
 }
 
 %code {
-    #include "parser/ParserDriver.h"
-    #define YY_DECL yy::parser::symbol_type yylex(souffle::ParserDriver& driver, yyscan_t yyscanner)
-    YY_DECL;
+   #include "parser/ParserDriver.h"
+   #define YY_DECL yy::parser::symbol_type yylex(souffle::ParserDriver& driver, yyscan_t yyscanner)
+   YY_DECL;
 }
 
 %param { ParserDriver &driver }
 %param { yyscan_t yyscanner }
 
 /* -- Tokens -- */
-%token END 0                     "end of input"
-%token LEAVE                     "end of included file"
-%token ENTER                     "start of included file"
-%token ENDFILE                   "end of file"
+%token END 0                     "end of file"
 %token <std::string> STRING      "symbol"
 %token <std::string> IDENT       "identifier"
 %token <std::string> NUMBER      "number"
@@ -165,19 +155,16 @@
 %token TRUELIT                   "true literal constraint"
 %token FALSELIT                  "false literal constraint"
 %token PLAN                      "plan keyword"
-%token ITERATION                 "recursive iteration keyword"
 %token CHOICEDOMAIN              "choice-domain"
 %token IF                        ":-"
 %token DECL                      "relation declaration"
 %token FUNCTOR                   "functor declaration"
 %token INPUT_DECL                "input directives declaration"
 %token OUTPUT_DECL               "output directives declaration"
-%token DEBUG_DELTA               "debug_delta"
 %token PRINTSIZE_DECL            "printsize directives declaration"
 %token LIMITSIZE_DECL            "limitsize directives declaration"
 %token OVERRIDE                  "override rules of super-component"
 %token TYPE                      "type declaration"
-%token LATTICE                   "lattice declaration"
 %token COMPONENT                 "component declaration"
 %token INSTANTIATE               "component instantiation"
 %token NUMBER_TYPE               "numeric type declaration"
@@ -194,7 +181,6 @@
 %token FTOU                      "convert float to unsigned"
 %token AS                        "type cast"
 %token AT                        "@"
-%token ATNOT                     "@!"
 %token NIL                       "nil reference"
 %token PIPE                      "|"
 %token LBRACKET                  "["
@@ -224,7 +210,6 @@
 %token LE                        "<="
 %token GE                        ">="
 %token NE                        "!="
-%token MAPSTO                    "->"
 %token BW_AND                    "band"
 %token BW_OR                     "bor"
 %token BW_XOR                    "bxor"
@@ -236,77 +221,64 @@
 %token L_OR                      "lor"
 %token L_XOR                     "lxor"
 %token L_NOT                     "lnot"
-%token <std::string> OUTER_DOC_COMMENT "outer doc comment"
-%token <std::string> INNER_DOC_COMMENT "inner doc comment"
 
 /* -- Non-Terminal Types -- */
-%type <RuleBody>                          aggregate_body
+%type <Mov<RuleBody>>                          aggregate_body
 %type <AggregateOp>                            aggregate_func
-%type <Own<ast::Argument>>                arg
-%type <VecOwn<ast::Argument>>             arg_list
-%type <Own<ast::Atom>>                    atom
-%type <VecOwn<ast::Attribute>>            attributes_list
-%type <RuleBody>                          body
-%type <Own<ast::ComponentType>>           component_type
-%type <Own<ast::ComponentInit>>           component_init
-%type <Own<ast::Component>>               component_decl
-%type <Own<ast::Component>>               component_body
-%type <Own<ast::Component>>               component_head
-%type <RuleBody>                          conjunction
-%type <Own<ast::Constraint>>              constraint
-%type <Own<ast::FunctionalConstraint>>    dependency
-%type <VecOwn<ast::FunctionalConstraint>> dependency_list
-%type <VecOwn<ast::FunctionalConstraint>> dependency_list_aux
-%type <RuleBody>                          disjunction
-%type <Own<ast::ExecutionOrder>>          plan_order
-%type <Own<ast::ExecutionPlan>>           query_plan
-%type <Own<ast::ExecutionPlan>>           query_plan_list
-%type <Own<ast::Clause>>                  fact
-%type <VecOwn<ast::Attribute>>            functor_arg_type_list
-%type <std::string>                       functor_built_in
-%type <Own<ast::FunctorDeclaration>>      functor_decl
-%type <VecOwn<ast::Atom>>                 head
-%type <ast::QualifiedName>                qualified_name
-%type <VecOwn<ast::Directive>>            directive_list
-%type <VecOwn<ast::Directive>>            directive_head
+%type <Mov<Own<ast::Argument>>>                arg
+%type <Mov<VecOwn<ast::Argument>>>             arg_list
+%type <Mov<Own<ast::Atom>>>                    atom
+%type <Mov<VecOwn<ast::Attribute>>>            attributes_list
+%type <Mov<RuleBody>>                          body
+%type <Mov<Own<ast::ComponentType>>>           component_type
+%type <Mov<Own<ast::ComponentInit>>>           component_init
+%type <Mov<Own<ast::Component>>>               component_decl
+%type <Mov<Own<ast::Component>>>               component_body
+%type <Mov<Own<ast::Component>>>               component_head
+%type <Mov<RuleBody>>                          conjunction
+%type <Mov<Own<ast::Constraint>>>              constraint
+%type <Mov<Own<ast::FunctionalConstraint>>>    dependency
+%type <Mov<VecOwn<ast::FunctionalConstraint>>> dependency_list
+%type <Mov<VecOwn<ast::FunctionalConstraint>>> dependency_list_aux
+%type <Mov<RuleBody>>                          disjunction
+%type <Mov<Own<ast::ExecutionOrder>>>          plan_order
+%type <Mov<Own<ast::ExecutionPlan>>>           query_plan
+%type <Mov<Own<ast::ExecutionPlan>>>           query_plan_list
+%type <Mov<Own<ast::Clause>>>                  fact
+%type <Mov<VecOwn<ast::Attribute>>>            functor_arg_type_list
+%type <Mov<std::string>>                       functor_built_in
+%type <Mov<Own<ast::FunctorDeclaration>>>      functor_decl
+%type <Mov<VecOwn<ast::Atom>>>                 head
+%type <Mov<ast::QualifiedName>>                qualified_name
+%type <Mov<VecOwn<ast::Directive>>>            directive_list
+%type <Mov<VecOwn<ast::Directive>>>            directive_head
 %type <ast::DirectiveType>                     directive_head_decl
-%type <VecOwn<ast::Directive>>            relation_directive_list
-%type <std::string>                       kvp_value
-%type <VecOwn<ast::Argument>>             non_empty_arg_list
-%type <Own<ast::Attribute>>               attribute
-%type <VecOwn<ast::Attribute>>            non_empty_attributes
-%type <std::vector<std::string>>          non_empty_attribute_names
-%type <ast::ExecutionOrder::ExecOrder>    non_empty_plan_order_list
-%type <VecOwn<ast::Attribute>>            non_empty_functor_arg_type_list
-%type <Own<ast::Attribute>>               functor_attribute;
-%type <std::vector<std::pair<std::string, std::string>>>      non_empty_key_value_pairs
-%type <VecOwn<ast::Relation>>             relation_names
-%type <Own<ast::Pragma>>                  pragma
-%type <VecOwn<ast::Attribute>>            record_type_list
-%type <VecOwn<ast::Relation>>             relation_decl
+%type <Mov<VecOwn<ast::Directive>>>            relation_directive_list
+%type <Mov<std::string>>                       kvp_value
+%type <Mov<VecOwn<ast::Argument>>>             non_empty_arg_list
+%type <Mov<Own<ast::Attribute>>>               attribute
+%type <Mov<VecOwn<ast::Attribute>>>            non_empty_attributes
+%type <Mov<std::vector<std::string>>>          non_empty_attribute_names
+%type <Mov<ast::ExecutionOrder::ExecOrder>>    non_empty_plan_order_list
+%type <Mov<VecOwn<ast::Attribute>>>            non_empty_functor_arg_type_list
+%type <Mov<Own<ast::Attribute>>>               functor_attribute;
+%type <Mov<std::vector<std::pair
+            <std::string, std::string>>>>      non_empty_key_value_pairs
+%type <Mov<VecOwn<ast::Relation>>>             relation_names
+%type <Mov<Own<ast::Pragma>>>                  pragma
+%type <Mov<VecOwn<ast::Attribute>>>            record_type_list
+%type <Mov<VecOwn<ast::Relation>>>             relation_decl
 %type <std::set<RelationTag>>                  relation_tags
-%type <VecOwn<ast::Clause>>               rule
-%type <VecOwn<ast::Clause>>               rule_def
-%type <RuleBody>                          term
-%type <Own<ast::Type>>                    type_decl
-%type <std::vector<ast::QualifiedName>>   component_type_params
-%type <std::vector<ast::QualifiedName>>   component_param_list
-%type <std::vector<ast::QualifiedName>>   union_type_list
-%type <VecOwn<ast::BranchType>>    adt_branch_list
-%type <Own<ast::BranchType>>       adt_branch
-%type <Own<ast::Lattice>>                 lattice_decl
-%type <std::pair<ast::LatticeOperator, Own<ast::Argument>>>                 lattice_operator
-%type <std::map<ast::LatticeOperator, Own<ast::Argument>>>      lattice_operator_list
-%type <ast::AnnotationList> annotations
-%type <ast::Annotation> annotation
-%type <ast::Annotation> inner_annotation
-%type <ast::AnnotationList> inner_annotations
-%type <ast::AnnotationList> non_empty_inner_annotations
-%type <ast::TokenStream> annotation_input
-%type <ast::TokenStream> token_stream
-%type <ast::TokenTree> ident_token
-%type <ast::TokenTree> token
-%type <ast::TokenTree> delim
+%type <Mov<VecOwn<ast::Clause>>>               rule
+%type <Mov<VecOwn<ast::Clause>>>               rule_def
+%type <Mov<RuleBody>>                          term
+%type <Mov<Own<ast::Type>>>                    type_decl
+%type <Mov<std::vector<ast::QualifiedName>>>   component_type_params
+%type <Mov<std::vector<ast::QualifiedName>>>   component_param_list
+%type <Mov<std::vector<ast::QualifiedName>>>   union_type_list
+%type <Mov<VecOwn<ast::BranchType>>>    adt_branch_list
+%type <Mov<Own<ast::BranchType>>>       adt_branch
+
 /* -- Operator precedence -- */
 %left L_OR
 %left L_XOR
@@ -338,93 +310,43 @@ program
 unit
   : %empty
     { }
-  | unit annotations ENTER
-    { // the ENTER token helps resynchronizing current source location
-      // when an included file is entered
-      const auto annotations = $annotations;
-      if (!annotations.empty()) {
-        driver.uselessAnnotations(annotations, "before '.include'");
-      }
-    }
-  | unit annotations LEAVE
-    { // the LEAVE token helps resynchronizing current source location
-      // when an included file is left
-      const auto annotations = $annotations;
-      if (!annotations.empty()) {
-          driver.uselessAnnotations(annotations, "at end of included file");
-      }
-    }
-  | unit annotations ENDFILE
+  | unit directive_head
     {
-      const auto annotations = $annotations;
-      if (!annotations.empty()) {
-          driver.uselessAnnotations(annotations, "at end of file");
-      }
-    }
-  | unit annotations directive_head
-    {
-      const auto annotations = $annotations;
-      for (auto&& cur : $directive_head) {
-        cur->setAnnotations(annotations);
+      for (auto&& cur : $directive_head)
         driver.addDirective(std::move(cur));
-      }
     }
   | unit rule
     {
-      for (auto&& cur : $rule) {
+      for (auto&& cur : $rule   )
         driver.addClause(std::move(cur));
-      }
     }
   | unit fact
     {
-      auto fact = $fact;
-      driver.addClause(std::move(fact));
-    }
-  | unit annotations component_decl
-    {
-      auto component_decl = $component_decl;
-      component_decl->prependAnnotations($annotations);
-      driver.addComponent(std::move(component_decl));
+      driver.addClause($fact);
     }
-  | unit annotations component_init
+  | unit component_decl
     {
-      auto component_init = $component_init;
-      component_init->setAnnotations($annotations);
-      driver.addInstantiation(std::move(component_init));
+      driver.addComponent($component_decl);
     }
-  | unit annotations pragma
+  | unit component_init
     {
-      auto pragma = $pragma;
-      pragma->setAnnotations($annotations);
-      driver.addPragma(std::move(pragma));
+      driver.addInstantiation($component_init);
     }
-  | unit annotations type_decl
+  | unit pragma
     {
-      auto type_decl = $type_decl;
-      type_decl->setAnnotations($annotations);
-      driver.addType(std::move(type_decl));
+      driver.addPragma($pragma);
     }
-  | unit annotations lattice_decl
+  | unit type_decl
     {
-      auto lattice_decl = $lattice_decl;
-      lattice_decl->setAnnotations($annotations);
-      driver.addLattice(std::move(lattice_decl));
+      driver.addType($type_decl);
     }
-  | unit annotations functor_decl
+  | unit functor_decl
     {
-      auto functor_decl = $functor_decl;
-      functor_decl->setAnnotations($annotations);
-      driver.addFunctorDeclaration(std::move(functor_decl));
+      driver.addFunctorDeclaration($functor_decl);
     }
-  | unit annotations relation_decl
+  | unit relation_decl
     {
-      const auto annotations = $annotations;
       for (auto&& rel : $relation_decl) {
-        // Note: we duplicate annotations on every relation of the declaration.
-        //
-        // An alternative would be to allow distinct annotations before each
-        // relation name.
-        rel->setAnnotations(annotations);
         driver.addIoFromDeprecatedTag(*rel);
         driver.addRelation(std::move(rel));
       }
@@ -438,11 +360,11 @@ unit
 qualified_name
   : IDENT
     {
-      $$ = driver.mkQN($IDENT);
+      $$ = $IDENT;
     }
   | qualified_name DOT IDENT
     {
-      $$ = $1; $$.append($IDENT);
+      $$ = $1; $$->append($IDENT);
     }
   ;
 
@@ -452,47 +374,37 @@ qualified_name
 type_decl
   : TYPE IDENT SUBTYPE qualified_name
     {
-      $$ = mk<ast::SubsetType>(driver.mkQN($IDENT), $qualified_name, @$);
+      $$ = mk<ast::SubsetType>($IDENT, $qualified_name, @$);
     }
   | TYPE IDENT EQUALS union_type_list
     {
-      auto utl = $union_type_list;
-      auto id = $IDENT;
-      if (utl.size() > 1) {
-        $$ = mk<ast::UnionType>(driver.mkQN(id), utl, @$);
+      if ($union_type_list.size() > 1) {
+         $$ = mk<ast::UnionType>($IDENT, $union_type_list, @$);
       } else {
-        $$ = mk<ast::AliasType>(driver.mkQN(id), utl[0], @$);
+         assert($union_type_list.size() == 1 && "qualified name missing for alias type");
+         $$ = mk<ast::AliasType>($IDENT, $union_type_list[0], @$);
       }
     }
   | TYPE IDENT EQUALS record_type_list
     {
-      $$ = mk<ast::RecordType>(driver.mkQN($IDENT), $record_type_list, @$);
-    }
-  | TYPE IDENT EQUALS annotation annotations adt_branch_list
-    { // special case to avoid conflict in grammar with `annotations`
-
-      // insert outer annotations before inner annotations of the first branch
-      auto branches = $adt_branch_list;
-      branches.front()->prependAnnotations($annotations);
-      branches.front()->prependAnnotation($annotation);
-      $$ = mk<ast::AlgebraicDataType>(driver.mkQN($IDENT), std::move(branches), @$);
+      $$ = mk<ast::RecordType>($IDENT, $record_type_list, @$);
     }
   | TYPE IDENT EQUALS adt_branch_list
     {
-      $$ = mk<ast::AlgebraicDataType>(driver.mkQN($IDENT), $adt_branch_list, @$);
+      $$ = mk<ast::AlgebraicDataType>($IDENT, $adt_branch_list, @$);
     }
     /* Deprecated Type Declarations */
   | NUMBER_TYPE IDENT
     {
-      $$ = driver.mkDeprecatedSubType(driver.mkQN($IDENT), driver.mkQN("number"), @$);
+      $$ = driver.mkDeprecatedSubType($IDENT, "number", @$);
     }
   | SYMBOL_TYPE IDENT
     {
-      $$ = driver.mkDeprecatedSubType(driver.mkQN($IDENT), driver.mkQN("symbol"), @$);
+      $$ = driver.mkDeprecatedSubType($IDENT, "symbol", @$);
     }
   | TYPE IDENT
     {
-      $$ = driver.mkDeprecatedSubType(driver.mkQN($IDENT), driver.mkQN("symbol"), @$);
+      $$ = driver.mkDeprecatedSubType($IDENT, "symbol", @$);
     }
   ;
 
@@ -525,59 +437,24 @@ adt_branch_list
     {
       $$.push_back($adt_branch);
     }
-  | adt_branch_list PIPE annotations adt_branch
+  | adt_branch_list PIPE adt_branch
     {
       $$ = $1;
-      auto adt_branch = $adt_branch;
-      adt_branch->addAnnotations($annotations);
-      $$.emplace_back(std::move(adt_branch));
+      $$.push_back($adt_branch);
     }
   ;
 
 adt_branch
-  : IDENT[name] LBRACE inner_annotations RBRACE
+  : IDENT[name] LBRACE RBRACE
     {
-      $$ = mk<ast::BranchType>(driver.mkQN($name), VecOwn<ast::Attribute>{}, @$);
-      $$->addAnnotations($inner_annotations);
+      $$ = mk<ast::BranchType>($name, VecOwn<ast::Attribute>{}, @$);
     }
-  | IDENT[name] LBRACE inner_annotations non_empty_attributes[attributes] RBRACE
+  | IDENT[name] LBRACE non_empty_attributes[attributes] RBRACE
     {
-      $$ = mk<ast::BranchType>(driver.mkQN($name), $attributes, @$);
-      $$->addAnnotations($inner_annotations);
+      $$ = mk<ast::BranchType>($name, $attributes, @$);
     }
   ;
 
-/**
- * Lattice Declarations
- */
-
-lattice_decl
-  : LATTICE IDENT[name] LT GT LBRACE lattice_operator_list RBRACE
-    {
-      $$ = mk<ast::Lattice>(driver.mkQN($name), std::move($lattice_operator_list), @$);
-    }
-
-lattice_operator_list
-  :  lattice_operator COMMA lattice_operator_list
-    {
-      $$ = $3;
-      $$.emplace($lattice_operator);
-    }
-  | lattice_operator
-    {
-      $$.emplace($lattice_operator);
-    }
-
-lattice_operator
-  : IDENT MAPSTO arg
-    {
-      auto op = ast::latticeOperatorFromString($IDENT);
-      if (!op.has_value()) {
-        driver.error(@$, "Lattice operator not recognized");
-      }
-      $$ = std::make_pair(op.value(), std::move($arg));
-    }
-
 /**
  * Relations
  */
@@ -607,23 +484,6 @@ relation_decl
         rel->setAttributes(clone(attributes_list));
       }
     }
-  | DECL IDENT[delta] EQUALS DEBUG_DELTA LPAREN IDENT[name] RPAREN relation_tags
-    {
-      auto tags = $relation_tags;
-      $$.push_back(mk<ast::Relation>(driver.mkQN($delta), @2));
-      for (auto&& rel : $$) {
-        rel->setIsDeltaDebug(driver.mkQN($name));
-        for (auto tag : tags) {
-          if (isRelationQualifierTag(tag)) {
-            rel->addQualifier(getRelationQualifierFromTag(tag));
-          } else if (isRelationRepresentationTag(tag)) {
-            rel->setRepresentation(getRelationRepresentationFromTag(tag));
-          } else {
-            assert(false && "unhandled tag");
-          }
-        }
-      }
-    }
   ;
 
 /**
@@ -632,12 +492,12 @@ relation_decl
 relation_names
   : IDENT
     {
-      $$.push_back(mk<ast::Relation>(driver.mkQN($1), @1));
+      $$.push_back(mk<ast::Relation>($1, @1));
     }
   | relation_names COMMA IDENT
     {
       $$ = $1;
-      $$.push_back(mk<ast::Relation>(driver.mkQN($3), @3));
+      $$.push_back(mk<ast::Relation>($3, @3));
     }
   ;
 
@@ -667,17 +527,9 @@ non_empty_attributes
   ;
 
 attribute
-  : annotations IDENT[name] COLON qualified_name[type]
+  : IDENT[name] COLON qualified_name[type]
     {
-      @$ = @$.from(@name);
       $$ = mk<ast::Attribute>($name, $type, @type);
-      $$->setAnnotations($annotations);
-    }
-  | annotations IDENT[name] COLON qualified_name[type] LT GT
-    {
-      @$ = @$.from(@name);
-      $$ = mk<ast::Attribute>($name, $type, true, @type);
-      $$->setAnnotations($annotations);
     }
   ;
 
@@ -801,11 +653,9 @@ dependency_list
  * Fact
  */
 fact
-  : annotations atom DOT
+  : atom DOT
     {
-      @$ = @$.from(@2);
-      $$ = mk<ast::Clause>($atom, VecOwn<ast::Literal> {}, nullptr, @$);
-      $$->setAnnotations($annotations);
+      $$ = mk<ast::Clause>($atom, Mov<VecOwn<ast::Literal>> {}, nullptr, @$);
     }
   ;
 
@@ -825,44 +675,34 @@ rule
         rule->setExecutionPlan(clone(query_plan));
       }
     }
-   | annotations atom[less] LE atom[greater] IF inner_annotations body DOT
+   | atom[less] LE atom[greater] IF body DOT 
     {
-      @$ = @$.from(@less);
-      auto bodies = $body.toClauseBodies();
-      const auto annotations = $annotations;
-      const auto inner_annotations = $inner_annotations;
+      auto bodies = $body->toClauseBodies();
       Own<ast::Atom> lt = nameUnnamedVariables(std::move($less));
       Own<ast::Atom> gt = std::move($greater);
       for (auto&& body : bodies) {
-        auto cur = mk<ast::SubsumptiveClause>(clone(lt));
+        auto cur = mk<ast::SubsumptiveClause>(clone(lt)); 
         cur->setBodyLiterals(clone(body->getBodyLiterals()));
         auto literals = cur->getBodyLiterals();
         cur->setHead(clone(lt));
         cur->addToBodyFront(clone(gt));
         cur->addToBodyFront(clone(lt));
-        cur->setAnnotations(annotations);
-        cur->addAnnotations(inner_annotations);
         cur->setSrcLoc(@$);
         $$.push_back(std::move(cur));
       }
     }
-   | annotations atom[less] LE atom[greater] IF inner_annotations body DOT query_plan
+   | atom[less] LE atom[greater] IF body DOT query_plan
     {
-      @$ = @$.from(@less);
-      auto bodies = $body.toClauseBodies();
-      const auto annotations = $annotations;
-      const auto inner_annotations = $inner_annotations;
+      auto bodies = $body->toClauseBodies();
       Own<ast::Atom> lt = nameUnnamedVariables(std::move($less));
       Own<ast::Atom> gt = std::move($greater);
       for (auto&& body : bodies) {
-        auto cur = mk<ast::SubsumptiveClause>(clone(lt));
+        auto cur = mk<ast::SubsumptiveClause>(clone(lt)); 
         cur->setBodyLiterals(clone(body->getBodyLiterals()));
         auto literals = cur->getBodyLiterals();
         cur->setHead(clone(lt));
         cur->addToBodyFront(clone(gt));
         cur->addToBodyFront(clone(lt));
-        cur->setAnnotations(annotations);
-        cur->addAnnotations(inner_annotations);
         cur->setSrcLoc(@$);
         cur->setExecutionPlan(clone($query_plan));
         $$.push_back(std::move(cur));
@@ -874,20 +714,15 @@ rule
  * Rule Definition
  */
 rule_def
-  : head[heads] IF inner_annotations body DOT
+  : head[heads] IF body DOT
     {
-      const auto inner_annotations = $inner_annotations;
-      auto bodies = $body.toClauseBodies();
+      auto bodies = $body->toClauseBodies();
       for (auto&& head : $heads) {
         for (auto&& body : bodies) {
           auto cur = clone(body);
-          std::unique_ptr<ast::Atom> curhead = clone(head);
-          // move annotations from head to clause
-          cur->stealAnnotationsFrom(*curhead);
-          cur->addAnnotations(inner_annotations);
-          cur->setHead(std::move(curhead));
+          cur->setHead(clone(head));
           cur->setSrcLoc(@$);
-          $$.emplace_back(std::move(cur));
+          $$.push_back(std::move(cur));
         }
       }
     }
@@ -897,19 +732,13 @@ rule_def
  * Rule Head
  */
 head
-  : annotations atom
+  : atom
     {
-      @$ = @$.from(@atom);
-      auto atom = $atom;
-      atom->setAnnotations($annotations);
-      $$.emplace_back(std::move(atom));
+      $$.push_back($atom);
     }
-  | head COMMA annotations atom
+  | head COMMA atom
     {
-      $$ = $1;
-      auto atom = $atom;
-      atom->setAnnotations($annotations);
-      $$.emplace_back(std::move(atom));
+      $$ = $1; $$.push_back($atom);
     }
   ;
 
@@ -931,7 +760,7 @@ disjunction
   | disjunction SEMICOLON conjunction
     {
       $$ = $1;
-      $$.disjunct($conjunction);
+      $$->disjunct($conjunction);
     }
   ;
 
@@ -943,7 +772,7 @@ conjunction
   | conjunction COMMA term
     {
       $$ = $1;
-      $$.conjunct($term);
+      $$->conjunct($term);
     }
   ;
 
@@ -965,7 +794,7 @@ term
     }
   | EXCLAMATION term
     {
-      $$ = $2.negated();
+      $$ = $2->negated();
     }
   ;
 
@@ -1075,10 +904,6 @@ arg
     {
       $$ = mk<ast::NumericConstant>($NUMBER, @$);
     }
-  | ITERATION LPAREN RPAREN
-    {
-      $$ = mk<ast::IterationCounter>(@$);
-    }
   | UNDERSCORE
     {
       $$ = mk<ast::UnnamedVariable>(@$);
@@ -1117,11 +942,11 @@ arg
     }
   | AT IDENT LPAREN arg_list RPAREN
     {
-      $$ = mk<ast::UserDefinedFunctor>($IDENT, $arg_list, @$);
+      $$ = mk<ast::UserDefinedFunctor>($IDENT, *$arg_list, @$);
     }
   | functor_built_in LPAREN arg_list RPAREN
     {
-      $$ = mk<ast::IntrinsicFunctor>($functor_built_in, $arg_list, @$);
+      $$ = mk<ast::IntrinsicFunctor>($functor_built_in, *$arg_list, @$);
     }
 
     /* some aggregates have the same name as functors */
@@ -1153,8 +978,8 @@ arg
   | MINUS arg[nested_arg] %prec NEG
     {
       // If we have a constant that is not already negated we just negate the constant value.
-      auto nested_arg = $nested_arg;
-      const auto* asNumeric = as<ast::NumericConstant>(nested_arg);
+      auto nested_arg = *$nested_arg;
+      const auto* asNumeric = as<ast::NumericConstant>(*nested_arg);
       if (asNumeric && !isPrefix("-", asNumeric->getConstant())) {
         $$ = mk<ast::NumericConstant>("-" + asNumeric->getConstant(), asNumeric->getFixedType(), @nested_arg);
       } else { // Otherwise, create a functor.
@@ -1231,36 +1056,23 @@ arg
     {
       $$ = mk<ast::IntrinsicFunctor>(@$, ">>>", $1, $3);
     }
-    /* -- User-defined aggregators -- */
-  | AT AT IDENT arg_list[rest] COLON arg[first] COMMA aggregate_body
-    {
-      auto bodies = $aggregate_body.toClauseBodies();
-      if (bodies.size() != 1) {
-        driver.error("ERROR: disjunctions in aggregation clauses are currently not supported");
-      }
-      auto rest = $rest;
-      auto expr = rest.empty() ? nullptr : std::move(rest[0]);
-      auto body = (bodies.size() == 1) ? clone(bodies[0]->getBodyLiterals()) : VecOwn<ast::Literal> {};
-      $$ = mk<ast::UserDefinedAggregator>($IDENT, std::move($first), std::move(expr), std::move(body), @$);
-    }
+
     /* -- aggregators -- */
   | aggregate_func arg_list COLON aggregate_body
     {
-      auto aggregate_func = $aggregate_func;
-      auto arg_list = $arg_list;
-      auto bodies = $aggregate_body.toClauseBodies();
+      auto bodies = $aggregate_body->toClauseBodies();
       if (bodies.size() != 1) {
         driver.error("ERROR: disjunctions in aggregation clauses are currently not supported");
       }
       // TODO: move this to a semantic check when aggs are extended to multiple exprs
-      auto given    = arg_list.size();
-      auto required = aggregateArity(aggregate_func);
+      auto given    = $arg_list.size();
+      auto required = aggregateArity($aggregate_func);
       if (given < required.first || required.second < given) {
         driver.error("ERROR: incorrect expression arity for given aggregate mode");
       }
-      auto expr = arg_list.empty() ? nullptr : std::move(arg_list[0]);
+      auto expr = $arg_list.empty() ? nullptr : std::move($arg_list[0]);
       auto body = (bodies.size() == 1) ? clone(bodies[0]->getBodyLiterals()) : VecOwn<ast::Literal> {};
-      $$ = mk<ast::IntrinsicAggregator>(aggregate_func, std::move(expr), std::move(body), @$);
+      $$ = mk<ast::Aggregator>($aggregate_func, std::move(expr), std::move(body), @$);
     }
   ;
 
@@ -1349,7 +1161,7 @@ query_plan
 query_plan_list
   : NUMBER COLON plan_order
     {
-      $$ = mk<ast::ExecutionPlan>(@$);
+      $$ = mk<ast::ExecutionPlan>();
       $$->setOrderFor(RamSignedFromString($NUMBER), Own<ast::ExecutionOrder>($plan_order));
     }
   | query_plan_list[curr_list] COMMA NUMBER COLON plan_order
@@ -1389,17 +1201,13 @@ non_empty_plan_order_list
  * Component Declaration
  */
 component_decl
-  : component_head LBRACE component_body annotations RBRACE
+  : component_head LBRACE component_body RBRACE
     {
       auto head = $component_head;
       $$ = $component_body;
       $$->setComponentType(clone(head->getComponentType()));
-      $$->copyBaseComponents(*head);
+      $$->copyBaseComponents(**head);
       $$->setSrcLoc(@$);
-      auto annotations = $annotations;
-      if (!annotations.empty()) {
-          driver.uselessAnnotations(annotations, "at end of the component");
-      }
     }
   ;
 
@@ -1451,12 +1259,12 @@ component_type_params
 component_param_list
   : IDENT
     {
-      $$.push_back(driver.mkQN($IDENT));
+      $$.push_back($IDENT);
     }
   | component_param_list COMMA IDENT
     {
       $$ = $1;
-      $$.push_back(driver.mkQN($IDENT));
+      $$.push_back($IDENT);
     }
   ;
 
@@ -1464,102 +1272,54 @@ component_param_list
  * Component body
  */
 component_body
-  : inner_annotations
+  : %empty
     {
       $$ = mk<ast::Component>();
-      $$->addAnnotations($inner_annotations);
     }
-  | component_body annotations ENTER
+  | component_body directive_head
     {
-      const auto annotations = $annotations;
-      if (!annotations.empty()) {
-          driver.uselessAnnotations(annotations, "before '.include'");
-      }
       $$ = $1;
-    }
-  | component_body annotations LEAVE
-    {
-      const auto annotations = $annotations;
-      if (!annotations.empty()) {
-          driver.uselessAnnotations(annotations, "at end of included file");
-      }
-      $$ = $1;
-    }
-  | component_body annotations ENDFILE
-    {
-      const auto annotations = $annotations;
-      if (!annotations.empty()) {
-          driver.uselessAnnotations(annotations, "at end of file");
-      }
-      // unterminated component
-      error(@1, "unterminated component, missing '}'");
-      $$ = $1;
-    }
-  | component_body annotations directive_head
-    {
-      $$ = $1;
-      const auto annotations = $annotations;
-      for (auto&& x : $3) {
-        x->setAnnotations(annotations);
+      for (auto&& x : $2) {
         $$->addDirective(std::move(x));
       }
     }
   | component_body rule
     {
       $$ = $1;
-      for (auto&& rule : $rule) {
-        $$->addClause(std::move(rule));
+      for (auto&& x : $2) {
+        $$->addClause(std::move(x));
       }
     }
   | component_body fact
     {
       $$ = $1;
-      $$->addClause($fact);
-    }
-  | component_body annotations OVERRIDE IDENT
-    {
-      $$ = $1;
-      $$->addOverride($4);
+      $$->addClause($2);
     }
-  | component_body annotations component_init
+  | component_body OVERRIDE IDENT
     {
       $$ = $1;
-      auto component_init = $component_init;
-      component_init->setAnnotations($annotations);
-      $$->addInstantiation(std::move(component_init));
+      $$->addOverride($3);
     }
-  | component_body annotations component_decl
+  | component_body component_init
     {
       $$ = $1;
-      auto component_decl = $component_decl;
-      component_decl->prependAnnotations($annotations);
-      $$->addComponent(std::move(component_decl));
+      $$->addInstantiation($2);
     }
-  | component_body annotations type_decl
+  | component_body component_decl
     {
       $$ = $1;
-      auto type_decl = $type_decl;
-      type_decl->setAnnotations($annotations);
-      $$->addType(std::move(type_decl));
+      $$->addComponent($2);
     }
-  | component_body annotations lattice_decl
+  | component_body type_decl
     {
       $$ = $1;
-      auto lattice_decl = $lattice_decl;
-      lattice_decl->setAnnotations($annotations);
-      $$->addLattice(std::move(lattice_decl));
+      $$->addType($2);
     }
-  | component_body annotations relation_decl
+  | component_body relation_decl
     {
       $$ = $1;
-      const auto annotations = $annotations;
       for (auto&& rel : $relation_decl) {
         driver.addIoFromDeprecatedTag(*rel);
-        // Note: we duplicate annotations on every relation of the declaration.
-        //
-        // An alternative would be to allow distinct annotations before each
-        // relation name.
-        rel->setAnnotations(annotations);
         $$->addRelation(std::move(rel));
       }
     }
@@ -1616,15 +1376,13 @@ non_empty_functor_arg_type_list
   ;
 
 functor_attribute
-  : annotations qualified_name[type]
+  : qualified_name[type]
     {
       $$ = mk<ast::Attribute>("", $type, @type);
-      $$->setAnnotations($annotations);
     }
-  | annotations IDENT[name] COLON qualified_name[type]
+  | IDENT[name] COLON qualified_name[type]
     {
       $$ = mk<ast::Attribute>($name, $type, @type);
-      $$->setAnnotations($annotations);
     }
   ;
 
@@ -1755,265 +1513,6 @@ kvp_value
     }
   ;
 
-/**
- * List of annotations
- */
-
-annotations
-  : %empty
-    {
-    }
-  | annotations annotation
-    {
-      auto annotations = $1;
-      if (annotations.empty()) {
-        @$ = @2;
-      }
-      annotations.emplace_back($annotation);
-      $$ = std::move(annotations);
-    }
-  ;
-
-annotation
-  : AT LBRACKET ident_token annotation_input RBRACKET
-    {
-      ast::QualifiedName key = driver.mkQN(std::get<ast::Single>($ident_token).token.text);
-      $$ = ast::Annotation(
-              ast::Annotation::Kind::Normal, ast::Annotation::Style::Outer, key, $annotation_input, @$);
-    }
-  | OUTER_DOC_COMMENT
-    { // doc comment is a syntactic sugar for annotation `@[doc = "some doc"]`
-      ast::TokenStream ts{makeTokenTree(ast::TokenKind::Eq, "="),
-              ast::Single{ast::TokenKind::Symbol, $OUTER_DOC_COMMENT}};
-      $$ = ast::Annotation(ast::Annotation::Kind::DocComment, ast::Annotation::Style::Outer,
-              ast::QualifiedName::fromString("doc"), std::move(ts), @$);
-    }
-  ;
-
-annotation_input
-  : %empty
-    {
-    }
-  | EQUALS token token_stream
-    {
-      $$ = $token_stream;
-      $$.insert($$.begin(), $token);
-      $$.insert($$.begin(), makeTokenTree(ast::TokenKind::Eq, "="));
-    }
-  | EQUALS ident_token token_stream
-    {
-      $$ = $token_stream;
-      $$.insert($$.begin(), $ident_token);
-      $$.insert($$.begin(), makeTokenTree(ast::TokenKind::Eq, "="));
-    }
-  | EQUALS delim
-    {
-      $$ = {$delim};
-      $$.insert($$.begin(), makeTokenTree(ast::TokenKind::Eq, "="));
-    }
-  | delim
-    {
-      $$ = ast::TokenStream{$1};
-    }
-  ;
-
-inner_annotations
-  : %empty
-    {
-    }
-  | non_empty_inner_annotations
-    {
-      $$ = $1;
-    }
-  ;
-
-non_empty_inner_annotations
-  :inner_annotation
-    {
-      $$.emplace_back($1);
-    }
-  | non_empty_inner_annotations inner_annotation
-    {
-      $$ = $1;
-      $$.emplace_back($2);
-    }
-  ;
-
-inner_annotation
-  : INNER_DOC_COMMENT
-    { // doc comment is a syntactic sugar for annotation `@[doc = "some doc"]`
-      ast::TokenStream ts{makeTokenTree(ast::TokenKind::Eq, "="),
-              ast::Single{ast::TokenKind::Symbol, $INNER_DOC_COMMENT}};
-      $$ = ast::Annotation(ast::Annotation::Kind::DocComment, ast::Annotation::Style::Inner,
-              ast::QualifiedName::fromString("doc"), std::move(ts), @1);
-    }
-  | ATNOT LBRACKET ident_token annotation_input RBRACKET
-    { // we introduce ATNOT (`@!`) token because using just `@` followed by `!`
-      // cause shift/reduce conflicts in the grammar when inner annotations are followed
-      // by outter annotations of the next item:
-      //
-      // ```
-      // .comp C {
-      //   @![inner_for_C()]
-      //   @[outter_for_D()]
-      //   .decl D()
-      // }
-      // ```
-      //
-      // The parser generator (bison) is not able to lookahead for `!` after `@`. When it
-      // sees the first `@` it has two choices:
-      // - either consider empty inner_annotations and start outter_annotations
-      //   (although it would fail because of the following `!`).
-      // - or consider the start of an inner annotation.
-      //
-      // For these reason, we make the scanner detect `@!` as a single token.
-      // The scanner does not detect any variant of `@` followed by `!`
-      // if there is a whitespace or a comment in-between.
-      // I believe it is a good enough tradeoff to keep the lexer simple.
-
-      ast::QualifiedName key = driver.mkQN(std::get<ast::Single>($ident_token).token.text);
-      $$ = ast::Annotation(
-              ast::Annotation::Kind::Normal, ast::Annotation::Style::Inner, key, $annotation_input, @$);
-    }
-
-token_stream
-  : %empty { }
-  | token_stream token
-  {
-    $$ = $1;
-    $$.emplace_back($token);
-  }
-  | token_stream ident_token
-  {
-    $$ = $1;
-    $$.emplace_back($ident_token);
-  }
-  | token_stream delim
-  {
-    $$ = $1;
-    $$.emplace_back($delim);
-  }
-  ;
-
-delim
-  : LPAREN token_stream RPAREN
-  {
-    $$ = makeTokenTree(ast::Delimiter::Paren, std::move($token_stream));
-  }
-  | LBRACE token_stream RBRACE
-  {
-    $$ = makeTokenTree(ast::Delimiter::Brace, std::move($token_stream));
-  }
-  | LBRACKET token_stream RBRACKET
-  {
-    $$ = makeTokenTree(ast::Delimiter::Bracket, std::move($token_stream));
-  }
-  ;
-
-  // all tokens that look like an identifier
-ident_token
-  : IDENT     { $$ = makeTokenTree(ast::TokenKind::Ident, $IDENT); }
-  | AS                        { $$ = makeTokenTree(ast::TokenKind::Ident, "as"); }
-  | AUTOINC                   { $$ = makeTokenTree(ast::TokenKind::Ident, "autoinc"); }
-  | BRIE_QUALIFIER            { $$ = makeTokenTree(ast::TokenKind::Ident, "brie"); }
-  | BTREE_DELETE_QUALIFIER    { $$ = makeTokenTree(ast::TokenKind::Ident, "btree_delete"); }
-  | BTREE_QUALIFIER           { $$ = makeTokenTree(ast::TokenKind::Ident, "btree"); }
-  | BW_AND                    { $$ = makeTokenTree(ast::TokenKind::Ident, "band"); }
-  | BW_NOT                    { $$ = makeTokenTree(ast::TokenKind::Ident, "bnot"); }
-  | BW_OR                     { $$ = makeTokenTree(ast::TokenKind::Ident, "bor"); }
-  | BW_SHIFT_L                { $$ = makeTokenTree(ast::TokenKind::Ident, "bshl"); }
-  | BW_SHIFT_R                { $$ = makeTokenTree(ast::TokenKind::Ident, "bshr"); }
-  | BW_SHIFT_R_UNSIGNED       { $$ = makeTokenTree(ast::TokenKind::Ident, "bshru"); }
-  | BW_XOR                    { $$ = makeTokenTree(ast::TokenKind::Ident, "bxor"); }
-  | CAT                       { $$ = makeTokenTree(ast::TokenKind::Ident, "cat"); }
-  | CHOICEDOMAIN              { $$ = makeTokenTree(ast::TokenKind::Ident, "choice-domain"); }
-  | COUNT                     { $$ = makeTokenTree(ast::TokenKind::Ident, "count"); }
-  | EQREL_QUALIFIER           { $$ = makeTokenTree(ast::TokenKind::Ident, "eqrel"); }
-  | FALSELIT                  { $$ = makeTokenTree(ast::TokenKind::Ident, "false"); }
-  | INLINE_QUALIFIER          { $$ = makeTokenTree(ast::TokenKind::Ident, "inline"); }
-  | INPUT_QUALIFIER           { $$ = makeTokenTree(ast::TokenKind::Ident, "input"); }
-  | L_AND                     { $$ = makeTokenTree(ast::TokenKind::Ident, "land"); }
-  | L_NOT                     { $$ = makeTokenTree(ast::TokenKind::Ident, "lnot"); }
-  | L_OR                      { $$ = makeTokenTree(ast::TokenKind::Ident, "lor"); }
-  | L_XOR                     { $$ = makeTokenTree(ast::TokenKind::Ident, "lxor"); }
-  | MAGIC_QUALIFIER           { $$ = makeTokenTree(ast::TokenKind::Ident, "magic"); }
-  | MAX                       { $$ = makeTokenTree(ast::TokenKind::Ident, "max"); }
-  | MEAN                      { $$ = makeTokenTree(ast::TokenKind::Ident, "mean"); }
-  | MIN                       { $$ = makeTokenTree(ast::TokenKind::Ident, "min"); }
-  | NIL                       { $$ = makeTokenTree(ast::TokenKind::Ident, "nil"); }
-  | NO_INLINE_QUALIFIER       { $$ = makeTokenTree(ast::TokenKind::Ident, "no_inline"); }
-  | NO_MAGIC_QUALIFIER        { $$ = makeTokenTree(ast::TokenKind::Ident, "no_magic"); }
-  | ORD                       { $$ = makeTokenTree(ast::TokenKind::Ident, "ord"); }
-  | OUTPUT_QUALIFIER          { $$ = makeTokenTree(ast::TokenKind::Ident, "output"); }
-  | OVERRIDABLE_QUALIFIER     { $$ = makeTokenTree(ast::TokenKind::Ident, "overridable"); }
-  | PRINTSIZE_QUALIFIER       { $$ = makeTokenTree(ast::TokenKind::Ident, "printsize"); }
-  | RANGE                     { $$ = makeTokenTree(ast::TokenKind::Ident, "range"); }
-  | STATEFUL                  { $$ = makeTokenTree(ast::TokenKind::Ident, "stateful"); }
-  | STRLEN                    { $$ = makeTokenTree(ast::TokenKind::Ident, "strlen"); }
-  | SUBSTR                    { $$ = makeTokenTree(ast::TokenKind::Ident, "substr"); }
-  | SUM                       { $$ = makeTokenTree(ast::TokenKind::Ident, "sum"); }
-  | TCONTAINS                 { $$ = makeTokenTree(ast::TokenKind::Ident, "contains"); }
-  | TMATCH                    { $$ = makeTokenTree(ast::TokenKind::Ident, "match"); }
-  | TOFLOAT                   { $$ = makeTokenTree(ast::TokenKind::Ident, "to_float"); }
-  | TONUMBER                  { $$ = makeTokenTree(ast::TokenKind::Ident, "to_number"); }
-  | TOSTRING                  { $$ = makeTokenTree(ast::TokenKind::Ident, "to_string"); }
-  | TOUNSIGNED                { $$ = makeTokenTree(ast::TokenKind::Ident, "to_unsigned"); }
-  | TRUELIT                   { $$ = makeTokenTree(ast::TokenKind::Ident, "true"); }
-
-  // all tokens from the lexer except delimiters
-token
-  : FLOAT     { $$ = makeTokenTree(ast::TokenKind::Float, $FLOAT); }
-  | NUMBER    { $$ = makeTokenTree(ast::TokenKind::Number, $NUMBER); }
-  | UNSIGNED  { $$ = makeTokenTree(ast::TokenKind::Unsigned, $UNSIGNED); }
-  | STRING    { $$ = makeTokenTree(ast::TokenKind::Symbol, $STRING); }
-  // punctuations
-  | AT                        { $$ = makeTokenTree(ast::TokenKind::At, "@"); }
-  | ATNOT                     { $$ = makeTokenTree(ast::TokenKind::AtNot, "@!"); }
-  | CARET                     { $$ = makeTokenTree(ast::TokenKind::Caret, "^"); }
-  | COLON                     { $$ = makeTokenTree(ast::TokenKind::Colon, ":"); }
-  | COMMA                     { $$ = makeTokenTree(ast::TokenKind::Comma, ","); }
-  | DOLLAR                    { $$ = makeTokenTree(ast::TokenKind::Dollar, "$"); }
-  | DOT                       { $$ = makeTokenTree(ast::TokenKind::Dot, "."); }
-  | DOUBLECOLON               { $$ = makeTokenTree(ast::TokenKind::DoubleColon, "::"); }
-  | EQUALS                    { $$ = makeTokenTree(ast::TokenKind::Eq, "="); }
-  | EXCLAMATION               { $$ = makeTokenTree(ast::TokenKind::Exclamation, "!"); }
-  | GE                        { $$ = makeTokenTree(ast::TokenKind::Ge, ">="); }
-  | GT                        { $$ = makeTokenTree(ast::TokenKind::Gt, ">"); }
-  | INNER_DOC_COMMENT         { /* ignore doc comments */ }
-  | IF                        { $$ = makeTokenTree(ast::TokenKind::If, ":-"); }
-  | LE                        { $$ = makeTokenTree(ast::TokenKind::Le, "<="); }
-  | LT                        { $$ = makeTokenTree(ast::TokenKind::Lt, "<"); }
-  | MAPSTO                    { $$ = makeTokenTree(ast::TokenKind::MapsTo, "->"); }
-  | MINUS                     { $$ = makeTokenTree(ast::TokenKind::Minus, "-"); }
-  | NE                        { $$ = makeTokenTree(ast::TokenKind::Ne, "!="); }
-  | OUTER_DOC_COMMENT         { /* ignore doc comments */ }
-  | PERCENT                   { $$ = makeTokenTree(ast::TokenKind::Percent, "%"); }
-  | PIPE                      { $$ = makeTokenTree(ast::TokenKind::Pipe, "|"); }
-  | PLUS                      { $$ = makeTokenTree(ast::TokenKind::Plus, "+"); }
-  | SEMICOLON                 { $$ = makeTokenTree(ast::TokenKind::Semicolon, ";"); }
-  | SLASH                     { $$ = makeTokenTree(ast::TokenKind::Slash, "/"); }
-  | STAR                      { $$ = makeTokenTree(ast::TokenKind::Star, "*"); }
-  | SUBTYPE                   { $$ = makeTokenTree(ast::TokenKind::Subtype, "<:"); }
-  | UNDERSCORE                { $$ = makeTokenTree(ast::TokenKind::Underscore, "_"); }
-  // commands
-  | COMPONENT                 { $$ = makeTokenTree(ast::TokenKind::Ident, ".comp"); }
-  | DECL                      { $$ = makeTokenTree(ast::TokenKind::Ident, ".decl"); }
-  | FUNCTOR                   { $$ = makeTokenTree(ast::TokenKind::Ident, ".functor"); }
-  | INPUT_DECL                { $$ = makeTokenTree(ast::TokenKind::Ident, ".input"); }
-  | INSTANTIATE               { $$ = makeTokenTree(ast::TokenKind::Ident, ".init"); }
-  | LATTICE                   { $$ = makeTokenTree(ast::TokenKind::Ident, ".lattice"); }
-  | LIMITSIZE_DECL            { $$ = makeTokenTree(ast::TokenKind::Ident, ".limitsize"); }
-  | NUMBER_TYPE               { $$ = makeTokenTree(ast::TokenKind::Ident, ".number_type"); }
-  | OUTPUT_DECL               { $$ = makeTokenTree(ast::TokenKind::Ident, ".output"); }
-  | OVERRIDE                  { $$ = makeTokenTree(ast::TokenKind::Ident, ".override"); }
-  | PLAN                      { $$ = makeTokenTree(ast::TokenKind::Ident, ".plan"); }
-  | PRAGMA                    { $$ = makeTokenTree(ast::TokenKind::Ident, ".pragma"); }
-  | PRINTSIZE_DECL            { $$ = makeTokenTree(ast::TokenKind::Ident, ".printsize"); }
-  | SYMBOL_TYPE               { $$ = makeTokenTree(ast::TokenKind::Ident, ".symbol_type"); }
-  | TYPE                      { $$ = makeTokenTree(ast::TokenKind::Ident, ".type"); }
-  ;
-
-
 %%
 
 void yy::parser::error(const location_type &l, const std::string &m)
diff --git a/src/parser/scanner.ll b/src/parser/scanner.ll
index de79b47..ff99cbc 100644
--- a/src/parser/scanner.ll
+++ b/src/parser/scanner.ll
@@ -68,22 +68,17 @@
 
 #define yylloc yyget_extra(yyscanner)->yylloc
 
-#define yyinfo (*yyget_extra(yyscanner))
+#define yyfilename yyget_extra(yyscanner)->yyfilename
 
-    void update_location(YYLTYPE& loc, int leng, char* text) {
-        loc.start = loc.end;
-        for (int i = 0; i < leng; ++i) {
-          if (text[i] == '\n') {
-            loc.end.line += 1;
-            loc.end.column = 1;
-          } else {
-            loc.end.column += 1;
-          }
-        }
-    }
+#define yyinfo (*yyget_extra(yyscanner))
 
     /* Execute when matching */
-#define YY_USER_ACTION update_location(yylloc, yyleng, yytext);
+#define YY_USER_ACTION  { \
+    yylloc.start = Point({ yylineno, yycolumn }); \
+    yycolumn += yyleng;             \
+    yylloc.end   = Point({ yylineno, yycolumn }); \
+    yylloc.setFile(yyfilename); \
+}
 
     // scan a string with escape sequences, skipping surrounding double-quotes if any.
     std::string lexString(souffle::ParserDriver& driver, const SrcLocation& loc, const char* text) {
@@ -124,18 +119,13 @@
 
 %}
 
-%x BLOCK_COMMENT
-%x INLINE_COMMENT_START
-%x INLINE_COMMENT_CONT
-%x INNER_DOC_COMMENT
-%x OUTER_DOC_COMMENT
+%x COMMENT
 %x INCLUDE
-%x REALEND
 
 WS [ \t\r\v\f]
 
 /* Add line number tracking */
-%option noyywrap nounput
+%option yylineno noyywrap nounput
 
 %%
 ".decl"/{WS}                          { return yy::parser::make_DECL(yylloc); }
@@ -152,22 +142,19 @@ WS [ \t\r\v\f]
 ".override"/{WS}                      { return yy::parser::make_OVERRIDE(yylloc); }
 ".pragma"/{WS}                        { return yy::parser::make_PRAGMA(yylloc); }
 ".plan"/{WS}                          { return yy::parser::make_PLAN(yylloc); }
-".lattice"/{WS}                       { return yy::parser::make_LATTICE(yylloc); }
 ".include"                            {
                                         yyinfo.LastIncludeDirectiveLoc = yylloc;
                                         BEGIN(INCLUDE);
                                       }
 ".once"                               {
                                         if (!driver.canEnterOnce(yylloc)) {
-                                          const auto loc = yylloc;
                                           yypop_buffer_state(yyscanner);
                                           yyinfo.pop();
                                           if (!YY_CURRENT_BUFFER) {
-                                            return yy::parser::make_END(loc);
+                                            return yy::parser::make_END(yylloc);
                                           }
                                         }
                                       }
-"debug_delta"                         { return yy::parser::make_DEBUG_DELTA(yylloc); }
 "autoinc"                             { return yy::parser::make_AUTOINC(yylloc); }
 "band"                                { return yy::parser::make_BW_AND(yylloc); }
 "bor"                                 { return yy::parser::make_BW_OR(yylloc); }
@@ -215,11 +202,10 @@ WS [ \t\r\v\f]
 "to_string"                           { return yy::parser::make_TOSTRING(yylloc); }
 "to_unsigned"                         { return yy::parser::make_TOUNSIGNED(yylloc); }
 "choice-domain"                       { return yy::parser::make_CHOICEDOMAIN(yylloc); }
-"recursive_iteration_cnt"             { return yy::parser::make_ITERATION(yylloc); }
 "__FILE__"                            {
                                         return yy::parser::make_STRING(yylloc.file->Reported, yylloc);
                                       }
-"__LINE__"                            { return yy::parser::make_NUMBER(std::to_string(yylloc.start.line), yylloc); }
+"__LINE__"                            { return yy::parser::make_NUMBER(std::to_string(yylineno), yylloc); }
 "__INCL__"                            {
                                           std::string result;
                                           const IncludeStack* incl = yylloc.file.get();
@@ -245,12 +231,10 @@ WS [ \t\r\v\f]
 "]"                                   { return yy::parser::make_RBRACKET(yylloc); }
 "$"                                   { return yy::parser::make_DOLLAR(yylloc); }
 "+"                                   { return yy::parser::make_PLUS(yylloc); }
-"->"                                  { return yy::parser::make_MAPSTO(yylloc); }
 "-"                                   { return yy::parser::make_MINUS(yylloc); }
 "("                                   { return yy::parser::make_LPAREN(yylloc); }
 ")"                                   { return yy::parser::make_RPAREN(yylloc); }
 ","                                   { return yy::parser::make_COMMA(yylloc); }
-"::"                                  { return yy::parser::make_DOUBLECOLON(yylloc); }
 ":"                                   { return yy::parser::make_COLON(yylloc); }
 ";"                                   { return yy::parser::make_SEMICOLON(yylloc); }
 "."                                   { return yy::parser::make_DOT(yylloc); }
@@ -261,6 +245,7 @@ WS [ \t\r\v\f]
 "="                                   { return yy::parser::make_EQUALS(yylloc); }
 "!"                                   { return yy::parser::make_EXCLAMATION(yylloc); }
 "*"                                   { return yy::parser::make_STAR(yylloc); }
+"@"                                   { return yy::parser::make_AT(yylloc); }
 "/"                                   { return yy::parser::make_SLASH(yylloc); }
 "^"                                   { return yy::parser::make_CARET(yylloc); }
 "%"                                   { return yy::parser::make_PERCENT(yylloc); }
@@ -269,8 +254,6 @@ WS [ \t\r\v\f]
 "<"                                   { return yy::parser::make_LT(yylloc); }
 ">"                                   { return yy::parser::make_GT(yylloc); }
 ":-"                                  { return yy::parser::make_IF(yylloc); }
-"@!"                                  { return yy::parser::make_ATNOT(yylloc); }
-"@"                                   { return yy::parser::make_AT(yylloc); }
 [0-9]+"."[0-9]+"."[0-9]+"."[0-9]+     {
                                         try {
                                         char *token = std::strtok(yytext, ".");
@@ -332,131 +315,51 @@ WS [ \t\r\v\f]
 
                                             if (flag == 0) {
                                               // update
-                                              yyinfo.setReported(filename);
-                                              yylloc.start = yylloc.end = {lineno-1, 1};
+                                              yyinfo.pop();
+                                              yyinfo.push(filename, yylloc);
+                                              yycolumn = 1;
+                                              yylineno = lineno-1;
                                             } else if (flag == 1) {
-                                              yyinfo.push(filename, yylloc,
-                                                      yylloc.file->ReducedConsecutiveNonLeadingWhitespaces);
-                                              yylloc.start = yylloc.end = {lineno-1, 1};
+                                              yyinfo.push(filename, yylloc);
+                                              yycolumn = 1;
+                                              yylineno = lineno-1;
                                             } else if (flag == 2) {
-                                              yyinfo.pop();
+                                              yyinfo.pop(); // leave
+                                              // update
                                               yyinfo.setReported(filename);
-                                              yylloc.start = yylloc.end = {lineno-1, 1};
+                                              yycolumn = 1;
+                                              yylineno = lineno-1;
                                             }
                                           } else {
-                                              yylloc.start = yylloc.end = {lineno-1, 1};
+                                            yycolumn = 1;
+                                            yylineno = lineno-1;
                                           }
                                         }
                                       }
-"//"                                  {
-                                          yyinfo.CommentContent.str("");
-                                          yyinfo.CommentExtent = yylloc;
-                                          yyinfo.commentKind = CommentKind::Inline;
-                                          yyinfo.CommentContent << yytext;
-                                          BEGIN(INLINE_COMMENT_START);
+"//".*$                               {
+                                        yyinfo.CommentExtent = yylloc;
+                                        yyinfo.CommentContent.str(yytext);
+                                        driver.addComment(yyinfo.CommentExtent, yyinfo.CommentContent);
+                                        yyinfo.CommentContent.str("");
                                       }
 "/*"                                  {
-                                          yyinfo.CommentContent.str("");
-                                          yyinfo.CommentExtent = yylloc;
-                                          yyinfo.commentKind = CommentKind::Block;
-                                          yyinfo.CommentContent << yytext;
-                                          BEGIN(BLOCK_COMMENT);
-                                      }
-<INLINE_COMMENT_START>{
-"/"                                   {
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent.str("");
-                                          yyinfo.commentKind = CommentKind::DocOuter;
-                                          BEGIN(OUTER_DOC_COMMENT);
-                                      }
-"!"                                   {
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent.str("");
-                                          yyinfo.commentKind = CommentKind::DocInner;
-                                          BEGIN(INNER_DOC_COMMENT);
-                                      }
-[^/!\r\n]                             {
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent << yytext;
-                                          BEGIN(INLINE_COMMENT_CONT);
-                                      }
-\r?\n                                 {
-                                          driver.addComment(yyinfo.CommentExtent, yyinfo.commentKind, yyinfo.CommentContent);
-                                          yyinfo.CommentContent.str("");
-                                          BEGIN(INITIAL);
-                                      }
-}
-<INLINE_COMMENT_CONT>{
-[^\r\n]+                              {
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent << yytext;
-                                      }
-\r?\n{WS}*"//!"                       { // continuation of the doc comment at next line
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent << "\n";
-                                      }
-\r?\n                                 {
-                                          driver.addComment(yyinfo.CommentExtent, yyinfo.commentKind, yyinfo.CommentContent);
-                                          yyinfo.CommentContent.str("");
-                                          BEGIN(INITIAL);
-                                      }
-}
-<OUTER_DOC_COMMENT>{
-[^\r\n]+                              {
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent << yytext;
-                                      }
-\r?\n{WS}*"///"                       { // continuation of the doc comment at next line
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent << "\n";
-                                      }
-\r?\n                                 { // end of doc comment at this line
-                                          driver.addComment(yyinfo.CommentExtent, yyinfo.commentKind, yyinfo.CommentContent);
-                                          auto token = yy::parser::make_OUTER_DOC_COMMENT(
-                                                  yyinfo.CommentContent.str(), yyinfo.CommentExtent);
-                                          BEGIN(INITIAL);
-                                          return token;
-                                      }
-}
-<INNER_DOC_COMMENT>{
-[^\r\n]+                              {
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent << yytext;
-                                      }
-\r?\n{WS}*"//!"                       { // continuation of the doc comment at next line
-                                          yyinfo.CommentExtent += yylloc;
-                                          yyinfo.CommentContent << "\n";
-                                      }
-\r?\n                                 { // end of doc comment at this line
-                                          driver.addComment(yyinfo.CommentExtent, yyinfo.commentKind, yyinfo.CommentContent);
-                                          auto token = yy::parser::make_INNER_DOC_COMMENT(
-                                                        yyinfo.CommentContent.str(), yyinfo.CommentExtent);
-                                          yyinfo.CommentContent.str("");
-                                          BEGIN(INITIAL);
-                                          return token;
+                                        yyinfo.CommentContent.str("");
+                                        yyinfo.CommentExtent = yylloc;
+                                        yyinfo.CommentContent << yytext;
+                                        BEGIN(COMMENT);
                                       }
-}
-<BLOCK_COMMENT>{
+<COMMENT>{
 "*/"                                  {
                                         yyinfo.CommentExtent += yylloc;
-                                        yyinfo.CommentContent << yytext;
-                                        driver.addComment(yyinfo.CommentExtent, yyinfo.commentKind, yyinfo.CommentContent);
+                                        std::string X(yytext);
+                                        yyinfo.CommentContent << X;
+                                        driver.addComment(yyinfo.CommentExtent, yyinfo.CommentContent);
                                         yyinfo.CommentContent.str("");
                                         BEGIN(INITIAL);
                                       }
 [^*\n]+                               { yyinfo.CommentExtent += yylloc; yyinfo.CommentContent << yytext; }
 "*"                                   { yyinfo.CommentExtent += yylloc; yyinfo.CommentContent << yytext; }
 \n                                    { yyinfo.CommentExtent += yylloc; yyinfo.CommentContent << yytext; }
-<<EOF>>                               { /* unterminated comment */
-                                          const auto loc = yylloc;
-                                          yyinfo.CommentExtent += loc;
-                                          yyinfo.CommentContent << yytext;
-                                          driver.addComment(yyinfo.CommentExtent, yyinfo.commentKind, yyinfo.CommentContent);
-                                          yyinfo.CommentContent.str("");
-
-                                          driver.error(yyinfo.CommentExtent, std::string("unterminated comment block, missing '*/'"));
-                                          BEGIN(INITIAL);
-                                      }
 }
 <INCLUDE>{
 {WS}+                                 { }
@@ -464,66 +367,29 @@ WS [ \t\r\v\f]
                                         std::string path = lexString(driver, yylloc, yytext);
                                         std::optional<std::filesystem::path> maybePath = driver.searchIncludePath(path, yylloc);
                                         yyin = nullptr;
-
-                                        const auto loc = yylloc;
-                                        if (!maybePath) {
-                                          driver.error(loc, std::string("cannot find include file ") + yytext);
-                                          return yy::parser::make_END(loc);
+                                        if (maybePath) {
+                                          yyin = fopen(maybePath->string().c_str(), "r");
+                                        }
+                                        if (!yyin) {
+                                          driver.error(yylloc, std::string("cannot find include file ") + yytext);
+                                          return yy::parser::make_END(yylloc);
                                         } else {
-                                          std::error_code ec;
-                                          auto code = driver.readFile(*maybePath, ec);
-
-                                          if (ec) {
-                                            driver.error(yylloc, std::string("cannot read file ") + maybePath->u8string());
-                                            return yy::parser::make_END(loc);
-                                          }
-
-                                          auto state = yy_create_buffer(nullptr, 32768, yyscanner);
-                                          yypush_buffer_state(state, yyscanner);
-                                          yy_scan_string(code->c_str(), yyscanner);
-                                          yy_delete_buffer(state, yyscanner);
-
-                                          yyinfo.holdInputBuffer(std::move(code));
-                                          yyinfo.push(*maybePath, yyinfo.LastIncludeDirectiveLoc,
-                                                  /* not using a C preprocessor, all whitespaces are
-                                                     maintained */
-                                                  false);
+                                          yyinfo.push(maybePath->string(), yyinfo.LastIncludeDirectiveLoc);
+                                          yypush_buffer_state(yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner), yyscanner);
                                         }
                                         BEGIN(INITIAL);
-                                        // emit a token to re-synchronize source location information
-                                        // in the parser.
-                                        return yy::parser::make_ENTER(yylloc);
-                                      }
-.                                     {
-                                        driver.error(yylloc, std::string("unexpected ") + yytext);
-                                        return yy::parser::make_YYUNDEF(yylloc);
                                       }
+.                                     { driver.error(yylloc, std::string("unexpected ") + yytext); }
 }
-\n                                    { }
+\n                                    { yycolumn = 1; }
 {WS}+                                 { }
-<REALEND>{
 <<EOF>>                               {
-                                        const auto loc = yylloc;
                                         yypop_buffer_state(yyscanner);
                                         yyinfo.pop();
-                                        return yy::parser::make_END(loc);
-                                      }
-}
-<<EOF>>                               {
-                                        if (yyinfo.inInputFile()) {
-                                          BEGIN(REALEND);
-                                          return yy::parser::make_ENDFILE(yylloc);
-                                        } else {
-                                          yypop_buffer_state(yyscanner);
-                                          yyinfo.pop();
-                                          // emit a token to re-synchronize source location information
-                                          // in the parser.
-                                          return yy::parser::make_LEAVE(yylloc);
+                                        if (!YY_CURRENT_BUFFER) {
+                                          return yy::parser::make_END(yylloc);
                                         }
                                       }
-.                                     {
-                                        driver.error(yylloc, std::string("unexpected ") + yytext);
-                                        return yy::parser::make_YYUNDEF(yylloc);
-                                      }
+.                                     { driver.error(yylloc, std::string("unexpected ") + yytext); }
 %%
 // vim: filetype=lex
diff --git a/src/ram/AbstractAggregate.h b/src/ram/AbstractAggregate.h
index 897f9a5..a48d3c2 100644
--- a/src/ram/AbstractAggregate.h
+++ b/src/ram/AbstractAggregate.h
@@ -14,7 +14,7 @@
 
 #pragma once
 
-#include "ram/Aggregator.h"
+#include "AggregateOp.h"
 #include "ram/Condition.h"
 #include "ram/Expression.h"
 #include "ram/Node.h"
@@ -38,8 +38,8 @@ namespace souffle::ram {
  */
 class AbstractAggregate {
 public:
-    AbstractAggregate(Own<Aggregator> op, Own<Expression> expr, Own<Condition> cond)
-            : function(std::move(op)), expression(std::move(expr)), condition(std::move(cond)) {
+    AbstractAggregate(AggregateOp fun, Own<Expression> expr, Own<Condition> cond)
+            : function(fun), expression(std::move(expr)), condition(std::move(cond)) {
         assert(condition != nullptr && "Condition is a null-pointer");
         assert(expression != nullptr && "Expression is a null-pointer");
     }
@@ -52,9 +52,9 @@ public:
         return *condition;
     }
 
-    const Aggregator& getAggregator() const {
-        assert(function != nullptr && "Aggregator of aggregate is a null-pointer");
-        return *function;
+    /** @brief Get aggregation function */
+    AggregateOp getFunction() const {
+        return function;
     }
 
     /** @brief Get target expression */
@@ -72,28 +72,37 @@ public:
     }
 
 protected:
-    void print(std::ostream& os, int tabpos) const {
-        function->print(os, tabpos);
-        if (expression) {
+    void print(std::ostream& os, int /* tabpos */) const {
+        switch (function) {
+            case AggregateOp::MIN:
+            case AggregateOp::FMIN:
+            case AggregateOp::UMIN: os << "min "; break;
+            case AggregateOp::MAX:
+            case AggregateOp::UMAX:
+            case AggregateOp::FMAX: os << "max "; break;
+            case AggregateOp::SUM:
+            case AggregateOp::FSUM:
+            case AggregateOp::USUM: os << "sum "; break;
+            case AggregateOp::COUNT: os << "count "; break;
+            case AggregateOp::MEAN: os << "mean "; break;
+        }
+        if (function != AggregateOp::COUNT) {
             os << *expression << " ";
         }
     }
 
     bool equal(const Node& node) const {
         const auto& other = asAssert<AbstractAggregate, AllowCrossCast>(node);
-        return equal_ptr(function, other.function) && equal_ptr(expression, other.expression) &&
+        return function == other.function && equal_ptr(expression, other.expression) &&
                equal_ptr(condition, other.condition);
     }
 
     std::vector<const Node*> getChildren() const {
-        std::vector<const Node*> res = function->getChildren();
-        res.push_back(expression.get());
-        res.push_back(condition.get());
-        return res;
+        return {expression.get(), condition.get()};
     }
 
     /** Aggregation function */
-    Own<Aggregator> function;
+    const AggregateOp function;
 
     /** Aggregation expression */
     Own<Expression> expression;
diff --git a/src/ram/AbstractConditional.h b/src/ram/AbstractConditional.h
index a7ac904..1520230 100644
--- a/src/ram/AbstractConditional.h
+++ b/src/ram/AbstractConditional.h
@@ -33,6 +33,11 @@ namespace souffle::ram {
  */
 class AbstractConditional : public NestedOperation {
 public:
+    AbstractConditional(Own<Condition> cond, Own<Operation> nested, std::string profileText = "")
+            : NestedOperation(std::move(nested), std::move(profileText)), condition(std::move(cond)) {
+        assert(condition != nullptr && "Condition is a null-pointer");
+    }
+
     AbstractConditional* cloning() const override = 0;
 
     /** @brief Get condition that must be satisfied */
@@ -46,19 +51,7 @@ public:
         condition = map(std::move(condition));
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_AbstractConditional && kind < NK_LastAbstractConditional);
-    }
-
 protected:
-    AbstractConditional(
-            NodeKind kind, Own<Condition> cond, Own<Operation> nested, std::string profileText = "")
-            : NestedOperation(kind, std::move(nested), std::move(profileText)), condition(std::move(cond)) {
-        assert(condition != nullptr && "Condition is a null-pointer");
-        assert(kind >= NK_AbstractConditional && kind < NK_LastAbstractConditional);
-    }
-
     bool equal(const Node& node) const override {
         const auto& other = asAssert<AbstractConditional>(node);
         return NestedOperation::equal(node) && equal_ptr(condition, other.condition);
diff --git a/src/ram/AbstractExistenceCheck.h b/src/ram/AbstractExistenceCheck.h
index 42a4265..ffc3374 100644
--- a/src/ram/AbstractExistenceCheck.h
+++ b/src/ram/AbstractExistenceCheck.h
@@ -39,6 +39,11 @@ namespace souffle::ram {
  */
 class AbstractExistenceCheck : public Condition {
 public:
+    AbstractExistenceCheck(std::string rel, VecOwn<Expression> vals)
+            : relation(std::move(rel)), values(std::move(vals)) {
+        assert(allValidPtrs(values));
+    }
+
     /** @brief Get relation */
     const std::string& getRelation() const {
         return relation;
@@ -59,18 +64,7 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_AbstractExistenceCheck && kind < NK_LastAbstractExistenceCheck);
-    }
-
 protected:
-    AbstractExistenceCheck(NodeKind kind, std::string rel, VecOwn<Expression> vals)
-            : Condition(kind), relation(std::move(rel)), values(std::move(vals)) {
-        assert(allValidPtrs(values));
-        assert(kind >= NK_AbstractExistenceCheck && kind < NK_LastAbstractExistenceCheck);
-    }
-
     void print(std::ostream& os) const override {
         os << "(" << join(values, ",") << ") IN " << relation;
     }
diff --git a/src/ram/AbstractOperator.h b/src/ram/AbstractOperator.h
index 31d4a47..7545305 100644
--- a/src/ram/AbstractOperator.h
+++ b/src/ram/AbstractOperator.h
@@ -33,33 +33,22 @@ namespace souffle::ram {
  */
 class AbstractOperator : public Expression {
 public:
+    explicit AbstractOperator(VecOwn<Expression> args) : arguments(std::move(args)) {
+        assert(allValidPtrs(arguments));
+    }
+
     /** @brief Get argument values */
     std::vector<Expression*> getArguments() const {
         return toPtrVector(arguments);
     }
 
-    std::size_t getNumArgs() const {
-        return arguments.size();
-    }
-
     void apply(const NodeMapper& map) override {
         for (auto& arg : arguments) {
             arg = map(std::move(arg));
         }
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_AbstractOperator && kind < NK_LastAbstractOperator);
-    }
-
 protected:
-    explicit AbstractOperator(NodeKind kind, VecOwn<Expression> args)
-            : Expression(kind), arguments(std::move(args)) {
-        assert(allValidPtrs(arguments));
-        assert(kind >= NK_AbstractOperator && kind < NK_LastAbstractOperator);
-    }
-
     bool equal(const Node& node) const override {
         const auto& other = asAssert<AbstractOperator>(node);
         return equal_targets(arguments, other.arguments);
diff --git a/src/ram/Aggregate.h b/src/ram/Aggregate.h
index d59145d..9e75bde 100644
--- a/src/ram/Aggregate.h
+++ b/src/ram/Aggregate.h
@@ -47,38 +47,23 @@ namespace souffle::ram {
  */
 class Aggregate : public RelationOperation, public AbstractAggregate {
 public:
-    Aggregate(Own<Operation> nested, Own<Aggregator> fun, std::string rel, Own<Expression> expression,
+    Aggregate(Own<Operation> nested, AggregateOp fun, std::string rel, Own<Expression> expression,
             Own<Condition> condition, std::size_t ident)
-            : Aggregate(NK_Aggregate, std::move(nested), std::move(fun), rel, std::move(expression),
-                      std::move(condition), ident) {}
-
-    ~Aggregate() override = default;
+            : RelationOperation(rel, ident, std::move(nested)),
+              AbstractAggregate(fun, std::move(expression), std::move(condition)) {}
 
     Aggregate* cloning() const override {
-        return new Aggregate(NK_Aggregate, clone(getOperation()), clone(function), relation,
-                clone(expression), clone(condition), getTupleId());
+        return new Aggregate(
+                clone(getOperation()), function, relation, clone(expression), clone(condition), getTupleId());
     }
 
     void apply(const NodeMapper& map) override {
         RelationOperation::apply(map);
         condition = map(std::move(condition));
         expression = map(std::move(expression));
-        function->apply(map);
-    }
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Aggregate && kind < NK_LastAggregate);
     }
 
 protected:
-    Aggregate(NodeKind kind, Own<Operation> nested, Own<Aggregator> fun, std::string rel,
-            Own<Expression> expression, Own<Condition> condition, std::size_t ident)
-            : RelationOperation(kind, rel, ident, std::move(nested)),
-              AbstractAggregate(std::move(fun), std::move(expression), std::move(condition)) {
-        assert(kind >= NK_Aggregate && kind < NK_LastAggregate);
-    }
-
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
         os << "t" << getTupleId() << ".0 = ";
diff --git a/src/ram/AutoIncrement.h b/src/ram/AutoIncrement.h
index 9dcb011..7f59da3 100644
--- a/src/ram/AutoIncrement.h
+++ b/src/ram/AutoIncrement.h
@@ -29,16 +29,10 @@ namespace souffle::ram {
  */
 class AutoIncrement : public Expression {
 public:
-    AutoIncrement() : Expression(NK_AutoIncrement) {}
-
     AutoIncrement* cloning() const override {
         return new AutoIncrement();
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_AutoIncrement;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "AUTOINC()";
diff --git a/src/ram/BinRelationStatement.h b/src/ram/BinRelationStatement.h
index 13c2315..70875be 100644
--- a/src/ram/BinRelationStatement.h
+++ b/src/ram/BinRelationStatement.h
@@ -36,8 +36,7 @@ namespace souffle::ram {
  */
 class BinRelationStatement : public Statement {
 public:
-    BinRelationStatement(std::string f, std::string s)
-            : BinRelationStatement(NK_BinRelationStatement, std::move(f), std::move(s)) {}
+    BinRelationStatement(std::string f, std::string s) : first(std::move(f)), second(std::move(s)) {}
 
     /** @brief Get first relation */
     const std::string& getFirstRelation() const {
@@ -49,17 +48,7 @@ public:
         return second;
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_BinRelationStatement && kind < NK_LastBinRelationStatement);
-    }
-
 protected:
-    BinRelationStatement(NodeKind kind, std::string f, std::string s)
-            : Statement(kind), first(std::move(f)), second(std::move(s)) {
-        assert(kind >= NK_BinRelationStatement && kind < NK_LastBinRelationStatement);
-    }
-
     bool equal(const Node& node) const override {
         const auto& other = asAssert<BinRelationStatement>(node);
         return first == other.first && second == other.second;
diff --git a/src/ram/Break.h b/src/ram/Break.h
index 5494535..2814425 100644
--- a/src/ram/Break.h
+++ b/src/ram/Break.h
@@ -45,16 +45,12 @@ namespace souffle::ram {
 class Break : public AbstractConditional {
 public:
     Break(Own<Condition> cond, Own<Operation> nested, std::string profileText = "")
-            : AbstractConditional(NK_Break, std::move(cond), std::move(nested), std::move(profileText)) {}
+            : AbstractConditional(std::move(cond), std::move(nested), std::move(profileText)) {}
 
     Break* cloning() const override {
         return new Break(clone(condition), clone(getOperation()), getProfileText());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Break;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/Call.h b/src/ram/Call.h
index b168029..db28453 100644
--- a/src/ram/Call.h
+++ b/src/ram/Call.h
@@ -38,7 +38,7 @@ namespace souffle::ram {
 
 class Call : public Statement {
 public:
-    Call(std::string name) : Statement(NK_Call), name(std::move(name)) {}
+    Call(std::string name) : name(std::move(name)) {}
 
     /** @brief Get call name */
     const std::string& getName() const {
@@ -49,10 +49,6 @@ public:
         return new Call(name);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Call;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "CALL " << name << std::endl;
diff --git a/src/ram/Clear.h b/src/ram/Clear.h
index c215334..200b089 100644
--- a/src/ram/Clear.h
+++ b/src/ram/Clear.h
@@ -42,16 +42,12 @@ namespace souffle::ram {
 
 class Clear : public RelationStatement {
 public:
-    Clear(std::string rel) : RelationStatement(NK_Clear, rel) {}
+    Clear(std::string rel) : RelationStatement(rel) {}
 
     Clear* cloning() const override {
         return new Clear(relation);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Clear;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/Condition.h b/src/ram/Condition.h
index d5d9692..9ec696a 100644
--- a/src/ram/Condition.h
+++ b/src/ram/Condition.h
@@ -26,20 +26,8 @@ namespace souffle::ram {
  * @brief Abstract class for conditions and boolean values in RAM
  */
 class Condition : public Node {
-protected:
-    using Node::Node;
-
-    Condition(NodeKind kind) : Node(kind) {
-        assert(kind >= NK_Condition && kind < NK_LastCondition);
-    }
-
 public:
     Condition* cloning() const override = 0;
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Condition && kind < NK_LastCondition);
-    }
 };
 
 }  // namespace souffle::ram
diff --git a/src/ram/Conjunction.h b/src/ram/Conjunction.h
index 41f6df0..5636a0c 100644
--- a/src/ram/Conjunction.h
+++ b/src/ram/Conjunction.h
@@ -45,8 +45,7 @@ namespace souffle::ram {
  */
 class Conjunction : public Condition {
 public:
-    Conjunction(Own<Condition> l, Own<Condition> r)
-            : Condition(NK_Conjunction), lhs(std::move(l)), rhs(std::move(r)) {
+    Conjunction(Own<Condition> l, Own<Condition> r) : lhs(std::move(l)), rhs(std::move(r)) {
         assert(lhs != nullptr && "left-hand side of conjunction is a nullptr");
         assert(rhs != nullptr && "right-hand side of conjunction is a nullptr");
     }
@@ -70,10 +69,6 @@ public:
         rhs = map(std::move(rhs));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Conjunction;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "(" << *lhs << " AND " << *rhs << ")";
diff --git a/src/ram/Constraint.h b/src/ram/Constraint.h
index 2a93eb8..ab9214a 100644
--- a/src/ram/Constraint.h
+++ b/src/ram/Constraint.h
@@ -47,7 +47,7 @@ namespace souffle::ram {
 class Constraint : public Condition {
 public:
     Constraint(BinaryConstraintOp op, Own<Expression> l, Own<Expression> r)
-            : Condition(NK_Constraint), op(op), lhs(std::move(l)), rhs(std::move(r)) {
+            : op(op), lhs(std::move(l)), rhs(std::move(r)) {
         assert(lhs != nullptr && "left-hand side of constraint is a null-pointer");
         assert(rhs != nullptr && "right-hand side of constraint is a null-pointer");
     }
@@ -76,10 +76,6 @@ public:
         rhs = map(std::move(rhs));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Constraint;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "(" << *lhs << " ";
diff --git a/src/ram/CountUniqueKeys.h b/src/ram/CountUniqueKeys.h
new file mode 100644
index 0000000..252dee1
--- /dev/null
+++ b/src/ram/CountUniqueKeys.h
@@ -0,0 +1,107 @@
+/*
+ * Souffle - A Datalog Compiler
+ * Copyright (c) 2022, The Souffle Developers. All rights reserved
+ * Licensed under the Universal Permissive License v 1.0 as shown at:
+ * - https://opensource.org/licenses/UPL
+ * - <souffle root>/licenses/SOUFFLE-UPL.txt
+ */
+
+/************************************************************************
+ *
+ * @file CountUniqueKeys.h
+ *
+ ***********************************************************************/
+
+#pragma once
+
+#include "ram/Expression.h"
+#include "ram/Node.h"
+#include "ram/Relation.h"
+#include "ram/RelationStatement.h"
+#include "souffle/utility/MiscUtil.h"
+#include "souffle/utility/StreamUtil.h"
+#include "souffle/utility/StringUtil.h"
+#include <memory>
+#include <ostream>
+#include <string>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+namespace souffle::ram {
+
+/**
+ * @class CountUniqueKeys
+ * @brief Count the number of unique keys on a relation given the key columns etc.
+ *
+ * This statement counts the number of unique keys in a relation.
+
+* For example:
+* ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+* UNIQUEKEYCOUNT rel A0 = 1, A1
+* ~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ * Counts the number of tuples in rel with a unique value for attribute 1,
+ * while also having the first attribute with a value of 1
+ */
+class CountUniqueKeys : public RelationStatement {
+public:
+    CountUniqueKeys(std::string rel, const std::vector<std::size_t>& columns,
+            const std::map<std::size_t, const ram::Expression*>& keyToConstants, bool isRecursive)
+            : RelationStatement(rel), keyColumns(columns), recursiveRelation(isRecursive) {
+        // copy the constants over
+        for (auto [k, constant] : keyToConstants) {
+            auto clonedConstant = clone(constant);
+            constantsMap[k] = clonedConstant.get();
+            constants.push_back(std::move(clonedConstant));
+        }
+    }
+
+    const std::vector<std::size_t>& getKeyColumns() const {
+        return keyColumns;
+    }
+
+    const std::map<std::size_t, const ram::Expression*>& getConstantsMap() const {
+        return constantsMap;
+    }
+
+    bool isRecursiveRelation() const {
+        return recursiveRelation;
+    }
+
+    CountUniqueKeys* cloning() const override {
+        return new CountUniqueKeys(relation, keyColumns, constantsMap, recursiveRelation);
+    }
+
+protected:
+    void print(std::ostream& os, int tabpos) const override {
+        os << times(" ", tabpos) << (recursiveRelation ? "REC" : "") << "UNIQUEKEYCOUNT " << relation << " ";
+        bool first = true;
+        for (auto k : keyColumns) {
+            if (first) {
+                first = false;
+            } else {
+                os << ", ";
+            }
+            os << "A" << k;
+            if (constantsMap.count(k)) {
+                os << " = " << *constantsMap.at(k);
+            }
+        }
+        os << std::endl;
+    }
+
+    bool equal(const Node& node) const override {
+        const auto& other = asAssert<CountUniqueKeys>(node);
+        return RelationStatement::equal(other) && keyColumns == other.getKeyColumns() &&
+               constantsMap == other.getConstantsMap() && recursiveRelation == other.isRecursiveRelation();
+    }
+
+    std::vector<std::size_t> keyColumns;
+    std::map<std::size_t, const ram::Expression*> constantsMap;
+    VecOwn<const ram::Expression> constants;
+    bool recursiveRelation;
+};
+
+}  // namespace souffle::ram
diff --git a/src/ram/DebugInfo.h b/src/ram/DebugInfo.h
index cc2e8e9..bf698c1 100644
--- a/src/ram/DebugInfo.h
+++ b/src/ram/DebugInfo.h
@@ -41,8 +41,7 @@ namespace souffle::ram {
  */
 class DebugInfo : public Statement, public AbstractLog {
 public:
-    DebugInfo(Own<Statement> stmt, std::string msg)
-            : Statement(NK_DebugInfo), AbstractLog(std::move(stmt), std::move(msg)) {}
+    DebugInfo(Own<Statement> stmt, std::string msg) : AbstractLog(std::move(stmt), std::move(msg)) {}
 
     DebugInfo* cloning() const override {
         return new DebugInfo(clone(statement), message);
@@ -52,10 +51,6 @@ public:
         AbstractLog::apply(map);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_DebugInfo;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "DEBUG \"" << stringify(message) << "\"" << std::endl;
diff --git a/src/ram/EmptinessCheck.h b/src/ram/EmptinessCheck.h
index 0284a05..31ba7a5 100644
--- a/src/ram/EmptinessCheck.h
+++ b/src/ram/EmptinessCheck.h
@@ -44,7 +44,7 @@ namespace souffle::ram {
  */
 class EmptinessCheck : public Condition {
 public:
-    EmptinessCheck(std::string rel) : Condition(NK_EmptinessCheck), relation(std::move(rel)) {}
+    EmptinessCheck(std::string rel) : relation(std::move(rel)) {}
 
     /** @brief Get relation */
     const std::string& getRelation() const {
@@ -55,10 +55,6 @@ public:
         return new EmptinessCheck(relation);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_EmptinessCheck;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "ISEMPTY(" << relation << ")";
diff --git a/src/ram/Erase.h b/src/ram/Erase.h
index 8b95529..14b705b 100644
--- a/src/ram/Erase.h
+++ b/src/ram/Erase.h
@@ -46,8 +46,8 @@ namespace souffle::ram {
 class Erase : public Operation {
 public:
     Erase(std::string rel, VecOwn<Expression> expressions)
-            : Operation(NK_Erase), relation(std::move(rel)), expressions(std::move(expressions)) {
-        for ([[maybe_unused]] auto const& expr : expressions) {
+            : relation(std::move(rel)), expressions(std::move(expressions)) {
+        for (auto const& expr : expressions) {
             assert(expr != nullptr && "Expression is a null-pointer");
         }
     }
@@ -84,10 +84,6 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Erase;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/ExistenceCheck.h b/src/ram/ExistenceCheck.h
index ac8a955..c201708 100644
--- a/src/ram/ExistenceCheck.h
+++ b/src/ram/ExistenceCheck.h
@@ -41,8 +41,7 @@ namespace souffle::ram {
  */
 class ExistenceCheck : public AbstractExistenceCheck {
 public:
-    ExistenceCheck(std::string rel, VecOwn<Expression> vals)
-            : AbstractExistenceCheck(NK_ExistenceCheck, rel, std::move(vals)) {}
+    ExistenceCheck(std::string rel, VecOwn<Expression> vals) : AbstractExistenceCheck(rel, std::move(vals)) {}
 
     ExistenceCheck* cloning() const override {
         VecOwn<Expression> newValues;
@@ -51,10 +50,6 @@ public:
         }
         return new ExistenceCheck(relation, std::move(newValues));
     }
-
-    static bool classof(const Node* n) {
-        return n->getKind() == Node::NK_ExistenceCheck;
-    }
 };
 
 }  // namespace souffle::ram
diff --git a/src/ram/Exit.h b/src/ram/Exit.h
index 868eac8..fa4a74a 100644
--- a/src/ram/Exit.h
+++ b/src/ram/Exit.h
@@ -42,7 +42,7 @@ namespace souffle::ram {
  */
 class Exit : public Statement {
 public:
-    Exit(Own<Condition> c) : Statement(NK_Exit), condition(std::move(c)) {
+    Exit(Own<Condition> c) : condition(std::move(c)) {
         assert(condition && "condition is a nullptr");
     }
 
@@ -59,10 +59,6 @@ public:
         condition = map(std::move(condition));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Exit;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "EXIT " << getCondition() << std::endl;
diff --git a/src/ram/Expression.h b/src/ram/Expression.h
index 6dea354..312aa9b 100644
--- a/src/ram/Expression.h
+++ b/src/ram/Expression.h
@@ -17,7 +17,6 @@
 #pragma once
 
 #include "ram/Node.h"
-#include <cassert>
 
 namespace souffle::ram {
 
@@ -26,19 +25,7 @@ namespace souffle::ram {
  * @brief Abstract class for describing scalar values in RAM
  */
 class Expression : public Node {
-protected:
-    using Node::Node;
-
-    explicit Expression(NodeKind kind) : Node(kind) {
-        assert(kind >= NK_Expression && kind < NK_LastExpression);
-    }
-
 public:
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Expression && kind < NK_LastExpression);
-    }
-
     Expression* cloning() const override = 0;
 };
 
diff --git a/src/ram/False.h b/src/ram/False.h
index 2bd0023..0ef4aaa 100644
--- a/src/ram/False.h
+++ b/src/ram/False.h
@@ -30,16 +30,10 @@ namespace souffle::ram {
  */
 class False : public Condition {
 public:
-    False() : Condition(NK_False) {}
-
     False* cloning() const override {
         return new False();
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_False;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "FALSE";
diff --git a/src/ram/Filter.h b/src/ram/Filter.h
index ae59400..5bb47ce 100644
--- a/src/ram/Filter.h
+++ b/src/ram/Filter.h
@@ -45,16 +45,12 @@ namespace souffle::ram {
 class Filter : public AbstractConditional {
 public:
     Filter(Own<Condition> cond, Own<Operation> nested, std::string profileText = "")
-            : AbstractConditional(NK_Filter, std::move(cond), std::move(nested), std::move(profileText)) {}
+            : AbstractConditional(std::move(cond), std::move(nested), std::move(profileText)) {}
 
     Filter* cloning() const override {
         return new Filter(clone(condition), clone(getOperation()), getProfileText());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Filter;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/FloatConstant.h b/src/ram/FloatConstant.h
index ee74611..6a19ed4 100644
--- a/src/ram/FloatConstant.h
+++ b/src/ram/FloatConstant.h
@@ -33,7 +33,7 @@ namespace souffle::ram {
  */
 class FloatConstant : public NumericConstant {
 public:
-    explicit FloatConstant(RamFloat val) : NumericConstant(NK_FloatConstant, ramBitCast(val)) {}
+    explicit FloatConstant(RamFloat val) : NumericConstant(ramBitCast(val)) {}
 
     /** @brief Get value of the constant. */
     RamFloat getValue() const {
@@ -45,10 +45,6 @@ public:
         return new FloatConstant(getValue());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_FloatConstant;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "FLOAT(" << getValue() << ")";
diff --git a/src/ram/GuardedInsert.h b/src/ram/GuardedInsert.h
index 2acca2f..7edbbbe 100644
--- a/src/ram/GuardedInsert.h
+++ b/src/ram/GuardedInsert.h
@@ -44,7 +44,7 @@ namespace souffle::ram {
 class GuardedInsert : public Insert {
 public:
     GuardedInsert(std::string rel, VecOwn<Expression> expressions, Own<Condition> condition = mk<True>())
-            : Insert(NK_GuardedInsert, rel, std::move(expressions)), condition(std::move(condition)) {}
+            : Insert(rel, std::move(expressions)), condition(std::move(condition)) {}
 
     /** @brief Get guarded condition */
     const Condition* getCondition() const {
@@ -67,10 +67,6 @@ public:
         condition = map(std::move(condition));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_GuardedInsert;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/IO.h b/src/ram/IO.h
index c8641da..59d38c0 100644
--- a/src/ram/IO.h
+++ b/src/ram/IO.h
@@ -38,7 +38,7 @@ namespace souffle::ram {
 class IO : public RelationStatement {
 public:
     IO(std::string rel, std::map<std::string, std::string> directives)
-            : RelationStatement(NK_IO, rel), directives(std::move(directives)) {}
+            : RelationStatement(rel), directives(std::move(directives)) {}
 
     /** @brief get I/O directives */
     const std::map<std::string, std::string>& getDirectives() const {
@@ -54,10 +54,6 @@ public:
         return new IO(relation, directives);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_IO;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/IfExists.h b/src/ram/IfExists.h
index df29167..7aed685 100644
--- a/src/ram/IfExists.h
+++ b/src/ram/IfExists.h
@@ -53,7 +53,8 @@ class IfExists : public RelationOperation, public AbstractIfExists {
 public:
     IfExists(std::string rel, std::size_t ident, Own<Condition> cond, Own<Operation> nested,
             std::string profileText = "")
-            : IfExists(NK_IfExists, rel, ident, clone(cond), clone(nested), profileText) {}
+            : RelationOperation(rel, ident, std::move(nested), std::move(profileText)),
+              AbstractIfExists(std::move(cond)) {}
 
     void apply(const NodeMapper& map) override {
         RelationOperation::apply(map);
@@ -61,21 +62,11 @@ public:
     }
 
     IfExists* cloning() const override {
-        return new IfExists(NK_IfExists, relation, getTupleId(), clone(condition), clone(getOperation()),
-                getProfileText());
-    }
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_IfExists && kind < NK_LastIfExists);
+        return new IfExists(
+                relation, getTupleId(), clone(condition), clone(getOperation()), getProfileText());
     }
 
 protected:
-    IfExists(NodeKind kind, std::string rel, std::size_t ident, Own<Condition> cond, Own<Operation> nested,
-            std::string profileText = "")
-            : RelationOperation(kind, rel, ident, std::move(nested), std::move(profileText)),
-              AbstractIfExists(std::move(cond)) {}
-
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
         os << "IF EXISTS t" << getTupleId();
diff --git a/src/ram/IndexAggregate.h b/src/ram/IndexAggregate.h
index 3b7d6c8..c07e330 100644
--- a/src/ram/IndexAggregate.h
+++ b/src/ram/IndexAggregate.h
@@ -45,10 +45,10 @@ namespace souffle::ram {
  */
 class IndexAggregate : public IndexOperation, public AbstractAggregate {
 public:
-    IndexAggregate(Own<Operation> nested, Own<Aggregator> fun, std::string rel, Own<Expression> expression,
+    IndexAggregate(Own<Operation> nested, AggregateOp fun, std::string rel, Own<Expression> expression,
             Own<Condition> condition, RamPattern queryPattern, std::size_t ident)
-            : IndexAggregate(NK_IndexAggregate, std::move(nested), std::move(fun), rel, std::move(expression),
-                      std::move(condition), std::move(queryPattern), ident) {}
+            : IndexOperation(rel, ident, std::move(queryPattern), std::move(nested)),
+              AbstractAggregate(fun, std::move(expression), std::move(condition)) {}
 
     IndexAggregate* cloning() const override {
         RamPattern pattern;
@@ -58,30 +58,17 @@ public:
         for (const auto& i : queryPattern.second) {
             pattern.second.emplace_back(i->cloning());
         }
-        return new IndexAggregate(NK_IndexAggregate, clone(getOperation()), clone(function), relation,
-                clone(expression), clone(condition), std::move(pattern), getTupleId());
+        return new IndexAggregate(clone(getOperation()), function, relation, clone(expression),
+                clone(condition), std::move(pattern), getTupleId());
     }
 
     void apply(const NodeMapper& map) override {
         IndexOperation::apply(map);
         condition = map(std::move(condition));
         expression = map(std::move(expression));
-        function->apply(map);
-    }
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_IndexAggregate && kind < NK_LastIndexAggregate);
     }
 
 protected:
-    IndexAggregate(NodeKind kind, Own<Operation> nested, Own<Aggregator> fun, std::string rel,
-            Own<Expression> expression, Own<Condition> condition, RamPattern queryPattern, std::size_t ident)
-            : IndexOperation(kind, rel, ident, std::move(queryPattern), std::move(nested)),
-              AbstractAggregate(std::move(fun), std::move(expression), std::move(condition)) {
-        assert(kind >= NK_IndexAggregate && kind < NK_LastIndexAggregate);
-    }
-
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
         os << "t" << getTupleId() << ".0 = ";
diff --git a/src/ram/IndexIfExists.h b/src/ram/IndexIfExists.h
index 6fab9ea..9feb2f8 100644
--- a/src/ram/IndexIfExists.h
+++ b/src/ram/IndexIfExists.h
@@ -54,8 +54,11 @@ class IndexIfExists : public IndexOperation, public AbstractIfExists {
 public:
     IndexIfExists(std::string rel, std::size_t ident, Own<Condition> cond, RamPattern queryPattern,
             Own<Operation> nested, std::string profileText = "")
-            : IndexIfExists(NK_IndexIfExists, rel, ident, std::move(cond), std::move(queryPattern),
-                      std::move(nested), profileText) {}
+
+            : IndexOperation(rel, ident, std::move(queryPattern), std::move(nested), std::move(profileText)),
+              AbstractIfExists(std::move(cond)) {
+        assert(getRangePattern().first.size() == getRangePattern().second.size() && "Arity mismatch");
+    }
 
     void apply(const NodeMapper& map) override {
         RelationOperation::apply(map);
@@ -76,26 +79,12 @@ public:
         for (const auto& i : queryPattern.second) {
             resQueryPattern.second.emplace_back(i->cloning());
         }
-        auto* res = new IndexIfExists(NK_IndexIfExists, relation, getTupleId(), clone(condition),
-                std::move(resQueryPattern), clone(getOperation()), getProfileText());
+        auto* res = new IndexIfExists(relation, getTupleId(), clone(condition), std::move(resQueryPattern),
+                clone(getOperation()), getProfileText());
         return res;
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_IndexIfExists && kind < NK_LastIndexIfExists);
-    }
-
 protected:
-    IndexIfExists(NodeKind kind, std::string rel, std::size_t ident, Own<Condition> cond,
-            RamPattern queryPattern, Own<Operation> nested, std::string profileText = "")
-            : IndexOperation(
-                      kind, rel, ident, std::move(queryPattern), std::move(nested), std::move(profileText)),
-              AbstractIfExists(std::move(cond)) {
-        assert(getRangePattern().first.size() == getRangePattern().second.size() && "Arity mismatch");
-        assert(kind >= NK_IndexIfExists && kind < NK_LastIndexIfExists);
-    }
-
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
         os << "IF EXISTS t" << getTupleId() << " IN " << relation;
diff --git a/src/ram/IndexOperation.h b/src/ram/IndexOperation.h
index cdb9bfe..49413aa 100644
--- a/src/ram/IndexOperation.h
+++ b/src/ram/IndexOperation.h
@@ -44,8 +44,12 @@ class IndexOperation : public RelationOperation {
 public:
     IndexOperation(std::string rel, std::size_t ident, RamPattern queryPattern, Own<Operation> nested,
             std::string profileText = "")
-            : IndexOperation(NK_IndexOperation, std::move(rel), ident, std::move(queryPattern),
-                      std::move(nested), std::move(profileText)) {}
+            : RelationOperation(rel, ident, std::move(nested), std::move(profileText)),
+              queryPattern(std::move(queryPattern)) {
+        assert(queryPattern.first.size() == queryPattern.second.size() && "Arity mismatch");
+        assert(allValidPtrs(queryPattern.first));
+        assert(allValidPtrs(queryPattern.second));
+    }
 
     /**
      * @brief Get range pattern
@@ -76,8 +80,8 @@ public:
         for (const auto& i : queryPattern.second) {
             resQueryPattern.second.emplace_back(i->cloning());
         }
-        return new IndexOperation(NK_IndexOperation, relation, getTupleId(), std::move(resQueryPattern),
-                clone(getOperation()), getProfileText());
+        return new IndexOperation(
+                relation, getTupleId(), std::move(resQueryPattern), clone(getOperation()), getProfileText());
     }
 
     /** @brief Helper method for printing */
@@ -125,22 +129,7 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_IndexOperation && kind < NK_LastIndexOperation);
-    }
-
 protected:
-    IndexOperation(NodeKind kind, std::string rel, std::size_t ident, RamPattern queryPattern,
-            Own<Operation> nested, std::string profileText = "")
-            : RelationOperation(kind, rel, ident, std::move(nested), std::move(profileText)),
-              queryPattern(std::move(queryPattern)) {
-        assert(queryPattern.first.size() == queryPattern.second.size() && "Arity mismatch");
-        assert(allValidPtrs(queryPattern.first));
-        assert(allValidPtrs(queryPattern.second));
-        assert(kind >= NK_IndexOperation && kind < NK_LastIndexOperation);
-    }
-
     bool equal(const Node& node) const override {
         const auto& other = asAssert<IndexOperation>(node);
         return RelationOperation::equal(other) &&
diff --git a/src/ram/IndexScan.h b/src/ram/IndexScan.h
index f7d4c20..4ba65a3 100644
--- a/src/ram/IndexScan.h
+++ b/src/ram/IndexScan.h
@@ -49,8 +49,8 @@ class IndexScan : public IndexOperation {
 public:
     IndexScan(std::string rel, std::size_t ident, RamPattern queryPattern, Own<Operation> nested,
             std::string profileText = "")
-            : IndexScan(NK_IndexScan, rel, ident, std::move(queryPattern), std::move(nested),
-                      std::move(profileText)) {}
+            : IndexOperation(rel, ident, std::move(queryPattern), std::move(nested), std::move(profileText)) {
+    }
 
     IndexScan* cloning() const override {
         RamPattern resQueryPattern;
@@ -60,23 +60,11 @@ public:
         for (const auto& i : queryPattern.second) {
             resQueryPattern.second.emplace_back(i->cloning());
         }
-        return new IndexScan(NK_IndexScan, relation, getTupleId(), std::move(resQueryPattern),
-                clone(getOperation()), getProfileText());
-    }
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_IndexScan && kind < NK_LastIndexScan);
+        return new IndexScan(
+                relation, getTupleId(), std::move(resQueryPattern), clone(getOperation()), getProfileText());
     }
 
 protected:
-    IndexScan(NodeKind kind, std::string rel, std::size_t ident, RamPattern queryPattern,
-            Own<Operation> nested, std::string profileText = "")
-            : IndexOperation(
-                      kind, rel, ident, std::move(queryPattern), std::move(nested), std::move(profileText)) {
-        assert(kind >= NK_IndexScan && kind < NK_LastIndexScan);
-    }
-
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
         os << "FOR t" << getTupleId() << " IN " << relation;
diff --git a/src/ram/Insert.h b/src/ram/Insert.h
index 9d68799..7453e9a 100644
--- a/src/ram/Insert.h
+++ b/src/ram/Insert.h
@@ -45,7 +45,9 @@ namespace souffle::ram {
 class Insert : public Operation {
 public:
     Insert(std::string rel, VecOwn<Expression> expressions)
-            : Insert(NK_Insert, std::move(rel), std::move(expressions)) {}
+            : relation(std::move(rel)), expressions(std::move(expressions)) {
+        assert(allValidPtrs(expressions));
+    }
 
     /** @brief Get relation */
     const std::string& getRelation() const {
@@ -62,7 +64,7 @@ public:
         for (auto& expr : expressions) {
             newValues.emplace_back(expr->cloning());
         }
-        return new Insert(NK_Insert, relation, std::move(newValues));
+        return new Insert(relation, std::move(newValues));
     }
 
     void apply(const NodeMapper& map) override {
@@ -71,18 +73,7 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Insert && kind < NK_LastInsert);
-    }
-
 protected:
-    Insert(NodeKind kind, std::string rel, VecOwn<Expression> expressions)
-            : Operation(kind), relation(std::move(rel)), expressions(std::move(expressions)) {
-        assert(allValidPtrs(expressions));
-        assert(kind >= NK_Insert && kind < NK_LastInsert);
-    }
-
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
         os << "INSERT (" << join(expressions, ", ", print_deref<Own<Expression>>()) << ") INTO " << relation
diff --git a/src/ram/IntrinsicOperator.h b/src/ram/IntrinsicOperator.h
index 83dd5cd..017106a 100644
--- a/src/ram/IntrinsicOperator.h
+++ b/src/ram/IntrinsicOperator.h
@@ -37,11 +37,10 @@ namespace souffle::ram {
 class IntrinsicOperator : public AbstractOperator {
 public:
     template <typename... Args>
-    IntrinsicOperator(FunctorOp op, Args... args)
-            : AbstractOperator(NK_IntrinsicOperator, {std::move(args)...}), operation(op) {}
+    IntrinsicOperator(FunctorOp op, Args... args) : AbstractOperator({std::move(args)...}), operation(op) {}
 
     IntrinsicOperator(FunctorOp op, VecOwn<Expression> args)
-            : AbstractOperator(NK_IntrinsicOperator, std::move(args)), operation(op) {}
+            : AbstractOperator(std::move(args)), operation(op) {}
 
     /** @brief Get operator symbol */
     FunctorOp getOperator() const {
@@ -56,10 +55,6 @@ public:
         return new IntrinsicOperator(operation, std::move(argsCopy));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_IntrinsicOperator;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         if (isInfixFunctorOp(operation)) {
diff --git a/src/ram/ListStatement.h b/src/ram/ListStatement.h
index 5cd9a62..d233d20 100644
--- a/src/ram/ListStatement.h
+++ b/src/ram/ListStatement.h
@@ -31,12 +31,11 @@ namespace souffle::ram {
  */
 class ListStatement : public Statement {
 public:
-    ListStatement() : Statement(NK_ListStatement) {}
-
-    ListStatement(VecOwn<Statement> statements) : ListStatement(NK_ListStatement, std::move(statements)) {}
+    ListStatement() = default;
+    ListStatement(VecOwn<Statement> statements) : statements(std::move(statements)) {}
 
     template <typename... Stmts>
-    ListStatement(NodeKind kind, Own<Stmts>&&... stmts) : Statement(kind) {
+    ListStatement(Own<Stmts>&&... stmts) {
         Own<Statement> tmp[] = {std::move(stmts)...};
         for (auto& cur : tmp) {
             assert(cur.get() != nullptr && "statement is a null-pointer");
@@ -55,21 +54,7 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_ListStatement && kind < NK_LastListStatement);
-    }
-
 protected:
-    ListStatement(NodeKind kind) : Statement(kind), statements() {
-        assert(kind >= NK_ListStatement && kind < NK_LastListStatement);
-    }
-
-    ListStatement(NodeKind kind, VecOwn<Statement> statements)
-            : Statement(kind), statements(std::move(statements)) {
-        assert(kind >= NK_ListStatement && kind < NK_LastListStatement);
-    }
-
     bool equal(const Node& node) const override {
         const auto& other = asAssert<ListStatement>(node);
         return equal_targets(statements, other.statements);
diff --git a/src/ram/LogRelationTimer.h b/src/ram/LogRelationTimer.h
index 2c27e73..2a3eac1 100644
--- a/src/ram/LogRelationTimer.h
+++ b/src/ram/LogRelationTimer.h
@@ -50,8 +50,7 @@ namespace souffle::ram {
 class LogRelationTimer : public RelationStatement, public AbstractLog {
 public:
     LogRelationTimer(Own<Statement> stmt, std::string msg, std::string relRef)
-            : RelationStatement(NK_LogRelationTimer, std::move(relRef)),
-              AbstractLog(std::move(stmt), std::move(msg)) {}
+            : RelationStatement(std::move(relRef)), AbstractLog(std::move(stmt), std::move(msg)) {}
 
     LogRelationTimer* cloning() const override {
         return new LogRelationTimer(clone(statement), message, relation);
@@ -62,10 +61,6 @@ public:
         AbstractLog::apply(map);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_LogRelationTimer;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "TIMER ON " << relation << " \"" << stringify(message) << "\""
diff --git a/src/ram/LogSize.h b/src/ram/LogSize.h
index a5f5769..da39231 100644
--- a/src/ram/LogSize.h
+++ b/src/ram/LogSize.h
@@ -33,8 +33,7 @@ namespace souffle::ram {
  */
 class LogSize : public RelationStatement {
 public:
-    LogSize(std::string rel, std::string message)
-            : RelationStatement(NK_LogSize, rel), message(std::move(message)) {}
+    LogSize(std::string rel, std::string message) : RelationStatement(rel), message(std::move(message)) {}
 
     /** @brief Get logging message */
     const std::string& getMessage() const {
@@ -45,10 +44,6 @@ public:
         return new LogSize(relation, message);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_LogSize;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "LOG SIZE " << relation;
diff --git a/src/ram/LogTimer.h b/src/ram/LogTimer.h
index bd33401..eed5155 100644
--- a/src/ram/LogTimer.h
+++ b/src/ram/LogTimer.h
@@ -49,8 +49,7 @@ namespace souffle::ram {
  */
 class LogTimer : public Statement, public AbstractLog {
 public:
-    LogTimer(Own<Statement> stmt, std::string msg)
-            : Statement(NK_LogTimer), AbstractLog(std::move(stmt), std::move(msg)) {}
+    LogTimer(Own<Statement> stmt, std::string msg) : AbstractLog(std::move(stmt), std::move(msg)) {}
 
     LogTimer* cloning() const override {
         return new LogTimer(clone(statement), message);
@@ -60,10 +59,6 @@ public:
         AbstractLog::apply(map);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_LogTimer;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "TIMER \"" << stringify(message) << "\"" << std::endl;
diff --git a/src/ram/Loop.h b/src/ram/Loop.h
index 1885e32..33601b4 100644
--- a/src/ram/Loop.h
+++ b/src/ram/Loop.h
@@ -42,7 +42,7 @@ namespace souffle::ram {
  */
 class Loop : public Statement {
 public:
-    Loop(Own<Statement> b) : Statement(NK_Loop), body(std::move(b)) {
+    Loop(Own<Statement> b) : body(std::move(b)) {
         assert(body != nullptr && "Loop body is a null-pointer");
     }
 
@@ -59,10 +59,6 @@ public:
         body = map(std::move(body));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Loop;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "LOOP" << std::endl;
diff --git a/src/ram/MergeExtend.h b/src/ram/MergeExtend.h
index 74cfdd9..419eab6 100644
--- a/src/ram/MergeExtend.h
+++ b/src/ram/MergeExtend.h
@@ -36,8 +36,7 @@ namespace souffle::ram {
  */
 class MergeExtend : public BinRelationStatement {
 public:
-    MergeExtend(std::string tRef, const std::string& sRef)
-            : BinRelationStatement(NK_MergeExtend, sRef, tRef) {}
+    MergeExtend(std::string tRef, const std::string& sRef) : BinRelationStatement(sRef, tRef) {}
 
     /** @brief Get source relation */
     const std::string& getSourceRelation() const {
@@ -54,10 +53,6 @@ public:
         return res;
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_MergeExtend;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/Negation.h b/src/ram/Negation.h
index f7863a7..340b0ff 100644
--- a/src/ram/Negation.h
+++ b/src/ram/Negation.h
@@ -40,7 +40,7 @@ namespace souffle::ram {
  */
 class Negation : public Condition {
 public:
-    Negation(Own<Condition> op) : Condition(NK_Negation), operand(std::move(op)) {
+    Negation(Own<Condition> op) : operand(std::move(op)) {
         assert(operand != nullptr && "operand of negation is a null-pointer");
     }
 
@@ -57,10 +57,6 @@ public:
         operand = map(std::move(operand));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Negation;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "(NOT " << *operand << ")";
diff --git a/src/ram/NestedIntrinsicOperator.h b/src/ram/NestedIntrinsicOperator.h
index 75dbfe6..a25c36d 100644
--- a/src/ram/NestedIntrinsicOperator.h
+++ b/src/ram/NestedIntrinsicOperator.h
@@ -58,8 +58,7 @@ class NestedIntrinsicOperator : public TupleOperation {
 public:
     NestedIntrinsicOperator(
             NestedIntrinsicOp op, VecOwn<Expression> args, Own<Operation> nested, std::size_t ident)
-            : TupleOperation(NK_NestedIntrinsicOperator, ident, std::move(nested)), args(std::move(args)),
-              op(op) {}
+            : TupleOperation(ident, std::move(nested)), args(std::move(args)), op(op) {}
 
     NestedIntrinsicOp getFunction() const {
         return op;
@@ -69,10 +68,6 @@ public:
         return toPtrVector(args);
     }
 
-    std::size_t getNumArgs() const {
-        return args.size();
-    }
-
     NestedIntrinsicOperator* cloning() const override {
         return new NestedIntrinsicOperator(op, clone(args), clone(getOperation()), getTupleId());
     }
@@ -84,10 +79,6 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_NestedIntrinsicOperator;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/NestedOperation.h b/src/ram/NestedOperation.h
index 8539190..65cd4fd 100644
--- a/src/ram/NestedOperation.h
+++ b/src/ram/NestedOperation.h
@@ -46,6 +46,11 @@ namespace souffle::ram {
  */
 class NestedOperation : public Operation {
 public:
+    NestedOperation(Own<Operation> nested, std::string profileText = "")
+            : nestedOperation(std::move(nested)), profileText(std::move(profileText)) {
+        assert(nestedOperation != nullptr);
+    }
+
     NestedOperation* cloning() const override = 0;
 
     /** @brief Get nested operation */
@@ -62,18 +67,7 @@ public:
         nestedOperation = map(std::move(nestedOperation));
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_NestedOperation && kind < NK_LastNestedOperation);
-    }
-
 protected:
-    NestedOperation(NodeKind kind, Own<Operation> nested, std::string profileText = "")
-            : Operation(kind), nestedOperation(std::move(nested)), profileText(std::move(profileText)) {
-        assert(nestedOperation != nullptr);
-        assert(kind >= NK_NestedOperation && kind < NK_LastNestedOperation);
-    }
-
     void print(std::ostream& os, int tabpos) const override {
         Operation::print(nestedOperation.get(), os, tabpos);
     }
diff --git a/src/ram/Node.cpp b/src/ram/Node.cpp
index 167831d..8009e94 100644
--- a/src/ram/Node.cpp
+++ b/src/ram/Node.cpp
@@ -19,11 +19,11 @@
 #include <cassert>
 #include <functional>
 #include <memory>
+#include <typeinfo>
 #include <utility>
 #include <vector>
 
 namespace souffle::ram {
-Node::Node(NodeKind kind) : Kind(kind) {}
 
 void Node::rewrite(const Node* oldNode, Own<Node> newNode) {
     assert(oldNode != nullptr && "old node is a null-pointer");
@@ -47,8 +47,4 @@ Node::ChildNodes Node::getChildNodes() {
     return ChildNodes(getChildren(), detail::ConstCaster());
 }
 
-Node::NodeKind Node::getKind() const {
-    return Kind;
-}
-
 }  // namespace souffle::ram
diff --git a/src/ram/Node.h b/src/ram/Node.h
index d3e65b2..57815e2 100644
--- a/src/ram/Node.h
+++ b/src/ram/Node.h
@@ -24,6 +24,7 @@
 #include <functional>
 #include <iostream>
 #include <memory>
+#include <typeinfo>
 #include <utility>
 #include <vector>
 
@@ -56,161 +57,11 @@ protected:
     using NodeVec = std::vector<Node const*>;  // std::reference_wrapper<Node const>>;
 
 public:
-    /// LLVM-style RTTI
-    ///
-    /// Each class under the ram::Node hierarchy must appear here and must implement
-    /// `static bool classof(const Node*)`.
-    ///
-    /// When class T is final, we must provide a single enum:
-    ///
-    ///   ...
-    ///   NK_T,
-    ///   ...
-    ///
-    /// When class T is non-final, we must provide enums like this:
-    ///
-    ///   NK_T,
-    ///     NK_Child1,
-    ///     ...
-    ///     NK_ChildN,
-    ///   NK_LastT
-    ///
-    ///
-    // clang-format off
-    enum NodeKind {
-        NK_NONE,
-        NK_Condition,
-            NK_AbstractExistenceCheck, //Abstract Class
-                NK_ExistenceCheck,
-                NK_ProvenanceExistenceCheck,
-            NK_LastAbstractExistenceCheck,
-
-            NK_Conjunction,
-            NK_Constraint,
-            NK_EmptinessCheck,
-            NK_False,
-            NK_Negation,
-            NK_True,
-        NK_LastCondition,
-
-        NK_Expression,
-            NK_AbstractOperator,
-                NK_IntrinsicOperator,
-                NK_UserDefinedOperator,
-            NK_LastAbstractOperator,
-
-            NK_AutoIncrement,
-            NK_NumericConstant,
-                NK_FloatConstant,
-                NK_SignedConstant,
-                NK_UnsignedConstant,
-            NK_LastNumericConstant,
-
-            NK_PackRecord,
-            NK_RelationSize,
-            NK_SubroutineArgument,
-            NK_StringConstant,
-            NK_TupleElement,
-            NK_UndefValue,
-            NK_Variable,
-        NK_LastExpression,
-
-        NK_Operation,
-            NK_Erase,
-            NK_Insert,
-                NK_GuardedInsert,
-            NK_LastInsert,
-
-            NK_NestedOperation,
-                NK_AbstractConditional,
-                    NK_Break,
-                    NK_Filter,
-                NK_LastAbstractConditional,
-
-                NK_TupleOperation,
-                    NK_RelationOperation,
-                        NK_Aggregate,
-                            NK_ParallelAggregate,
-                        NK_LastAggregate,
-
-                        NK_IfExists,
-                            NK_ParallelIfExists,
-                        NK_LastIfExists,
-
-                        NK_IndexOperation,
-                            NK_IndexAggregate,
-                                NK_ParallelIndexAggregate,
-                            NK_LastIndexAggregate,
-
-                            NK_IndexIfExists,
-                                NK_ParallelIndexIfExists,
-                            NK_LastIndexIfExists,
-
-                            NK_IndexScan,
-                                NK_ParallelIndexScan,
-                            NK_LastIndexScan,
-                        NK_LastIndexOperation,
-
-                        NK_Scan,
-                            NK_ParallelScan,
-                        NK_LastScan,
-
-                    NK_LastRelationOperation,
-
-                    NK_UnpackRecord,
-                    NK_NestedIntrinsicOperator,
-                NK_LastTupleOperation,
-
-            NK_LastNestedOperation,
-
-            NK_Project,
-            NK_SubroutineReturn,
-        NK_LastOperation,
-
-        NK_Program,
-        NK_Relation,
-        NK_Statement,
-            NK_Assign,
-
-            NK_BinRelationStatement,
-                NK_MergeExtend,
-                NK_Swap,
-            NK_LastBinRelationStatement,
-
-            NK_Call,
-            NK_DebugInfo,
-            NK_Exit,
-            NK_ListStatement,
-                NK_Parallel,
-                NK_Sequence,
-            NK_LastListStatement,
-
-            NK_LogTimer,
-            NK_Loop,
-            NK_Query,
-            NK_RelationStatement,
-                NK_Clear,
-                NK_EstimateJoinSize,
-                NK_IO,
-                NK_LogRelationTimer,
-                NK_LogSize,
-            NK_LastRelationStatement,
-
-        NK_LastStatement,
-    };
-    // clang-format on
-private:
-    const NodeKind Kind;
-
-public:
-    explicit Node(NodeKind K);
-    Node() = delete;
-    virtual ~Node() = default;
+    Node() = default;
     Node(Node const&) = delete;
+    virtual ~Node() = default;
     Node& operator=(Node const&) = delete;
 
-    NodeKind getKind() const;
-
     /**
      * @brief Equivalence check for two RAM nodes
      */
diff --git a/src/ram/NumericConstant.h b/src/ram/NumericConstant.h
index 3e3d811..6e3a9b2 100644
--- a/src/ram/NumericConstant.h
+++ b/src/ram/NumericConstant.h
@@ -35,15 +35,8 @@ public:
         return constant;
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_NumericConstant && kind < NK_LastNumericConstant);
-    }
-
 protected:
-    explicit NumericConstant(NodeKind kind, RamDomain constant) : Expression(kind), constant(constant) {
-        assert(kind >= NK_NumericConstant && kind < NK_LastNumericConstant);
-    }
+    explicit NumericConstant(RamDomain constant) : constant(constant) {}
 
     bool equal(const Node& node) const override {
         const auto& other = asAssert<NumericConstant>(node);
diff --git a/src/ram/Operation.h b/src/ram/Operation.h
index 55ae45b..420cd3b 100644
--- a/src/ram/Operation.h
+++ b/src/ram/Operation.h
@@ -29,16 +29,7 @@ class Operation : public Node {
 public:
     Operation* cloning() const override = 0;
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Operation && kind < NK_LastOperation);
-    }
-
 protected:
-    Operation(NodeKind kind) : Node(kind) {
-        assert(kind >= NK_Operation && kind < NK_LastOperation);
-    }
-
     void print(std::ostream& os) const override {
         print(os, 0);
     }
diff --git a/src/ram/PackRecord.h b/src/ram/PackRecord.h
index b58f4a6..d7f60cd 100644
--- a/src/ram/PackRecord.h
+++ b/src/ram/PackRecord.h
@@ -35,7 +35,7 @@ namespace souffle::ram {
  */
 class PackRecord : public Expression {
 public:
-    PackRecord(VecOwn<Expression> args) : Expression(NK_PackRecord), arguments(std::move(args)) {
+    PackRecord(VecOwn<Expression> args) : arguments(std::move(args)) {
         assert(allValidPtrs(arguments));
     }
 
@@ -44,10 +44,6 @@ public:
         return toPtrVector(arguments);
     }
 
-    std::size_t getNumArgs() const {
-        return arguments.size();
-    }
-
     PackRecord* cloning() const override {
         auto* res = new PackRecord({});
         for (auto& cur : arguments) {
@@ -62,10 +58,6 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_PackRecord;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "PACK("
diff --git a/src/ram/Parallel.h b/src/ram/Parallel.h
index a142fe8..62ed685 100644
--- a/src/ram/Parallel.h
+++ b/src/ram/Parallel.h
@@ -44,11 +44,11 @@ namespace souffle::ram {
  */
 class Parallel : public ListStatement {
 public:
-    Parallel(VecOwn<Statement> statements) : ListStatement(NK_Parallel, std::move(statements)) {}
-    Parallel() : ListStatement(NK_Parallel) {}
+    Parallel(VecOwn<Statement> statements) : ListStatement(std::move(statements)) {}
+    Parallel() : ListStatement() {}
     template <typename... Stmts>
     Parallel(Own<Statement> first, Own<Stmts>... rest)
-            : ListStatement(NK_Parallel, std::move(first), std::move(rest)...) {}
+            : ListStatement(std::move(first), std::move(rest)...) {}
 
     Parallel* cloning() const override {
         auto* res = new Parallel();
@@ -58,10 +58,6 @@ public:
         return res;
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Parallel;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "PARALLEL" << std::endl;
diff --git a/src/ram/ParallelAggregate.h b/src/ram/ParallelAggregate.h
index 93dc61f..577a700 100644
--- a/src/ram/ParallelAggregate.h
+++ b/src/ram/ParallelAggregate.h
@@ -48,18 +48,13 @@ namespace souffle::ram {
  */
 class ParallelAggregate : public Aggregate, public AbstractParallel {
 public:
-    ParallelAggregate(Own<Operation> nested, Own<Aggregator> fun, std::string rel, Own<Expression> expression,
+    ParallelAggregate(Own<Operation> nested, AggregateOp fun, std::string rel, Own<Expression> expression,
             Own<Condition> condition, std::size_t ident)
-            : Aggregate(NK_ParallelAggregate, std::move(nested), std::move(fun), rel, std::move(expression),
-                      std::move(condition), ident) {}
+            : Aggregate(std::move(nested), fun, rel, std::move(expression), std::move(condition), ident) {}
 
     ParallelAggregate* cloning() const override {
-        return new ParallelAggregate(clone(getOperation()), clone(function), relation, clone(expression),
-                clone(condition), identifier);
-    }
-
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_ParallelAggregate;
+        return new ParallelAggregate(
+                clone(getOperation()), function, relation, clone(expression), clone(condition), identifier);
     }
 
 protected:
diff --git a/src/ram/ParallelIfExists.h b/src/ram/ParallelIfExists.h
index 032f03e..0a4912c 100644
--- a/src/ram/ParallelIfExists.h
+++ b/src/ram/ParallelIfExists.h
@@ -48,17 +48,13 @@ class ParallelIfExists : public IfExists, public AbstractParallel {
 public:
     ParallelIfExists(std::string rel, std::size_t ident, Own<Condition> cond, Own<Operation> nested,
             std::string profileText = "")
-            : IfExists(NK_ParallelIfExists, rel, ident, std::move(cond), std::move(nested), profileText) {}
+            : IfExists(rel, ident, std::move(cond), std::move(nested), profileText) {}
 
     ParallelIfExists* cloning() const override {
         return new ParallelIfExists(
                 relation, getTupleId(), clone(condition), clone(getOperation()), getProfileText());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_ParallelIfExists;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/ParallelIndexAggregate.h b/src/ram/ParallelIndexAggregate.h
index 405825f..1c8eeda 100644
--- a/src/ram/ParallelIndexAggregate.h
+++ b/src/ram/ParallelIndexAggregate.h
@@ -47,10 +47,10 @@ namespace souffle::ram {
  */
 class ParallelIndexAggregate : public IndexAggregate, public AbstractParallel {
 public:
-    ParallelIndexAggregate(Own<Operation> nested, Own<Aggregator> fun, std::string rel,
+    ParallelIndexAggregate(Own<Operation> nested, AggregateOp fun, std::string rel,
             Own<Expression> expression, Own<Condition> condition, RamPattern queryPattern, std::size_t ident)
-            : IndexAggregate(NK_ParallelIndexAggregate, std::move(nested), std::move(fun), rel,
-                      std::move(expression), std::move(condition), std::move(queryPattern), ident) {}
+            : IndexAggregate(std::move(nested), fun, rel, std::move(expression), std::move(condition),
+                      std::move(queryPattern), ident) {}
 
     ParallelIndexAggregate* cloning() const override {
         RamPattern pattern;
@@ -60,14 +60,10 @@ public:
         for (const auto& i : queryPattern.second) {
             pattern.second.emplace_back(i->cloning());
         }
-        return new ParallelIndexAggregate(clone(getOperation()), clone(function), relation, clone(expression),
+        return new ParallelIndexAggregate(clone(getOperation()), function, relation, clone(expression),
                 clone(condition), std::move(pattern), getTupleId());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_ParallelIndexAggregate;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/ParallelIndexIfExists.h b/src/ram/ParallelIndexIfExists.h
index 44e52ff..3bfc843 100644
--- a/src/ram/ParallelIndexIfExists.h
+++ b/src/ram/ParallelIndexIfExists.h
@@ -55,8 +55,8 @@ class ParallelIndexIfExists : public IndexIfExists, public AbstractParallel {
 public:
     ParallelIndexIfExists(std::string rel, std::size_t ident, Own<Condition> cond, RamPattern queryPattern,
             Own<Operation> nested, std::string profileText = "")
-            : IndexIfExists(NK_ParallelIndexIfExists, rel, ident, std::move(cond), std::move(queryPattern),
-                      std::move(nested), profileText) {}
+            : IndexIfExists(
+                      rel, ident, std::move(cond), std::move(queryPattern), std::move(nested), profileText) {}
 
     ParallelIndexIfExists* cloning() const override {
         RamPattern resQueryPattern;
@@ -71,10 +71,6 @@ public:
         return res;
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_ParallelIndexIfExists;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/ParallelIndexScan.h b/src/ram/ParallelIndexScan.h
index 0bf9ddd..5847e6e 100644
--- a/src/ram/ParallelIndexScan.h
+++ b/src/ram/ParallelIndexScan.h
@@ -54,8 +54,7 @@ class ParallelIndexScan : public IndexScan, public AbstractParallel {
 public:
     ParallelIndexScan(std::string rel, std::size_t ident, RamPattern queryPattern, Own<Operation> nested,
             std::string profileText = "")
-            : IndexScan(NK_ParallelIndexScan, rel, ident, std::move(queryPattern), std::move(nested),
-                      profileText) {}
+            : IndexScan(rel, ident, std::move(queryPattern), std::move(nested), profileText) {}
 
     ParallelIndexScan* cloning() const override {
         RamPattern resQueryPattern;
@@ -69,10 +68,6 @@ public:
                 relation, getTupleId(), std::move(resQueryPattern), clone(getOperation()), getProfileText());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_ParallelIndexScan;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/ParallelScan.h b/src/ram/ParallelScan.h
index 1b32c0f..198d7ea 100644
--- a/src/ram/ParallelScan.h
+++ b/src/ram/ParallelScan.h
@@ -46,16 +46,12 @@ namespace souffle::ram {
 class ParallelScan : public Scan, public AbstractParallel {
 public:
     ParallelScan(std::string rel, std::size_t ident, Own<Operation> nested, std::string profileText = "")
-            : Scan(NK_ParallelScan, rel, ident, std::move(nested), profileText) {}
+            : Scan(rel, ident, std::move(nested), profileText) {}
 
     ParallelScan* cloning() const override {
         return new ParallelScan(relation, getTupleId(), clone(getOperation()), getProfileText());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_ParallelScan;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/Program.h b/src/ram/Program.h
index 10a44b8..f8cb1fc 100644
--- a/src/ram/Program.h
+++ b/src/ram/Program.h
@@ -49,12 +49,11 @@ namespace souffle::ram {
  */
 class Program : public Node {
 private:
-    Program() : Node(NK_Program){};
+    Program() = default;
 
 public:
     Program(VecOwn<Relation> rels, Own<Statement> main, std::map<std::string, Own<Statement>> subs)
-            : Node(NK_Program), relations(std::move(rels)), main(std::move(main)),
-              subroutines(std::move(subs)) {
+            : relations(std::move(rels)), main(std::move(main)), subroutines(std::move(subs)) {
         assert(this->main != nullptr && "Main program is a null-pointer");
         assert(allValidPtrs(relations));
         assert(allValidPtrs(makeTransformRange(subroutines, [](auto&& kv) { return kv.second.get(); })));
@@ -106,10 +105,6 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Program;
-    }
-
 protected:
     void print(std::ostream& out) const override {
         out << "PROGRAM" << std::endl;
diff --git a/src/ram/ProvenanceExistenceCheck.h b/src/ram/ProvenanceExistenceCheck.h
index 59ab6c0..e945e27 100644
--- a/src/ram/ProvenanceExistenceCheck.h
+++ b/src/ram/ProvenanceExistenceCheck.h
@@ -35,7 +35,7 @@ namespace souffle::ram {
 class ProvenanceExistenceCheck : public AbstractExistenceCheck {
 public:
     ProvenanceExistenceCheck(std::string rel, VecOwn<Expression> vals)
-            : AbstractExistenceCheck(NK_ProvenanceExistenceCheck, rel, std::move(vals)) {}
+            : AbstractExistenceCheck(rel, std::move(vals)) {}
 
     ProvenanceExistenceCheck* cloning() const override {
         VecOwn<Expression> newValues;
@@ -45,10 +45,6 @@ public:
         return new ProvenanceExistenceCheck(relation, std::move(newValues));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == Node::NK_ProvenanceExistenceCheck;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "PROV ";
diff --git a/src/ram/Query.h b/src/ram/Query.h
index 877a3ff..6e7b078 100644
--- a/src/ram/Query.h
+++ b/src/ram/Query.h
@@ -45,7 +45,7 @@ namespace souffle::ram {
  */
 class Query : public Statement {
 public:
-    Query(Own<Operation> o) : Statement(NK_Query), operation(std::move(o)) {
+    Query(Own<Operation> o) : operation(std::move(o)) {
         assert(operation && "operation is a nullptr");
     }
 
@@ -62,10 +62,6 @@ public:
         operation = map(std::move(operation));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Query;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos) << "QUERY" << std::endl;
diff --git a/src/ram/Relation.h b/src/ram/Relation.h
index 4311ad0..50a364b 100644
--- a/src/ram/Relation.h
+++ b/src/ram/Relation.h
@@ -16,7 +16,6 @@
 #pragma once
 
 #include "RelationTag.h"
-#include "ram/AbstractOperator.h"
 #include "ram/Node.h"
 #include "souffle/utility/ContainerUtil.h"
 #include "souffle/utility/MiscUtil.h"
@@ -39,7 +38,7 @@ public:
     Relation(std::string name, std::size_t arity, std::size_t auxiliaryArity,
             std::vector<std::string> attributeNames, std::vector<std::string> attributeTypes,
             RelationRepresentation representation)
-            : Node(NK_Relation), representation(representation), name(std::move(name)), arity(arity),
+            : representation(representation), name(std::move(name)), arity(arity),
               auxiliaryArity(auxiliaryArity), attributeNames(std::move(attributeNames)),
               attributeTypes(std::move(attributeTypes)) {
         assert(this->attributeNames.size() == arity && "arity mismatch for attributes");
@@ -99,10 +98,6 @@ public:
         return new Relation(name, arity, auxiliaryArity, attributeNames, attributeTypes, representation);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Relation;
-    }
-
 protected:
     void print(std::ostream& out) const override {
         out << name;
@@ -149,23 +144,4 @@ protected:
     const std::vector<std::string> attributeTypes;
 };
 
-/**
- * @class NameComparison
- * @brief Comparator for relations
- *
- * Lexicographical order for Relation
- * using the relation name as an ordering criteria.
- */
-struct NameComparison {
-    bool operator()(const Relation* x, const Relation* y) const {
-        if (x != nullptr && y != nullptr) {
-            return *x < *y;
-        }
-        return y != nullptr;
-    }
-};
-
-/** Relation set */
-using RelationSet = std::set<const Relation*, NameComparison>;
-
 }  // namespace souffle::ram
diff --git a/src/ram/RelationOperation.h b/src/ram/RelationOperation.h
index 8a61bf3..1d5366d 100644
--- a/src/ram/RelationOperation.h
+++ b/src/ram/RelationOperation.h
@@ -36,10 +36,8 @@ namespace souffle::ram {
  */
 class RelationOperation : public TupleOperation {
 public:
-    RelationOperation(NodeKind kind, std::string rel, std::size_t ident, Own<Operation> nested,
-            std::string profileText = "")
-            : TupleOperation(kind, ident, std::move(nested), std::move(profileText)),
-              relation(std::move(rel)) {}
+    RelationOperation(std::string rel, std::size_t ident, Own<Operation> nested, std::string profileText = "")
+            : TupleOperation(ident, std::move(nested), std::move(profileText)), relation(std::move(rel)) {}
 
     RelationOperation* cloning() const override = 0;
 
@@ -48,11 +46,6 @@ public:
         return relation;
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_RelationOperation && kind < NK_LastRelationOperation);
-    }
-
 protected:
     bool equal(const Node& node) const override {
         const auto& other = asAssert<RelationOperation>(node);
diff --git a/src/ram/RelationSize.h b/src/ram/RelationSize.h
index 28d624c..98478bf 100644
--- a/src/ram/RelationSize.h
+++ b/src/ram/RelationSize.h
@@ -41,7 +41,7 @@ namespace souffle::ram {
  */
 class RelationSize : public Expression {
 public:
-    RelationSize(std::string rel) : Expression(NK_RelationSize), relation(std::move(rel)) {}
+    RelationSize(std::string rel) : relation(std::move(rel)) {}
 
     /** @brief Get relation */
     const std::string getRelation() const {
@@ -52,10 +52,6 @@ public:
         return new RelationSize(relation);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_RelationSize;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "SIZE(" << relation << ")";
diff --git a/src/ram/RelationStatement.h b/src/ram/RelationStatement.h
index 6a978fc..2847ca5 100644
--- a/src/ram/RelationStatement.h
+++ b/src/ram/RelationStatement.h
@@ -32,23 +32,14 @@ namespace souffle::ram {
  */
 class RelationStatement : public Statement {
 public:
-    RelationStatement(std::string rel) : RelationStatement(NK_RelationStatement, std::move(rel)) {}
+    RelationStatement(std::string rel) : relation(std::move(rel)) {}
 
     /** @brief Get RAM relation */
     const std::string& getRelation() const {
         return relation;
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_RelationStatement && kind < NK_LastRelationStatement);
-    }
-
 protected:
-    RelationStatement(NodeKind kind, std::string rel) : Statement(kind), relation(std::move(rel)) {
-        assert(kind >= NK_RelationStatement && kind < NK_LastRelationStatement);
-    }
-
     bool equal(const Node& node) const override {
         const auto& other = asAssert<RelationStatement>(node);
         return relation == other.relation;
diff --git a/src/ram/Scan.h b/src/ram/Scan.h
index 4beb866..cbc0553 100644
--- a/src/ram/Scan.h
+++ b/src/ram/Scan.h
@@ -43,24 +43,13 @@ namespace souffle::ram {
 class Scan : public RelationOperation {
 public:
     Scan(std::string rel, std::size_t ident, Own<Operation> nested, std::string profileText = "")
-            : Scan(NK_Scan, rel, ident, std::move(nested), std::move(profileText)) {}
+            : RelationOperation(rel, ident, std::move(nested), std::move(profileText)) {}
 
     Scan* cloning() const override {
-        return new Scan(NK_Scan, relation, getTupleId(), clone(getOperation()), getProfileText());
-    }
-
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Scan && kind < NK_LastScan);
+        return new Scan(relation, getTupleId(), clone(getOperation()), getProfileText());
     }
 
 protected:
-    Scan(NodeKind kind, std::string rel, std::size_t ident, Own<Operation> nested,
-            std::string profileText = "")
-            : RelationOperation(kind, rel, ident, std::move(nested), std::move(profileText)) {
-        assert(kind >= NK_Scan && kind < NK_LastScan);
-    }
-
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
         os << "FOR t" << getTupleId();
diff --git a/src/ram/Sequence.h b/src/ram/Sequence.h
index bcb373d..fd651b2 100644
--- a/src/ram/Sequence.h
+++ b/src/ram/Sequence.h
@@ -17,7 +17,6 @@
 #include "ram/ListStatement.h"
 #include "ram/Statement.h"
 #include "souffle/utility/MiscUtil.h"
-#include "souffle/utility/Types.h"
 #include <memory>
 #include <ostream>
 #include <utility>
@@ -33,11 +32,11 @@ namespace souffle::ram {
  */
 class Sequence : public ListStatement {
 public:
-    Sequence(VecOwn<Statement> statements) : ListStatement(NK_Sequence, std::move(statements)) {}
-    Sequence() : ListStatement(NK_Sequence) {}
+    Sequence(VecOwn<Statement> statements) : ListStatement(std::move(statements)) {}
+    Sequence() : ListStatement() {}
     template <typename... Stmts>
     Sequence(Own<Statement> first, Own<Stmts>... rest)
-            : ListStatement(NK_Sequence, std::move(first), std::move(rest)...) {}
+            : ListStatement(std::move(first), std::move(rest)...) {}
 
     Sequence* cloning() const override {
         auto* res = new Sequence();
@@ -47,10 +46,6 @@ public:
         return res;
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Sequence;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         for (const auto& stmt : statements) {
diff --git a/src/ram/SignedConstant.h b/src/ram/SignedConstant.h
index 71d9963..47bc661 100644
--- a/src/ram/SignedConstant.h
+++ b/src/ram/SignedConstant.h
@@ -33,7 +33,7 @@ namespace souffle::ram {
  */
 class SignedConstant : public NumericConstant {
 public:
-    explicit SignedConstant(RamDomain val) : NumericConstant(NK_SignedConstant, val) {}
+    explicit SignedConstant(RamDomain val) : NumericConstant(val) {}
 
     /** @brief Get value of the constant. */
     RamDomain getValue() const {
@@ -45,10 +45,6 @@ public:
         return new SignedConstant(getValue());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_SignedConstant;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "NUMBER(" << constant << ")";
diff --git a/src/ram/Statement.h b/src/ram/Statement.h
index 5b49e48..82c7a3b 100644
--- a/src/ram/Statement.h
+++ b/src/ram/Statement.h
@@ -31,16 +31,7 @@ class Statement : public Node {
 public:
     Statement* cloning() const override = 0;
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_Statement && kind < NK_LastStatement);
-    }
-
 protected:
-    Statement(NodeKind kind) : Node(kind) {
-        assert(kind > NK_Statement && kind < NK_LastStatement);
-    }
-
     void print(std::ostream& os) const override {
         print(os, 0);
     }
diff --git a/src/ram/StringConstant.h b/src/ram/StringConstant.h
index 73e4591..22fdb3e 100644
--- a/src/ram/StringConstant.h
+++ b/src/ram/StringConstant.h
@@ -31,7 +31,7 @@ namespace souffle::ram {
  */
 class StringConstant : public Expression {
 public:
-    StringConstant(std::string constant) : Expression(NK_StringConstant), constant(constant) {}
+    StringConstant(std::string constant) : constant(constant) {}
 
     /** @brief Get constant */
     const std::string& getConstant() const {
@@ -42,13 +42,9 @@ public:
         return new StringConstant(constant);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_StringConstant;
-    }
-
 protected:
     void print(std::ostream& os) const override {
-        os << "STRING(\"" << stringify(constant) << "\")";
+        os << "string(\"" << stringify(constant) << "\")";
     }
 
     bool equal(const Node& node) const override {
diff --git a/src/ram/SubroutineArgument.h b/src/ram/SubroutineArgument.h
index 52f76c1..6e87e3c 100644
--- a/src/ram/SubroutineArgument.h
+++ b/src/ram/SubroutineArgument.h
@@ -34,7 +34,7 @@ namespace souffle::ram {
  */
 class SubroutineArgument : public Expression {
 public:
-    SubroutineArgument(std::size_t number) : Expression(NK_SubroutineArgument), number(number) {}
+    SubroutineArgument(std::size_t number) : number(number) {}
 
     /** @brief Get argument */
     std::size_t getArgument() const {
@@ -45,10 +45,6 @@ public:
         return new SubroutineArgument(number);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_SubroutineArgument;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "ARGUMENT(" << number << ")";
diff --git a/src/ram/SubroutineReturn.h b/src/ram/SubroutineReturn.h
index 99e7147..82a79c5 100644
--- a/src/ram/SubroutineReturn.h
+++ b/src/ram/SubroutineReturn.h
@@ -41,7 +41,7 @@ namespace souffle::ram {
  */
 class SubroutineReturn : public Operation {
 public:
-    SubroutineReturn(VecOwn<Expression> vals) : Operation(NK_SubroutineReturn), expressions(std::move(vals)) {
+    SubroutineReturn(VecOwn<Expression> vals) : expressions(std::move(vals)) {
         assert(allValidPtrs(expressions));
     }
 
@@ -50,10 +50,6 @@ public:
         return toPtrVector(expressions);
     }
 
-    std::size_t getNumValues() const {
-        return expressions.size();
-    }
-
     SubroutineReturn* cloning() const override {
         VecOwn<Expression> newValues;
         for (auto& expr : expressions) {
@@ -68,10 +64,6 @@ public:
         }
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_SubroutineReturn;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/Swap.h b/src/ram/Swap.h
index cf1c71b..22c2db5 100644
--- a/src/ram/Swap.h
+++ b/src/ram/Swap.h
@@ -38,16 +38,12 @@ namespace souffle::ram {
  */
 class Swap : public BinRelationStatement {
 public:
-    Swap(std::string f, std::string s) : BinRelationStatement(NK_Swap, f, s) {}
+    Swap(std::string f, std::string s) : BinRelationStatement(f, s) {}
 
     Swap* cloning() const override {
         return new Swap(first, second);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_Swap;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/TranslationUnit.cpp b/src/ram/TranslationUnit.cpp
index 16aa8ca..645893f 100644
--- a/src/ram/TranslationUnit.cpp
+++ b/src/ram/TranslationUnit.cpp
@@ -8,13 +8,12 @@
 
 #include "TranslationUnit.h"
 #include "Global.h"
-#include "ram/Program.h"
 #include "souffle/utility/StringUtil.h"
 
 namespace souffle::ram {
 
 void TranslationUnit::logAnalysis(Analysis& analysis) const {
-    if (!global().config().has("debug-report")) return;
+    if (!Global::config().has("debug-report")) return;
 
     auto ss = toString(analysis);
     debugReport.addSection(
diff --git a/src/ram/True.h b/src/ram/True.h
index 41edc1e..b90046d 100644
--- a/src/ram/True.h
+++ b/src/ram/True.h
@@ -30,16 +30,10 @@ namespace souffle::ram {
  */
 class True : public Condition {
 public:
-    True() : Condition(NK_True) {}
-
     True* cloning() const override {
         return new True();
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_True;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "TRUE";
diff --git a/src/ram/TupleElement.h b/src/ram/TupleElement.h
index b93a33b..aaa4d5e 100644
--- a/src/ram/TupleElement.h
+++ b/src/ram/TupleElement.h
@@ -36,8 +36,7 @@ namespace souffle::ram {
  */
 class TupleElement : public Expression {
 public:
-    TupleElement(std::size_t ident, std::size_t elem)
-            : Expression(NK_TupleElement), identifier(ident), element(elem) {}
+    TupleElement(std::size_t ident, std::size_t elem) : identifier(ident), element(elem) {}
 
     /** @brief Get identifier */
     std::size_t getTupleId() const {
@@ -53,10 +52,6 @@ public:
         return new TupleElement(identifier, element);
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_TupleElement;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "t" << identifier << "." << element;
diff --git a/src/ram/TupleOperation.h b/src/ram/TupleOperation.h
index b81c494..e752751 100644
--- a/src/ram/TupleOperation.h
+++ b/src/ram/TupleOperation.h
@@ -32,7 +32,7 @@ namespace souffle::ram {
 class TupleOperation : public NestedOperation {
 public:
     TupleOperation(std::size_t ident, Own<Operation> nested, std::string profileText = "")
-            : TupleOperation(NK_TupleOperation, ident, std::move(nested), std::move(profileText)) {}
+            : NestedOperation(std::move(nested), std::move(profileText)), identifier(ident) {}
 
     TupleOperation* cloning() const override = 0;
 
@@ -46,17 +46,7 @@ public:
         identifier = id;
     }
 
-    static bool classof(const Node* n) {
-        const NodeKind kind = n->getKind();
-        return (kind >= NK_TupleOperation && kind < NK_LastTupleOperation);
-    }
-
 protected:
-    TupleOperation(NodeKind kind, std::size_t ident, Own<Operation> nested, std::string profileText = "")
-            : NestedOperation(kind, std::move(nested), std::move(profileText)), identifier(ident) {
-        assert(kind > NK_TupleOperation && kind < NK_LastTupleOperation);
-    }
-
     bool equal(const Node& node) const override {
         const auto& other = asAssert<TupleOperation>(node);
         return NestedOperation::equal(other) && identifier == other.identifier;
diff --git a/src/ram/UndefValue.h b/src/ram/UndefValue.h
index dfc07ca..ed45ef1 100644
--- a/src/ram/UndefValue.h
+++ b/src/ram/UndefValue.h
@@ -29,16 +29,10 @@ namespace souffle::ram {
  */
 class UndefValue : public Expression {
 public:
-    UndefValue() : Expression(NK_UndefValue) {}
-
     UndefValue* cloning() const override {
         return new UndefValue();
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_UndefValue;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "UNDEF";
diff --git a/src/ram/UnpackRecord.h b/src/ram/UnpackRecord.h
index 4e403ba..d2a8cb8 100644
--- a/src/ram/UnpackRecord.h
+++ b/src/ram/UnpackRecord.h
@@ -46,8 +46,7 @@ namespace souffle::ram {
 class UnpackRecord : public TupleOperation {
 public:
     UnpackRecord(Own<Operation> nested, std::size_t ident, Own<Expression> expr, std::size_t arity)
-            : TupleOperation(NK_UnpackRecord, ident, std::move(nested)), expression(std::move(expr)),
-              arity(arity) {
+            : TupleOperation(ident, std::move(nested)), expression(std::move(expr)), arity(arity) {
         assert(expression != nullptr && "Expression is a null-pointer");
     }
 
@@ -71,10 +70,6 @@ public:
         expression = map(std::move(expression));
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_UnpackRecord;
-    }
-
 protected:
     void print(std::ostream& os, int tabpos) const override {
         os << times(" ", tabpos);
diff --git a/src/ram/UnsignedConstant.h b/src/ram/UnsignedConstant.h
index 6be0ec6..6c3265f 100644
--- a/src/ram/UnsignedConstant.h
+++ b/src/ram/UnsignedConstant.h
@@ -33,7 +33,7 @@ namespace souffle::ram {
  */
 class UnsignedConstant : public NumericConstant {
 public:
-    explicit UnsignedConstant(RamUnsigned val) : NumericConstant(NK_UnsignedConstant, ramBitCast(val)) {}
+    explicit UnsignedConstant(RamUnsigned val) : NumericConstant(ramBitCast(val)) {}
 
     /** @brief Get value of the constant. */
     RamUnsigned getValue() const {
@@ -45,10 +45,6 @@ public:
         return new UnsignedConstant(getValue());
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_UnsignedConstant;
-    }
-
 protected:
     void print(std::ostream& os) const override {
         os << "UNSIGNED(" << getValue() << ")";
diff --git a/src/ram/UserDefinedOperator.h b/src/ram/UserDefinedOperator.h
index 66a82f2..46eb5d2 100644
--- a/src/ram/UserDefinedOperator.h
+++ b/src/ram/UserDefinedOperator.h
@@ -39,8 +39,8 @@ class UserDefinedOperator : public AbstractOperator {
 public:
     UserDefinedOperator(std::string n, std::vector<TypeAttribute> argsTypes, TypeAttribute returnType,
             bool stateful, VecOwn<Expression> args)
-            : AbstractOperator(NK_UserDefinedOperator, std::move(args)), name(std::move(n)),
-              argsTypes(std::move(argsTypes)), returnType(returnType), stateful(stateful) {
+            : AbstractOperator(std::move(args)), name(std::move(n)), argsTypes(std::move(argsTypes)),
+              returnType(returnType), stateful(stateful) {
         assert(argsTypes.size() == args.size());
     }
 
@@ -54,10 +54,6 @@ public:
         return argsTypes;
     }
 
-    std::size_t getNumArgs() const {
-        return argsTypes.size();
-    }
-
     /** @brief Get return type */
     TypeAttribute getReturnType() const {
         return returnType;
@@ -77,13 +73,13 @@ public:
         return res;
     }
 
-    static bool classof(const Node* n) {
-        return n->getKind() == NK_UserDefinedOperator;
-    }
-
 protected:
     void print(std::ostream& os) const override {
-        os << "@" << name;
+        os << "@" << name << "_" << argsTypes;
+        os << "_" << returnType;
+        if (stateful) {
+            os << "_stateful";
+        }
         os << "(" << join(arguments, ",", [](std::ostream& out, const Own<Expression>& arg) { out << *arg; })
            << ")";
     }
diff --git a/src/ram/analysis/Complexity.cpp b/src/ram/analysis/Complexity.cpp
index ff0eabb..a360ac6 100644
--- a/src/ram/analysis/Complexity.cpp
+++ b/src/ram/analysis/Complexity.cpp
@@ -62,7 +62,7 @@ int ComplexityAnalysis::getComplexity(const Node* node) const {
         }
 
         int visit_(type_identity<UserDefinedOperator>, const UserDefinedOperator&) override {
-            return std::numeric_limits<int>::max();
+            return 10;
         }
 
         // emptiness check
@@ -71,17 +71,8 @@ int ComplexityAnalysis::getComplexity(const Node* node) const {
             return (ra->lookup(emptiness.getRelation()).getArity() > 0) ? 1 : 0;
         }
 
-        int visit_(type_identity<AbstractOperator>, const AbstractOperator& op) override {
-            int exprComplexity = 0;
-            for (auto* expr : op.getArguments()) {
-                exprComplexity += dispatch(*expr);
-            }
-            return exprComplexity;
-        }
-
         // default rule
-        int visit_(type_identity<Node>, const Node& node) override {
-            (void)node;
+        int visit_(type_identity<Node>, const Node&) override {
             return 0;
         }
 
@@ -90,8 +81,7 @@ int ComplexityAnalysis::getComplexity(const Node* node) const {
     };
 
     assert((isA<Expression>(node) || isA<Condition>(node)) && "not an expression/condition/operation");
-    const int complexity = ValueComplexityVisitor(ra).dispatch(*node);
-    return complexity;
+    return ValueComplexityVisitor(ra).dispatch(*node);
 }
 
 }  // namespace souffle::ram::analysis
diff --git a/src/ram/analysis/Index.cpp b/src/ram/analysis/Index.cpp
index e4713c5..853ae86 100644
--- a/src/ram/analysis/Index.cpp
+++ b/src/ram/analysis/Index.cpp
@@ -17,7 +17,7 @@
 #include "ram/analysis/Index.h"
 #include "Global.h"
 #include "RelationTag.h"
-#include "ram/EstimateJoinSize.h"
+#include "ram/CountUniqueKeys.h"
 #include "ram/Expression.h"
 #include "ram/Node.h"
 #include "ram/Program.h"
@@ -394,8 +394,8 @@ void IndexAnalysis::run(const TranslationUnit& translationUnit) {
 
     // visit all nodes to collect searches of each relation
     visit(translationUnit.getProgram(), [&](const Node& node) {
-        if (const auto* estimateJoinSize = as<EstimateJoinSize>(node)) {
-            relationToSearches[estimateJoinSize->getRelation()].insert(getSearchSignature(estimateJoinSize));
+        if (const auto* countUniqueKeys = as<CountUniqueKeys>(node)) {
+            relationToSearches[countUniqueKeys->getRelation()].insert(getSearchSignature(countUniqueKeys));
         } else if (const auto* indexSearch = as<IndexOperation>(node)) {
             relationToSearches[indexSearch->getRelation()].insert(getSearchSignature(indexSearch));
         } else if (const auto* exists = as<ExistenceCheck>(node)) {
@@ -491,14 +491,14 @@ SearchSignature searchSignature(std::size_t arity, Seq const& xs) {
 }
 }  // namespace
 
-SearchSignature IndexAnalysis::getSearchSignature(const EstimateJoinSize* estimateJoinSize) const {
-    const Relation* rel = &relAnalysis->lookup(estimateJoinSize->getRelation());
+SearchSignature IndexAnalysis::getSearchSignature(const CountUniqueKeys* count) const {
+    const Relation* rel = &relAnalysis->lookup(count->getRelation());
     std::size_t arity = rel->getArity();
 
     // default everything is AttributeConstraint::None
     SearchSignature keys(arity);
     // set join column attributes
-    for (std::size_t col : estimateJoinSize->getKeyColumns()) {
+    for (std::size_t col : count->getKeyColumns()) {
         keys[col] = AttributeConstraint::Equal;
     }
     return keys;
diff --git a/src/ram/analysis/Index.h b/src/ram/analysis/Index.h
index 98d05a0..924f188 100644
--- a/src/ram/analysis/Index.h
+++ b/src/ram/analysis/Index.h
@@ -17,7 +17,7 @@
 #pragma once
 
 #include "ram/AbstractExistenceCheck.h"
-#include "ram/EstimateJoinSize.h"
+#include "ram/CountUniqueKeys.h"
 #include "ram/ExistenceCheck.h"
 #include "ram/IndexOperation.h"
 #include "ram/ProvenanceExistenceCheck.h"
@@ -502,11 +502,11 @@ public:
     }
 
     /**
-     * @Brief Get index signature for an Ram EstimateJoinSize operation
-     * @param  EstimateJoinSize operation
+     * @Brief Get index signature for an Ram CountUniqueKeys operation
+     * @param  CountUniqueKeys operation
      * @result Index signature of operation
      */
-    SearchSignature getSearchSignature(const EstimateJoinSize* estimateJoinSize) const;
+    SearchSignature getSearchSignature(const CountUniqueKeys* count) const;
 
     /**
      * @Brief Get index signature for an Ram IndexOperation operation
diff --git a/src/ram/analysis/Level.cpp b/src/ram/analysis/Level.cpp
index b53d47c..380a4fe 100644
--- a/src/ram/analysis/Level.cpp
+++ b/src/ram/analysis/Level.cpp
@@ -85,11 +85,6 @@ std::optional<std::size_t> LevelAnalysis::getLevel(const Node* node) const {
             return std::nullopt;
         }
 
-        // number constant
-        maybe_level visit_(type_identity<Variable>, const Variable&) override {
-            return std::nullopt;
-        }
-
         // true
         maybe_level visit_(type_identity<True>, const True&) override {
             return std::nullopt;
diff --git a/src/ram/transform/MakeIndex.cpp b/src/ram/transform/MakeIndex.cpp
index c40cd9c..bfa5eef 100644
--- a/src/ram/transform/MakeIndex.cpp
+++ b/src/ram/transform/MakeIndex.cpp
@@ -88,13 +88,11 @@ ExpressionPair MakeIndexTransformer::getExpressionPair(
 // Retrieves the <expr1> <= Tuple[level, element] <= <expr2> part of the constraint as a pair { <expr1>,
 // <expr2> }
 ExpressionPair MakeIndexTransformer::getLowerUpperExpression(Condition* c, std::size_t& element,
-        const std::optional<std::size_t>& identifier, const ram::Relation& rel) {
+        const std::optional<std::size_t>& identifier, RelationRepresentation rep) {
     if (auto* binRelOp = as<Constraint>(c)) {
-        const bool interpreter = !glb->config().has("compile") && !glb->config().has("dl-program") &&
-                                 !glb->config().has("generate") && !glb->config().has("generate-many") &&
-                                 !glb->config().has("swig");
-        bool provenance = rel.getAuxiliaryArity() > 0;  // rep == RelationRepresentation::PROVENANCE;
-        auto rep = rel.getRepresentation();
+        bool interpreter = !Global::config().has("compile") && !Global::config().has("dl-program") &&
+                           !Global::config().has("generate") && !Global::config().has("swig");
+        bool provenance = rep == RelationRepresentation::PROVENANCE;
         bool btree = (rep == RelationRepresentation::BTREE || rep == RelationRepresentation::DEFAULT ||
                       rep == RelationRepresentation::BTREE_DELETE);
         auto op = binRelOp->getOperator();
@@ -140,8 +138,9 @@ ExpressionPair MakeIndexTransformer::getLowerUpperExpression(Condition* c, std::
     return {mk<UndefValue>(), mk<UndefValue>()};
 }
 
-Own<Condition> MakeIndexTransformer::constructPattern(const ram::Relation& rel, RamPattern& queryPattern,
-        bool& indexable, VecOwn<Condition> conditionList, std::size_t identifier) {
+Own<Condition> MakeIndexTransformer::constructPattern(const std::vector<std::string>& attributeTypes,
+        RamPattern& queryPattern, bool& indexable, VecOwn<Condition> conditionList, std::size_t identifier,
+        RelationRepresentation rep) {
     // Remaining conditions which cannot be handled by an index
     Own<Condition> condition;
     auto addCondition = [&](Own<Condition> c) {
@@ -202,12 +201,12 @@ Own<Condition> MakeIndexTransformer::constructPattern(const ram::Relation& rel,
     // Define a comparator which orders all of the conditions nicely
     // 1. Equalities come before inequalities
     // 2. Conditions are ordered by the index of the constraint i.e. t0.0 comes before t0.1
-    auto cmp = [&](const auto& c1, const auto& c2) -> bool {
+    auto cmp = [&](auto& c1, auto& c2) -> bool {
         auto* cond1 = as<Constraint>(c1);
         auto* cond2 = as<Constraint>(c2);
         // place non-conditions at the end
         if (!cond1 && !cond2) {
-            return false;
+            return c1.get() < c2.get();
         }
         if (cond1 && !cond2) {
             return true;
@@ -221,7 +220,7 @@ Own<Condition> MakeIndexTransformer::constructPattern(const ram::Relation& rel,
         bool rhsIndexable = isIndexableConstraint(cond2->getOperator());
 
         if (!lhsIndexable && !rhsIndexable) {
-            return false;
+            return c1.get() < c2.get();
         }
         if (lhsIndexable && !rhsIndexable) {
             return true;
@@ -248,7 +247,7 @@ Own<Condition> MakeIndexTransformer::constructPattern(const ram::Relation& rel,
         bool rhsUndefined = isUndefValue(p2.first.get()) && isUndefValue(p2.second.get());
 
         if (lhsUndefined && rhsUndefined) {
-            return false;
+            return c1.get() < c2.get();
         }
 
         if (!lhsUndefined && rhsUndefined) {
@@ -263,7 +262,7 @@ Own<Condition> MakeIndexTransformer::constructPattern(const ram::Relation& rel,
         return attr1 < attr2;
     };
 
-    std::stable_sort(conditionList.begin(), conditionList.end(), cmp);
+    std::sort(conditionList.begin(), conditionList.end(), cmp);
 
     // Build query pattern and remaining condition
     bool seenInequality = false;
@@ -286,7 +285,7 @@ Own<Condition> MakeIndexTransformer::constructPattern(const ram::Relation& rel,
         Own<Expression> lowerExpression;
         Own<Expression> upperExpression;
         std::tie(lowerExpression, upperExpression) =
-                getLowerUpperExpression(cond.get(), element, identifier, rel);
+                getLowerUpperExpression(cond.get(), element, identifier, rep);
 
         // we have new bounds if at least one is defined
         if (!isUndefValue(lowerExpression.get()) || !isUndefValue(upperExpression.get())) {
@@ -313,7 +312,7 @@ Own<Condition> MakeIndexTransformer::constructPattern(const ram::Relation& rel,
                 continue;
             }
 
-            auto type = rel.getAttributeTypes()[element];
+            auto type = attributeTypes[element];
             indexable = true;
             if (firstConstraint) {
                 // equality
@@ -414,12 +413,12 @@ Own<Operation> MakeIndexTransformer::rewriteAggregate(const Aggregate* agg) {
         }
 
         bool indexable = false;
-        Own<Condition> condition = constructPattern(
-                rel, queryPattern, indexable, toConjunctionList(&agg->getCondition()), identifier);
+        Own<Condition> condition = constructPattern(rel.getAttributeTypes(), queryPattern, indexable,
+                toConjunctionList(&agg->getCondition()), identifier, rel.getRepresentation());
         if (indexable) {
-            return mk<IndexAggregate>(clone(agg->getOperation()), clone(agg->getAggregator()),
-                    agg->getRelation(), clone(agg->getExpression()), std::move(condition),
-                    std::move(queryPattern), agg->getTupleId());
+            return mk<IndexAggregate>(clone(agg->getOperation()), agg->getFunction(), agg->getRelation(),
+                    clone(agg->getExpression()), std::move(condition), std::move(queryPattern),
+                    agg->getTupleId());
         }
     }
     return nullptr;
@@ -436,8 +435,8 @@ Own<Operation> MakeIndexTransformer::rewriteScan(const Scan* scan) {
         }
 
         bool indexable = false;
-        Own<Condition> condition = constructPattern(
-                rel, queryPattern, indexable, toConjunctionList(&filter->getCondition()), identifier);
+        Own<Condition> condition = constructPattern(rel.getAttributeTypes(), queryPattern, indexable,
+                toConjunctionList(&filter->getCondition()), identifier, rel.getRepresentation());
         if (indexable) {
             Own<Operation> op = clone(filter->getOperation());
             if (!isTrue(condition.get())) {
@@ -461,8 +460,8 @@ Own<Operation> MakeIndexTransformer::rewriteIndexScan(const IndexScan* iscan) {
 
         bool indexable = false;
         // strengthen the pattern with construct pattern
-        Own<Condition> condition = constructPattern(
-                rel, strengthenedPattern, indexable, toConjunctionList(&filter->getCondition()), identifier);
+        Own<Condition> condition = constructPattern(rel.getAttributeTypes(), strengthenedPattern, indexable,
+                toConjunctionList(&filter->getCondition()), identifier, rel.getRepresentation());
 
         if (indexable) {
             // Merge Index Pattern here
@@ -478,8 +477,7 @@ Own<Operation> MakeIndexTransformer::rewriteIndexScan(const IndexScan* iscan) {
     return nullptr;
 }
 
-bool MakeIndexTransformer::makeIndex(Global& g, Program& program) {
-    glb = &g;
+bool MakeIndexTransformer::makeIndex(Program& program) {
     bool changed = false;
     forEachQueryMap(program, [&](auto&& go, Own<Node> node) -> Own<Node> {
         if (const Scan* scan = as<Scan>(node)) {
diff --git a/src/ram/transform/MakeIndex.h b/src/ram/transform/MakeIndex.h
index 4c35085..55b799c 100644
--- a/src/ram/transform/MakeIndex.h
+++ b/src/ram/transform/MakeIndex.h
@@ -82,7 +82,7 @@ public:
     ExpressionPair getExpressionPair(
             const Constraint* binRelOp, std::size_t& element, const std::optional<std::size_t>& identifier);
     ExpressionPair getLowerUpperExpression(Condition* c, std::size_t& element,
-            const std::optional<std::size_t>& level, const ram::Relation& rel);
+            const std::optional<std::size_t>& level, RelationRepresentation rep);
 
     /**
      * @param AttributeTypes to indicate type of each attribute in the relation
@@ -93,8 +93,9 @@ public:
      * @param RelationRepresentation identifying the data structure
      * @result Remaining conditions that could not be transformed to an index
      */
-    Own<Condition> constructPattern(const ram::Relation& rel, RamPattern& queryPattern, bool& indexable,
-            VecOwn<Condition> conditionList, std::size_t identifier);
+    Own<Condition> constructPattern(const std::vector<std::string>& attributeTypes, RamPattern& queryPattern,
+            bool& indexable, VecOwn<Condition> conditionList, std::size_t identifier,
+            RelationRepresentation rep);
 
     /**
      * @brief Rewrite a scan operation to an indexed scan operation
@@ -125,7 +126,7 @@ public:
      * @param RAM program that is transformed
      * @result Flag that indicates whether the input program has changed
      */
-    bool makeIndex(Global&, Program& program);
+    bool makeIndex(Program& program);
 
 protected:
     analysis::LevelAnalysis* rla{nullptr};
@@ -133,12 +134,10 @@ protected:
     bool transform(TranslationUnit& translationUnit) override {
         rla = &translationUnit.getAnalysis<analysis::LevelAnalysis>();
         relAnalysis = &translationUnit.getAnalysis<analysis::RelationAnalysis>();
-        return makeIndex(translationUnit.global(), translationUnit.getProgram());
+        return makeIndex(translationUnit.getProgram());
     }
 
     analysis::RelationAnalysis* relAnalysis{nullptr};
-
-    Global* glb;
 };
 
 }  // namespace souffle::ram::transform
diff --git a/src/ram/transform/Parallel.cpp b/src/ram/transform/Parallel.cpp
index 72bd09a..c18a917 100644
--- a/src/ram/transform/Parallel.cpp
+++ b/src/ram/transform/Parallel.cpp
@@ -15,7 +15,6 @@
 #include "ram/transform/Parallel.h"
 #include "ram/Condition.h"
 #include "ram/Expression.h"
-#include "ram/IntrinsicAggregator.h"
 #include "ram/Node.h"
 #include "ram/Operation.h"
 #include "ram/Program.h"
@@ -80,26 +79,19 @@ bool ParallelTransformer::parallelizeOperations(Program& program) {
                 }
             } else if (const Aggregate* aggregate = as<Aggregate>(node)) {
                 const Relation& rel = relAnalysis->lookup(aggregate->getRelation());
-                if (aggregate->getTupleId() == 0 &&
-                        !rel.isNullary()
-                        // We can only parallelize intrinsic aggregators for
-                        && isA<ram::IntrinsicAggregator>(aggregate->getAggregator())) {
+                if (aggregate->getTupleId() == 0 && !rel.isNullary()) {
                     changed = true;
-                    return mk<ParallelAggregate>(clone(aggregate->getOperation()),
-                            clone(aggregate->getAggregator()), aggregate->getRelation(),
-                            clone(aggregate->getExpression()), clone(aggregate->getCondition()),
-                            aggregate->getTupleId());
+                    return mk<ParallelAggregate>(clone(aggregate->getOperation()), aggregate->getFunction(),
+                            aggregate->getRelation(), clone(aggregate->getExpression()),
+                            clone(aggregate->getCondition()), aggregate->getTupleId());
                 }
             } else if (const IndexAggregate* indexAggregate = as<IndexAggregate>(node)) {
                 const Relation& rel = relAnalysis->lookup(indexAggregate->getRelation());
-                if (indexAggregate->getTupleId() == 0 &&
-                        !rel.isNullary()
-                        // We can only parallelize intrinsic aggregators
-                        && isA<ram::IntrinsicAggregator>(indexAggregate->getAggregator())) {
+                if (indexAggregate->getTupleId() == 0 && !rel.isNullary()) {
                     changed = true;
                     RamPattern queryPattern = clone(indexAggregate->getRangePattern());
                     return mk<ParallelIndexAggregate>(clone(indexAggregate->getOperation()),
-                            clone(indexAggregate->getAggregator()), indexAggregate->getRelation(),
+                            indexAggregate->getFunction(), indexAggregate->getRelation(),
                             clone(indexAggregate->getExpression()), clone(indexAggregate->getCondition()),
                             std::move(queryPattern), indexAggregate->getTupleId());
                 }
diff --git a/src/ram/transform/ReorderConditions.cpp b/src/ram/transform/ReorderConditions.cpp
index fdf9943..6eba118 100644
--- a/src/ram/transform/ReorderConditions.cpp
+++ b/src/ram/transform/ReorderConditions.cpp
@@ -41,10 +41,9 @@ bool ReorderConditionsTransformer::transform(TranslationUnit& tu) {
             for (auto& cond : condList) {
                 sortedConds.emplace_back(cond->cloning());
             }
-            std::stable_sort(sortedConds.begin(), sortedConds.end(),
-                    [&](const Own<Condition>& a, const Own<Condition>& b) {
-                        return rca.getComplexity(a.get()) < rca.getComplexity(b.get());
-                    });
+            std::sort(sortedConds.begin(), sortedConds.end(), [&](Own<Condition>& a, Own<Condition>& b) {
+                return rca.getComplexity(a.get()) < rca.getComplexity(b.get());
+            });
             auto sorted_node = toCondition(sortedConds);
 
             if (sorted_node != node) {
diff --git a/src/ram/transform/Transformer.cpp b/src/ram/transform/Transformer.cpp
index 6c56b72..9874a53 100644
--- a/src/ram/transform/Transformer.cpp
+++ b/src/ram/transform/Transformer.cpp
@@ -31,8 +31,8 @@
 namespace souffle::ram::transform {
 
 bool Transformer::apply(TranslationUnit& translationUnit) {
-    const bool debug = translationUnit.global().config().has("debug-report");
-    const bool verbose = translationUnit.global().config().has("verbose");
+    const bool debug = Global::config().has("debug-report");
+    const bool verbose = Global::config().has("verbose");
     std::string ramProgStrOld = debug ? toString(translationUnit.getProgram()) : "";
 
     // invoke the transformation
diff --git a/src/ram/utility/Visitor.h b/src/ram/utility/Visitor.h
index 0506e91..ccc9264 100644
--- a/src/ram/utility/Visitor.h
+++ b/src/ram/utility/Visitor.h
@@ -21,8 +21,6 @@
 #include "ram/AbstractExistenceCheck.h"
 #include "ram/AbstractOperator.h"
 #include "ram/Aggregate.h"
-#include "ram/Aggregator.h"
-#include "ram/Assign.h"
 #include "ram/AutoIncrement.h"
 #include "ram/BinRelationStatement.h"
 #include "ram/Break.h"
@@ -31,10 +29,10 @@
 #include "ram/Condition.h"
 #include "ram/Conjunction.h"
 #include "ram/Constraint.h"
+#include "ram/CountUniqueKeys.h"
 #include "ram/DebugInfo.h"
 #include "ram/EmptinessCheck.h"
 #include "ram/Erase.h"
-#include "ram/EstimateJoinSize.h"
 #include "ram/ExistenceCheck.h"
 #include "ram/Exit.h"
 #include "ram/Expression.h"
@@ -91,9 +89,7 @@
 #include "ram/UndefValue.h"
 #include "ram/UnpackRecord.h"
 #include "ram/UnsignedConstant.h"
-#include "ram/UserDefinedAggregator.h"
 #include "ram/UserDefinedOperator.h"
-#include "ram/Variable.h"
 #include "souffle/utility/FunctionalUtil.h"
 #include "souffle/utility/MiscUtil.h"
 #include "souffle/utility/Visitor.h"
@@ -123,7 +119,6 @@ struct Visitor : souffle::detail::VisitorBase<R, NodeType, Params...> {
         SOUFFLE_VISITOR_FORWARD(TupleElement);
         SOUFFLE_VISITOR_FORWARD(SignedConstant);
         SOUFFLE_VISITOR_FORWARD(UnsignedConstant);
-        SOUFFLE_VISITOR_FORWARD(Variable);
         SOUFFLE_VISITOR_FORWARD(FloatConstant);
         SOUFFLE_VISITOR_FORWARD(NumericConstant);
         SOUFFLE_VISITOR_FORWARD(StringConstant);
@@ -168,12 +163,11 @@ struct Visitor : souffle::detail::VisitorBase<R, NodeType, Params...> {
         SOUFFLE_VISITOR_FORWARD(IndexAggregate);
 
         // Statements
-        SOUFFLE_VISITOR_FORWARD(Assign);
         SOUFFLE_VISITOR_FORWARD(IO);
         SOUFFLE_VISITOR_FORWARD(Query);
         SOUFFLE_VISITOR_FORWARD(Clear);
         SOUFFLE_VISITOR_FORWARD(LogSize);
-        SOUFFLE_VISITOR_FORWARD(EstimateJoinSize);
+        SOUFFLE_VISITOR_FORWARD(CountUniqueKeys);
 
         SOUFFLE_VISITOR_FORWARD(Swap);
         SOUFFLE_VISITOR_FORWARD(MergeExtend);
@@ -199,10 +193,9 @@ protected:
     SOUFFLE_VISITOR_LINK(Query, Statement);
     SOUFFLE_VISITOR_LINK(Clear, RelationStatement);
     SOUFFLE_VISITOR_LINK(LogSize, RelationStatement);
-    SOUFFLE_VISITOR_LINK(EstimateJoinSize, RelationStatement);
+    SOUFFLE_VISITOR_LINK(CountUniqueKeys, RelationStatement);
 
     SOUFFLE_VISITOR_LINK(RelationStatement, Statement);
-    SOUFFLE_VISITOR_LINK(Assign, Statement);
 
     SOUFFLE_VISITOR_LINK(Swap, BinRelationStatement);
     SOUFFLE_VISITOR_LINK(MergeExtend, BinRelationStatement);
@@ -266,7 +259,6 @@ protected:
     SOUFFLE_VISITOR_LINK(SignedConstant, NumericConstant);
     SOUFFLE_VISITOR_LINK(UnsignedConstant, NumericConstant);
     SOUFFLE_VISITOR_LINK(FloatConstant, NumericConstant);
-    SOUFFLE_VISITOR_LINK(Variable, Expression);
     SOUFFLE_VISITOR_LINK(NumericConstant, Expression);
     SOUFFLE_VISITOR_LINK(StringConstant, Expression);
     SOUFFLE_VISITOR_LINK(UndefValue, Expression);
diff --git a/src/reports/DebugReport.cpp b/src/reports/DebugReport.cpp
index 26616fa..158aaf5 100644
--- a/src/reports/DebugReport.cpp
+++ b/src/reports/DebugReport.cpp
@@ -59,19 +59,6 @@ std::string replaceAll(std::string_view text, std::string_view key, std::string_
 }
 }  // namespace
 
-DebugReport::DebugReport() : enabled(false), reportPath(), programName() {}
-
-DebugReport::DebugReport(Global& glb) {
-    enabled = !glb.config().get("debug-report").empty();
-    if (enabled) {
-        reportPath = glb.config().get("debug-report");
-        programName = glb.config().get("");
-    }
-}
-
-DebugReport::DebugReport(const std::string& report_path, const std::string& program_name)
-        : enabled(true), reportPath(report_path), programName(program_name) {}
-
 void DebugReportSection::printIndex(std::ostream& out) const {
     out << "<a href=\"#" << id << "\">" << title << "</a>\n";
     out << "<ul>\n";
@@ -121,41 +108,28 @@ DebugReport::~DebugReport() {
 }
 
 void DebugReport::flush() {
-    if (!enabled || empty()) return;
-
-    std::ofstream(*reportPath) << *this;
-}
-
-bool DebugReport::empty() const {
-    return sections.empty();
-}
-
-void DebugReport::addSection(DebugReportSection section) {
-    auto& buf = currentSubsections.empty() ? sections : currentSubsections.top();
-    buf.emplace_back(std::move(section));
-}
+    auto&& dst = Global::config().get("debug-report");
+    if (dst.empty() || empty()) return;
 
-static std::string codeToHtml(const std::string_view code) {
-    return replaceAll(
-            replaceAll(replaceAll(replaceAll(replaceAll(code, "&", "&nbsp;"), "<", "&lt;"), ">", "&gt;"),
-                    "\"", "&ldquo;"),
-            "'", "&lsquo");
+    std::ofstream(dst) << *this;
 }
 
 void DebugReport::addSection(std::string id, std::string title, const std::string_view code) {
     addSection(DebugReportSection(
-            std::move(id), std::move(title), tfm::format("<pre>%s</pre>", codeToHtml(code))));
+            std::move(id), std::move(title), tfm::format("<pre>%s</pre>", replaceAll(code, "<", "&lt"))));
 }
 
-void DebugReport::addCodeSection(std::string id, std::string title,
-        [[maybe_unused]] std::string_view language, std::string_view prev, std::string_view curr) {
-    const std::string diff = (prev.empty() ? std::string(curr) : generateDiff(prev, curr));
+void DebugReport::addCodeSection(std::string id, std::string title, std::string_view language,
+        std::string_view prev, std::string_view curr) {
+    auto diff =
+            replaceAll(replaceAll(prev.empty() ? curr : generateDiff(prev, curr), "\\", "\\\\"), "`", "\\`");
     auto divId = nextUniqueId++;
     auto html = R"(
-        <div id="code-id-%d" class="diff-%s">%s</div>
+        <div id="code-id-%d"></div>
+        <script type="text/javascript"> renderDiff('%s', 'code-id-%d', `%s`) </script>
     )";
     addSection(DebugReportSection(
-            std::move(id), std::move(title), tfm::format(html, divId, language, codeToHtml(diff))));
+            std::move(id), std::move(title), tfm::format(html, divId, language, divId, diff)));
 }
 
 void DebugReport::endSection(std::string currentSectionName, std::string currentSectionTitle) {
@@ -167,13 +141,13 @@ void DebugReport::endSection(std::string currentSectionName, std::string current
 }
 
 void DebugReport::print(std::ostream& out) const {
-    out << R"--html--(
+    out << R"(
 <!DOCTYPE html>
-<html lang="en">
-<meta charset="utf8">
+<html lang='en-AU'>
 <head>
-<title>Souffle Debug Report ()--html--";
-    out << *programName << R"--html--()</title>
+<meta charset=\"UTF-8\">
+<title>Souffle Debug Report ()";
+    out << Global::config().get("") << R"()</title>
 <style>
     ul { list-style-type: none; }
     ul > li.leaf { display: inline-block; padding: 0em 1em; }
@@ -188,15 +162,15 @@ void DebugReport::print(std::ostream& out) const {
     .headerdiv a { float:right; }
 </style>
 
-<link rel="stylesheet" href=
-  "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/styles/default.min.css">
-<script src=
-  "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.8.0/build/highlight.min.js"></script>
+<link rel="stylesheet" type="text/css" href=
+    "https://cdn.jsdelivr.net/npm/highlight.js@10.0.0/styles/default.min.css" />
+<script type="text/javascript" src=
+    "https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.0.0/build/highlight.min.js"></script>
 
 <link rel="stylesheet" type="text/css" href=
-    "https://cdn.jsdelivr.net/npm/diff2html@3.4.34/bundles/css/diff2html.min.css" />
+    "https://cdn.jsdelivr.net/npm/diff2html/bundles/css/diff2html.min.css" />
 <script type="text/javascript" src=
-    "https://cdn.jsdelivr.net/npm/diff2html@3.4.34/bundles/js/diff2html-ui-base.min.js"></script>
+    "https://cdn.jsdelivr.net/npm/diff2html/bundles/js/diff2html-ui-base.min.js"></script>
 
 <script>
   function toggleVisibility(id) {
@@ -216,195 +190,97 @@ void DebugReport::print(std::ostream& out) const {
       ]
 
       let KEYWORDS = {
-        $pattern: /\.?\w+/,
+        $pattern: '\\.?\\w+',
         literal: 'true false',
-        keyword: '.pragma .functor .comp .init .override .decl .input .output .type .plan .include .once .lattice ' +
-          'ord strlen strsub range matches land lor lxor lnot bwand bwor bwxor bwnot bshl bshr bshru inline btree btree_delete override unsigned number float symbol',
+        keyword: '.pragma .functor .component .decl .input .output ' +
+          'ord strlen strsub range matches land lor lxor lnot bwand bwor bwxor bwnot bshl bshr bshru',
       }
 
       let STRING = hljs.QUOTE_STRING_MODE
       let NUMBERS = {
-        scope: 'number', relevance: 0, variants: [
-          { begin: /\b0b[01]+/ },
-          { begin: /\b\d+\.\d+/ }, // float
-          { begin: /\b\d+\.\d+.\d+.\d+/ }, // IPv4 literal
-          { begin: /\b\d+u?/ },
-          { begin: /\b0x[a-fA-F0-9]+u?/ }
+        className: 'number', relevance: 0, variants: [
+          { begin: /0b[01]+/ },
+          { begin: /\d+\.\d+/ }, // float
+          { begin: /\d+\.\d+.\d+.\d+/ }, // IPv4 literal
+          { begin: /\d+u?/ },
+          { begin: /0x[a-fA-F0-9]+u?/ }
         ]
       }
 
-      let ANNOTATIONS = {
-        scope: 'meta',
-        begin: /@\s*\!?\s*\[/,
-        end: /\]/,
-        contains: [
-          {
-            begin: /\[/,
-            end: /\]/,
-            contains: [
-              'self',
-              hljs.inherit(STRING, { scope: 'meta-string' }),
-            ]
-          },
-        ].concat(COMMENT_MODES)
-      };
-
       let PREPROCESSOR = {
-        scope: 'meta',
+        className: 'meta',
         begin: /#\s*[a-z]+\b/,
         end: /$/,
-        keyword: {
+        keywords: {
           'meta-keyword': 'if else elif endif define undef warning error line pragma ifdef ifndef include'
         },
         contains: [
           { begin: /\\\n/, relevance: 0 },
-          hljs.inherit(STRING, { scope: 'meta-string' }),
+          hljs.inherit(STRING, { className: 'meta-string' }),
         ].concat(COMMENT_MODES)
       };
 
-      let PRED_OP = { begin: /:\-/, scope: 'keyword' } // relevance booster
-
-      let RELATION_DISPATCH = {
-          scope: 'title.function',
-          relevance: 0,
-          begin: hljs.regex.concat(hljs.IDENT_RE, hljs.regex.lookahead(/\s*\(/))
-      };
+      let ATOM = { begin: /[a-z][A-Za-z0-9_]*/, relevance: 0 }
+      let VAR = {
+        className: 'symbol', relevance: 0, variants: [
+          { begin: /[A-Z][a-zA-Z0-9_]*/ },
+          { begin: /_[A-Za-z0-9_]*/ },
+        ]
+      }
+      let PARENTED = { begin: /\(/, end: /\)/, relevance: 0 }
+      let LIST = { begin: /\[/, end: /\]/ }
+      let PRED_OP = { begin: /:-/ } // relevance booster
 
       let INNER = [
-        RELATION_DISPATCH,
+        ATOM,
+        VAR,
+        PARENTED,
         PRED_OP,
+        LIST,
         STRING,
         NUMBERS,
-        PREPROCESSOR,
-        ANNOTATIONS
       ].concat(COMMENT_MODES)
 
+      PARENTED.contains = INNER;
+      LIST.contains = INNER;
+
       return {
         name: 'souffle',
         keywords: KEYWORDS,
         contains: INNER.concat([{ begin: /\.$/ }]) // relevance booster
       };
-    });
-
-    hljs.registerLanguage('ram', function (hljs) {
-      const COMMENT_MODES = [
-        hljs.C_LINE_COMMENT_MODE,
-        hljs.C_BLOCK_COMMENT_MODE,
-      ];
-
-      const KEYWORDS = {
-        keyword: [
-          'ALL',
-          'AND',
-          'BEGIN',
-          'CALL',
-          'CLEAR',
-          'DEBUG',
-          'DECLARATION',
-          'END',
-          'EXIT',
-          'FLOAT',
-          'FOR',
-          'IF',
-          'IN',
-          'INDEX',
-          'INSERT',
-          'INTO',
-          'IO',
-          'ISEMPTY',
-          'LOOP',
-          'MAIN',
-          'NOT',
-          'NUMBER',
-          'ON',
-          'PROGRAM',
-          'QUERY',
-          'SEARCH',
-          'STRING',
-          'SUBROUTINE',
-          'SWAP',
-          'UNSIGNED',
-          'count',
-          'max',
-          'mean',
-          'min',
-          'sum',
-        ],
-      };
-
-      const STRING = hljs.QUOTE_STRING_MODE;
-
-      const INDEX = {
-        scope: 'variable',
-        begin: /\bt\d+(\.\d+)?/
-      }
-
-      const INNER = [
-        INDEX,
-        hljs.QUOTE_STRING_MODE,
-        hljs.C_NUMBER_MODE,
-      ].concat(COMMENT_MODES)
-
-      return {
-        name: 'ram',
-        keywords: KEYWORDS,
-        contains: INNER
-      };
-    });
-
-    hljs.configure({ languages: ['souffle', 'ram'] })
+    })
+    // TODO: Add a highlighter for `ram`
+    hljs.configure({ languages: ['souffle'] })
   }
 
   if (typeof Diff2HtmlUI !== 'undefined' && typeof hljs !== 'undefined') {
+    function renderDiff(lang, id, diff) {
       // file extension determines the language used for highlighting
-      let souffle_file = `Datalog.souffle`
-      let souffle_prefix = `diff ${souffle_file} ${souffle_file}
---- ${souffle_file}
-+++ ${souffle_file}
+      let file   = `Datalog.${lang}`
+      let prefix = `diff ${file} ${file}
+--- ${file}
++++ ${file}
 @@ -1 +1 @@
 `
-      let ram_file = `Datalog.ram`
-      let ram_prefix = `diff ${ram_file} ${ram_file}
---- ${ram_file}
-+++ ${ram_file}
-@@ -1 +1 @@
-`
-      let extLang = new Map();
-      extLang.set('souffle', 'souffle');
-      extLang.set('ram', 'ram');
-
-      document.addEventListener('DOMContentLoaded', function() {
-          var els = document.getElementsByClassName("diff-souffle");
-          Array.prototype.forEach.call(els, function(el) {
-              diff2htmlUi = new Diff2HtmlUI(el, souffle_prefix + el.textContent, {
-                  drawFileList: false,
-                  highlight: true,
-                  matching: 'none',
-                  outputFormat: 'side-by-side',
-                  synchronisedScroll: true,
-                  highlightLanguages: extLang
-              }, hljs);
-              diff2htmlUi.draw();
-          });
-          var els = document.getElementsByClassName("diff-ram");
-          Array.prototype.forEach.call(els, function(el) {
-              diff2htmlUi = new Diff2HtmlUI(el, ram_prefix + el.textContent, {
-                  drawFileList: false,
-                  highlight: true,
-                  matching: 'none',
-                  outputFormat: 'side-by-side',
-                  synchronisedScroll: true,
-                  highlightLanguages: extLang
-              }, hljs);
-              diff2htmlUi.draw();
-          });
-      });
+      new Diff2HtmlUI(document.getElementById(id), prefix + diff, {
+        drawFileList: false,
+        highlight: true,
+        matching: 'none',
+        outputFormat: 'side-by-side',
+        synchronisedScroll: true,
+      }, hljs).draw()
+    }
+  } else { // fallback to plain text
+    function renderDiff(lang, id, diff) {
+      document.getElementById(id).innerText = diff
+    }
   }
 </script>
 </head>
 <body>
-<div class='headerdiv'><h1>Souffle Debug Report ()--html--";
-    out << *programName << ")</h1></div>\n";
+<div class='headerdiv'><h1>Souffle Debug Report ()";
+    out << Global::config().get("") << ")</h1></div>\n";
     for (const DebugReportSection& section : sections) {
         section.printIndex(out);
     }
diff --git a/src/reports/DebugReport.h b/src/reports/DebugReport.h
index 5a8fa57..85e78bb 100644
--- a/src/reports/DebugReport.h
+++ b/src/reports/DebugReport.h
@@ -15,10 +15,7 @@
  ***********************************************************************/
 #pragma once
 
-#include "Global.h"
-
 #include <cstdint>
-#include <optional>
 #include <ostream>
 #include <stack>
 #include <string>
@@ -83,17 +80,14 @@ private:
  */
 class DebugReport {
 public:
-    DebugReport();
-
-    DebugReport(Global& glb);
-
-    DebugReport(const std::string& report_path, const std::string& program_name);
-
     ~DebugReport();
 
     void flush();
 
-    void addSection(DebugReportSection section);
+    void addSection(DebugReportSection section) {
+        auto& buf = currentSubsections.empty() ? sections : currentSubsections.top();
+        buf.emplace_back(std::move(section));
+    }
 
     void addSection(std::string id, std::string title, std::string_view code);
     void addCodeSection(std::string id, std::string title, std::string_view language, std::string_view prev,
@@ -123,15 +117,13 @@ public:
     }
 
 private:
-    bool enabled;
-    std::optional<std::string> reportPath;
-    std::optional<std::string> programName;
-
     std::vector<DebugReportSection> sections;
     std::stack<std::vector<DebugReportSection>> currentSubsections;
     uint32_t nextUniqueId = 0;  // used for generating unique HTML `id` tags
 
-    bool empty() const;
+    bool empty() const {
+        return sections.empty();
+    }
 };
 
 }  // end of namespace souffle
diff --git a/src/reports/ErrorReport.h b/src/reports/ErrorReport.h
index cb82004..043dc78 100644
--- a/src/reports/ErrorReport.h
+++ b/src/reports/ErrorReport.h
@@ -18,11 +18,9 @@
 
 #include "parser/SrcLocation.h"
 #include <algorithm>
-#include <bitset>
 #include <cassert>
 #include <cstdlib>
 #include <iostream>
-#include <optional>
 #include <set>
 #include <string>
 #include <utility>
@@ -145,68 +143,9 @@ private:
     std::vector<DiagnosticMessage> additionalMessages;
 };
 
-enum class WarnType : std::size_t {
-    DeprecatedTypeDecl,
-    DeprecatedQualifier,
-    DollarSign,
-    LatticeMissingOperator,
-    NoRulesNorFacts,
-    NoSubsumptiveRule,
-    VarAppearsOnce,
-    UselessDocComment,
-    UselessAnnotation,
-
-    // last element, never used except for computing the size parameter of
-    // bitset_type in the definition of WarnSet.
-    LastWarnType
-};
-
-class WarnSet {
-private:
-    using bitset_type = std::bitset<(std::size_t)WarnType::LastWarnType>;
-
-public:
-    WarnSet() : warns(bitset_type()) {
-        this->set();  // default to enabling all warnings
-    }
-
-    WarnSet(const WarnSet& other) = default;
-
-    bool test(const WarnType warn);
-
-    // Enable all warnings
-    void set();
-
-    // Enable one warning
-    void set(const WarnType warn);
-
-    // Disable all warnings
-    void reset(const WarnType warn);
-
-    // Disable one warning
-    void reset();
-
-    // Enable one warning
-    //
-    // Returns whether or not the string was valid
-    bool setStr(const std::string& str);
-
-    // Disable one warning
-    //
-    // Returns whether or not the string was valid
-    bool resetStr(const std::string& str);
-
-private:
-    bitset_type warns;
-
-    std::optional<WarnType> warnTypeFromString(const std::string& s);
-};
-
 class ErrorReport {
 public:
-    ErrorReport() : warns(WarnSet()) {}
-
-    ErrorReport(WarnSet warns) : warns(warns) {}
+    ErrorReport(bool nowarn = false) : nowarn(nowarn) {}
 
     ErrorReport(const ErrorReport& other) = default;
 
@@ -231,8 +170,8 @@ public:
     }
 
     /** Adds a warning with the given message and location */
-    void addWarning(const WarnType type, const std::string& message, SrcLocation location) {
-        if (warns.test(type)) {
+    void addWarning(const std::string& message, SrcLocation location) {
+        if (!nowarn) {
             diagnostics.insert(
                     Diagnostic(Diagnostic::Type::WARNING, DiagnosticMessage(message, std::move(location))));
         }
@@ -264,7 +203,7 @@ public:
 
 private:
     std::set<Diagnostic> diagnostics;
-    WarnSet warns;
+    bool nowarn;
 };
 
 }  // end of namespace souffle
diff --git a/src/souffle-compile.template.py b/src/souffle-compile.template.py
index 48ee304..0180bda 100644
--- a/src/souffle-compile.template.py
+++ b/src/souffle-compile.template.py
@@ -74,24 +74,20 @@ parser.add_argument('-L', action='append', default=[], metavar='LIBDIR', dest='l
 parser.add_argument('-g', action='store_true', dest='debug', help="Debug build type")
 parser.add_argument('-s', metavar='LANG', dest='swiglang', choices=["java", "python"], help="use SWIG interface to generate into LANG language")
 parser.add_argument('-v', action='store_true', dest='verbose', help="Verbose output")
-parser.add_argument('source', nargs='+', metavar='SOURCE', type=lambda p: pathlib.Path(p).absolute(), help="C++ source files")
-parser.add_argument('-o', metavar='BINARY', dest='output', type=lambda p: pathlib.Path(p).absolute(), help="Binary file name")
+parser.add_argument('source', metavar='SOURCE', type=lambda p: pathlib.Path(p).absolute(), help="C++ source file")
 
 args = parser.parse_args()
 
-if not args.output:
-    raise RuntimeError("Missing output file name in souffle-compile")
-
-for f in args.source:
-    if not os.path.isfile(f):
-        raise RuntimeError("Cannot open source file: '{}'".format(f))
+stemname = args.source.stem
+dirname = args.source.parent
 
+if not os.path.isfile(args.source):
+    raise RuntimeError("Cannot open source file: '{}'".format(args.source))
 
 # Check if the input file has a valid extension
-for f in args.source:
-    extname = f.suffix
-    if extname != ".cpp":
-        raise RuntimeError("Source file is not a .cpp file: '{}'".format(f))
+extname = args.source.suffix
+if extname != ".cpp":
+    raise RuntimeError("Source file is not a .cpp file: '{}'".format(args.source))
 
 # Search for Souffle includes directory
 souffle_include_dir = None
@@ -130,8 +126,7 @@ if args.swiglang:
         cmd.append("-c")
         cmd.append("-D__EMBEDDED_SOUFFLE__")
         cmd.append("SwigInterface_wrap.cxx")
-        for f in args.source:
-            cmd.append(str(f))
+        cmd.append(str(args.source))
         cmd.append(conf['definitions'])
         cmd.append(conf['compile_options'])
         cmd.append(conf['includes'])
@@ -150,7 +145,7 @@ if args.swiglang:
         cmd.append('"{}"'.format(conf['compiler']))
         cmd.append("-shared")
         cmd.append("SwigInterface_wrap.o")
-        cmd.append(os.path.basename(args.output) + ".o")
+        cmd.append("{}{}".format(stemname, ".o"))
         cmd.append("-o")
         cmd.append(swig_outname)
         cmd.append(conf['definitions'])
@@ -181,7 +176,7 @@ if args.swiglang:
         # move generated files to same directory as cpp file
         os.sys.exit(0)
 else:
-    exepath = pathlib.Path("{}{}".format(args.output, exeext))
+    exepath = pathlib.Path(dirname.joinpath("{}{}".format(stemname, exeext)))
 
     cmd = []
     cmd.append('"{}"'.format(conf['compiler']))
@@ -197,8 +192,7 @@ else:
         cmd.append(conf['release_cxx_flags'])
 
     cmd.append(OUTNAME_FMT.format(exepath))
-    for f in args.source:
-        cmd.append(str(f))
+    cmd.append(str(args.source))
 
     cmd.append(conf['link_options'])
     cmd.extend(list(map(lambda rpath: RPATH_FMT.format(rpath), RPATHS)))
diff --git a/src/souffle_prof.cpp b/src/souffle_prof.cpp
index be9fd2b..06a7749 100644
--- a/src/souffle_prof.cpp
+++ b/src/souffle_prof.cpp
@@ -20,7 +20,7 @@
 
 int main(int argc, char* argv[]) {
     souffle::profile::Cli cli_obj(argc, argv);
-    const int status = cli_obj.parse();
+    cli_obj.parse();
     std::cout << "\n";
-    return status;
+    return 0;
 }
diff --git a/src/synthesiser/Relation.cpp b/src/synthesiser/Relation.cpp
index 27a12a6..677de4b 100644
--- a/src/synthesiser/Relation.cpp
+++ b/src/synthesiser/Relation.cpp
@@ -12,7 +12,6 @@
 #include "souffle/SouffleInterface.h"
 #include "souffle/utility/MiscUtil.h"
 #include "souffle/utility/StreamUtil.h"
-#include "synthesiser/Utils.h"
 #include <algorithm>
 #include <cassert>
 #include <functional>
@@ -48,16 +47,15 @@ Own<Relation> Relation::getSynthesiserRelation(
         const ram::Relation& ramRel, const ram::analysis::IndexCluster& indexSelection) {
     Relation* rel;
 
-    bool hasProvenance = ramRel.getArity() > 0 && ramRel.getAttributeNames().back() == "@level_number";
     // Handle the qualifier in souffle code
-    if (ramRel.getAuxiliaryArity() > 0) {
-        rel = new DirectRelation(ramRel, indexSelection, true, hasProvenance, false);
+    if (ramRel.getRepresentation() == RelationRepresentation::PROVENANCE) {
+        rel = new DirectRelation(ramRel, indexSelection, true, false);
     } else if (ramRel.isNullary()) {
         rel = new NullaryRelation(ramRel, indexSelection);
     } else if (ramRel.getRepresentation() == RelationRepresentation::BTREE) {
-        rel = new DirectRelation(ramRel, indexSelection, false, false, false);
+        rel = new DirectRelation(ramRel, indexSelection, false, false);
     } else if (ramRel.getRepresentation() == RelationRepresentation::BTREE_DELETE) {
-        rel = new DirectRelation(ramRel, indexSelection, false, false, true);
+        rel = new DirectRelation(ramRel, indexSelection, false, true);
     } else if (ramRel.getRepresentation() == RelationRepresentation::BRIE) {
         rel = new BrieRelation(ramRel, indexSelection);
     } else if (ramRel.getRepresentation() == RelationRepresentation::EQREL) {
@@ -69,7 +67,7 @@ Own<Relation> Relation::getSynthesiserRelation(
         if (ramRel.getArity() > 6) {
             rel = new IndirectRelation(ramRel, indexSelection);
         } else {
-            rel = new DirectRelation(ramRel, indexSelection, false, false, false);
+            rel = new DirectRelation(ramRel, indexSelection, false, false);
         }
     }
 
@@ -93,9 +91,8 @@ std::string InfoRelation::getTypeName() {
 }
 
 /** Generate type struct of a info relation, which is empty,
- * the actual implementation is in Info.h */
-void InfoRelation::generateTypeStruct(GenDb& db) {
-    db.datastructureIncludes(getTypeName(), "\"souffle/datastructure/Info.h\"");
+ * the actual implementation is in CompiledSouffle.h */
+void InfoRelation::generateTypeStruct(std::ostream&) {
     return;
 }
 
@@ -112,9 +109,8 @@ std::string NullaryRelation::getTypeName() {
 }
 
 /** Generate type struct of a nullary relation, which is empty,
- * the actual implementation is in Nullaries.h */
-void NullaryRelation::generateTypeStruct(GenDb& db) {
-    db.datastructureIncludes(getTypeName(), "\"souffle/datastructure/Nullaries.h\"");
+ * the actual implementation is in CompiledSouffle.h */
+void NullaryRelation::generateTypeStruct(std::ostream&) {
     return;
 }
 
@@ -138,7 +134,7 @@ void DirectRelation::computeIndices() {
         // we must expand all search orders to be full indices,
         // since weak/strong comparators and updaters need this,
         // and also add provenance annotations to the indices
-        if (hasAuxiliary || hasErase) {
+        if (isProvenance || hasErase) {
             // expand index to be full
             for (std::size_t i = 0; i < getArity() - relation.getAuxiliaryArity(); i++) {
                 if (curIndexElems.find(i) == curIndexElems.end()) {
@@ -146,18 +142,21 @@ void DirectRelation::computeIndices() {
                 }
             }
 
-            if (hasAuxiliary) {
+            if (isProvenance) {
                 // remove any provenance annotations already in the index order
-                std::size_t n = getArity() - relation.getAuxiliaryArity();
-                for (std::size_t i = n; i < getArity(); i++) {
-                    if (curIndexElems.find(i) != curIndexElems.end()) {
-                        ind.erase(std::find(ind.begin(), ind.end(), i));
-                    }
+                if (curIndexElems.find(getArity() - relation.getAuxiliaryArity() + 1) !=
+                        curIndexElems.end()) {
+                    ind.erase(
+                            std::find(ind.begin(), ind.end(), getArity() - relation.getAuxiliaryArity() + 1));
                 }
-                // add provenance annotations to the index, but in reverse order
-                for (std::size_t i = getArity(); i > n; i--) {
-                    ind.push_back(i - 1);
+
+                if (curIndexElems.find(getArity() - relation.getAuxiliaryArity()) != curIndexElems.end()) {
+                    ind.erase(std::find(ind.begin(), ind.end(), getArity() - relation.getAuxiliaryArity()));
                 }
+
+                // add provenance annotations to the index, but in reverse order
+                ind.push_back(getArity() - relation.getAuxiliaryArity() + 1);
+                ind.push_back(getArity() - relation.getAuxiliaryArity());
             }
             masterIndex = 0;
         } else if (ind.size() == getArity()) {
@@ -170,7 +169,7 @@ void DirectRelation::computeIndices() {
 }
 
 /** Generate type name of a direct indexed relation */
-std::string DirectRelation::getTypeNamespace() {
+std::string DirectRelation::getTypeName() {
     // collect all attributes used in the lex-order
     std::unordered_set<std::size_t> attributesUsed;
     for (auto& ind : getIndices()) {
@@ -180,8 +179,11 @@ std::string DirectRelation::getTypeNamespace() {
     }
 
     std::stringstream res;
-    res << "t_btree_";
-    res << hasErase << hasAuxiliary << hasProvenance << "_";
+    if (hasErase) {
+        res << "t_btree_delete_";
+    } else {
+        res << "t_btree_";
+    }
     res << getTypeAttributeString(relation.getAttributeTypes(), attributesUsed);
 
     for (auto& ind : getIndices()) {
@@ -195,12 +197,8 @@ std::string DirectRelation::getTypeNamespace() {
     return res.str();
 }
 
-std::string DirectRelation::getTypeName() {
-    return getTypeNamespace() + "::Type";
-}
-
 /** Generate type struct of a direct indexed relation */
-void DirectRelation::generateTypeStruct(GenDb& db) {
+void DirectRelation::generateTypeStruct(std::ostream& out) {
     std::size_t arity = getArity();
     std::size_t auxiliaryArity = relation.getAuxiliaryArity();
     auto types = relation.getAttributeTypes();
@@ -208,56 +206,24 @@ void DirectRelation::generateTypeStruct(GenDb& db) {
     std::size_t numIndexes = inds.size();
     std::map<LexOrder, std::size_t> indexToNumMap;
 
-    fs::path basename(uniqueCppIdent(getTypeNamespace(), 20));
-    GenDatastructure& cl = db.getDatastructure("Type", basename, std::make_optional(getTypeNamespace()));
-    std::ostream& decl = cl.decl();
-    std::ostream& def = cl.def();
-
-    cl.addInclude("\"souffle/SouffleInterface.h\"");
-    if (hasErase) {
-        cl.addInclude("\"souffle/datastructure/BTreeDelete.h\"");
-    } else {
-        cl.addInclude("\"souffle/datastructure/BTree.h\"");
-    }
-
     // struct definition
-    decl << "struct Type {\n";
-    decl << "static constexpr Relation::arity_type Arity = " << arity << ";\n";
+    out << "struct " << getTypeName() << " {\n";
+    out << "static constexpr Relation::arity_type Arity = " << arity << ";\n";
 
     // stored tuple type
-    decl << "using t_tuple = Tuple<RamDomain, " << arity << ">;\n";
+    out << "using t_tuple = Tuple<RamDomain, " << arity << ">;\n";
 
     // generate an updater class for provenance
-    if (hasAuxiliary) {
-        decl << "struct updater {\n";
-        decl << "bool update(t_tuple& old_t, const t_tuple& new_t) {\n";
-        decl << "bool changed = false;\n";
-        if (hasProvenance) {
-            assert(auxiliaryArity == 2);
-            auto rule = arity - 2;
-            auto level = arity - 1;
-            decl << "if (ramBitCast<RamSigned>(new_t[" << level << "]) < ramBitCast<RamSigned>(old_t["
-                 << level << "])"
-                 << " || (ramBitCast<RamSigned>(new_t[" << level << "]) == ramBitCast<RamSigned>(old_t["
-                 << level << "])"
-                 << " && ramBitCast<RamSigned>(new_t[" << rule << "]) < ramBitCast<RamSigned>(old_t[" << rule
-                 << "]))) {\n";
-            decl << "    old_t[" << rule << "] = new_t[" << rule << "];\n";
-            decl << "    old_t[" << level << "] = new_t[" << level << "];\n";
-            decl << "    changed = true;\n";
-            decl << "}\n";
-        } else {
-            for (std::size_t i = arity - auxiliaryArity; i < arity; i++) {
-                decl << "if (old_t[" << i << "] != new_t[" << i << "]) {\n";
-                decl << "    changed = true;\n";
-                decl << "    old_t[" << i << "] = new_t[" << i << "];\n";
-                decl << "}\n";
-            }
+    if (isProvenance) {
+        out << "struct updater_" << getTypeName() << " {\n";
+        out << "void update(t_tuple& old_t, const t_tuple& new_t) {\n";
+
+        for (std::size_t i = arity - auxiliaryArity; i < arity; i++) {
+            out << "old_t[" << i << "] = new_t[" << i << "];\n";
         }
-        decl << "return changed;\n";
 
-        decl << "}\n";
-        decl << "};\n";
+        out << "}\n";
+        out << "};\n";
     }
 
     // generate the btree type for each relation
@@ -280,57 +246,56 @@ void DirectRelation::generateTypeStruct(GenDb& db) {
         }
 
         auto genstruct = [&](std::string name, std::size_t bound) {
-            decl << "struct " << name << "{\n";
-            decl << " int operator()(const t_tuple& a, const t_tuple& b) const {\n";
-            decl << "  return ";
+            out << "struct " << name << "{\n";
+            out << " int operator()(const t_tuple& a, const t_tuple& b) const {\n";
+            out << "  return ";
             std::function<void(std::size_t)> gencmp = [&](std::size_t i) {
                 std::size_t attrib = ind[i];
                 const auto& typecast = typecasts[attrib];
 
-                decl << "(" << typecast << "(a[" << attrib << "]) < " << typecast << "(b[" << attrib
-                     << "])) ? -1 : (" << typecast << "(a[" << attrib << "]) > " << typecast << "(b["
-                     << attrib << "])) ? 1 :(";
+                out << "(" << typecast << "(a[" << attrib << "]) < " << typecast << "(b[" << attrib
+                    << "])) ? -1 : (" << typecast << "(a[" << attrib << "]) > " << typecast << "(b[" << attrib
+                    << "])) ? 1 :(";
                 if (i + 1 < bound) {
                     gencmp(i + 1);
                 } else {
-                    decl << "0";
+                    out << "0";
                 }
-                decl << ")";
+                out << ")";
             };
             gencmp(0);
-            decl << ";\n }\n";
-            decl << "bool less(const t_tuple& a, const t_tuple& b) const {\n";
-            decl << "  return ";
+            out << ";\n }\n";
+            out << "bool less(const t_tuple& a, const t_tuple& b) const {\n";
+            out << "  return ";
             std::function<void(std::size_t)> genless = [&](std::size_t i) {
                 std::size_t attrib = ind[i];
                 const auto& typecast = typecasts[attrib];
 
-                decl << "(" << typecast << "(a[" << attrib << "]) < " << typecast << "(b[" << attrib << "]))";
+                out << "(" << typecast << "(a[" << attrib << "]) < " << typecast << "(b[" << attrib << "]))";
                 if (i + 1 < bound) {
-                    decl << "|| ((" << typecast << "(a[" << attrib << "]) == " << typecast << "(b[" << attrib
-                         << "])) && (";
+                    out << "|| ((" << typecast << "(a[" << attrib << "]) == " << typecast << "(b[" << attrib
+                        << "])) && (";
                     genless(i + 1);
-                    decl << "))";
+                    out << "))";
                 }
             };
             genless(0);
-            decl << ";\n }\n";
-            decl << "bool equal(const t_tuple& a, const t_tuple& b) const {\n";
-            decl << "return ";
+            out << ";\n }\n";
+            out << "bool equal(const t_tuple& a, const t_tuple& b) const {\n";
+            out << "return ";
             std::function<void(std::size_t)> geneq = [&](std::size_t i) {
                 std::size_t attrib = ind[i];
                 const auto& typecast = typecasts[attrib];
 
-                decl << "(" << typecast << "(a[" << attrib << "]) == " << typecast << "(b[" << attrib
-                     << "]))";
+                out << "(" << typecast << "(a[" << attrib << "]) == " << typecast << "(b[" << attrib << "]))";
                 if (i + 1 < bound) {
-                    decl << "&&";
+                    out << "&&";
                     geneq(i + 1);
                 }
             };
             geneq(0);
-            decl << ";\n }\n";
-            decl << "};\n";
+            out << ";\n }\n";
+            out << "};\n";
         };
 
         std::string comparator = "t_comparator_" + std::to_string(i);
@@ -339,7 +304,7 @@ void DirectRelation::generateTypeStruct(GenDb& db) {
         // for provenance, all indices must be full so we use btree_set
         // also strong/weak comparators and updater methods
 
-        if (hasAuxiliary) {
+        if (isProvenance) {
             std::string comparator_aux;
             if (provenanceIndexNumbers.find(i) == provenanceIndexNumbers.end()) {
                 // index for bottom up phase
@@ -349,90 +314,81 @@ void DirectRelation::generateTypeStruct(GenDb& db) {
                 // index for top down phase
                 comparator_aux = comparator;
             }
-            decl << "using t_ind_" << i << " = btree_set<t_tuple," << comparator
-                 << ",std::allocator<t_tuple>,256,typename "
-                    "souffle::detail::default_strategy<t_tuple>::type,"
-                 << comparator_aux << ",updater>;\n";
+            out << "using t_ind_" << i << " = btree_set<t_tuple," << comparator
+                << ",std::allocator<t_tuple>,256,typename "
+                   "souffle::detail::default_strategy<t_tuple>::type,"
+                << comparator_aux << ",updater_" << getTypeName() << ">;\n";
         } else {
             std::string btree_name = "btree";
             if (hasErase) {
                 btree_name = "btree_delete";
             }
             if (ind.size() == arity) {
-                decl << "using t_ind_" << i << " = " << btree_name << "_set<t_tuple," << comparator << ">;\n";
+                out << "using t_ind_" << i << " = " << btree_name << "_set<t_tuple," << comparator << ">;\n";
             } else {
                 // without provenance, some indices may be not full, so we use btree_multiset for those
-                decl << "using t_ind_" << i << " = " << btree_name << "_multiset<t_tuple," << comparator
-                     << ">;\n";
+                out << "using t_ind_" << i << " = " << btree_name << "_multiset<t_tuple," << comparator
+                    << ">;\n";
             }
         }
-        decl << "t_ind_" << i << " ind_" << i << ";\n";
-        def << "using t_ind_" << i << " = Type::t_ind_" << i << ";\n";
+        out << "t_ind_" << i << " ind_" << i << ";\n";
     }
 
     // typedef master index iterator to be struct iterator
-    decl << "using iterator = t_ind_" << masterIndex << "::iterator;\n";
-    def << "using iterator = Type::iterator;\n";
+    out << "using iterator = t_ind_" << masterIndex << "::iterator;\n";
 
     // create a struct storing hints for each btree
-    decl << "struct context {\n";
+    out << "struct context {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        decl << "t_ind_" << i << "::operation_hints hints_" << i << "_lower"
-             << ";\n";
-        decl << "t_ind_" << i << "::operation_hints hints_" << i << "_upper"
-             << ";\n";
+        out << "t_ind_" << i << "::operation_hints hints_" << i << "_lower"
+            << ";\n";
+        out << "t_ind_" << i << "::operation_hints hints_" << i << "_upper"
+            << ";\n";
     }
-    decl << "};\n";
-    def << "using context = Type::context;\n";
-    decl << "context createContext() { return context(); }\n";
+    out << "};\n";
+    out << "context createContext() { return context(); }\n";
 
     // erase method
     if (hasErase) {
-        decl << "bool erase(const t_tuple& t);\n";
-
-        def << "bool Type::erase(const t_tuple& t) {\n";
+        out << "bool erase(const t_tuple& t) {\n";
 
-        def << "if (ind_" << masterIndex << ".erase(t) > 0) {\n";
+        out << "if (ind_" << masterIndex << ".erase(t) > 0) {\n";
         for (std::size_t i = 0; i < numIndexes; i++) {
             if (i != masterIndex && provenanceIndexNumbers.find(i) == provenanceIndexNumbers.end()) {
-                def << "ind_" << i << ".erase(t);\n";
+                out << "ind_" << i << ".erase(t);\n";
             }
         }
-        def << "return true;\n";
-        def << "} else return false;\n";
-        def << "}\n";  // end of erase(t_tuple&)
+        out << "return true;\n";
+        out << "} else return false;\n";
+        out << "}\n";  // end of erase(t_tuple&)
     }
 
     // insert methods
-    decl << "bool insert(const t_tuple& t);\n";
+    out << "bool insert(const t_tuple& t) {\n";
+    out << "context h;\n";
+    out << "return insert(t, h);\n";
+    out << "}\n";  // end of insert(t_tuple&)
 
-    def << "bool Type::insert(const t_tuple& t) {\n";
-    def << "context h;\n";
-    def << "return insert(t, h);\n";
-    def << "}\n";  // end of insert(t_tuple&)
-
-    decl << "bool insert(const t_tuple& t, context& h);\n";
-    def << "bool Type::insert(const t_tuple& t, context& h) {\n";
-    def << "if (ind_" << masterIndex << ".insert(t, h.hints_" << masterIndex << "_lower"
+    out << "bool insert(const t_tuple& t, context& h) {\n";
+    out << "if (ind_" << masterIndex << ".insert(t, h.hints_" << masterIndex << "_lower"
         << ")) {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
         if (i != masterIndex && provenanceIndexNumbers.find(i) == provenanceIndexNumbers.end()) {
-            def << "ind_" << i << ".insert(t, h.hints_" << i << "_lower"
+            out << "ind_" << i << ".insert(t, h.hints_" << i << "_lower"
                 << ");\n";
         }
     }
-    def << "return true;\n";
-    def << "} else return false;\n";
-    def << "}\n";  // end of insert(t_tuple&, context&)
-
-    decl << "bool insert(const RamDomain* ramDomain);\n";
-    def << "bool Type::insert(const RamDomain* ramDomain) {\n";
-    def << "RamDomain data[" << arity << "];\n";
-    def << "std::copy(ramDomain, ramDomain + " << arity << ", data);\n";
-    def << "const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);\n";
-    def << "context h;\n";
-    def << "return insert(tuple, h);\n";
-    def << "}\n";  // end of insert(RamDomain*)
+    out << "return true;\n";
+    out << "} else return false;\n";
+    out << "}\n";  // end of insert(t_tuple&, context&)
+
+    out << "bool insert(const RamDomain* ramDomain) {\n";
+    out << "RamDomain data[" << arity << "];\n";
+    out << "std::copy(ramDomain, ramDomain + " << arity << ", data);\n";
+    out << "const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);\n";
+    out << "context h;\n";
+    out << "return insert(tuple, h);\n";
+    out << "}\n";  // end of insert(RamDomain*)
 
     std::vector<std::string> decls;
     std::vector<std::string> params;
@@ -440,72 +396,59 @@ void DirectRelation::generateTypeStruct(GenDb& db) {
         decls.push_back("RamDomain a" + std::to_string(i));
         params.push_back("a" + std::to_string(i));
     }
-    decl << "bool insert(" << join(decls, ",") << ");\n";
-
-    def << "bool Type::insert(" << join(decls, ",") << ") {\n";
-    def << "RamDomain data[" << arity << "] = {" << join(params, ",") << "};\n";
-    def << "return insert(data);\n";
-    def << "}\n";  // end of insert(RamDomain x1, RamDomain x2, ...)
+    out << "bool insert(" << join(decls, ",") << ") {\n";
+    out << "RamDomain data[" << arity << "] = {" << join(params, ",") << "};\n";
+    out << "return insert(data);\n";
+    out << "}\n";  // end of insert(RamDomain x1, RamDomain x2, ...)
 
     // contains methods
-    decl << "bool contains(const t_tuple& t, context& h) const;\n";
-    def << "bool Type::contains(const t_tuple& t, context& h) const {\n";
-    def << "return ind_" << masterIndex << ".contains(t, h.hints_" << masterIndex << "_lower"
+    out << "bool contains(const t_tuple& t, context& h) const {\n";
+    out << "return ind_" << masterIndex << ".contains(t, h.hints_" << masterIndex << "_lower"
         << ");\n";
-    def << "}\n";
+    out << "}\n";
 
-    decl << "bool contains(const t_tuple& t) const;\n";
-    def << "bool Type::contains(const t_tuple& t) const {\n";
-    def << "context h;\n";
-    def << "return contains(t, h);\n";
-    def << "}\n";
+    out << "bool contains(const t_tuple& t) const {\n";
+    out << "context h;\n";
+    out << "return contains(t, h);\n";
+    out << "}\n";
 
     // size method
-    decl << "std::size_t size() const;\n";
-    def << "std::size_t Type::size() const {\n";
-    def << "return ind_" << masterIndex << ".size();\n";
-    def << "}\n";
+    out << "std::size_t size() const {\n";
+    out << "return ind_" << masterIndex << ".size();\n";
+    out << "}\n";
 
     // find methods
-    decl << "iterator find(const t_tuple& t, context& h) const;\n";
-    def << "iterator Type::find(const t_tuple& t, context& h) const {\n";
-    def << "return ind_" << masterIndex << ".find(t, h.hints_" << masterIndex << "_lower"
+    out << "iterator find(const t_tuple& t, context& h) const {\n";
+    out << "return ind_" << masterIndex << ".find(t, h.hints_" << masterIndex << "_lower"
         << ");\n";
-    def << "}\n";
+    out << "}\n";
 
-    decl << "iterator find(const t_tuple& t) const;\n";
-    def << "iterator Type::find(const t_tuple& t) const {\n";
-    def << "context h;\n";
-    def << "return find(t, h);\n";
-    def << "}\n";
+    out << "iterator find(const t_tuple& t) const {\n";
+    out << "context h;\n";
+    out << "return find(t, h);\n";
+    out << "}\n";
 
     // empty lowerUpperRange method
-    decl << "range<iterator> lowerUpperRange_" << SearchSignature(arity)
-         << "(const t_tuple& /* lower */, const t_tuple& /* upper */, context& /* h */) const;\n";
-    def << "range<iterator> Type::lowerUpperRange_" << SearchSignature(arity)
+    out << "range<iterator> lowerUpperRange_" << SearchSignature(arity)
         << "(const t_tuple& /* lower */, const t_tuple& /* upper */, context& /* h */) const "
            "{\n";
 
-    def << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
-    def << "}\n";
+    out << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
+    out << "}\n";
 
-    decl << "range<iterator> lowerUpperRange_" << SearchSignature(arity)
-         << "(const t_tuple& /* lower */, const t_tuple& /* upper */) const;\n";
-    def << "range<iterator> Type::lowerUpperRange_" << SearchSignature(arity)
+    out << "range<iterator> lowerUpperRange_" << SearchSignature(arity)
         << "(const t_tuple& /* lower */, const t_tuple& /* upper */) const {\n";
 
-    def << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
-    def << "}\n";
+    out << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
+    out << "}\n";
 
     // lowerUpperRange methods for each pattern which is used to search this relation
     for (auto search : indexSelection.getSearches()) {
         auto& lexOrder = indexSelection.getLexOrder(search);
         std::size_t indNum = indexToNumMap[lexOrder];
 
-        decl << "range<t_ind_" << indNum << "::iterator> lowerUpperRange_" << search;
-        decl << "(const t_tuple& lower, const t_tuple& upper, context& h) const;\n";
-        def << "range<t_ind_" << indNum << "::iterator> Type::lowerUpperRange_" << search;
-        def << "(const t_tuple& lower, const t_tuple& upper, context& h) const {\n";
+        out << "range<t_ind_" << indNum << "::iterator> lowerUpperRange_" << search;
+        out << "(const t_tuple& lower, const t_tuple& upper, context& h) const {\n";
 
         // count size of search pattern
         std::size_t eqSize = 0;
@@ -515,96 +458,86 @@ void DirectRelation::generateTypeStruct(GenDb& db) {
             }
         }
 
-        def << "t_comparator_" << indNum << " comparator;\n";
-        def << "int cmp = comparator(lower, upper);\n";
+        out << "t_comparator_" << indNum << " comparator;\n";
+        out << "int cmp = comparator(lower, upper);\n";
 
         // if search signature is full we can apply this specialization
         if (eqSize == arity) {
             // use the more efficient find() method if lower == upper
-            def << "if (cmp == 0) {\n";
-            def << "    auto pos = ind_" << indNum << ".find(lower, h.hints_" << indNum << "_lower);\n";
-            def << "    auto fin = ind_" << indNum << ".end();\n";
-            def << "    if (pos != fin) {fin = pos; ++fin;}\n";
-            def << "    return make_range(pos, fin);\n";
-            def << "}\n";
+            out << "if (cmp == 0) {\n";
+            out << "    auto pos = ind_" << indNum << ".find(lower, h.hints_" << indNum << "_lower);\n";
+            out << "    auto fin = ind_" << indNum << ".end();\n";
+            out << "    if (pos != fin) {fin = pos; ++fin;}\n";
+            out << "    return make_range(pos, fin);\n";
+            out << "}\n";
         }
         // if lower_bound > upper_bound then we return an empty range
-        def << "if (cmp > 0) {\n";
-        def << "    return make_range(ind_" << indNum << ".end(), ind_" << indNum << ".end());\n";
-        def << "}\n";
+        out << "if (cmp > 0) {\n";
+        out << "    return make_range(ind_" << indNum << ".end(), ind_" << indNum << ".end());\n";
+        out << "}\n";
         // otherwise use the general method
-        def << "return make_range(ind_" << indNum << ".lower_bound(lower, h.hints_" << indNum << "_lower"
+        out << "return make_range(ind_" << indNum << ".lower_bound(lower, h.hints_" << indNum << "_lower"
             << "), ind_" << indNum << ".upper_bound(upper, h.hints_" << indNum << "_upper"
             << "));\n";
 
-        def << "}\n";
+        out << "}\n";
 
-        decl << "range<t_ind_" << indNum << "::iterator> lowerUpperRange_" << search;
-        decl << "(const t_tuple& lower, const t_tuple& upper) const;\n";
-        def << "range<t_ind_" << indNum << "::iterator> Type::lowerUpperRange_" << search;
-        def << "(const t_tuple& lower, const t_tuple& upper) const {\n";
+        out << "range<t_ind_" << indNum << "::iterator> lowerUpperRange_" << search;
+        out << "(const t_tuple& lower, const t_tuple& upper) const {\n";
 
-        def << "context h;\n";
-        def << "return lowerUpperRange_" << search << "(lower,upper,h);\n";
-        def << "}\n";
+        out << "context h;\n";
+        out << "return lowerUpperRange_" << search << "(lower,upper,h);\n";
+        out << "}\n";
     }
 
     // empty method
-    decl << "bool empty() const;\n";
-    def << "bool Type::empty() const {\n";
-    def << "return ind_" << masterIndex << ".empty();\n";
-    def << "}\n";
+    out << "bool empty() const {\n";
+    out << "return ind_" << masterIndex << ".empty();\n";
+    out << "}\n";
 
     // partition method for parallelism
-    decl << "std::vector<range<iterator>> partition() const;\n";
-    def << "std::vector<range<iterator>> Type::partition() const {\n";
-    def << "return ind_" << masterIndex << ".getChunks(400);\n";
-    def << "}\n";
+    out << "std::vector<range<iterator>> partition() const {\n";
+    out << "return ind_" << masterIndex << ".getChunks(400);\n";
+    out << "}\n";
 
     // purge method
-    decl << "void purge();\n";
-    def << "void Type::purge() {\n";
+    out << "void purge() {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        def << "ind_" << i << ".clear();\n";
+        out << "ind_" << i << ".clear();\n";
     }
-    def << "}\n";
+    out << "}\n";
 
     // begin and end iterators
-    decl << "iterator begin() const;\n";
-    def << "iterator Type::begin() const {\n";
-    def << "return ind_" << masterIndex << ".begin();\n";
-    def << "}\n";
+    out << "iterator begin() const {\n";
+    out << "return ind_" << masterIndex << ".begin();\n";
+    out << "}\n";
 
-    decl << "iterator end() const;\n";
-    def << "iterator Type::end() const {\n";
-    def << "return ind_" << masterIndex << ".end();\n";
-    def << "}\n";
+    out << "iterator end() const {\n";
+    out << "return ind_" << masterIndex << ".end();\n";
+    out << "}\n";
 
     // copyIndex method
     if (!provenanceIndexNumbers.empty()) {
-        decl << "void copyIndex();\n";
-        def << "void Type::copyIndex() {\n";
-        def << "for (auto const &cur : ind_" << masterIndex << ") {\n";
+        out << "void copyIndex() {\n";
+        out << "for (auto const &cur : ind_" << masterIndex << ") {\n";
         for (auto const i : provenanceIndexNumbers) {
-            def << "ind_" << i << ".insert(cur);\n";
+            out << "ind_" << i << ".insert(cur);\n";
         }
-        def << "}\n";
-        def << "}\n";
+        out << "}\n";
+        out << "}\n";
     }
 
     // printStatistics method
-    decl << "void printStatistics(std::ostream& o) const;\n";
-    def << "void Type::printStatistics(std::ostream& o) const {\n";
+    out << "void printStatistics(std::ostream& o) const {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        def << "o << \" arity " << arity << " direct b-tree index " << i << " lex-order " << inds[i]
+        out << "o << \" arity " << arity << " direct b-tree index " << i << " lex-order " << inds[i]
             << "\\n\";\n";
-        def << "ind_" << i << ".printStats(o);\n";
+        out << "ind_" << i << ".printStats(o);\n";
     }
-    def << "}\n";
+    out << "}\n";
 
     // end struct
-    decl << "};\n";
-
+    out << "};\n";
 }  // namespace souffle
 
 // -------- Indirect Indexed B-Tree Relation --------
@@ -630,7 +563,7 @@ void IndirectRelation::computeIndices() {
 }
 
 /** Generate type name of a indirect indexed relation */
-std::string IndirectRelation::getTypeNamespace() {
+std::string IndirectRelation::getTypeName() {
     // collect all attributes used in the lex-order
     std::unordered_set<std::size_t> attributesUsed;
     for (auto& ind : getIndices()) {
@@ -653,38 +586,24 @@ std::string IndirectRelation::getTypeNamespace() {
     return res.str();
 }
 
-std::string IndirectRelation::getTypeName() {
-    return getTypeNamespace() + "::Type";
-}
-
 /** Generate type struct of a indirect indexed relation */
-void IndirectRelation::generateTypeStruct(GenDb& db) {
+void IndirectRelation::generateTypeStruct(std::ostream& out) {
     std::size_t arity = getArity();
     const auto& inds = getIndices();
     auto types = relation.getAttributeTypes();
     std::size_t numIndexes = inds.size();
     std::map<LexOrder, std::size_t> indexToNumMap;
 
-    fs::path basename(uniqueCppIdent(getTypeNamespace(), 20));
-    GenDatastructure& cl = db.getDatastructure("Type", basename, std::make_optional(getTypeNamespace()));
-
-    std::ostream& decl = cl.decl();
-    std::ostream& def = cl.def();
-
-    cl.addInclude("\"souffle/SouffleInterface.h\"");
-    cl.addInclude("\"souffle/datastructure/Table.h\"");
-    cl.addInclude("\"souffle/datastructure/BTree.h\"");
-
     // struct definition
-    decl << "struct Type {\n";
-    decl << "static constexpr Relation::arity_type Arity = " << arity << ";\n";
+    out << "struct " << getTypeName() << " {\n";
+    out << "static constexpr Relation::arity_type Arity = " << arity << ";\n";
 
     // stored tuple type
-    decl << "using t_tuple = Tuple<RamDomain, " << arity << ">;\n";
+    out << "using t_tuple = Tuple<RamDomain, " << arity << ">;\n";
 
     // table and lock required for storing actual data for indirect indices
-    decl << "Table<t_tuple> dataTable;\n";
-    decl << "Lock insert_lock;\n";
+    out << "Table<t_tuple> dataTable;\n";
+    out << "Lock insert_lock;\n";
 
     // btree types
     for (std::size_t i = 0; i < inds.size(); i++) {
@@ -707,117 +626,108 @@ void IndirectRelation::generateTypeStruct(GenDb& db) {
 
         std::string comparator = "t_comparator_" + std::to_string(i);
 
-        decl << "struct " << comparator << "{\n";
-        decl << " int operator()(const t_tuple *a, const t_tuple *b) const {\n";
-        decl << "  return ";
+        out << "struct " << comparator << "{\n";
+        out << " int operator()(const t_tuple *a, const t_tuple *b) const {\n";
+        out << "  return ";
         std::function<void(std::size_t)> gencmp = [&](std::size_t i) {
             std::size_t attrib = ind[i];
             const auto& typecast = typecasts[attrib];
-            decl << "(" << typecast << "((*a)[" << attrib << "]) <" << typecast << " ((*b)[" << attrib
-                 << "])) ? -1 : ((" << typecast << "((*a)[" << attrib << "]) > " << typecast << "((*b)["
-                 << attrib << "])) ? 1 :(";
+            out << "(" << typecast << "((*a)[" << attrib << "]) <" << typecast << " ((*b)[" << attrib
+                << "])) ? -1 : ((" << typecast << "((*a)[" << attrib << "]) > " << typecast << "((*b)["
+                << attrib << "])) ? 1 :(";
             if (i + 1 < ind.size()) {
                 gencmp(i + 1);
             } else {
-                decl << "0";
+                out << "0";
             }
-            decl << "))";
+            out << "))";
         };
         gencmp(0);
-        decl << ";\n }\n";
-        decl << "bool less(const t_tuple *a, const t_tuple *b) const {\n";
-        decl << "  return ";
+        out << ";\n }\n";
+        out << "bool less(const t_tuple *a, const t_tuple *b) const {\n";
+        out << "  return ";
         std::function<void(std::size_t)> genless = [&](std::size_t i) {
             std::size_t attrib = ind[i];
             const auto& typecast = typecasts[attrib];
-            decl << typecast << " ((*a)[" << attrib << "]) < " << typecast << "((*b)[" << attrib << "])";
+            out << typecast << " ((*a)[" << attrib << "]) < " << typecast << "((*b)[" << attrib << "])";
             if (i + 1 < ind.size()) {
-                decl << "|| ((" << typecast << "((*a)[" << attrib << "]) == " << typecast << "((*b)["
-                     << attrib << "]) && (";
+                out << "|| ((" << typecast << "((*a)[" << attrib << "]) == " << typecast << "((*b)[" << attrib
+                    << "]) && (";
                 genless(i + 1);
-                decl << ")))";
+                out << ")))";
             }
         };
         genless(0);
-        decl << ";\n }\n";
-        decl << "bool equal(const t_tuple *a, const t_tuple *b) const {\n";
-        decl << "return ";
+        out << ";\n }\n";
+        out << "bool equal(const t_tuple *a, const t_tuple *b) const {\n";
+        out << "return ";
         std::function<void(std::size_t)> geneq = [&](std::size_t i) {
             std::size_t attrib = ind[i];
             const auto& typecast = typecasts[attrib];
-            decl << typecast << "((*a)[" << attrib << "]) == " << typecast << "((*b)[" << attrib << "])";
+            out << typecast << "((*a)[" << attrib << "]) == " << typecast << "((*b)[" << attrib << "])";
             if (i + 1 < ind.size()) {
-                decl << "&&";
+                out << "&&";
                 geneq(i + 1);
             }
         };
         geneq(0);
-        decl << ";\n }\n";
-        decl << "};\n";
+        out << ";\n }\n";
+        out << "};\n";
 
         if (ind.size() == arity) {
-            decl << "using t_ind_" << i << " = btree_set<const t_tuple*," << comparator << ">;\n";
+            out << "using t_ind_" << i << " = btree_set<const t_tuple*," << comparator << ">;\n";
         } else {
-            decl << "using t_ind_" << i << " = btree_multiset<const t_tuple*," << comparator << ">;\n";
+            out << "using t_ind_" << i << " = btree_multiset<const t_tuple*," << comparator << ">;\n";
         }
 
-        decl << "t_ind_" << i << " ind_" << i << ";\n";
+        out << "t_ind_" << i << " ind_" << i << ";\n";
     }
 
     // typedef deref iterators
     for (std::size_t i = 0; i < numIndexes; i++) {
-        decl << "using iterator_" << i << " = IterDerefWrapper<typename t_ind_" << i << "::iterator>;\n";
-        def << "using iterator_" << i << " = Type::iterator_" << i << ";\n";
+        out << "using iterator_" << i << " = IterDerefWrapper<typename t_ind_" << i << "::iterator>;\n";
     }
-    decl << "using iterator = iterator_" << masterIndex << ";\n";
-    def << "using iterator = Type::iterator;\n";
+    out << "using iterator = iterator_" << masterIndex << ";\n";
 
     // Create a struct storing the context hints for each index
-    decl << "struct context {\n";
+    out << "struct context {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        decl << "t_ind_" << i << "::operation_hints hints_" << i << "_lower;\n";
-        decl << "t_ind_" << i << "::operation_hints hints_" << i << "_upper;\n";
+        out << "t_ind_" << i << "::operation_hints hints_" << i << "_lower;\n";
+        out << "t_ind_" << i << "::operation_hints hints_" << i << "_upper;\n";
     }
-    decl << "};\n";
-
-    decl << "context createContext();\n";
-    def << "using context = Type::context;\n";
-    def << "context Type::createContext() { return context(); }\n";
+    out << "};\n";
+    out << "context createContext() { return context(); }\n";
 
     // insert methods
-    decl << "bool insert(const t_tuple& t);\n";
-    def << "bool Type::insert(const t_tuple& t) {\n";
-    def << "context h;\n";
-    def << "return insert(t, h);\n";
-    def << "}\n";
-
-    decl << "bool insert(const t_tuple& t, context& h);\n";
-
-    def << "bool Type::insert(const t_tuple& t, context& h) {\n";
-    def << "const t_tuple* masterCopy = nullptr;\n";
-    def << "{\n";
-    def << "auto lease = insert_lock.acquire();\n";
-    def << "if (contains(t, h)) return false;\n";
-    def << "masterCopy = &dataTable.insert(t);\n";
-    def << "ind_" << masterIndex << ".insert(masterCopy, h.hints_" << masterIndex << "_lower);\n";
-    def << "}\n";
+    out << "bool insert(const t_tuple& t) {\n";
+    out << "context h;\n";
+    out << "return insert(t, h);\n";
+    out << "}\n";
+
+    out << "bool insert(const t_tuple& t, context& h) {\n";
+    out << "const t_tuple* masterCopy = nullptr;\n";
+    out << "{\n";
+    out << "auto lease = insert_lock.acquire();\n";
+    out << "if (contains(t, h)) return false;\n";
+    out << "masterCopy = &dataTable.insert(t);\n";
+    out << "ind_" << masterIndex << ".insert(masterCopy, h.hints_" << masterIndex << "_lower);\n";
+    out << "}\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
         if (i != masterIndex) {
-            def << "ind_" << i << ".insert(masterCopy, h.hints_" << i << "_lower"
+            out << "ind_" << i << ".insert(masterCopy, h.hints_" << i << "_lower"
                 << ");\n";
         }
     }
-    def << "return true;\n";
-    def << "}\n";
-
-    decl << "bool insert(const RamDomain* ramDomain);\n";
-    def << "bool Type::insert(const RamDomain* ramDomain) {\n";
-    def << "RamDomain data[" << arity << "];\n";
-    def << "std::copy(ramDomain, ramDomain + " << arity << ", data);\n";
-    def << "const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);\n";
-    def << "context h;\n";
-    def << "return insert(tuple, h);\n";
-    def << "}\n";  // end of insert(RamDomain*)
+    out << "return true;\n";
+    out << "}\n";
+
+    out << "bool insert(const RamDomain* ramDomain) {\n";
+    out << "RamDomain data[" << arity << "];\n";
+    out << "std::copy(ramDomain, ramDomain + " << arity << ", data);\n";
+    out << "const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);\n";
+    out << "context h;\n";
+    out << "return insert(tuple, h);\n";
+    out << "}\n";  // end of insert(RamDomain*)
 
     std::vector<std::string> decls;
     std::vector<std::string> params;
@@ -825,67 +735,57 @@ void IndirectRelation::generateTypeStruct(GenDb& db) {
         decls.push_back("RamDomain a" + std::to_string(i));
         params.push_back("a" + std::to_string(i));
     }
-    decl << "bool insert(" << join(decls, ",") << ");\n";
-    def << "bool Type::insert(" << join(decls, ",") << ") {\n";
-    def << "RamDomain data[" << arity << "] = {" << join(params, ",") << "};\n";
-    def << "return insert(data);\n";
-    def << "}\n";  // end of insert(RamDomain x1, RamDomain x2, ...)
+    out << "bool insert(" << join(decls, ",") << ") {\n";
+    out << "RamDomain data[" << arity << "] = {" << join(params, ",") << "};\n";
+    out << "return insert(data);\n";
+    out << "}\n";  // end of insert(RamDomain x1, RamDomain x2, ...)
 
     // contains methods
-    decl << "bool contains(const t_tuple& t, context& h) const;\n";
-    def << "bool Type::contains(const t_tuple& t, context& h) const {\n";
-    def << "return ind_" << masterIndex << ".contains(&t, h.hints_" << masterIndex << "_lower"
+    out << "bool contains(const t_tuple& t, context& h) const {\n";
+    out << "return ind_" << masterIndex << ".contains(&t, h.hints_" << masterIndex << "_lower"
         << ");\n";
-    def << "}\n";
+    out << "}\n";
 
-    decl << "bool contains(const t_tuple& t) const;\n";
-    def << "bool Type::contains(const t_tuple& t) const {\n";
-    def << "context h;\n";
-    def << "return contains(t, h);\n";
-    def << "}\n";
+    out << "bool contains(const t_tuple& t) const {\n";
+    out << "context h;\n";
+    out << "return contains(t, h);\n";
+    out << "}\n";
 
     // size method
-    decl << "std::size_t size() const;\n";
-    def << "std::size_t Type::size() const {\n";
-    def << "return ind_" << masterIndex << ".size();\n";
-    def << "}\n";
+    out << "std::size_t size() const {\n";
+    out << "return ind_" << masterIndex << ".size();\n";
+    out << "}\n";
 
     // find methods
-    decl << "iterator find(const t_tuple& t, context& h) const;\n";
-    def << "iterator Type::find(const t_tuple& t, context& h) const {\n";
-    def << "return ind_" << masterIndex << ".find(&t, h.hints_" << masterIndex << "_lower"
+    out << "iterator find(const t_tuple& t, context& h) const {\n";
+    out << "return ind_" << masterIndex << ".find(&t, h.hints_" << masterIndex << "_lower"
         << ");\n";
-    def << "}\n";
+    out << "}\n";
 
-    decl << "iterator find(const t_tuple& t) const;\n";
-    def << "iterator Type::find(const t_tuple& t) const {\n";
-    def << "context h;\n";
-    def << "return find(t, h);\n";
-    def << "}\n";
+    out << "iterator find(const t_tuple& t) const {\n";
+    out << "context h;\n";
+    out << "return find(t, h);\n";
+    out << "}\n";
 
     // empty lowerUpperRange method
-    decl << "range<iterator> lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper, context& h) "
-            "const;\n";
-    def << "range<iterator> Type::lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper, context& h) "
-           "const "
+    out << "range<iterator> lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper, context& h) const "
            "{\n";
-    def << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
-    def << "}\n";
 
-    decl << "range<iterator> lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper) const;\n";
-    def << "range<iterator> Type::lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper) const {\n";
-    def << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
-    def << "}\n";
+    out << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
+    out << "}\n";
+
+    out << "range<iterator> lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper) const {\n";
+
+    out << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
+    out << "}\n";
 
     // lowerUpperRange methods for each pattern which is used to search this relation
     for (auto search : indexSelection.getSearches()) {
         auto& lexOrder = indexSelection.getLexOrder(search);
         std::size_t indNum = indexToNumMap[lexOrder];
 
-        decl << "range<iterator_" << indNum << "> lowerUpperRange_" << search;
-        decl << "(const t_tuple& lower, const t_tuple& upper, context& h) const;\n";
-        def << "range<iterator_" << indNum << "> Type::lowerUpperRange_" << search;
-        def << "(const t_tuple& lower, const t_tuple& upper, context& h) const {\n";
+        out << "range<iterator_" << indNum << "> lowerUpperRange_" << search;
+        out << "(const t_tuple& lower, const t_tuple& upper, context& h) const {\n";
 
         // count size of search pattern
         std::size_t eqSize = 0;
@@ -895,91 +795,83 @@ void IndirectRelation::generateTypeStruct(GenDb& db) {
             }
         }
 
-        def << "t_comparator_" << indNum << " comparator;\n";
-        def << "int cmp = comparator(&lower, &upper);\n";
+        out << "t_comparator_" << indNum << " comparator;\n";
+        out << "int cmp = comparator(&lower, &upper);\n";
 
         // use the more efficient find() method if the search pattern is full
         if (eqSize == arity) {
             // if lower == upper we can just do a find
-            def << "if (cmp == 0) {\n";
-            def << "    auto pos = ind_" << indNum << ".find(&lower, h.hints_" << indNum << "_lower);\n";
-            def << "    auto fin = ind_" << indNum << ".end();\n";
-            def << "    if (pos != fin) {fin = pos; ++fin;}\n";
-            def << "    return range<iterator_" << indNum << ">(pos, fin);\n";
-            def << "}\n";
+            out << "if (cmp == 0) {\n";
+            out << "    auto pos = ind_" << indNum << ".find(&lower, h.hints_" << indNum << "_lower);\n";
+            out << "    auto fin = ind_" << indNum << ".end();\n";
+            out << "    if (pos != fin) {fin = pos; ++fin;}\n";
+            out << "    return range<iterator_" << indNum << ">(pos, fin);\n";
+            out << "}\n";
         }
         // if lower > upper then we have an empty range
-        def << "if (cmp > 0) {\n";
-        def << "    return range<iterator_" << indNum << ">(ind_" << indNum << ".end(), ind_" << indNum
+        out << "if (cmp > 0) {\n";
+        out << "    return range<iterator_" << indNum << ">(ind_" << indNum << ".end(), ind_" << indNum
             << ".end());\n";
-        def << "}\n";
+        out << "}\n";
 
         // otherwise do the default method
-        def << "return range<iterator_" << indNum << ">(ind_" << indNum << ".lower_bound(&lower, h.hints_"
+        out << "return range<iterator_" << indNum << ">(ind_" << indNum << ".lower_bound(&lower, h.hints_"
             << indNum << "_lower"
             << "), ind_" << indNum << ".upper_bound(&upper, h.hints_" << indNum << "_upper"
             << "));\n";
 
-        def << "}\n";
+        out << "}\n";
 
-        decl << "range<iterator_" << indNum << "> lowerUpperRange_" << search;
-        decl << "(const t_tuple& lower, const t_tuple& upper) const;\n";
-        def << "range<iterator_" << indNum << "> Type::lowerUpperRange_" << search;
-        def << "(const t_tuple& lower, const t_tuple& upper) const {\n";
+        out << "range<iterator_" << indNum << "> lowerUpperRange_" << search;
+        out << "(const t_tuple& lower, const t_tuple& upper) const {\n";
 
-        def << "context h;\n";
-        def << "return lowerUpperRange_" << search << "(lower, upper, h);\n";
-        def << "}\n";
+        out << "context h;\n";
+        out << "return lowerUpperRange_" << search << "(lower, upper, h);\n";
+        out << "}\n";
     }
 
     // empty method
-    decl << "bool empty() const;\n";
-    def << "bool Type::empty() const {\n";
-    def << "return ind_" << masterIndex << ".empty();\n";
-    def << "}\n";
+    out << "bool empty() const {\n";
+    out << "return ind_" << masterIndex << ".empty();\n";
+    out << "}\n";
 
     // partition method
-    decl << "std::vector<range<iterator>> partition() const;\n";
-    def << "std::vector<range<iterator>> Type::partition() const {\n";
-    def << "std::vector<range<iterator>> res;\n";
-    def << "for (const auto& cur : ind_" << masterIndex << ".getChunks(400)) {\n";
-    def << "    res.push_back(make_range(derefIter(cur.begin()), derefIter(cur.end())));\n";
-    def << "}\n";
-    def << "return res;\n";
-    def << "}\n";
+    out << "std::vector<range<iterator>> partition() const {\n";
+    out << "std::vector<range<iterator>> res;\n";
+    out << "for (const auto& cur : ind_" << masterIndex << ".getChunks(400)) {\n";
+    out << "    res.push_back(make_range(derefIter(cur.begin()), derefIter(cur.end())));\n";
+    out << "}\n";
+    out << "return res;\n";
+    out << "}\n";
 
     // purge method
-    decl << "void purge();\n";
-    def << "void Type::purge() {\n";
+    out << "void purge() {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        def << "ind_" << i << ".clear();\n";
+        out << "ind_" << i << ".clear();\n";
     }
-    def << "dataTable.clear();\n";
-    def << "}\n";
+    out << "dataTable.clear();\n";
+    out << "}\n";
 
     // begin and end iterators
-    decl << "iterator begin() const;\n";
-    def << "iterator Type::begin() const {\n";
-    def << "return ind_" << masterIndex << ".begin();\n";
-    def << "}\n";
+    out << "iterator begin() const {\n";
+    out << "return ind_" << masterIndex << ".begin();\n";
+    out << "}\n";
 
-    decl << "iterator end() const;\n";
-    def << "iterator Type::end() const {\n";
-    def << "return ind_" << masterIndex << ".end();\n";
-    def << "}\n";
+    out << "iterator end() const {\n";
+    out << "return ind_" << masterIndex << ".end();\n";
+    out << "}\n";
 
     // printStatistics method
-    decl << "void printStatistics(std::ostream& o) const;\n";
-    def << "void Type::printStatistics(std::ostream& o) const {\n";
+    out << "void printStatistics(std::ostream& o) const {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        def << "o << \" arity " << arity << " indirect b-tree index " << i << " lex-order " << inds[i]
+        out << "o << \" arity " << arity << " indirect b-tree index " << i << " lex-order " << inds[i]
             << "\\n\";\n";
-        def << "ind_" << i << ".printStats(o);\n";
+        out << "ind_" << i << ".printStats(o);\n";
     }
-    def << "}\n";
+    out << "}\n";
 
     // end struct
-    decl << "};\n";
+    out << "};\n";
 }
 
 // -------- Brie Relation --------
@@ -1014,7 +906,7 @@ void BrieRelation::computeIndices() {
 }
 
 /** Generate type name of a brie relation */
-std::string BrieRelation::getTypeNamespace() {
+std::string BrieRelation::getTypeName() {
     // collect all attributes used in the lex-order
     std::unordered_set<std::size_t> attributesUsed;
     for (auto& ind : getIndices()) {
@@ -1037,120 +929,100 @@ std::string BrieRelation::getTypeNamespace() {
     return res.str();
 }
 
-std::string BrieRelation::getTypeName() {
-    return getTypeNamespace() + "::Type";
-}
-
 /** Generate type struct of a brie relation */
-void BrieRelation::generateTypeStruct(GenDb& db) {
+void BrieRelation::generateTypeStruct(std::ostream& out) {
     std::size_t arity = getArity();
     const auto& inds = getIndices();
     std::size_t numIndexes = inds.size();
     std::map<LexOrder, std::size_t> indexToNumMap;
 
-    fs::path basename(uniqueCppIdent(getTypeNamespace(), 20));
-    GenDatastructure& cl = db.getDatastructure("Type", basename, std::make_optional(getTypeNamespace()));
-    std::ostream& decl = cl.decl();
-    std::ostream& def = cl.def();
-    cl.addInclude("\"souffle/SouffleInterface.h\"");
-    cl.addInclude("\"souffle/datastructure/Brie.h\"");
-
     // struct definition
-    decl << "struct Type {\n";
-    decl << "static constexpr Relation::arity_type Arity = " << arity << ";\n";
+    out << "struct " << getTypeName() << " {\n";
+    out << "static constexpr Relation::arity_type Arity = " << arity << ";\n";
 
     // define trie structures
     for (std::size_t i = 0; i < inds.size(); i++) {
         if (i < indexSelection.getAllOrders().size()) {
             indexToNumMap[indexSelection.getAllOrders()[i]] = i;
         }
-        decl << "using t_ind_" << i << " = Trie<" << inds[i].size() << ">;\n";
-        decl << "t_ind_" << i << " ind_" << i << ";\n";
+        out << "using t_ind_" << i << " = Trie<" << inds[i].size() << ">;\n";
+        out << "t_ind_" << i << " ind_" << i << ";\n";
     }
-    decl << "using t_tuple = t_ind_" << masterIndex << "::entry_type;\n";
+    out << "using t_tuple = t_ind_" << masterIndex << "::entry_type;\n";
 
     // generate auxiliary iterators that use orderOut
     for (std::size_t i = 0; i < numIndexes; i++) {
         // generate auxiliary iterators which orderOut
-        decl << "class iterator_" << i << " : public std::iterator<std::forward_iterator_tag, t_tuple> {\n";
-        decl << "    using nested_iterator = typename t_ind_" << i << "::iterator;\n";
-        decl << "    nested_iterator nested;\n";
-        decl << "    t_tuple value;\n";
-
-        decl << "public:\n";
-        decl << "    iterator_" << i << "() = default;\n";
-        decl << "    iterator_" << i << "(const nested_iterator& iter) : nested(iter), value(orderOut_" << i
-             << "(*iter)) {}\n";
-        decl << "    iterator_" << i << "(const iterator_" << i << "& other) = default;\n";
-        decl << "    iterator_" << i << "& operator=(const iterator_" << i << "& other) = default;\n";
-
-        decl << "    bool operator==(const iterator_" << i << "& other) const {\n";
-        decl << "        return nested == other.nested;\n";
-        decl << "    }\n";
-
-        decl << "    bool operator!=(const iterator_" << i << "& other) const {\n";
-        decl << "        return !(*this == other);\n";
-        decl << "    }\n";
-
-        decl << "    const t_tuple& operator*() const {\n";
-        decl << "        return value;\n";
-        decl << "    }\n";
-
-        decl << "    const t_tuple* operator->() const {\n";
-        decl << "        return &value;\n";
-        decl << "    }\n";
-
-        decl << "    iterator_" << i << "& operator++() {\n";
-        decl << "        ++nested;\n";
-        decl << "        value = orderOut_" << i << "(*nested);\n";
-        decl << "        return *this;\n";
-        decl << "    }\n";
-        decl << "};\n";
-
-        def << "using iterator_" << i << " = Type::iterator_" << i << ";\n";
+        out << "class iterator_" << i << " : public std::iterator<std::forward_iterator_tag, t_tuple> {\n";
+        out << "    using nested_iterator = typename t_ind_" << i << "::iterator;\n";
+        out << "    nested_iterator nested;\n";
+        out << "    t_tuple value;\n";
+
+        out << "public:\n";
+        out << "    iterator_" << i << "() = default;\n";
+        out << "    iterator_" << i << "(const nested_iterator& iter) : nested(iter), value(orderOut_" << i
+            << "(*iter)) {}\n";
+        out << "    iterator_" << i << "(const iterator_" << i << "& other) = default;\n";
+        out << "    iterator_" << i << "& operator=(const iterator_" << i << "& other) = default;\n";
+
+        out << "    bool operator==(const iterator_" << i << "& other) const {\n";
+        out << "        return nested == other.nested;\n";
+        out << "    }\n";
+
+        out << "    bool operator!=(const iterator_" << i << "& other) const {\n";
+        out << "        return !(*this == other);\n";
+        out << "    }\n";
+
+        out << "    const t_tuple& operator*() const {\n";
+        out << "        return value;\n";
+        out << "    }\n";
+
+        out << "    const t_tuple* operator->() const {\n";
+        out << "        return &value;\n";
+        out << "    }\n";
+
+        out << "    iterator_" << i << "& operator++() {\n";
+        out << "        ++nested;\n";
+        out << "        value = orderOut_" << i << "(*nested);\n";
+        out << "        return *this;\n";
+        out << "    }\n";
+        out << "};\n";
     }
-    decl << "using iterator = iterator_" << masterIndex << ";\n";
-    def << "using iterator = Type::iterator;\n";
+    out << "using iterator = iterator_" << masterIndex << ";\n";
 
     // hints struct
-    decl << "struct context {\n";
+    out << "struct context {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        decl << "t_ind_" << i << "::op_context hints_" << i << ";\n";
+        out << "t_ind_" << i << "::op_context hints_" << i << ";\n";
     }
-    decl << "};\n";
-    def << "using context = Type::context;\n";
-
-    decl << "context createContext();\n";
-    def << "context Type::createContext() { return context(); }\n";
+    out << "};\n";
+    out << "context createContext() { return context(); }\n";
 
     // insert methods
-    decl << "bool insert(const t_tuple& t);\n";
-    def << "bool Type::insert(const t_tuple& t) {\n";
-    def << "context h;\n";
-    def << "return insert(t, h);\n";
-    def << "}\n";
-
-    decl << "bool insert(const t_tuple& t, context& h);\n";
-    def << "bool Type::insert(const t_tuple& t, context& h) {\n";
-    def << "if (ind_" << masterIndex << ".insert(orderIn_" << masterIndex << "(t), h.hints_" << masterIndex
+    out << "bool insert(const t_tuple& t) {\n";
+    out << "context h;\n";
+    out << "return insert(t, h);\n";
+    out << "}\n";
+
+    out << "bool insert(const t_tuple& t, context& h) {\n";
+    out << "if (ind_" << masterIndex << ".insert(orderIn_" << masterIndex << "(t), h.hints_" << masterIndex
         << ")) {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
         if (i != masterIndex) {
-            def << "ind_" << i << ".insert(orderIn_" << i << "(t), h.hints_" << i << ");\n";
+            out << "ind_" << i << ".insert(orderIn_" << i << "(t), h.hints_" << i << ");\n";
         }
     }
-    def << "return true;\n";
-    def << "} else return false;\n";
-    def << "}\n";
-
-    decl << "bool insert(const RamDomain* ramDomain);\n";
-    def << "bool Type::insert(const RamDomain* ramDomain) {\n";
-    def << "RamDomain data[" << arity << "];\n";
-    def << "std::copy(ramDomain, ramDomain + " << arity << ", data);\n";
-    def << "const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);\n";
-    def << "context h;\n";
-    def << "return insert(tuple, h);\n";
-    def << "}\n";
+    out << "return true;\n";
+    out << "} else return false;\n";
+    out << "}\n";
+
+    out << "bool insert(const RamDomain* ramDomain) {\n";
+    out << "RamDomain data[" << arity << "];\n";
+    out << "std::copy(ramDomain, ramDomain + " << arity << ", data);\n";
+    out << "const t_tuple& tuple = reinterpret_cast<const t_tuple&>(data);\n";
+    out << "context h;\n";
+    out << "return insert(tuple, h);\n";
+    out << "}\n";
 
     // insert method
     std::vector<std::string> decls;
@@ -1159,68 +1031,57 @@ void BrieRelation::generateTypeStruct(GenDb& db) {
         decls.push_back("RamDomain a" + std::to_string(i));
         params.push_back("a" + std::to_string(i));
     }
-    decl << "bool insert(" << join(decls, ",") << ");\n";
-    def << "bool Type::insert(" << join(decls, ",") << ") {\nRamDomain data[";
-    def << arity << "] = {" << join(params, ",") << "};\n";
-    def << "return insert(data);\n";
-    def << "}\n";
+    out << "bool insert(" << join(decls, ",") << ") {\nRamDomain data[";
+    out << arity << "] = {" << join(params, ",") << "};\n";
+    out << "return insert(data);\n";
+    out << "}\n";
 
     // contains methods
-    decl << "bool contains(const t_tuple& t, context& h) const;\n";
-    def << "bool Type::contains(const t_tuple& t, context& h) const {\n";
-    def << "return ind_" << masterIndex << ".contains(orderIn_" << masterIndex << "(t), h.hints_"
+    out << "bool contains(const t_tuple& t, context& h) const {\n";
+    out << "return ind_" << masterIndex << ".contains(orderIn_" << masterIndex << "(t), h.hints_"
         << masterIndex << ");\n";
-    def << "}\n";
+    out << "}\n";
 
-    decl << "bool contains(const t_tuple& t) const;\n";
-    def << "bool Type::contains(const t_tuple& t) const {\n";
-    def << "context h;\n";
-    def << "return contains(t, h);\n";
-    def << "}\n";
+    out << "bool contains(const t_tuple& t) const {\n";
+    out << "context h;\n";
+    out << "return contains(t, h);\n";
+    out << "}\n";
 
     // size method
-    decl << "std::size_t size() const;\n";
-    def << "std::size_t Type::size() const {\n";
-    def << "return ind_" << masterIndex << ".size();\n";
-    def << "}\n";
+    out << "std::size_t size() const {\n";
+    out << "return ind_" << masterIndex << ".size();\n";
+    out << "}\n";
 
     // find methods
     if (arity > 1) {
-        decl << "iterator find(const t_tuple& t, context& h) const;\n";
-        def << "iterator Type::find(const t_tuple& t, context& h) const {\n";
-        def << "return ind_" << masterIndex << ".find(orderIn_" << masterIndex << "(t), h.hints_"
+        out << "iterator find(const t_tuple& t, context& h) const {\n";
+        out << "return ind_" << masterIndex << ".find(orderIn_" << masterIndex << "(t), h.hints_"
             << masterIndex << ");\n";
-        def << "}\n";
+        out << "}\n";
 
-        decl << "iterator find(const t_tuple& t) const;\n";
-        def << "iterator Type::find(const t_tuple& t) const {\n";
-        def << "context h;\n";
-        def << "return find(t, h);\n";
-        def << "}\n";
+        out << "iterator find(const t_tuple& t) const {\n";
+        out << "context h;\n";
+        out << "return find(t, h);\n";
+        out << "}\n";
     }
 
     // empty lowerUpperRange method
-    decl << "range<iterator> lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper, context& h) "
-            "const;\n";
-    def << "range<iterator> Type::lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper, context& h)"
-        << " const {\n";
-    def << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
-    def << "}\n";
-
-    decl << "range<iterator> lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper) const;\n";
-    def << "range<iterator> Type::lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper) const {\n";
-    def << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
-    def << "}\n";
+    out << "range<iterator> lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper, context& h) const "
+           "{\n";
+    out << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
+    out << "}\n";
+
+    out << "range<iterator> lowerUpperRange_0(const t_tuple& lower, const t_tuple& upper) const {\n";
+    out << "return range<iterator>(ind_" << masterIndex << ".begin(),ind_" << masterIndex << ".end());\n";
+    out << "}\n";
 
     // loweUpperRange methods
     for (auto search : indexSelection.getSearches()) {
         auto& lexOrder = indexSelection.getLexOrder(search);
         std::size_t indNum = indexToNumMap[lexOrder];
 
-        decl << "range<iterator_" << indNum << "> lowerUpperRange_" << search;
-        decl << "(const t_tuple& lower, const t_tuple& upper, context& h) const;\n";
-        def << "range<iterator_" << indNum << "> Type::lowerUpperRange_" << search;
-        def << "(const t_tuple& lower, const t_tuple& upper, context& h) const {\n";
+        out << "range<iterator_" << indNum << "> lowerUpperRange_" << search;
+        out << "(const t_tuple& lower, const t_tuple& upper, context& h) const {\n";
 
         // compute size of sub-index
         std::size_t indSize = 0;
@@ -1230,86 +1091,79 @@ void BrieRelation::generateTypeStruct(GenDb& db) {
             }
         }
 
-        def << "auto r = ind_" << indNum << ".template getBoundaries<" << indSize << ">(orderIn_" << indNum
+        out << "auto r = ind_" << indNum << ".template getBoundaries<" << indSize << ">(orderIn_" << indNum
             << "(lower), h.hints_" << indNum << ");\n";
-        def << "return make_range(iterator_" << indNum << "(r.begin()), iterator_" << indNum
+        out << "return make_range(iterator_" << indNum << "(r.begin()), iterator_" << indNum
             << "(r.end()));\n";
-        def << "}\n";
-
-        decl << "range<iterator_" << indNum << "> lowerUpperRange_" << search;
-        decl << "(const t_tuple& lower, const t_tuple& upper) const;\n";
-        def << "range<iterator_" << indNum << "> Type::lowerUpperRange_" << search;
-        def << "(const t_tuple& lower, const t_tuple& upper) const {\n";
-        def << "context h; return lowerUpperRange_" << search << "(lower,upper, h);\n";
-        def << "}\n";
+        out << "}\n";
+
+        out << "range<iterator_" << indNum << "> lowerUpperRange_" << search;
+        out << "(const t_tuple& lower, const t_tuple& upper) const {\n";
+        out << "context h; return lowerUpperRange_" << search << "(lower,upper, h);\n";
+        out << "}\n";
     }
 
     // empty method
-    decl << "bool empty() const;\n";
-    def << "bool Type::empty() const {\n";
-    def << "return ind_" << masterIndex << ".empty();\n";
-    def << "}\n";
+    out << "bool empty() const {\n";
+    out << "return ind_" << masterIndex << ".empty();\n";
+    out << "}\n";
 
     // partition method
-    decl << "std::vector<range<iterator>> partition() const;\n";
-    def << "std::vector<range<iterator>> Type::partition() const {\n";
-    def << "std::vector<range<iterator>> res;\n";
-    def << "for (const auto& cur : ind_" << masterIndex << ".partition(10000)) {\n";
-    def << "    res.push_back(make_range(iterator(cur.begin()), iterator(cur.end())));\n";
-    def << "}\n";
-    def << "return res;\n";
-    def << "}\n";
+    out << "std::vector<range<iterator>> partition() const {\n";
+    out << "std::vector<range<iterator>> res;\n";
+    out << "for (const auto& cur : ind_" << masterIndex << ".partition(10000)) {\n";
+    out << "    res.push_back(make_range(iterator(cur.begin()), iterator(cur.end())));\n";
+    out << "}\n";
+    out << "return res;\n";
+    out << "}\n";
 
     // purge method
-    decl << "void purge();\n";
-    def << "void Type::purge() {\n";
+    out << "void purge() {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        def << "ind_" << i << ".clear();\n";
+        out << "ind_" << i << ".clear();\n";
     }
-    def << "}\n";
+    out << "}\n";
 
     // begin and end iterators
-    decl << "iterator begin() const;\n";
-    def << "iterator Type::begin() const {\n";
-    def << "return iterator_" << masterIndex << "(ind_" << masterIndex << ".begin());\n";
-    def << "}\n";
+    out << "iterator begin() const {\n";
+    out << "return iterator_" << masterIndex << "(ind_" << masterIndex << ".begin());\n";
+    out << "}\n";
 
-    decl << "iterator end() const;\n";
-    def << "iterator Type::end() const {\n";
-    def << "return iterator_" << masterIndex << "(ind_" << masterIndex << ".end());\n";
-    def << "}\n";
+    out << "iterator end() const {\n";
+    out << "return iterator_" << masterIndex << "(ind_" << masterIndex << ".end());\n";
+    out << "}\n";
 
     // TODO: finish printStatistics method
-    decl << "void printStatistics(std::ostream& o) const;\n";
-    def << "void Type::printStatistics(std::ostream& o) const {\n";
+    out << "void printStatistics(std::ostream& o) const {\n";
     for (std::size_t i = 0; i < numIndexes; i++) {
-        def << "o << \" arity " << arity << " brie index " << i << " lex-order " << inds[i] << "\\n\";\n";
-        def << "ind_" << i << ".printStats(o);\n";
+        out << "o << \" arity " << arity << " brie index " << i << " lex-order " << inds[i] << "\\n\";\n";
+        ;
+        out << "ind_" << i << ".printStats(o);\n";
     }
-    def << "}\n";
+    out << "}\n";
 
     // orderOut and orderIn methods for reordering tuples according to index orders
     for (std::size_t i = 0; i < numIndexes; i++) {
         auto ind = inds[i];
-        decl << "static t_tuple orderIn_" << i << "(const t_tuple& t) {\n";
-        decl << "t_tuple res;\n";
+        out << "static t_tuple orderIn_" << i << "(const t_tuple& t) {\n";
+        out << "t_tuple res;\n";
         for (std::size_t j = 0; j < ind.size(); j++) {
-            decl << "res[" << j << "] = t[" << ind[j] << "];\n";
+            out << "res[" << j << "] = t[" << ind[j] << "];\n";
         }
-        decl << "return res;\n";
-        decl << "}\n";
+        out << "return res;\n";
+        out << "}\n";
 
-        decl << "static t_tuple orderOut_" << i << "(const t_tuple& t) {\n";
-        decl << "t_tuple res;\n";
+        out << "static t_tuple orderOut_" << i << "(const t_tuple& t) {\n";
+        out << "t_tuple res;\n";
         for (std::size_t j = 0; j < ind.size(); j++) {
-            decl << "res[" << ind[j] << "] = t[" << j << "];\n";
+            out << "res[" << ind[j] << "] = t[" << j << "];\n";
         }
-        decl << "return res;\n";
-        decl << "}\n";
+        out << "return res;\n";
+        out << "}\n";
     }
 
     // end class
-    decl << "};\n";
+    out << "};\n";
 }
 
 // -------- Eqrel Relation --------
@@ -1325,9 +1179,8 @@ std::string EqrelRelation::getTypeName() {
 }
 
 /** Generate type struct of a eqrel relation, which is empty,
- * the actual implementation is in EqRel.h */
-void EqrelRelation::generateTypeStruct(GenDb& db) {
-    db.datastructureIncludes(getTypeName(), "\"souffle/datastructure/EqRel.h\"");
+ * the actual implementation is in CompiledSouffle.h */
+void EqrelRelation::generateTypeStruct(std::ostream&) {
     return;
 }
 
diff --git a/src/synthesiser/Relation.h b/src/synthesiser/Relation.h
index c38f364..d0acee2 100644
--- a/src/synthesiser/Relation.h
+++ b/src/synthesiser/Relation.h
@@ -10,7 +10,6 @@
 
 #include "ram/Relation.h"
 #include "ram/analysis/Index.h"
-#include "synthesiser/GenDb.h"
 #include <cstddef>
 #include <cstdint>
 #include <memory>
@@ -66,7 +65,7 @@ public:
             const std::unordered_set<std::size_t>& attributesUsed) const;
 
     /** Generate relation type struct */
-    virtual void generateTypeStruct(GenDb& db) = 0;
+    virtual void generateTypeStruct(std::ostream& out) = 0;
 
     /** Factory method to generate a SynthesiserRelation */
     static Own<Relation> getSynthesiserRelation(
@@ -99,7 +98,7 @@ public:
 
     void computeIndices() override;
     std::string getTypeName() override;
-    void generateTypeStruct(GenDb& db) override;
+    void generateTypeStruct(std::ostream& out) override;
 };
 
 class InfoRelation : public Relation {
@@ -109,24 +108,21 @@ public:
 
     void computeIndices() override;
     std::string getTypeName() override;
-    void generateTypeStruct(GenDb& db) override;
+    void generateTypeStruct(std::ostream& out) override;
 };
 
 class DirectRelation : public Relation {
 public:
     DirectRelation(const ram::Relation& ramRel, const ram::analysis::IndexCluster& indexSelection,
-            bool hasAuxiliary, bool hasProvenance, bool hasErase)
-            : Relation(ramRel, indexSelection), hasAuxiliary(hasAuxiliary), hasProvenance(hasProvenance),
-              hasErase(hasErase) {}
+            bool isProvenance, bool hasErase)
+            : Relation(ramRel, indexSelection), isProvenance(isProvenance), hasErase(hasErase) {}
 
     void computeIndices() override;
-    std::string getTypeNamespace();
     std::string getTypeName() override;
-    void generateTypeStruct(GenDb& db) override;
+    void generateTypeStruct(std::ostream& out) override;
 
 private:
-    const bool hasAuxiliary;
-    const bool hasProvenance;
+    const bool isProvenance;
     const bool hasErase;
 };
 
@@ -136,9 +132,8 @@ public:
             : Relation(ramRel, indexSelection) {}
 
     void computeIndices() override;
-    std::string getTypeNamespace();
     std::string getTypeName() override;
-    void generateTypeStruct(GenDb& db) override;
+    void generateTypeStruct(std::ostream& out) override;
 };
 
 class BrieRelation : public Relation {
@@ -147,9 +142,8 @@ public:
             : Relation(ramRel, indexSelection) {}
 
     void computeIndices() override;
-    std::string getTypeNamespace();
     std::string getTypeName() override;
-    void generateTypeStruct(GenDb& db) override;
+    void generateTypeStruct(std::ostream& out) override;
 };
 
 class EqrelRelation : public Relation {
@@ -159,6 +153,6 @@ public:
 
     void computeIndices() override;
     std::string getTypeName() override;
-    void generateTypeStruct(GenDb& db) override;
+    void generateTypeStruct(std::ostream& out) override;
 };
 }  // namespace souffle::synthesiser
diff --git a/src/synthesiser/Synthesiser.cpp b/src/synthesiser/Synthesiser.cpp
index 59e7606..563066d 100644
--- a/src/synthesiser/Synthesiser.cpp
+++ b/src/synthesiser/Synthesiser.cpp
@@ -17,13 +17,10 @@
 #include "synthesiser/Synthesiser.h"
 #include "AggregateOp.h"
 #include "FunctorOps.h"
-#include "GenDb.h"
 #include "Global.h"
 #include "RelationTag.h"
-#include "config.h"
 #include "ram/AbstractParallel.h"
 #include "ram/Aggregate.h"
-#include "ram/Aggregator.h"
 #include "ram/AutoIncrement.h"
 #include "ram/Break.h"
 #include "ram/Call.h"
@@ -46,7 +43,6 @@
 #include "ram/IndexIfExists.h"
 #include "ram/IndexScan.h"
 #include "ram/Insert.h"
-#include "ram/IntrinsicAggregator.h"
 #include "ram/IntrinsicOperator.h"
 #include "ram/LogRelationTimer.h"
 #include "ram/LogSize.h"
@@ -86,7 +82,6 @@
 #include "ram/UndefValue.h"
 #include "ram/UnpackRecord.h"
 #include "ram/UnsignedConstant.h"
-#include "ram/UserDefinedAggregator.h"
 #include "ram/UserDefinedOperator.h"
 #include "ram/analysis/Index.h"
 #include "ram/utility/Utils.h"
@@ -101,9 +96,7 @@
 #include "souffle/utility/StringUtil.h"
 #include "souffle/utility/json11.h"
 #include "souffle/utility/tinyformat.h"
-#include "synthesiser/GenDb.h"
 #include "synthesiser/Relation.h"
-#include "synthesiser/Utils.h"
 #include <algorithm>
 #include <cassert>
 #include <cctype>
@@ -156,15 +149,33 @@ const std::string Synthesiser::convertRamIdent(const std::string& name) {
     if (it != identifiers.end()) {
         return it->second;
     }
-    std::string id = uniqueCppIdent(name);
+    // strip leading numbers
+    unsigned int i;
+    for (i = 0; i < name.length(); ++i) {
+        if ((isalnum(name.at(i)) != 0) || name.at(i) == '_') {
+            break;
+        }
+    }
+    std::string id;
+    for (auto ch : std::to_string(identifiers.size() + 1) + '_' + name.substr(i)) {
+        // alphanumeric characters are allowed
+        if (isalnum(ch) != 0) {
+            id += ch;
+        }
+        // all other characters are replaced by an underscore, except when
+        // the previous character was an underscore as double underscores
+        // in identifiers are reserved by the standard
+        else if (id.empty() || id.back() != '_') {
+            id += '_';
+        }
+    }
+    // most compilers have a limit of 2048 characters (if they have a limit at all) for
+    // identifiers; we use half of that for safety
+    id = id.substr(0, 1024);
     identifiers.insert(std::make_pair(name, id));
     return id;
 }
 
-const std::string Synthesiser::convertStratumIdent(const std::string& name) {
-    return convertRamIdent(name);
-}
-
 /** Get relation name */
 const std::string Synthesiser::getRelationName(const ram::Relation& rel) {
     return "rel_" + convertRamIdent(rel.getName());
@@ -180,21 +191,20 @@ const std::string Synthesiser::getOpContextName(const ram::Relation& rel) {
 }
 
 /** Get relation type struct */
-void Synthesiser::generateRelationTypeStruct(GenDb& db, Own<Relation> relationType) {
-    std::string name = relationType->getTypeName();
+void Synthesiser::generateRelationTypeStruct(std::ostream& out, Own<Relation> relationType) {
     // If this type has been generated already, use the cached version
-    if (typeCache.find(name) != typeCache.end()) {
+    if (typeCache.find(relationType->getTypeName()) != typeCache.end()) {
         return;
     }
-    typeCache.insert(name);
+    typeCache.insert(relationType->getTypeName());
 
     // Generate the type struct for the relation
-    relationType->generateTypeStruct(db);
+    relationType->generateTypeStruct(out);
 }
 
 /** Get referenced relations */
-ram::RelationSet Synthesiser::getReferencedRelations(const Operation& op) {
-    ram::RelationSet res;
+std::set<const ram::Relation*> Synthesiser::getReferencedRelations(const Operation& op) {
+    std::set<const ram::Relation*> res;
     visit(op, [&](const Node& node) {
         if (auto scan = as<RelationOperation>(node)) {
             res.insert(lookup(scan->getRelation()));
@@ -211,40 +221,24 @@ ram::RelationSet Synthesiser::getReferencedRelations(const Operation& op) {
     return res;
 }
 
-std::optional<std::size_t> Synthesiser::compileRegex(const std::string& pattern) {
-    auto i = regexes.find(pattern);
-    if (i != regexes.end()) {
-        return i->second;
-    }
-    try {
-        const std::regex regex(pattern);
-        std::size_t index = regexes.size();
-        return regexes.emplace(pattern, index).first->second;
-    } catch (const std::exception&) {
-        std::cerr << "warning: wrong pattern provided \"" << pattern << "\"\n";
-        return std::nullopt;
-    }
-}
-
 void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
     class CodeEmitter : public ram::Visitor<void, Node const, std::ostream&> {
         using ram::Visitor<void, Node const, std::ostream&>::visit_;
 
     private:
         Synthesiser& synthesiser;
-        Global& glb;
         IndexAnalysis* const isa = &synthesiser.getTranslationUnit().getAnalysis<IndexAnalysis>();
 
 // macros to add comments to generated code for debugging
 #ifndef PRINT_BEGIN_COMMENT
-#define PRINT_BEGIN_COMMENT(os)                                          \
-    if (glb.config().has("debug-report") || glb.config().has("verbose")) \
+#define PRINT_BEGIN_COMMENT(os)                                                  \
+    if (Global::config().has("debug-report") || Global::config().has("verbose")) \
     os << "/* BEGIN " << __FUNCTION__ << " @" << __FILE__ << ":" << __LINE__ << " */\n"
 #endif
 
 #ifndef PRINT_END_COMMENT
-#define PRINT_END_COMMENT(os)                                            \
-    if (glb.config().has("debug-report") || glb.config().has("verbose")) \
+#define PRINT_END_COMMENT(os)                                                    \
+    if (Global::config().has("debug-report") || Global::config().has("verbose")) \
     os << "/* END " << __FUNCTION__ << " @" << __FILE__ << ":" << __LINE__ << " */\n"
 #endif
 
@@ -256,7 +250,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
         bool preambleIssued = false;
 
     public:
-        CodeEmitter(Synthesiser& syn) : synthesiser(syn), glb(synthesiser.glb) {
+        CodeEmitter(Synthesiser& syn) : synthesiser(syn) {
             rec = [&](auto& out, const auto* value) {
                 out << "ramBitCast(";
                 dispatch(*value, out);
@@ -335,8 +329,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
         void visit_(type_identity<IO>, const IO& io, std::ostream& out) override {
             PRINT_BEGIN_COMMENT(out);
 
-            synthesiser.currentClass->addInclude("\"souffle/io/IOSystem.h\"", true);
-
             // print directives as C++ initializers
             auto printDirectives = [&](const std::map<std::string, std::string>& registry) {
                 auto cur = registry.begin();
@@ -371,16 +363,13 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 out << "} catch (std::exception& e) {std::cerr << \"Error loading " << io.getRelation()
                     << " data: \" << e.what() "
                        "<< "
-                       "'\\n';\nexit(1);\n}\n";
+                       "'\\n';}\n";
             } else if (op == "output" || op == "printsize") {
                 out << "try {";
                 out << "std::map<std::string, std::string> directiveMap(";
                 printDirectives(directives);
                 out << ");\n";
-                out << R"_(if (outputDirectory == "-"){)_";
-                out << R"_(directiveMap["IO"] = "stdout"; directiveMap["headers"] = "true";)_";
-                out << "}\n";
-                out << R"_(else if (!outputDirectory.empty()) {)_";
+                out << R"_(if (!outputDirectory.empty()) {)_";
                 out << R"_(directiveMap["output-dir"] = outputDirectory;)_";
                 out << "}\n";
                 out << "IOSystem::getInstance().getWriter(";
@@ -489,16 +478,11 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
         void visit_(type_identity<Clear>, const Clear& clear, std::ostream& out) override {
             PRINT_BEGIN_COMMENT(out);
 
-            auto Relation = synthesiser.lookup(clear.getRelation());
-            bool isIntermediate =
-                    !contains(synthesiser.storeRelations, Relation->getName()) && !Relation->isTemp();
-
-            if (isIntermediate) {
+            if (!synthesiser.lookup(clear.getRelation())->isTemp()) {
                 out << "if (pruneImdtRels) ";
             }
-            if (Relation->isTemp() || isIntermediate) {
-                out << synthesiser.getRelationName(Relation) << "->purge();\n";
-            }
+            out << synthesiser.getRelationName(synthesiser.lookup(clear.getRelation())) << "->"
+                << "purge();\n";
 
             PRINT_END_COMMENT(out);
         }
@@ -566,17 +550,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             PRINT_END_COMMENT(out);
         }
 
-        void visit_(type_identity<Assign>, const Assign& assign, std::ostream& out) override {
-            if (assign.isInit()) {
-                out << "auto ";
-            }
-            dispatch(assign.getVariable(), out);
-            out << " = ";
-            dispatch(assign.getValue(), out);
-            assign.getValue();
-            out << ";\n";
-        }
-
         void visit_(type_identity<Swap>, const Swap& swap, std::ostream& out) override {
             PRINT_BEGIN_COMMENT(out);
             const std::string& deltaKnowledge =
@@ -607,9 +580,11 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
         void visit_(type_identity<Call>, const Call& call, std::ostream& out) override {
             PRINT_BEGIN_COMMENT(out);
+            const Program& prog = synthesiser.getTranslationUnit().getProgram();
+            const auto& subs = prog.getSubroutines();
             out << "{\n";
             out << " std::vector<RamDomain> args, ret;\n";
-            out << synthesiser.convertStratumIdent(call.getName()) << ".run(args, ret);\n";
+            out << "subroutine_" << distance(subs.begin(), subs.find(call.getName())) << "(args, ret);\n";
             out << "}\n";
             PRINT_END_COMMENT(out);
         }
@@ -620,7 +595,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             // create local scope for name resolution
             out << "{\n";
 
-            const std::string ext = fileExtension(glb.config().get("profile"));
+            const std::string ext = fileExtension(Global::config().get("profile"));
 
             const auto* rel = synthesiser.lookup(timer.getRelation());
             auto relName = synthesiser.getRelationName(rel);
@@ -640,7 +615,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             // create local scope for name resolution
             out << "{\n";
 
-            const std::string ext = fileExtension(glb.config().get("profile"));
+            const std::string ext = fileExtension(Global::config().get("profile"));
 
             // create local timer
             out << "\tLogger logger(R\"_(" << timer.getMessage() << ")_\",iter);\n";
@@ -668,7 +643,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
         void visit_(
                 type_identity<NestedOperation>, const NestedOperation& nested, std::ostream& out) override {
             dispatch(nested.getOperation(), out);
-            if (glb.config().has("profile") && glb.config().has("profile-frequency") &&
+            if (Global::config().has("profile") && Global::config().has("profile-frequency") &&
                     !nested.getProfileText().empty()) {
                 out << "freqs[" << synthesiser.lookupFreqIdx(nested.getProfileText()) << "]++;\n";
             }
@@ -835,25 +810,21 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             PRINT_END_COMMENT(out);
         }
 
-        void visit_(type_identity<EstimateJoinSize>, const EstimateJoinSize& estimateJoinSize,
-                std::ostream& out) override {
-            const auto* rel = synthesiser.lookup(estimateJoinSize.getRelation());
+        void visit_(
+                type_identity<CountUniqueKeys>, const CountUniqueKeys& count, std::ostream& out) override {
+            const auto* rel = synthesiser.lookup(count.getRelation());
             auto relName = synthesiser.getRelationName(rel);
-            auto keys = isa->getSearchSignature(&estimateJoinSize);
+            auto keys = isa->getSearchSignature(&count);
 
             std::size_t indexNumber = 0;
             if (!keys.empty()) {
-                indexNumber = isa->getIndexSelection(estimateJoinSize.getRelation()).getLexOrderNum(keys);
+                indexNumber = isa->getIndexSelection(count.getRelation()).getLexOrderNum(keys);
             }
-
-            auto relationType =
-                    Relation::getSynthesiserRelation(*rel, isa->getIndexSelection(rel->getName()));
-            const std::string& type = relationType->getTypeName();
-            auto indexName = relName + (type == "t_eqrel" ? "->ind" : "->ind_" + std::to_string(indexNumber));
+            auto indexName = relName + "->ind_" + std::to_string(indexNumber);
 
             bool onlyConstants = true;
-            for (auto col : estimateJoinSize.getKeyColumns()) {
-                if (estimateJoinSize.getConstantsMap().count(col) == 0) {
+            for (auto col : count.getKeyColumns()) {
+                if (count.getConstantsMap().count(col) == 0) {
                     onlyConstants = false;
                     break;
                 }
@@ -861,7 +832,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
             // create a copy of the map to the real numeric constants
             std::map<std::size_t, RamDomain> keyConstants;
-            for (auto [k, constant] : estimateJoinSize.getConstantsMap()) {
+            for (auto [k, constant] : count.getConstantsMap()) {
                 RamDomain value;
                 if (const auto* signedConstant = as<ram::SignedConstant>(constant)) {
                     value = ramBitCast<RamDomain>(signedConstant->getValue());
@@ -879,13 +850,13 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 keyConstants[k] = value;
             }
             std::stringstream columnsStream;
-            columnsStream << estimateJoinSize.getKeyColumns();
+            columnsStream << count.getKeyColumns();
             std::string columns = columnsStream.str();
 
             std::stringstream constantsStream;
-            constantsStream << "{";
+            constantsStream << "[";
             bool first = true;
-            for (auto& [k, constant] : estimateJoinSize.getConstantsMap()) {
+            for (auto& [k, constant] : count.getConstantsMap()) {
                 if (first) {
                     first = false;
                 } else {
@@ -893,22 +864,21 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 }
                 constantsStream << k << "->" << *constant;
             }
-            constantsStream << "}";
+            constantsStream << "]";
             std::string constants = stringify(constantsStream.str());
 
             std::string profilerText =
-                    (estimateJoinSize.isRecursiveRelation() ? stringify("@recursive-estimate-join-size;" +
-                                                                        estimateJoinSize.getRelation() + ";" +
-                                                                        columns + ";" + constants)
-                                                            : stringify("@non-recursive-estimate-join-size;" +
-                                                                        estimateJoinSize.getRelation() + ";" +
-                                                                        columns + ";" + constants));
+                    (count.isRecursiveRelation()
+                                    ? stringify("@recursive-count-unique-keys;" + count.getRelation() + ";" +
+                                                columns + ";" + constants)
+                                    : stringify("@non-recursive-count-unique-keys;" + count.getRelation() +
+                                                ";" + columns + ";" + constants));
 
             PRINT_BEGIN_COMMENT(out);
             auto ctxName = "READ_OP_CONTEXT(" + synthesiser.getOpContextName(*rel) + ")";
             out << "{\n";
-            out << "double total = 0;\n";
-            out << "double duplicates = 0;\n";
+            out << "std::size_t total = 0;\n";
+            out << "std::size_t duplicates = 0;\n";
 
             out << "if (!" << indexName << ".empty()) {\n";
             out << "bool first = true;\n";
@@ -928,7 +898,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             out << "if (first) { first = false; }\n";
             out << "else {\n";
             out << "    bool matchesPrev = true;\n";
-            for (auto k : estimateJoinSize.getKeyColumns()) {
+            for (auto k : count.getKeyColumns()) {
                 if (rel->getArity() > 6) {
                     out << "matchesPrev &= (tup[0][" << k << "] == prev[0][" << k << "]);\n";
                 } else {
@@ -941,14 +911,13 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             out << "\n";
             out << "}\n";
             out << "}\n";
-            out << "double joinSize = ("
-                << (onlyConstants ? "total" : "total / std::max(1.0, (total - duplicates))") << ");\n";
-            if (estimateJoinSize.isRecursiveRelation()) {
+            out << "std::size_t uniqueKeys = (" << (onlyConstants ? "total" : "total - duplicates") << ");\n";
+            if (count.isRecursiveRelation()) {
                 out << "ProfileEventSingleton::instance().makeRecursiveCountEvent(\"" << profilerText
-                    << "\", joinSize, iter);\n";
+                    << "\", uniqueKeys, iter);\n";
             } else {
                 out << "ProfileEventSingleton::instance().makeNonRecursiveCountEvent(\"" << profilerText
-                    << "\", joinSize);\n";
+                    << "\", uniqueKeys);\n";
             }
             out << "}\n";
             PRINT_END_COMMENT(out);
@@ -1118,151 +1087,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             PRINT_END_COMMENT(out);
         }
 
-        std::string initValue(const Aggregator& aggregator) {
-            if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-                switch (ia->getFunction()) {
-                    case AggregateOp::MIN: return "MAX_RAM_SIGNED";
-                    case AggregateOp::FMIN: return "MAX_RAM_FLOAT";
-                    case AggregateOp::UMIN: return "MAX_RAM_UNSIGNED";
-                    case AggregateOp::MAX: return "MIN_RAM_SIGNED";
-                    case AggregateOp::FMAX: return "MIN_RAM_FLOAT";
-                    case AggregateOp::UMAX: return "MIN_RAM_UNSIGNED";
-                    case AggregateOp::COUNT:
-                    case AggregateOp::MEAN:
-                    case AggregateOp::FSUM:
-                    case AggregateOp::USUM:
-                    case AggregateOp::SUM: return "0";
-                }
-            } else if (const auto* uda = as<ram::UserDefinedAggregator>(aggregator)) {
-                assert(uda);
-                std::stringstream ss;
-                dispatch(*uda->getInitValue(), ss);
-                return ss.str();
-            }
-            fatal("Unhandled aggregate operation");
-        }
-
-        void updateRes(std::ostream& out, const AbstractAggregate& aggregate) {
-            const auto& aggregator = aggregate.getAggregator();
-            if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-                AggregateOp aggregateFun = ia->getFunction();
-                std::string type = getType(aggregator);
-                switch (aggregateFun) {
-                    case AggregateOp::FMIN:
-                    case AggregateOp::UMIN:
-                    case AggregateOp::MIN:
-                        out << "res0 = std::min(res0,ramBitCast<" << type << ">(";
-                        dispatch(aggregate.getExpression(), out);
-                        out << "));\n";
-                        break;
-                    case AggregateOp::FMAX:
-                    case AggregateOp::UMAX:
-                    case AggregateOp::MAX:
-                        out << "res0 = std::max(res0,ramBitCast<" << type << ">(";
-                        dispatch(aggregate.getExpression(), out);
-                        out << "));\n";
-                        break;
-                    case AggregateOp::COUNT: out << "++res0\n;"; break;
-                    case AggregateOp::FSUM:
-                    case AggregateOp::USUM:
-                    case AggregateOp::SUM:
-                        out << "res0 += "
-                            << "ramBitCast<" << type << ">(";
-                        dispatch(aggregate.getExpression(), out);
-                        out << ");\n";
-                        break;
-
-                    case AggregateOp::MEAN:
-                        out << "res0 += "
-                            << "ramBitCast<RamFloat>(";
-                        dispatch(aggregate.getExpression(), out);
-                        out << ");\n";
-                        out << "++res1;\n";
-                        break;
-                }
-            } else if (const auto* uda = as<ram::UserDefinedAggregator>(aggregator)) {
-                out << "res0 = " << uda->getName() << "(";
-                if (uda->isStateful()) {
-                    out << "&symTable, &recordTable, ";
-                }
-                out << "res0, ";
-                dispatch(aggregate.getExpression(), out);
-                out << ");\n";
-            }
-        }
-
-        bool shouldRunNested(const Aggregator& aggregator) {
-            if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-                switch (ia->getFunction()) {
-                    case AggregateOp::COUNT:
-                    case AggregateOp::FSUM:
-                    case AggregateOp::USUM:
-                    case AggregateOp::SUM: return true;
-                    default: return false;
-                }
-            } else if (isA<ram::UserDefinedAggregator>(aggregator)) {
-                return true;
-            }
-            fatal("Unhandled aggregate operation");
-        }
-
-        std::string getType(const Aggregator& aggregator) {
-            auto str = [&](souffle::TypeAttribute ta) {
-                switch (ta) {
-                    case TypeAttribute::Signed: return "RamSigned";
-                    case TypeAttribute::Unsigned: return "RamUnsigned";
-                    case TypeAttribute::Float: return "RamFloat";
-                    case TypeAttribute::Symbol:
-                    case TypeAttribute::ADT:
-                    case TypeAttribute::Record: return "RamDomain";
-                    default: return "RamDomain";
-                }
-            };
-            if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-                return str(getTypeAttributeAggregate(ia->getFunction()));
-            } else if (const auto* uda = as<ram::UserDefinedAggregator>(aggregator)) {
-                return str(uda->getReturnType());
-            }
-            fatal("Unhandled aggregator");
-        }
-
-        std::tuple<std::string, std::string, int> reductionOperation(const Aggregator& aggregator) {
-            if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-                switch (ia->getFunction()) {
-                    case AggregateOp::MIN:
-                    case AggregateOp::FMIN:
-                    case AggregateOp::UMIN: return std::make_tuple("min", "", 200805);
-                    case AggregateOp::MAX:
-                    case AggregateOp::FMAX:
-                    case AggregateOp::UMAX: return std::make_tuple("max", "", 200805);
-                    case AggregateOp::MEAN:
-                    case AggregateOp::FSUM:
-                    case AggregateOp::USUM:
-                    case AggregateOp::COUNT:
-                    case AggregateOp::SUM: return std::make_tuple("+", "", 0);
-                    default: fatal("Unhandled aggregate operation");
-                }
-            } else if (const auto* uda = as<ram::UserDefinedAggregator>(aggregator)) {
-                std::stringstream def;
-                std::string name = uda->getName();
-                def << "#pragma omp declare reduction("
-                    << "reduction_" << name << " : " << getType(aggregator) << " : \\\n";
-                // TODO: does not work for stateful functors
-                def << "omp_out = " << name << "(omp_out, omp_in) )\\\n";
-                def << "initializer (omp_priv=(omp_orig))\n";
-                return std::make_tuple("reduction_" + name, def.str(), 0);
-            }
-            fatal("Unhandled aggregator");
-        }
-
-        void ifIntrinsic(const ram::Aggregator& aggregator, AggregateOp op, std::function<void()> fn) {
-            if (const auto* ia = as<ram::IntrinsicAggregator>(aggregator)) {
-                if (ia->getFunction() == op) {
-                    fn();
-                };
-            }
-        }
-
         void visit_(type_identity<ParallelIndexAggregate>, const ParallelIndexAggregate& aggregate,
                 std::ostream& out) override {
             assert(aggregate.getTupleId() == 0 && "not outer-most loop");
@@ -1285,13 +1109,9 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             // get range to aggregate
             auto keys = isa->getSearchSignature(&aggregate);
 
-            const ram::Aggregator& aggregator = aggregate.getAggregator();
-
-            bool isCount = false;
-            ifIntrinsic(aggregator, AggregateOp::COUNT, [&]() { isCount = true; });
-
             // special case: counting number elements over an unrestricted predicate
-            if (isCount && keys.empty() && isTrue(&aggregate.getCondition())) {
+            if (aggregate.getFunction() == AggregateOp::COUNT && keys.empty() &&
+                    isTrue(&aggregate.getCondition())) {
                 // shortcut: use relation size
                 out << "env" << identifier << "[0] = " << relName << "->"
                     << "size();\n";
@@ -1302,26 +1122,79 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 return;
             }
 
+            out << "bool shouldRunNested = false;\n";
+
             // init result and reduction operation
-            std::string init = initValue(aggregator);
-            out << "bool shouldRunNested = " << (shouldRunNested(aggregator) ? "true" : "false") << ";\n";
+            std::string init;
+            switch (aggregate.getFunction()) {
+                case AggregateOp::MIN: init = "MAX_RAM_SIGNED"; break;
+                case AggregateOp::FMIN: init = "MAX_RAM_FLOAT"; break;
+                case AggregateOp::UMIN: init = "MAX_RAM_UNSIGNED"; break;
+                case AggregateOp::MAX: init = "MIN_RAM_SIGNED"; break;
+                case AggregateOp::FMAX: init = "MIN_RAM_FLOAT"; break;
+                case AggregateOp::UMAX: init = "MIN_RAM_UNSIGNED"; break;
+                case AggregateOp::COUNT:
+                    init = "0";
+                    out << "shouldRunNested = true;\n";
+                    break;
+                case AggregateOp::MEAN: init = "0"; break;
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::SUM:
+                    init = "0";
+                    out << "shouldRunNested = true;\n";
+                    break;
+            }
 
             // Set reduction operation
             std::string op;
-            std::string op_def;
-            int omp_min_ver;
-            std::tie(op, op_def, omp_min_ver) = reductionOperation(aggregator);
+            std::string omp_min_ver;
+            switch (aggregate.getFunction()) {
+                case AggregateOp::MIN:
+                case AggregateOp::FMIN:
+                case AggregateOp::UMIN: {
+                    op = "min";
+                    omp_min_ver = "200805";  // from OMP 3.0
+                    break;
+                }
 
+                case AggregateOp::MAX:
+                case AggregateOp::FMAX:
+                case AggregateOp::UMAX: {
+                    op = "max";
+                    omp_min_ver = "200805";  // from OMP 3.0
+                    break;
+                }
+
+                case AggregateOp::MEAN:
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::COUNT:
+                case AggregateOp::SUM: {
+                    omp_min_ver = "0";
+                    op = "+";
+                    break;
+                }
+                default: fatal("Unhandled aggregate operation");
+            }
             // res0 stores the aggregate result
             std::string sharedVariable = "res0";
 
-            std::string type = getType(aggregator);
+            std::string type;
+            switch (getTypeAttributeAggregate(aggregate.getFunction())) {
+                case TypeAttribute::Signed: type = "RamSigned"; break;
+                case TypeAttribute::Unsigned: type = "RamUnsigned"; break;
+                case TypeAttribute::Float: type = "RamFloat"; break;
 
+                case TypeAttribute::Symbol:
+                case TypeAttribute::ADT:
+                case TypeAttribute::Record: type = "RamDomain"; break;
+            }
             out << type << " res0 = " << init << ";\n";
-            ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() {
+            if (aggregate.getFunction() == AggregateOp::MEAN) {
                 out << "RamUnsigned res1 = 0;\n";
                 sharedVariable += ", res1";
-            });
+            }
 
             out << preamble.str();
             out << "PARALLEL_START\n";
@@ -1329,7 +1202,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             if (keys.empty()) {
                 // OMP reduction is not available on all versions of OpenMP
                 out << "#if defined _OPENMP && _OPENMP >= " << omp_min_ver << "\n";
-                out << op_def << "\n";
                 out << "#pragma omp for reduction(" << op << ":" << sharedVariable << ")\n";
                 out << "#endif\n";
 
@@ -1356,7 +1228,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
                 // OMP reduction is not available on all versions of OpenMP
                 out << "#if defined _OPENMP && _OPENMP >= " << omp_min_ver << "\n";
-                out << op_def << "\n";
                 out << "#pragma omp for reduction(" << op << ":" << sharedVariable << ")\n";
                 out << "#endif\n";
 
@@ -1381,7 +1252,39 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             out << "shouldRunNested = true;\n";
 
             // pick function
-            updateRes(out, aggregate);
+            switch (aggregate.getFunction()) {
+                case AggregateOp::FMIN:
+                case AggregateOp::UMIN:
+                case AggregateOp::MIN:
+                    out << "res0 = std::min(res0,ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << "));\n";
+                    break;
+                case AggregateOp::FMAX:
+                case AggregateOp::UMAX:
+                case AggregateOp::MAX:
+                    out << "res0 = std::max(res0,ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << "));\n";
+                    break;
+                case AggregateOp::COUNT: out << "++res0\n;"; break;
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::SUM:
+                    out << "res0 += "
+                        << "ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << ");\n";
+                    break;
+
+                case AggregateOp::MEAN:
+                    out << "res0 += "
+                        << "ramBitCast<RamFloat>(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << ");\n";
+                    out << "++res1;\n";
+                    break;
+            }
 
             // end if statement
             out << "}\n";
@@ -1397,11 +1300,11 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             // start single-threaded section
             out << "#pragma omp single\n{\n";
 
-            ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() {
+            if (aggregate.getFunction() == AggregateOp::MEAN) {
                 out << "if (res1 != 0) {\n";
                 out << "res0 = res0 / res1;\n";
                 out << "}\n";
-            });
+            }
 
             // write result into environment tuple
             out << "env" << identifier << "[0] = ramBitCast(res0);\n";
@@ -1445,13 +1348,9 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             // get range to aggregate
             auto keys = isa->getSearchSignature(&aggregate);
 
-            const ram::Aggregator& aggregator = aggregate.getAggregator();
-
-            bool isCount = false;
-            ifIntrinsic(aggregator, AggregateOp::COUNT, [&]() { isCount = true; });
-
             // special case: counting number elements over an unrestricted predicate
-            if (isCount && keys.empty() && isTrue(&aggregate.getCondition())) {
+            if (aggregate.getFunction() == AggregateOp::COUNT && keys.empty() &&
+                    isTrue(&aggregate.getCondition())) {
                 // shortcut: use relation size
                 out << "env" << identifier << "[0] = " << relName << "->"
                     << "size();\n";
@@ -1460,15 +1359,45 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 return;
             }
 
+            out << "bool shouldRunNested = false;\n";
+
             // init result
-            std::string init = initValue(aggregator);
-            out << "bool shouldRunNested = " << (shouldRunNested(aggregator) ? "true" : "false") << ";\n";
+            std::string init;
+            switch (aggregate.getFunction()) {
+                case AggregateOp::MIN: init = "MAX_RAM_SIGNED"; break;
+                case AggregateOp::FMIN: init = "MAX_RAM_FLOAT"; break;
+                case AggregateOp::UMIN: init = "MAX_RAM_UNSIGNED"; break;
+                case AggregateOp::MAX: init = "MIN_RAM_SIGNED"; break;
+                case AggregateOp::FMAX: init = "MIN_RAM_FLOAT"; break;
+                case AggregateOp::UMAX: init = "MIN_RAM_UNSIGNED"; break;
+                case AggregateOp::COUNT:
+                    init = "0";
+                    out << "shouldRunNested = true;\n";
+                    break;
+                case AggregateOp::MEAN: init = "0"; break;
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::SUM:
+                    init = "0";
+                    out << "shouldRunNested = true;\n";
+                    break;
+            }
 
-            std::string type = getType(aggregator);
+            std::string type;
+            switch (getTypeAttributeAggregate(aggregate.getFunction())) {
+                case TypeAttribute::Signed: type = "RamSigned"; break;
+                case TypeAttribute::Unsigned: type = "RamUnsigned"; break;
+                case TypeAttribute::Float: type = "RamFloat"; break;
 
+                case TypeAttribute::Symbol:
+                case TypeAttribute::ADT:
+                case TypeAttribute::Record: type = "RamDomain"; break;
+            }
             out << type << " res0 = " << init << ";\n";
 
-            ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() { out << "RamUnsigned res1 = 0;\n"; });
+            if (aggregate.getFunction() == AggregateOp::MEAN) {
+                out << "RamUnsigned res1 = 0;\n";
+            }
 
             // check whether there is an index to use
             if (keys.empty()) {
@@ -1496,26 +1425,53 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             out << "shouldRunNested = true;\n";
 
             // pick function
-            updateRes(out, aggregate);
-            auto printBreak = [&]() {
-                if (isGuaranteedToBeMinimum(aggregate)) {
-                    out << "break;\n";
-                }
-            };
-            ifIntrinsic(aggregator, AggregateOp::FMIN, printBreak);
-            ifIntrinsic(aggregator, AggregateOp::UMIN, printBreak);
-            ifIntrinsic(aggregator, AggregateOp::MIN, printBreak);
+            switch (aggregate.getFunction()) {
+                case AggregateOp::FMIN:
+                case AggregateOp::UMIN:
+                case AggregateOp::MIN:
+                    out << "res0 = std::min(res0,ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << "));\n";
+                    if (isGuaranteedToBeMinimum(aggregate)) {
+                        out << "break;\n";
+                    }
+                    break;
+                case AggregateOp::FMAX:
+                case AggregateOp::UMAX:
+                case AggregateOp::MAX:
+                    out << "res0 = std::max(res0,ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << "));\n";
+                    break;
+                case AggregateOp::COUNT: out << "++res0\n;"; break;
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::SUM:
+                    out << "res0 += "
+                        << "ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << ");\n";
+                    break;
+
+                case AggregateOp::MEAN:
+                    out << "res0 += "
+                        << "ramBitCast<RamFloat>(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << ");\n";
+                    out << "++res1;\n";
+                    break;
+            }
 
             out << "}\n";
 
             // end aggregator loop
             out << "}\n";
 
-            ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() {
+            if (aggregate.getFunction() == AggregateOp::MEAN) {
                 out << "if (res1 != 0) {\n";
                 out << "res0 = res0 / res1;\n";
                 out << "}\n";
-            });
+            }
 
             // write result into environment tuple
             out << "env" << identifier << "[0] = ramBitCast(res0);\n";
@@ -1544,13 +1500,8 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             // declare environment variable
             out << "Tuple<RamDomain,1> env" << identifier << ";\n";
 
-            const ram::Aggregator& aggregator = aggregate.getAggregator();
-
-            bool isCount = false;
-            ifIntrinsic(aggregator, AggregateOp::COUNT, [&]() { isCount = true; });
-
             // special case: counting number elements over an unrestricted predicate
-            if (isCount && isTrue(&aggregate.getCondition())) {
+            if (aggregate.getFunction() == AggregateOp::COUNT && isTrue(&aggregate.getCondition())) {
                 // shortcut: use relation size
                 out << "env" << identifier << "[0] = " << relName << "->"
                     << "size();\n";
@@ -1561,25 +1512,83 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 return;
             }
 
+            out << "bool shouldRunNested = false;\n";
+
             // init result
-            std::string init = initValue(aggregator);
-            out << "bool shouldRunNested = " << (shouldRunNested(aggregator) ? "true" : "false") << ";\n";
+            std::string init;
+            switch (aggregate.getFunction()) {
+                case AggregateOp::MIN: init = "MAX_RAM_SIGNED"; break;
+                case AggregateOp::FMIN: init = "MAX_RAM_FLOAT"; break;
+                case AggregateOp::UMIN: init = "MAX_RAM_UNSIGNED"; break;
+                case AggregateOp::MAX: init = "MIN_RAM_SIGNED"; break;
+                case AggregateOp::FMAX: init = "MIN_RAM_FLOAT"; break;
+                case AggregateOp::UMAX: init = "MIN_RAM_UNSIGNED"; break;
+                case AggregateOp::COUNT:
+                    init = "0";
+                    out << "shouldRunNested = true;\n";
+                    break;
+
+                case AggregateOp::MEAN: init = "0"; break;
+
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::SUM:
+                    init = "0";
+                    out << "shouldRunNested = true;\n";
+                    break;
+            }
 
             // Set reduction operation
             std::string op;
-            std::string op_def;
-            int omp_min_ver;
-            std::tie(op, op_def, omp_min_ver) = reductionOperation(aggregator);
+            std::string omp_min_ver;
+            switch (aggregate.getFunction()) {
+                case AggregateOp::MIN:
+                case AggregateOp::FMIN:
+                case AggregateOp::UMIN: {
+                    op = "min";
+                    omp_min_ver = "200805";  // from OMP 3.0
+                    break;
+                }
 
-            std::string type = getType(aggregator);
+                case AggregateOp::MAX:
+                case AggregateOp::FMAX:
+                case AggregateOp::UMAX: {
+                    op = "max";
+                    omp_min_ver = "200805";  // from OMP 3.0
+                    break;
+                }
+
+                case AggregateOp::MEAN:
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::COUNT:
+                case AggregateOp::SUM: {
+                    op = "+";
+                    omp_min_ver = "0";
+                    break;
+                }
 
+                default: fatal("Unhandled aggregate operation");
+            }
+
+            char const* type = NULL;
+            switch (getTypeAttributeAggregate(aggregate.getFunction())) {
+                case TypeAttribute::Signed: type = "RamSigned"; break;
+                case TypeAttribute::Unsigned: type = "RamUnsigned"; break;
+                case TypeAttribute::Float: type = "RamFloat"; break;
+
+                case TypeAttribute::Symbol:
+                case TypeAttribute::ADT:
+                case TypeAttribute::Record: type = "RamDomain"; break;
+                default: assert(0);
+            }
             out << type << " res0 = " << init << ";\n";
 
             std::string sharedVariable = "res0";
-            ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() {
+            if (aggregate.getFunction() == AggregateOp::MEAN) {
                 out << "RamUnsigned res1 = " << init << ";\n";
                 sharedVariable += ", res1";
-            });
+            }
 
             // create a partitioning of the relation to iterate over simeltaneously
             out << "auto part = " << relName << "->partition();\n";
@@ -1596,7 +1605,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
             // pragma statement
             out << "#if defined _OPENMP && _OPENMP >= " << omp_min_ver << "\n";
-            out << op_def << "\n";
             out << "#pragma omp for reduction(" << op << ":" << sharedVariable << ")\n";
             out << "#endif\n";
 
@@ -1619,7 +1627,37 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
             out << "shouldRunNested = true;\n";
             // pick function
-            updateRes(out, aggregate);
+            switch (aggregate.getFunction()) {
+                case AggregateOp::FMIN:
+                case AggregateOp::UMIN:
+                case AggregateOp::MIN:
+                    out << "res0 = std::min(res0, ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << "));\n";
+                    break;
+                case AggregateOp::FMAX:
+                case AggregateOp::UMAX:
+                case AggregateOp::MAX:
+                    out << "res0 = std::max(res0, ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << "));\n";
+                    break;
+                case AggregateOp::COUNT: out << "++res0\n;"; break;
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::SUM:
+                    out << "res0 += ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << ");\n";
+                    break;
+
+                case AggregateOp::MEAN:
+                    out << "res0 += ramBitCast<RamFloat>(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << ");\n";
+                    out << "++res1;\n";
+                    break;
+            }
 
             out << "}\n";
 
@@ -1631,11 +1669,11 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             // the rest shouldn't be run in parallel
             out << "#pragma omp single\n{\n";
 
-            ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() {
+            if (aggregate.getFunction() == AggregateOp::MEAN) {
                 out << "if (res1 != 0) {\n";
                 out << "res0 = res0 / res1;\n";
                 out << "}\n";
-            });
+            }
 
             // write result into environment tuple
             out << "env" << identifier << "[0] = ramBitCast(res0);\n";
@@ -1658,13 +1696,8 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             // declare environment variable
             out << "Tuple<RamDomain,1> env" << identifier << ";\n";
 
-            const ram::Aggregator& aggregator = aggregate.getAggregator();
-
-            bool isCount = false;
-            ifIntrinsic(aggregator, AggregateOp::COUNT, [&]() { isCount = true; });
-
             // special case: counting number elements over an unrestricted predicate
-            if (isCount && isTrue(&aggregate.getCondition())) {
+            if (aggregate.getFunction() == AggregateOp::COUNT && isTrue(&aggregate.getCondition())) {
                 // shortcut: use relation size
                 out << "env" << identifier << "[0] = " << relName << "->"
                     << "size();\n";
@@ -1673,15 +1706,48 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 return;
             }
 
+            out << "bool shouldRunNested = false;\n";
+
             // init result
-            std::string init = initValue(aggregator);
-            out << "bool shouldRunNested = " << (shouldRunNested(aggregator) ? "true" : "false") << ";\n";
+            std::string init;
+            switch (aggregate.getFunction()) {
+                case AggregateOp::MIN: init = "MAX_RAM_SIGNED"; break;
+                case AggregateOp::FMIN: init = "MAX_RAM_FLOAT"; break;
+                case AggregateOp::UMIN: init = "MAX_RAM_UNSIGNED"; break;
+                case AggregateOp::MAX: init = "MIN_RAM_SIGNED"; break;
+                case AggregateOp::FMAX: init = "MIN_RAM_FLOAT"; break;
+                case AggregateOp::UMAX: init = "MIN_RAM_UNSIGNED"; break;
+                case AggregateOp::COUNT:
+                    init = "0";
+                    out << "shouldRunNested = true;\n";
+                    break;
 
-            std::string type = getType(aggregator);
+                case AggregateOp::MEAN: init = "0"; break;
 
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::SUM:
+                    init = "0";
+                    out << "shouldRunNested = true;\n";
+                    break;
+            }
+
+            std::string type;
+            switch (getTypeAttributeAggregate(aggregate.getFunction())) {
+                case TypeAttribute::Signed: type = "RamSigned"; break;
+                case TypeAttribute::Unsigned: type = "RamUnsigned"; break;
+                case TypeAttribute::Float: type = "RamFloat"; break;
+
+                case TypeAttribute::Symbol:
+                case TypeAttribute::ADT:
+                case TypeAttribute::Record:
+                default: type = "RamDomain"; break;
+            }
             out << type << " res0 = " << init << ";\n";
 
-            ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() { out << "RamUnsigned res1 = 0;\n"; });
+            if (aggregate.getFunction() == AggregateOp::MEAN) {
+                out << "RamUnsigned res1 = 0;\n";
+            }
 
             // check whether there is an index to use
             out << "for(const auto& env" << identifier << " : "
@@ -1694,14 +1760,49 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
             out << "shouldRunNested = true;\n";
             // pick function
-            updateRes(out, aggregate);
+            switch (aggregate.getFunction()) {
+                case AggregateOp::FMIN:
+                case AggregateOp::UMIN:
+                case AggregateOp::MIN:
+                    out << "res0 = std::min(res0, ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << "));\n";
+                    break;
+                case AggregateOp::FMAX:
+                case AggregateOp::UMAX:
+                case AggregateOp::MAX:
+                    out << "res0 = std::max(res0,ramBitCast<" << type << ">(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << "));\n";
+                    break;
+                case AggregateOp::COUNT: out << "++res0\n;"; break;
+                case AggregateOp::FSUM:
+                case AggregateOp::USUM:
+                case AggregateOp::SUM:
+                    out << "res0 += "
+                        << "ramBitCast<" << type << ">(";
+                    ;
+                    dispatch(aggregate.getExpression(), out);
+                    out << ");\n";
+                    break;
+
+                case AggregateOp::MEAN:
+                    out << "res0 += "
+                        << "ramBitCast<RamFloat>(";
+                    dispatch(aggregate.getExpression(), out);
+                    out << ");\n";
+                    out << "++res1;\n";
+                    break;
+            }
 
             out << "}\n";
 
             // end aggregator loop
             out << "}\n";
 
-            ifIntrinsic(aggregator, AggregateOp::MEAN, [&]() { out << "res0 = res0 / res1;\n"; });
+            if (aggregate.getFunction() == AggregateOp::MEAN) {
+                out << "res0 = res0 / res1;\n";
+            }
 
             // write result into environment tuple
             out << "env" << identifier << "[0] = ramBitCast(res0);\n";
@@ -1865,43 +1966,21 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
                 // strings
                 case BinaryConstraintOp::MATCH: {
-                    if (const StringConstant* str = as<StringConstant>(&rel.getLHS()); str) {
-                        const auto& regex = synthesiser.compileRegex(str->getConstant());
-                        if (regex) {
-                            out << "std::regex_match(symTable.decode(";
-                            dispatch(rel.getRHS(), out);
-                            out << "), regexes.at(" << *regex << "))";
-                        } else {
-                            out << "false";
-                        }
-                    } else {
-                        synthesiser.SubroutineUsingStdRegex = true;
-                        out << "regex_wrapper(symTable.decode(";
-                        dispatch(rel.getLHS(), out);
-                        out << "),symTable.decode(";
-                        dispatch(rel.getRHS(), out);
-                        out << "))";
-                    }
+                    synthesiser.UsingStdRegex = true;
+                    out << "regex_wrapper(symTable.decode(";
+                    dispatch(rel.getLHS(), out);
+                    out << "),symTable.decode(";
+                    dispatch(rel.getRHS(), out);
+                    out << "))";
                     break;
                 }
                 case BinaryConstraintOp::NOT_MATCH: {
-                    if (const StringConstant* str = as<StringConstant>(&rel.getLHS()); str) {
-                        const auto& regex = synthesiser.compileRegex(str->getConstant());
-                        if (regex) {
-                            out << "!std::regex_match(symTable.decode(";
-                            dispatch(rel.getRHS(), out);
-                            out << "), regexes.at(" << *regex << "))";
-                        } else {
-                            out << "false";
-                        }
-                    } else {
-                        synthesiser.SubroutineUsingStdRegex = true;
-                        out << "!regex_wrapper(symTable.decode(";
-                        dispatch(rel.getLHS(), out);
-                        out << "),symTable.decode(";
-                        dispatch(rel.getRHS(), out);
-                        out << "))";
-                    }
+                    synthesiser.UsingStdRegex = true;
+                    out << "!regex_wrapper(symTable.decode(";
+                    dispatch(rel.getLHS(), out);
+                    out << "),symTable.decode(";
+                    dispatch(rel.getRHS(), out);
+                    out << "))";
                     break;
                 }
                 case BinaryConstraintOp::CONTAINS: {
@@ -1956,7 +2035,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             auto arity = rel->getArity();
             assert(arity > 0 && "AstToRamTranslator failed");
             std::string after;
-            if (glb.config().has("profile") && glb.config().has("profile-frequency") &&
+            if (Global::config().has("profile") && Global::config().has("profile-frequency") &&
                     !synthesiser.lookup(exists.getRelation())->isTemp()) {
                 out << R"_((reads[)_" << synthesiser.lookupReadIdx(rel->getName()) << R"_(]++,)_";
                 after = ")";
@@ -2067,10 +2146,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             PRINT_END_COMMENT(out);
         }
 
-        void visit_(type_identity<Variable>, const Variable& v, std::ostream& out) override {
-            out << v.getName();
-        }
-
         void visit_(type_identity<TupleElement>, const TupleElement& access, std::ostream& out) override {
             PRINT_BEGIN_COMMENT(out);
             out << "env" << access.getTupleId() << "[" << access.getElement() << "]";
@@ -2099,7 +2174,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
             PRINT_BEGIN_COMMENT(out);
 
-            // clang-format off
+// clang-format off
 #define UNARY_OP(opcode, ty, op)                \
     case FunctorOp::opcode: {                   \
         out << "(" #op "(ramBitCast<" #ty ">("; \
@@ -2177,17 +2252,14 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
         dispatch(*args[0], out);                  \
         out << "))";                              \
     } break;
-#define CONV_FROM_STRING(opcode, ty)                                                       \
-    case FunctorOp::opcode: {                                                              \
-        synthesiser.currentClass->addInclude("\"souffle/utility/EvaluatorUtil.h\"", true); \
-        out << "souffle::evaluator::symbol2numeric<" #ty ">(symTable.decode(";             \
-        dispatch(*args[0], out);                                                           \
-        out << "))";                                                                       \
+#define CONV_FROM_STRING(opcode, ty)                                            \
+    case FunctorOp::opcode: {                                                   \
+        out << "souffle::evaluator::symbol2numeric<" #ty ">(symTable.decode(";  \
+        dispatch(*args[0], out);                                                \
+        out << "))";                                                            \
     } break;
             // clang-format on
-            if (op.getOperator() == FunctorOp::LXOR) {
-                synthesiser.currentClass->addInclude("\"souffle/utility/EvaluatorUtil.h\"", true);
-            }
+
             auto args = op.getArguments();
             switch (op.getOperator()) {
                 /** Unary Functor Operators */
@@ -2298,7 +2370,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
                 /** Ternary Functor Operators */
                 case FunctorOp::SUBSTR: {
-                    synthesiser.SubroutineUsingSubstr = true;
                     out << "symTable.encode(";
                     out << "substr_wrapper(symTable.decode(";
                     dispatch(*args[0], out);
@@ -2314,35 +2385,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 case FunctorOp::URANGE:
                 case FunctorOp::FRANGE:
                     fatal("ICE: functor `%s` must map onto `NestedIntrinsicOperator`", op.getOperator());
-
-                case FunctorOp::SSADD: {
-                    const StringConstant* lstr = as<StringConstant>(args[0]);
-                    const StringConstant* rstr = as<StringConstant>(args[1]);
-                    if (lstr && rstr) {
-                        out << "RamSigned("
-                            << synthesiser.convertSymbol2Idx(lstr->getConstant() + rstr->getConstant())
-                            << ")";
-                    } else {
-                        out << "symTable.encode(";
-                        if (lstr) {
-                            out << "R\"_(" << lstr->getConstant() << ")_\"";
-                        } else {
-                            out << "symTable.decode(";
-                            dispatch(*args[0], out);
-                            out << ")";
-                        }
-                        out << " + ";
-                        if (rstr) {
-                            out << "R\"_(" << rstr->getConstant() << ")_\"";
-                        } else {
-                            out << "symTable.decode(";
-                            dispatch(*args[1], out);
-                            out << ")";
-                        }
-                        out << ")";
-                    }
-                    break;
-                }
             }
             PRINT_END_COMMENT(out);
 
@@ -2364,7 +2406,6 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
             };
 
             auto emitRange = [&](char const* ty) {
-                synthesiser.currentClass->addInclude("\"souffle/utility/EvaluatorUtil.h\"", true);
                 return emitHelper(tfm::format("souffle::evaluator::runRange<%s>", ty));
             };
 
@@ -2383,7 +2424,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
 
             auto args = op.getArguments();
             if (op.isStateful()) {
-                out << name << "(&symTable, &recordTable";
+                out << "functors::" << name << "(&symTable, &recordTable";
                 for (auto& arg : args) {
                     out << ",";
                     dispatch(*arg, out);
@@ -2395,7 +2436,7 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
                 if (op.getReturnType() == TypeAttribute::Symbol) {
                     out << "symTable.encode(";
                 }
-                out << name << "(";
+                out << "functors::" << name << "(";
 
                 for (std::size_t i = 0; i < args.size(); i++) {
                     if (i > 0) {
@@ -2493,39 +2534,58 @@ void Synthesiser::emitCode(std::ostream& out, const Statement& stmt) {
     CodeEmitter(*this).dispatch(stmt, out);
 }
 
-std::set<std::string> Synthesiser::accessedRelations(Statement& stmt) {
-    std::set<std::string> accessed;
-    visit(stmt, [&](const Insert& node) { accessed.insert(node.getRelation()); });
-    visit(stmt, [&](const RelationOperation& node) { accessed.insert(node.getRelation()); });
-    visit(stmt, [&](const RelationStatement& node) { accessed.insert(node.getRelation()); });
-    visit(stmt, [&](const AbstractExistenceCheck& node) { accessed.insert(node.getRelation()); });
-    visit(stmt, [&](const EmptinessCheck& node) { accessed.insert(node.getRelation()); });
-    visit(stmt, [&](const RelationSize& node) { accessed.insert(node.getRelation()); });
-    visit(stmt, [&](const BinRelationStatement& node) {
-        accessed.insert(node.getFirstRelation());
-        accessed.insert(node.getSecondRelation());
-    });
-    return accessed;
-}
+/** An output stream where some pieces may be filled later or conditionnaly. */
+class DelayableOutputStream : public std::streambuf, public std::ostream {
+public:
+    DelayableOutputStream() : std::ostream(this) {}
 
-std::set<std::string> Synthesiser::accessedUserDefinedFunctors(Statement& stmt) {
-    std::set<std::string> accessed;
-    visit(stmt, [&](const UserDefinedOperator& node) {
-        const std::string& name = node.getName();
-        accessed.insert(name);
-    });
-    auto visitAggregate = [&](const AbstractAggregate& op) {
-        const Aggregator& aggregator = op.getAggregator();
-        if (const auto* uda = as<UserDefinedAggregator>(aggregator)) {
-            accessed.insert(uda->getName());
+    ~DelayableOutputStream() {}
+
+    std::streambuf::int_type overflow(std::streambuf::int_type ch) override {
+        if (!current_stream) {
+            pieces.emplace_back(std::nullopt, std::make_shared<std::stringstream>());
+            current_stream = pieces.back().second;
         }
-    };
-    visit(stmt, [&](const Aggregate& op) { visitAggregate(op); });
-    visit(stmt, [&](const IndexAggregate& op) { visitAggregate(op); });
-    return accessed;
+        current_stream->put(ch);
+        return ch;
+    }
+
+    /** Return a piece of stream that will be included in the output only if the given condition is true when
+     * this stream is flushed. */
+    std::shared_ptr<std::ostream> delayed_if(const bool& cond) {
+        current_stream.reset();
+        pieces.emplace_back(&cond, std::make_shared<std::stringstream>());
+        return pieces.back().second;
+    }
+
+    /** Return a piece of stream that will be included in the output when this stream is flushed. */
+    std::shared_ptr<std::ostream> delayed() {
+        current_stream.reset();
+        pieces.emplace_back(std::nullopt, std::make_shared<std::stringstream>());
+        return pieces.back().second;
+    }
+
+    /** */
+    void flushAll(std::ostream& os) {
+        current_stream.reset();
+        while (!pieces.empty()) {
+            auto& piece = pieces.front();
+            if ((!piece.first) || **piece.first) {
+                os << piece.second->str();
+            }
+            pieces.pop_front();
+        }
+    }
+
+private:
+    /* the sequence of pieces that compose the output stream. */
+    std::list<std::pair<std::optional<const bool*>, std::shared_ptr<std::stringstream>>> pieces;
+
+    /* points to the current piece's stream. */
+    std::shared_ptr<std::ostream> current_stream;
 };
 
-void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withSharedLibrary) {
+void Synthesiser::generateCode(std::ostream& sos, const std::string& id, bool& withSharedLibrary) {
     // ---------------------------------------------------------------
     //                      Auto-Index Generation
     // ---------------------------------------------------------------
@@ -2535,43 +2595,40 @@ void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withShare
     //                      Code Generation
     // ---------------------------------------------------------------
 
+    DelayableOutputStream os;
+
     withSharedLibrary = false;
 
     std::string classname = "Sf_" + id;
 
     // generate C++ program
-    std::string package_gen_version = "SOUFFLE_GENERATOR_VERSION \"";
-    package_gen_version += PACKAGE_VERSION;
-    package_gen_version += "\"";
-    db.addGlobalDefine(package_gen_version);
-
-    if (glb.config().has("verbose")) {
-        db.addGlobalDefine("_SOUFFLE_STATS");
-        db.addGlobalInclude("\"souffle/profile/ProfileEvent.h\"");
-    }
 
-    if (glb.config().has("provenance")) {
-        db.addGlobalInclude("<mutex>");
-        db.addGlobalInclude("\"souffle/provenance/Explain.h\"");
+    if (Global::config().has("verbose")) {
+        os << "#define _SOUFFLE_STATS\n";
+        os << "#include \"souffle/profile/ProfileEvent.h\"";
+    }
+    os << "\n#include \"souffle/CompiledSouffle.h\"\n";
+    if (Global::config().has("provenance")) {
+        os << "#include <mutex>\n";
+        os << "#include \"souffle/provenance/Explain.h\"\n";
     }
 
-    if (glb.config().has("live-profile")) {
-        db.addGlobalInclude("<thread>");
-        db.addGlobalInclude("\"souffle/profile/Tui.h\"");
+    if (Global::config().has("live-profile")) {
+        os << "#include <thread>\n";
+        os << "#include \"souffle/profile/Tui.h\"\n";
     }
 
-    db.addGlobalInclude("\"souffle/utility/MiscUtil.h\"");
-    if (glb.config().has("profile") || glb.config().has("live-profile")) {
-        db.addGlobalInclude("\"souffle/profile/Logger.h\"");
-        db.addGlobalInclude("\"souffle/profile/ProfileEvent.h\"");
+    {
+        auto _os = os.delayed_if(UsingStdRegex);
+        *_os << "#include <regex>\n";
     }
 
-    if (glb.config().has("generate-namespace")) {
-        db.setNS(glb.config().get("generate-namespace"));
-    } else {
-        db.setNS("souffle");
+    if (Global::config().has("profile") || Global::config().has("live-profile")) {
+        os << "#include \"souffle/profile/Logger.h\"\n";
+        os << "#include \"souffle/profile/ProfileEvent.h\"\n";
     }
 
+    os << "\n";
     // produce external definitions for user-defined functors
     std::map<std::string, std::tuple<TypeAttribute, std::vector<TypeAttribute>, bool>> functors;
     visit(prog, [&](const UserDefinedOperator& op) {
@@ -2580,18 +2637,9 @@ void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withShare
         }
         withSharedLibrary = true;
     });
-    auto visitAggregate = [&](const AbstractAggregate& op) {
-        const Aggregator& aggregator = op.getAggregator();
-        if (const auto* uda = as<UserDefinedAggregator>(aggregator)) {
-            functors[uda->getName()] =
-                    std::make_tuple(uda->getReturnType(), uda->getArgsTypes(), uda->isStateful());
-            withSharedLibrary = true;
-        }
-    };
-    visit(prog, [&](const Aggregate& op) { visitAggregate(op); });
-    visit(prog, [&](const IndexAggregate& op) { visitAggregate(op); });
-
+    os << "namespace functors {\n extern \"C\" {\n";
     for (const auto& f : functors) {
+        //        std::size_t arity = f.second.length() - 1;
         const std::string& name = f.first;
 
         const auto& functorTypes = f.second;
@@ -2612,272 +2660,135 @@ void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withShare
             UNREACHABLE_BAD_CASE_ANALYSIS
         };
 
-        std::vector<std::string> argsTy;
-        std::string retTy;
         if (stateful) {
-            retTy = "souffle::RamDomain";
-            argsTy.push_back("souffle::SymbolTable*");
-            argsTy.push_back("souffle::RecordTable*");
+            os << "souffle::RamDomain " << name << "(souffle::SymbolTable *, souffle::RecordTable *";
             for (std::size_t i = 0; i < argsTypes.size(); i++) {
-                argsTy.push_back("souffle::RamDomain");
+                os << ",souffle::RamDomain";
             }
+            os << ");\n";
         } else {
-            retTy = cppTypeDecl(returnType);
-            for (auto ty : argsTypes) {
-                argsTy.push_back(cppTypeDecl(ty));
-            }
+            tfm::format(os, "%s %s(%s);\n", cppTypeDecl(returnType), name,
+                    join(map(argsTypes, cppTypeDecl), ","));
         }
-        functor_signatures[name] = std::make_pair(argsTy, retTy);
-        auto extern_decl = [&](std::ostream& os) {
-            os << retTy << " " << name << "("
-               << join(argsTy, ", ", [&](auto& out, const std::string ty) { out << ty; }) << ");\n";
-        };
-
-        extern_decl(db.externC());
     }
-
-    // main class
-    GenClass& mainClass = db.getClass(classname, fs::path(classname));
-    mainClass.inherits("public SouffleProgram");
-    mainClass.addInclude("\"souffle/CompiledSouffle.h\"");
-    mainClass.addInclude("<any>");
-    mainClass.isMain = true;
-
-    auto function_ty = [&](std::string name) -> std::string {
-        auto [argsTy, retTy] = functor_signatures[name];
-        std::stringstream os;
-        os << "std::function<" << retTy << "("
-           << join(argsTy, ", ", [&](auto& out, const std::string ty) { out << ty; }) << ")>";
-        return os.str();
-    };
-    auto functors_initialize = [&](std::ostream& os, std::string name) {
-        auto [argsTy, retTy] = functor_signatures[name];
-        os << name << " = functors::" << name << ";\n";
-    };
-
-    std::map<std::string, std::string> relationTypes;
+    os << "}\n}\n";
+    os << "\n";
+    os << "namespace souffle {\n";
+    os << "static const RamDomain RAM_BIT_SHIFT_MASK = RAM_DOMAIN_SIZE - 1;\n";
 
     // synthesise data-structures for relations
     for (auto rel : prog.getRelations()) {
         auto relationType =
                 Relation::getSynthesiserRelation(*rel, idxAnalysis.getIndexSelection(rel->getName()));
 
-        std::string typeName = relationType->getTypeName();
-        generateRelationTypeStruct(db, std::move(relationType));
-
-        relationTypes[getRelationName(*rel)] = typeName;
-
-        db.usesDatastructure(mainClass, typeName);
+        generateRelationTypeStruct(os, std::move(relationType));
+    }
+    os << '\n';
+
+    os << "class " << classname << " : public SouffleProgram {\n";
+
+    {
+        // regex wrapper
+        auto osp = os.delayed_if(UsingStdRegex);
+        auto& _os = *osp;
+        _os << "private:\n";
+        _os << "static inline bool regex_wrapper(const std::string& pattern, const std::string& text) {\n";
+        _os << "   bool result = false; \n";
+        _os << "   try { result = std::regex_match(text, std::regex(pattern)); } catch(...) { \n";
+        _os << "     std::cerr << \"warning: wrong pattern provided for match(\\\"\" << pattern << "
+               "\"\\\",\\\"\" "
+               "<< text << \"\\\").\\n\";\n}\n";
+        _os << "   return result;\n";
+        _os << "}\n";
     }
 
-    std::set<std::string> loadRelations;
-    std::set<const IO*> loadIOs;
-    std::set<const IO*> storeIOs;
-
-    // collect load/store operations/relations
-    visit(prog, [&](const IO& io) {
-        auto op = io.get("operation");
-        if (op == "input") {
-            loadRelations.insert(io.getRelation());
-            loadIOs.insert(&io);
-        } else if (op == "printsize" || op == "output") {
-            storeRelations.insert(io.getRelation());
-            storeIOs.insert(&io);
-        } else {
-            assert("wrong I/O operation");
-        }
-    });
-
-    // identify relations used by each subroutines
-    std::multimap<std::string /* stratum_* */, std::string> subroutineUses;
-
-    // generate class for each subroutine
-    std::vector<std::pair<std::string, std::string>> subroutineInits;
-    for (auto& sub : prog.getSubroutines()) {
-        GenClass& gen = db.getClass(convertStratumIdent("Stratum_" + sub.first),
-                fs::path(convertStratumIdent("Stratum_" + sub.first)));
-        mainClass.addDependency(gen);
-
-        auto accessedRels = accessedRelations(*sub.second);
-        auto accessedFunctors = accessedUserDefinedFunctors(*sub.second);
-
-        gen.addInclude("\"souffle/SouffleInterface.h\"");
-        gen.addInclude("\"souffle/SignalHandler.h\"");
-
-        GenFunction& constructor = gen.addConstructor(Visibility::Public);
-
-        enum Mode { Reference, Relation };
-        std::vector<std::tuple<Mode, std::string /*name*/, std::string /*type*/>> args;
-        args.push_back(std::make_tuple(Reference, "symTable", "SymbolTable"));
-        args.push_back(std::make_tuple(Reference, "recordTable", "RecordTable"));
-        args.push_back(std::make_tuple(Reference, "regexCache", "ConcurrentCache<std::string,std::regex>"));
-        args.push_back(std::make_tuple(Reference, "pruneImdtRels", "bool"));
-        args.push_back(std::make_tuple(Reference, "performIO", "bool"));
-        args.push_back(std::make_tuple(Reference, "signalHandler", "SignalHandler*"));
-        args.push_back(std::make_tuple(Reference, "iter", "std::atomic<std::size_t>"));
-        args.push_back(std::make_tuple(Reference, "ctr", "std::atomic<RamDomain>"));
-        args.push_back(std::make_tuple(Reference, "inputDirectory", "std::string"));
-        args.push_back(std::make_tuple(Reference, "outputDirectory", "std::string"));
-        for (std::string rel : accessedRels) {
-            std::string name = getRelationName(lookup(rel));
-            std::string tyname = relationTypes[name];
-            args.push_back(std::make_tuple(Relation, name, tyname));
-            db.usesDatastructure(gen, tyname);
-        }
-        for (std::string fn : accessedFunctors) {
-            args.push_back(std::make_tuple(Reference, fn, function_ty(fn)));
-        }
-
-        for (auto arg : args) {
-            Mode kind;
-            std::string name, ty;
-            std::tie(kind, name, ty) = arg;
-            constructor.setNextArg(ty + std::string("&"), name);
-
-            constructor.setNextInitializer(
-                    name, (kind == Relation ? std::string("&") : std::string("")) + name);
-
-            gen.addField(ty + (kind == Relation ? "*" : "&"), name, Visibility::Private);
-        }
-        std::stringstream initStr;
-        initStr << join(args, ",", [&](auto& out, const auto arg) {
-            Mode kind;
-            std::string name, ty;
-            std::tie(kind, name, ty) = arg;
-            out << (kind == Relation ? "*" : "") << name;
-        });
-        subroutineInits.push_back(std::make_pair(sub.first, initStr.str()));
-
-        GenFunction& run = gen.addFunction("run", Visibility::Public);
-        run.setRetType("void");
-        run.setNextArg("[[maybe_unused]] const std::vector<RamDomain>&", "args");
-        run.setNextArg("[[maybe_unused]] std::vector<RamDomain>&", "ret");
-
-        bool needLock = false;
-        visit(*sub.second, [&](const SubroutineReturn&) { needLock = true; });
-        if (needLock) {
-            run.body() << "std::mutex lock;\n";
-        }
-        SubroutineUsingStdRegex = false;
-        SubroutineUsingSubstr = false;
-        // emit code for subroutine
-        currentClass = &gen;
-        emitCode(run.body(), *sub.second);
-        // issue end of subroutine
-        UsingStdRegex |= SubroutineUsingStdRegex;
-
-        if (SubroutineUsingStdRegex) {
-            // regex wrapper
-            GenFunction& wrapper = gen.addFunction("regex_wrapper", Visibility::Private);
-            wrapper.setRetType("inline bool");
-            wrapper.setNextArg("const std::string&", "pattern");
-            wrapper.setNextArg("const std::string&", "text");
-            wrapper.body()
-                    << "   bool result = false; \n"
-                    << "   try { result = std::regex_match(text, regexCache.getOrCreate(pattern)); } "
-                       "catch(...) { "
-                       "\n"
-                    << "     std::cerr << \"warning: wrong pattern provided for match(\\\"\" << pattern << "
-                       "\"\\\",\\\"\" "
-                       "<< text << \"\\\").\\n\";\n}\n"
-                    << "   return result;\n";
-        }
-
-        if (!regexes.empty()) {
-            gen.addField("std::vector<std::regex>", "regexes", Visibility::Private);
-            std::stringstream rst;
-            // we need to collect the patterns first and place each
-            // one into the correct slot
-            std::vector<std::string> patterns;
-            patterns.resize(regexes.size());
-            for (const auto& pi : regexes) {
-                patterns.at(pi.second) = pi.first;
-            }
-            rst << "{\n";
-            for (const auto& p : patterns) {
-                const std::string escaped = escape(p);
-                rst << "\tstd::regex(\"" << escaped << "\"),\n";
-            }
-            rst << "}";
-
-            constructor.setNextInitializer("regexes", rst.str());
-            regexes.clear();
-        }
-
-        // substring wrapper
-        if (SubroutineUsingSubstr) {
-            GenFunction& wrapper = gen.addFunction("substr_wrapper", Visibility::Private);
-            wrapper.setRetType("inline std::string");
-            wrapper.setNextArg("const std::string&", "str");
-            wrapper.setNextArg("std::size_t", "idx");
-            wrapper.setNextArg("std::size_t", "len");
-            wrapper.body() << "std::string result; \n"
-                           << "try { result = str.substr(idx,len); } catch(std::out_of_range&) { \n"
-                           << "  std::cerr << \"warning: wrong index position provided by substr(\\\"\";\n"
-                           << "  std::cerr << str << \"\\\",\" << (int32_t)idx << \",\" << (int32_t)len << "
-                              "\") functor.\\n\";\n"
-                           << "} return result;\n";
-        }
+    // substring wrapper
+    os << "private:\n";
+    os << "static inline std::string substr_wrapper(const std::string& str, std::size_t idx, "
+          "std::size_t "
+          "len) {\n";
+    os << "   std::string result; \n";
+    os << "   try { result = str.substr(idx,len); } catch(...) { \n";
+    os << "     std::cerr << \"warning: wrong index position provided by substr(\\\"\";\n";
+    os << "     std::cerr << str << \"\\\",\" << (int32_t)idx << \",\" << (int32_t)len << \") "
+          "functor.\\n\";\n";
+    os << "   } return result;\n";
+    os << "}\n";
+
+    if (Global::config().has("profile")) {
+        os << "std::string profiling_fname;\n";
     }
 
-    GenFunction& constructor = mainClass.addConstructor(Visibility::Public);
-    constructor.setIsConstructor();
+    os << "public:\n";
 
-    if (glb.config().has("profile")) {
-        mainClass.addField("std::string", "profiling_fname", Visibility::Public);
-        constructor.setNextArg("std::string", "pf", std::make_optional("\"profile.log\""));
-        constructor.setNextInitializer("profiling_fname", "std::move(pf)");
-    }
+    // declare symbol table
+    os << "// -- initialize symbol table --\n";
 
     // issue symbol table with string constants
     visit(prog, [&](const StringConstant& sc) { convertSymbol2Idx(sc.getConstant()); });
-    std::stringstream st;
+    os << "SymbolTableImpl symTable";
     if (!symbolMap.empty()) {
-        st << "{\n";
+        os << "{\n";
         for (const auto& x : symbolIndex) {
-            st << "\tR\"_(" << x << ")_\",\n";
+            os << "\tR\"_(" << x << ")_\",\n";
         }
-        st << "}";
+        os << "}";
     }
-    mainClass.addField("SymbolTableImpl", "symTable", Visibility::Private);
-    constructor.setNextInitializer("symTable", st.str());
+    os << ";";
 
     // declare record table
-    std::stringstream rt;
-    rt << "SpecializedRecordTable<0";
-    for (std::size_t arity : arities) {
-        if (arity > 0) {
-            rt << "," << arity;
-        }
-    }
-    rt << ">";
-    mainClass.addField(rt.str(), "recordTable", Visibility::Private);
-    constructor.setNextInitializer("recordTable", "");
+    os << "// -- initialize record table --\n";
 
-    mainClass.addField("ConcurrentCache<std::string,std::regex>", "regexCache", Visibility::Private);
-    constructor.setNextInitializer("regexCache", "");
+    auto recordTable_os = os.delayed();
 
-    if (glb.config().has("profile")) {
+    if (Global::config().has("profile")) {
+        os << "private:\n";
         std::size_t numFreq = 0;
         visit(prog, [&](const Statement&) { numFreq++; });
-        mainClass.addField("std::size_t", "freqs[" + std::to_string(numFreq) + "]", Visibility::Private);
-        constructor.setNextInitializer("freqs", "");
+        os << "  std::size_t freqs[" << numFreq << "]{};\n";
         std::size_t numRead = 0;
         for (auto rel : prog.getRelations()) {
             if (!rel->isTemp()) {
                 numRead++;
             }
         }
-        mainClass.addField("std::size_t", "reads[" + std::to_string(numRead) + "]", Visibility::Private);
-        constructor.setNextInitializer("reads", "");
+        os << "  std::size_t reads[" << numRead << "]{};\n";
     }
 
-    for (const auto& f : functors) {
-        const std::string& name = f.first;
-        mainClass.addField(function_ty(name), name, Visibility::Private);
+    // print relation definitions
+    std::stringstream initCons;     // initialization of constructor
+    std::stringstream registerRel;  // registration of relations
+    auto initConsSep = [&, empty = true]() mutable -> std::stringstream& {
+        initCons << (empty ? "\n: " : "\n, ");
+        empty = false;
+        return initCons;
+    };
+
+    // `pf` must be a ctor param (see below)
+    if (Global::config().has("profile")) {
+        initConsSep() << "profiling_fname(std::move(pf))";
     }
 
     int relCtr = 0;
+    std::set<std::string> storeRelations;
+    std::set<std::string> loadRelations;
+    std::set<const IO*> loadIOs;
+    std::set<const IO*> storeIOs;
+
+    // collect load/store operations/relations
+    visit(prog, [&](const IO& io) {
+        auto op = io.get("operation");
+        if (op == "input") {
+            loadRelations.insert(io.getRelation());
+            loadIOs.insert(&io);
+        } else if (op == "printsize" || op == "output") {
+            storeRelations.insert(io.getRelation());
+            storeIOs.insert(&io);
+        } else {
+            assert("wrong I/O operation");
+        }
+    });
+
     for (auto rel : prog.getRelations()) {
         // get some table details
         const std::string& datalogName = rel->getName();
@@ -2888,12 +2799,11 @@ void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withShare
         const std::string& type = relationType->getTypeName();
 
         // defining table
-        mainClass.addField("Own<" + type + ">", cppName, Visibility::Private);
-        constructor.setNextInitializer(cppName, "mk<" + type + ">()");
+        os << "// -- Table: " << datalogName << "\n";
+
+        os << "Own<" << type << "> " << cppName << " = mk<" << type << ">();\n";
         if (!rel->isTemp()) {
-            std::stringstream ty, init, wrapper_name;
-            ty << "souffle::RelationWrapper<" << type << ">";
-            wrapper_name << "wrapper_" << cppName;
+            tfm::format(os, "souffle::RelationWrapper<%s> wrapper_%s;\n", type, cppName);
 
             auto strLitAry = [](auto&& xs) {
                 std::stringstream ss;
@@ -2904,60 +2814,52 @@ void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withShare
 
             auto foundIn = [&](auto&& set) { return contains(set, rel->getName()) ? "true" : "false"; };
 
-            init << relCtr++ << ", *" << cppName << ", *this, \"" << datalogName << "\", "
-                 << strLitAry(rel->getAttributeTypes()) << ", " << strLitAry(rel->getAttributeNames()) << ", "
-                 << rel->getAuxiliaryArity();
-            constructor.body() << "addRelation(\"" << datalogName << "\", wrapper_" << cppName << ", "
-                               << foundIn(loadRelations) << ", " << foundIn(storeRelations) << ");\n";
-
-            mainClass.addField(ty.str(), wrapper_name.str(), Visibility::Private);
-            constructor.setNextInitializer(wrapper_name.str(), init.str());
+            tfm::format(initConsSep(), "wrapper_%s(%s, *%s, *this, \"%s\", %s, %s, %s)", cppName, relCtr++,
+                    cppName, datalogName, strLitAry(rel->getAttributeTypes()),
+                    strLitAry(rel->getAttributeNames()), rel->getAuxiliaryArity());
+            tfm::format(registerRel, "addRelation(\"%s\", wrapper_%s, %s, %s);\n", datalogName, cppName,
+                    foundIn(loadRelations), foundIn(storeRelations));
         }
     }
+    os << "public:\n";
 
-    for (auto [name, value] : subroutineInits) {
-        std::string clName = convertStratumIdent("Stratum_" + name);
-        std::string fName = convertStratumIdent("stratum_" + name);
-        mainClass.addField(clName, fName, Visibility::Private);
-        constructor.setNextInitializer(fName, value);
-    }
-
-    if (glb.config().has("profile")) {
-        constructor.body() << "ProfileEventSingleton::instance().setOutputFile(profiling_fname);\n";
-    }
+    // -- constructor --
 
-    for (const auto& f : functors) {
-        const std::string& name = f.first;
-        functors_initialize(constructor.body(), name);
+    os << classname;
+    os << (Global::config().has("profile") ? "(std::string pf=\"profile.log\")" : "()");
+    os << initCons.str() << '\n';
+    os << "{\n";
+    if (Global::config().has("profile")) {
+        os << "ProfileEventSingleton::instance().setOutputFile(profiling_fname);\n";
     }
-
+    os << registerRel.str();
+    os << "}\n";
     // -- destructor --
-    GenFunction& destructor = mainClass.addFunction("~" + classname, Visibility::Public);
-    destructor.setIsConstructor();
+
+    os << "~" << classname << "() {\n";
+    os << "}\n";
 
     // issue state variables for the evaluation
     //
     // Improve compile time by storing the signal handler in one loc instead of
     // emitting thousands of `SignalHandler::instance()`. The volume of calls
     // makes GVN and register alloc very expensive, even if the call is inlined.
-    mainClass.addField("std::string", "inputDirectory", Visibility::Private);
-    mainClass.addField("std::string", "outputDirectory", Visibility::Private);
-    mainClass.addField("SignalHandler*", "signalHandler", Visibility::Private, "{SignalHandler::instance()}");
-    mainClass.addField("std::atomic<RamDomain>", "ctr", Visibility::Private, "{}");
-    mainClass.addField("std::atomic<std::size_t>", "iter", Visibility::Private, "{}");
-
-    GenFunction& runFunction = mainClass.addFunction("runFunction", Visibility::Private);
-    runFunction.setRetType("void");
-    runFunction.setNextArg("std::string", "inputDirectoryArg");
-    runFunction.setNextArg("std::string", "outputDirectoryArg");
-    runFunction.setNextArg("bool", "performIOArg");
-    runFunction.setNextArg("bool", "pruneImdtRelsArg");
-
-    runFunction.body() << R"_(
+    os << R"_(
+private:
+std::string             inputDirectory;
+std::string             outputDirectory;
+SignalHandler*          signalHandler {SignalHandler::instance()};
+std::atomic<RamDomain>  ctr {};
+std::atomic<std::size_t>     iter {};
+
+void runFunction(std::string  inputDirectoryArg,
+                 std::string  outputDirectoryArg,
+                 bool         performIOArg,
+                 bool         pruneImdtRelsArg) {
     this->inputDirectory  = std::move(inputDirectoryArg);
     this->outputDirectory = std::move(outputDirectoryArg);
     this->performIO       = performIOArg;
-    this->pruneImdtRels   = pruneImdtRelsArg;
+    this->pruneImdtRels   = pruneImdtRelsArg; 
 
     // set default threads (in embedded mode)
     // if this is not set, and omp is used, the default omp setting of number of cores is used.
@@ -2967,18 +2869,17 @@ void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withShare
 
     signalHandler->set();
 )_";
-    if (glb.config().has("verbose")) {
-        runFunction.body() << "signalHandler->enableLogging();\n";
+    if (Global::config().has("verbose")) {
+        os << "signalHandler->enableLogging();\n";
     }
 
     // add actual program body
-    runFunction.body() << "// -- query evaluation --\n";
-    if (glb.config().has("profile")) {
-        runFunction.body() << "ProfileEventSingleton::instance().startTimer();\n"
-                           << R"_(ProfileEventSingleton::instance().makeTimeEvent("@time;starttime");)_"
-                           << '\n'
-                           << "{\n"
-                           << R"_(Logger logger("@runtime;", 0);)_" << '\n';
+    os << "// -- query evaluation --\n";
+    if (Global::config().has("profile")) {
+        os << "ProfileEventSingleton::instance().startTimer();\n";
+        os << R"_(ProfileEventSingleton::instance().makeTimeEvent("@time;starttime");)_" << '\n';
+        os << "{\n"
+           << R"_(Logger logger("@runtime;", 0);)_" << '\n';
         // Store count of relations
         std::size_t relationCount = 0;
         for (auto rel : prog.getRelations()) {
@@ -2987,117 +2888,107 @@ void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withShare
             }
         }
         // Store configuration
-        runFunction.body()
-                << R"_(ProfileEventSingleton::instance().makeConfigRecord("relationCount", std::to_string()_"
-                << relationCount << "));";
+        os << R"_(ProfileEventSingleton::instance().makeConfigRecord("relationCount", std::to_string()_"
+           << relationCount << "));";
     }
 
     // emit code
-    currentClass = &mainClass;
-    emitCode(runFunction.body(), prog.getMain());
+    emitCode(os, prog.getMain());
 
-    if (glb.config().has("profile")) {
-        runFunction.body() << "}\n"
-                           << "ProfileEventSingleton::instance().stopTimer();\n"
-                           << "dumpFreqs();\n";
+    if (Global::config().has("profile")) {
+        os << "}\n";
+        os << "ProfileEventSingleton::instance().stopTimer();\n";
+        os << "dumpFreqs();\n";
     }
 
     // add code printing hint statistics
-    runFunction.body() << "\n// -- relation hint statistics --\n";
+    os << "\n// -- relation hint statistics --\n";
 
-    if (glb.config().has("verbose")) {
+    if (Global::config().has("verbose")) {
         for (auto rel : prog.getRelations()) {
             auto name = getRelationName(*rel);
-            runFunction.body() << "std::cout << \"Statistics for Relation " << name << ":\\n\";\n"
-                               << name << "->printStatistics(std::cout);\n"
-                               << "std::cout << \"\\n\";\n";
+            os << "std::cout << \"Statistics for Relation " << name << ":\\n\";\n";
+            os << name << "->printStatistics(std::cout);\n";
+            os << "std::cout << \"\\n\";\n";
         }
     }
 
-    runFunction.body() << "signalHandler->reset();\n";
+    os << "signalHandler->reset();\n";
+
+    os << "}\n";  // end of runFunction() method
 
     // add methods to run with and without performing IO (mainly for the interface)
-    GenFunction& run = mainClass.addFunction("run", Visibility::Public);
-    run.setOverride();
-    run.setRetType("void");
-    run.body() << "runFunction(\"\", \"\", false, false);\n";
-
-    GenFunction& runAll = mainClass.addFunction("runAll", Visibility::Public);
-    runAll.setOverride();
-    runAll.setRetType("void");
-    runAll.setNextArg("std::string", "inputDirectoryArg", std::make_optional("\"\""));
-    runAll.setNextArg("std::string", "outputDirectoryArg", std::make_optional("\"\""));
-    runAll.setNextArg("bool", "performIOArg", std::make_optional("true"));
-    runAll.setNextArg("bool", "pruneImdtRelsArg", std::make_optional("true"));
-    if (glb.config().has("live-profile")) {
-        runAll.body() << "std::thread profiler([]() { profile::Tui().runProf(); });\n";
+    os << "public:\nvoid run() override { runFunction(\"\", \"\", "
+          "false, false); }\n";
+    os << "public:\nvoid runAll(std::string inputDirectoryArg = \"\", std::string outputDirectoryArg = \"\", "
+          "bool performIOArg=true, bool pruneImdtRelsArg=true) override { ";
+    if (Global::config().has("live-profile")) {
+        os << "std::thread profiler([]() { profile::Tui().runProf(); });\n";
     }
-    runAll.body() << "runFunction(inputDirectoryArg, outputDirectoryArg, performIOArg, pruneImdtRelsArg);\n";
-    if (glb.config().has("live-profile")) {
-        runAll.body() << "if (profiler.joinable()) { profiler.join(); }\n";
+    os << "runFunction(inputDirectoryArg, outputDirectoryArg, performIOArg, pruneImdtRelsArg);\n";
+    if (Global::config().has("live-profile")) {
+        os << "if (profiler.joinable()) { profiler.join(); }\n";
     }
-
+    os << "}\n";
     // issue printAll method
-    GenFunction& printAll = mainClass.addFunction("printAll", Visibility::Public);
-    printAll.setOverride();
-    printAll.setRetType("void");
-    printAll.setNextArg("[[maybe_unused]] std::string", "outputDirectoryArg", std::make_optional("\"\""));
+    os << "public:\n";
+    os << "void printAll(std::string outputDirectoryArg = \"\") override {\n";
 
     // print directives as C++ initializers
-    auto printDirectives = [&](std::ostream& o, const std::map<std::string, std::string>& registry) {
+    auto printDirectives = [&](const std::map<std::string, std::string>& registry) {
         auto cur = registry.begin();
         if (cur == registry.end()) {
             return;
         }
-        o << "{{\"" << cur->first << "\",\"" << escape(cur->second) << "\"}";
+        os << "{{\"" << cur->first << "\",\"" << escape(cur->second) << "\"}";
         ++cur;
         for (; cur != registry.end(); ++cur) {
-            o << ",{\"" << cur->first << "\",\"" << escape(cur->second) << "\"}";
+            os << ",{\"" << cur->first << "\",\"" << escape(cur->second) << "\"}";
         }
-        o << '}';
+        os << '}';
     };
 
     for (auto store : storeIOs) {
         auto const& directive = store->getDirectives();
-        printAll.body() << "try {";
-        printAll.body() << "std::map<std::string, std::string> directiveMap(";
-        printDirectives(printAll.body(), directive);
-        printAll.body() << ");\n";
-        printAll.body() << R"_(if (!outputDirectoryArg.empty()) {)_";
-        printAll.body() << R"_(directiveMap["output-dir"] = outputDirectoryArg;)_";
-        printAll.body() << "}\n";
-        printAll.body() << "IOSystem::getInstance().getWriter(";
-        printAll.body() << "directiveMap, symTable, recordTable";
-        printAll.body() << ")->writeAll(*" << getRelationName(lookup(store->getRelation())) << ");\n";
-
-        printAll.body() << "} catch (std::exception& e) {std::cerr << e.what();exit(1);}\n";
+        os << "try {";
+        os << "std::map<std::string, std::string> directiveMap(";
+        printDirectives(directive);
+        os << ");\n";
+        os << R"_(if (!outputDirectoryArg.empty()) {)_";
+        os << R"_(directiveMap["output-dir"] = outputDirectoryArg;)_";
+        os << "}\n";
+        os << "IOSystem::getInstance().getWriter(";
+        os << "directiveMap, symTable, recordTable";
+        os << ")->writeAll(*" << getRelationName(lookup(store->getRelation())) << ");\n";
+
+        os << "} catch (std::exception& e) {std::cerr << e.what();exit(1);}\n";
     }
+    os << "}\n";  // end of printAll() method
 
     // issue loadAll method
-    GenFunction& loadAll = mainClass.addFunction("loadAll", Visibility::Public);
-    loadAll.setOverride();
-    loadAll.setRetType("void");
-    loadAll.setNextArg("[[maybe_unused]] std::string", "inputDirectoryArg", std::make_optional("\"\""));
+    os << "public:\n";
+    os << "void loadAll(std::string inputDirectoryArg = \"\") override {\n";
 
     for (auto load : loadIOs) {
-        loadAll.body() << "try {";
-        loadAll.body() << "std::map<std::string, std::string> directiveMap(";
-        printDirectives(loadAll.body(), load->getDirectives());
-        loadAll.body() << ");\n";
-        loadAll.body() << R"_(if (!inputDirectoryArg.empty()) {)_";
-        loadAll.body() << R"_(directiveMap["fact-dir"] = inputDirectoryArg;)_";
-        loadAll.body() << "}\n";
-        loadAll.body() << "IOSystem::getInstance().getReader(";
-        loadAll.body() << "directiveMap, symTable, recordTable";
-        loadAll.body() << ")->readAll(*" << getRelationName(lookup(load->getRelation()));
-        loadAll.body() << ");\n";
-        loadAll.body() << "} catch (std::exception& e) {std::cerr << \"Error loading " << load->getRelation()
-                       << " data: \" << e.what() << "
-                          "'\\n';\nexit(1);\n}\n";
+        os << "try {";
+        os << "std::map<std::string, std::string> directiveMap(";
+        printDirectives(load->getDirectives());
+        os << ");\n";
+        os << R"_(if (!inputDirectoryArg.empty()) {)_";
+        os << R"_(directiveMap["fact-dir"] = inputDirectoryArg;)_";
+        os << "}\n";
+        os << "IOSystem::getInstance().getReader(";
+        os << "directiveMap, symTable, recordTable";
+        os << ")->readAll(*" << getRelationName(lookup(load->getRelation()));
+        os << ");\n";
+        os << "} catch (std::exception& e) {std::cerr << \"Error loading " << load->getRelation()
+           << " data: \" << e.what() << "
+              "'\\n';}\n";
     }
 
+    os << "}\n";  // end of loadAll() method
     // issue dump methods
-    auto dumpRelation = [&](std::ostream& os, const ram::Relation& ramRelation) {
+    auto dumpRelation = [&](const ram::Relation& ramRelation) {
         const auto& relName = getRelationName(ramRelation);
         const auto& name = ramRelation.getName();
         const auto& attributesTypes = ramRelation.getAttributeTypes();
@@ -3122,165 +3013,188 @@ void Synthesiser::generateCode(GenDb& db, const std::string& id, bool& withShare
     };
 
     // dump inputs
-    GenFunction& dumpInputs = mainClass.addFunction("dumpInputs", Visibility::Public);
-    dumpInputs.setOverride();
-    dumpInputs.setRetType("void");
+    os << "public:\n";
+    os << "void dumpInputs() override {\n";
     for (auto load : loadIOs) {
-        dumpRelation(dumpInputs.body(), *lookup(load->getRelation()));
+        dumpRelation(*lookup(load->getRelation()));
     }
+    os << "}\n";  // end of dumpInputs() method
 
     // dump outputs
-    GenFunction& dumpOutputs = mainClass.addFunction("dumpOutputs", Visibility::Public);
-    dumpOutputs.setOverride();
-    dumpOutputs.setRetType("void");
+    os << "public:\n";
+    os << "void dumpOutputs() override {\n";
     for (auto store : storeIOs) {
-        dumpRelation(dumpOutputs.body(), *lookup(store->getRelation()));
+        dumpRelation(*lookup(store->getRelation()));
     }
+    os << "}\n";  // end of dumpOutputs() method
 
-    GenFunction& getSymbolTable = mainClass.addFunction("getSymbolTable", Visibility::Public);
-    getSymbolTable.setOverride();
-    getSymbolTable.setRetType("SymbolTable&");
-    getSymbolTable.body() << "return symTable;\n";
-
-    GenFunction& getRecordTable = mainClass.addFunction("getRecordTable", Visibility::Public);
-    getRecordTable.setOverride();
-    getRecordTable.setRetType("RecordTable&");
-    getRecordTable.body() << "return recordTable;\n";
+    os << "public:\n";
+    os << "SymbolTable& getSymbolTable() override {\n";
+    os << "return symTable;\n";
+    os << "}\n";  // end of getSymbolTable() method
 
-    GenFunction& setNumThreads = mainClass.addFunction("setNumThreads", Visibility::Public);
-    setNumThreads.setRetType("void");
-    setNumThreads.setNextArg("std::size_t", "numThreadsValue");
+    os << "RecordTable& getRecordTable() override {\n";
+    os << "return recordTable;\n";
+    os << "}\n";  // end of getRecordTable() method
 
-    setNumThreads.body() << "SouffleProgram::setNumThreads(numThreadsValue);\n";
-    setNumThreads.body() << "symTable.setNumLanes(getNumThreads());\n";
-    setNumThreads.body() << "recordTable.setNumLanes(getNumThreads());\n";
-    setNumThreads.body() << "regexCache.setNumLanes(getNumThreads());\n";
+    os << "void setNumThreads(std::size_t numThreadsValue) override {\n";
+    os << "SouffleProgram::setNumThreads(numThreadsValue);\n";
+    os << "symTable.setNumLanes(getNumThreads());\n";
+    os << "recordTable.setNumLanes(getNumThreads());\n";
+    os << "}\n";  // end of setNumThreads
 
     if (!prog.getSubroutines().empty()) {
         // generate subroutine adapter
-        GenFunction& executeSubroutine = mainClass.addFunction("executeSubroutine", Visibility::Public);
-        executeSubroutine.setRetType("void");
-        executeSubroutine.setOverride();
-        executeSubroutine.setNextArg("std::string", "name");
-        executeSubroutine.setNextArg("const std::vector<RamDomain>&", "args");
-        executeSubroutine.setNextArg("std::vector<RamDomain>&", "ret");
-
+        os << "void executeSubroutine(std::string name, const std::vector<RamDomain>& args, "
+              "std::vector<RamDomain>& ret) override {\n";
+        // subroutine number
+        std::size_t subroutineNum = 0;
+        for (auto& sub : prog.getSubroutines()) {
+            os << "if (name == \"" << sub.first << "\") {\n"
+               << "subroutine_" << subroutineNum
+               << "(args, ret);\n"  // subroutine_<i> to deal with special characters in relation names
+               << "return;"
+               << "}\n";
+            subroutineNum++;
+        }
+        os << "fatal(\"unknown subroutine\");\n";
+        os << "}\n";  // end of executeSubroutine
+
+        // generate method for each subroutine
+        subroutineNum = 0;
         for (auto& sub : prog.getSubroutines()) {
-            executeSubroutine.body() << "if (name == \"" << sub.first << "\") {\n"
-                                     << convertStratumIdent("stratum_" + sub.first) << ".run(args, ret);\n"
-                                     << "return;"
-                                     << "}\n";
+            // silence unused argument warnings on MSVC
+            os << "#ifdef _MSC_VER\n";
+            os << "#pragma warning(disable: 4100)\n";
+            os << "#endif // _MSC_VER\n";
+
+            // issue method header
+            os << "void "
+               << "subroutine_" << subroutineNum
+               << "(const std::vector<RamDomain>& args, "
+                  "std::vector<RamDomain>& ret) {\n";
+
+            // issue lock variable for return statements
+            bool needLock = false;
+            visit(*sub.second, [&](const SubroutineReturn&) { needLock = true; });
+            if (needLock) {
+                os << "std::mutex lock;\n";
+            }
+
+            // emit code for subroutine
+            emitCode(os, *sub.second);
+
+            // issue end of subroutine
+            os << "}\n";
+
+            // restore unused argument warning
+            os << "#ifdef _MSC_VER\n";
+            os << "#pragma warning(default: 4100)\n";
+            os << "#endif // _MSC_VER\n";
+            subroutineNum++;
         }
-        executeSubroutine.body() << "fatal((\"unknown subroutine \" + name).c_str());\n";
     }
-
     // dumpFreqs method
     //  Frequency counts must be emitted after subroutines otherwise lookup tables
     //  are not populated.
-    if (glb.config().has("profile")) {
-        GenFunction& dumpFreqs = mainClass.addFunction("dumpFreqs", Visibility::Private);
-        dumpFreqs.setRetType("void");
-
+    if (Global::config().has("profile")) {
+        os << "private:\n";
+        os << "void dumpFreqs() {\n";
         for (auto const& cur : idxMap) {
-            dumpFreqs.body() << "\tProfileEventSingleton::instance().makeQuantityEvent(R\"_(" << cur.first
-                             << ")_\", freqs[" << cur.second << "],0);\n";
+            os << "\tProfileEventSingleton::instance().makeQuantityEvent(R\"_(" << cur.first << ")_\", freqs["
+               << cur.second << "],0);\n";
         }
         for (auto const& cur : neIdxMap) {
-            dumpFreqs.body() << "\tProfileEventSingleton::instance().makeQuantityEvent(R\"_(@relation-reads;"
-                             << cur.first << ")_\", reads[" << cur.second << "],0);\n";
+            os << "\tProfileEventSingleton::instance().makeQuantityEvent(R\"_(@relation-reads;" << cur.first
+               << ")_\", reads[" << cur.second << "],0);\n";
         }
+        os << "}\n";  // end of dumpFreqs() method
     }
-
-    GenClass& factory = db.getClass("factory_" + classname, fs::path("factory_" + classname));
-    factory.addInclude("\"souffle/SouffleInterface.h\"");
-    factory.addDependency(mainClass, true);
-    factory.inherits("souffle::ProgramFactory");
-    GenFunction& newInstance = factory.addFunction("newInstance", Visibility::Public);
-    newInstance.setRetType("souffle::SouffleProgram*");
-    newInstance.body() << "return new " << db.getNS() << "::" << classname << "();\n";
-    GenFunction& factoryConstructor = factory.addConstructor(Visibility::Public);
-    factoryConstructor.setNextInitializer("souffle::ProgramFactory", "\"" + id + "\"");
-
-    std::ostream& hook = mainClass.hooks();
-    std::ostream& factory_hook = factory.hooks();
+    os << "};\n";  // end of class declaration
 
     // hidden hooks
-    hook << "namespace souffle {\n";
-    hook << "SouffleProgram *newInstance_" << id << "(){return new " << db.getNS() << "::" << classname
-         << ";}\n";
-    hook << "SymbolTable *getST_" << id << "(SouffleProgram *p){return &reinterpret_cast<" << db.getNS(false)
-         << "::" << classname << "*>(p)->getSymbolTable();}\n";
-
-    hook << "} // namespace souffle\n";
-
-    factory_hook << "namespace souffle {\n";
-    factory_hook << "\n#ifdef __EMBEDDED_SOUFFLE__\n";
-    factory_hook << "extern \"C\" {\n";
-    factory_hook << db.getNS(false) << "::factory_" << classname << " __factory_" << classname
-                 << "_instance;\n";
-    factory_hook << "}\n";
-    factory_hook << "#endif\n";
-    factory_hook << "} // namespace souffle\n";
-
-    hook << "\n#ifndef __EMBEDDED_SOUFFLE__\n";
-    hook << "#include \"souffle/CompiledOptions.h\"\n";
-
-    hook << "int main(int argc, char** argv)\n{\n";
-    hook << "try{\n";
+    os << "SouffleProgram *newInstance_" << id << "(){return new " << classname << ";}\n";
+    os << "SymbolTable *getST_" << id << "(SouffleProgram *p){return &reinterpret_cast<" << classname
+       << "*>(p)->getSymbolTable();}\n";
+
+    os << "\n#ifdef __EMBEDDED_SOUFFLE__\n";
+    os << "class factory_" << classname << ": public souffle::ProgramFactory {\n";
+    os << "SouffleProgram *newInstance() {\n";
+    os << "return new " << classname << "();\n";
+    os << "};\n";
+    os << "public:\n";
+    os << "factory_" << classname << "() : ProgramFactory(\"" << id << "\"){}\n";
+    os << "};\n";
+    os << "extern \"C\" {\n";
+    os << "factory_" << classname << " __factory_" << classname << "_instance;\n";
+    os << "}\n";
+    os << "}\n";
+    os << "#else\n";
+    os << "}\n";
+    os << "int main(int argc, char** argv)\n{\n";
+    os << "try{\n";
 
     // parse arguments
-    hook << "souffle::CmdOptions opt(";
-    hook << "R\"(" << glb.config().get("") << ")\",\n";
-    hook << "R\"()\",\n";
-    hook << "R\"()\",\n";
-    if (glb.config().has("profile")) {
-        hook << "true,\n";
-        hook << "R\"(" << glb.config().get("profile") << ")\",\n";
+    os << "souffle::CmdOptions opt(";
+    os << "R\"(" << Global::config().get("") << ")\",\n";
+    os << "R\"()\",\n";
+    os << "R\"()\",\n";
+    if (Global::config().has("profile")) {
+        os << "true,\n";
+        os << "R\"(" << Global::config().get("profile") << ")\",\n";
     } else {
-        hook << "false,\n";
-        hook << "R\"()\",\n";
+        os << "false,\n";
+        os << "R\"()\",\n";
     }
-    hook << std::stoi(glb.config().get("jobs"));
-    hook << ");\n";
+    os << std::stoi(Global::config().get("jobs"));
+    os << ");\n";
 
-    hook << "if (!opt.parse(argc,argv)) return 1;\n";
+    os << "if (!opt.parse(argc,argv)) return 1;\n";
 
-    if (!db.getNS(false).empty()) {
-        hook << db.getNS(false) << "::";
-    }
-    if (glb.config().has("profile")) {
-        hook << classname + " obj(opt.getProfileName());\n";
+    os << "souffle::";
+    if (Global::config().has("profile")) {
+        os << classname + " obj(opt.getProfileName());\n";
     } else {
-        hook << classname + " obj;\n";
+        os << classname + " obj;\n";
+    }
+
+    os << "#if defined(_OPENMP) \n";
+    os << "obj.setNumThreads(opt.getNumJobs());\n";
+    os << "\n#endif\n";
+
+    if (Global::config().has("profile")) {
+        os << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("", opt.getSourceFileName());)_"
+           << '\n';
+        os << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("fact-dir", opt.getInputFileDir());)_"
+           << '\n';
+        os << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("jobs", std::to_string(opt.getNumJobs()));)_"
+           << '\n';
+        os << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("output-dir", opt.getOutputFileDir());)_"
+           << '\n';
+        os << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("version", ")_"
+           << Global::config().get("version") << R"_(");)_" << '\n';
     }
+    os << "obj.runAll(opt.getInputFileDir(), opt.getOutputFileDir());\n";
 
-    hook << "#if defined(_OPENMP) \n";
-    hook << "obj.setNumThreads(opt.getNumJobs());\n";
-    hook << "\n#endif\n";
-
-    if (glb.config().has("profile")) {
-        hook << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("", opt.getSourceFileName());)_"
-             << '\n';
-        hook << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("fact-dir", opt.getInputFileDir());)_"
-             << '\n';
-        hook << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("jobs", std::to_string(opt.getNumJobs()));)_"
-             << '\n';
-        hook << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("output-dir", opt.getOutputFileDir());)_"
-             << '\n';
-        hook << R"_(souffle::ProfileEventSingleton::instance().makeConfigRecord("version", ")_"
-             << glb.config().get("version") << R"_(");)_" << '\n';
+    if (Global::config().get("provenance") == "explain") {
+        os << "explain(obj, false);\n";
+    } else if (Global::config().get("provenance") == "explore") {
+        os << "explain(obj, true);\n";
     }
-    hook << "obj.runAll(opt.getInputFileDir(), opt.getOutputFileDir());\n";
+    os << "return 0;\n";
+    os << "} catch(std::exception &e) { souffle::SignalHandler::instance()->error(e.what());}\n";
+    os << "}\n";
+    os << "\n#endif\n";
 
-    if (glb.config().get("provenance") == "explain") {
-        hook << "explain(obj, false);\n";
-    } else if (glb.config().get("provenance") == "explore") {
-        hook << "explain(obj, true);\n";
+    *recordTable_os << "SpecializedRecordTable<0";
+    for (std::size_t arity : arities) {
+        if (arity > 0) {
+            *recordTable_os << "," << arity;
+        }
     }
-    hook << "return 0;\n";
-    hook << "} catch(std::exception &e) { souffle::SignalHandler::instance()->error(e.what());}\n";
-    hook << "}\n";
-    hook << "#endif\n";
+    *recordTable_os << "> recordTable{};\n";
+
+    os.flushAll(sos);
 }
 
 }  // namespace souffle::synthesiser
diff --git a/src/synthesiser/Synthesiser.h b/src/synthesiser/Synthesiser.h
index f6e6c1e..b8bbee3 100644
--- a/src/synthesiser/Synthesiser.h
+++ b/src/synthesiser/Synthesiser.h
@@ -23,13 +23,11 @@
 #include "ram/utility/Visitor.h"
 #include "souffle/RecordTable.h"
 #include "souffle/utility/ContainerUtil.h"
-#include "synthesiser/GenDb.h"
 #include "synthesiser/Relation.h"
 #include <cstddef>
 #include <map>
 #include <memory>
 #include <ostream>
-#include <regex>
 #include <set>
 #include <string>
 
@@ -45,9 +43,6 @@ private:
     /** RAM translation unit */
     ram::TranslationUnit& translationUnit;
 
-    /** Global */
-    Global& glb;
-
     /** RAM identifier to C++ identifier map */
     std::map<const std::string, const std::string> identifiers;
 
@@ -72,35 +67,13 @@ private:
     /** Is set to true if there is a need to include std::regex */
     bool UsingStdRegex = false;
 
-    /** Is set to true if the current subroutine uses std::regex */
-    bool SubroutineUsingStdRegex = false;
-    bool SubroutineUsingSubstr = false;
-
-    /** A mapping of valid regex patterns to to a unique index.
-     * The index to which the pattern is mapped is in
-     *  the range from 0 regexes.size()-1.
-     */
-    std::map<std::string, std::size_t> regexes;
-
-    /** Pointer to the subroutine class currently being built */
-    GenClass* currentClass = nullptr;
-
     /** Set of packed and unpacked records arities */
     std::set<std::size_t> arities;
 
-    /** signatures of the user-defined functors */
-    std::map<std::string, std::pair<std::vector<std::string>, std::string>> functor_signatures;
-
-    /** Output relations */
-    std::set<std::string> storeRelations;
-
 protected:
     /** Convert RAM identifier */
     const std::string convertRamIdent(const std::string& name);
 
-    /** Convert stratum name to a C++-compliant identifier */
-    const std::string convertStratumIdent(const std::string& name);
-
     /** Get relation name */
     const std::string getRelationName(const ram::Relation& rel);
     const std::string getRelationName(const ram::Relation* rel);
@@ -109,13 +82,10 @@ protected:
     const std::string getOpContextName(const ram::Relation& rel);
 
     /** Get relation struct definition */
-    void generateRelationTypeStruct(GenDb& db, Own<Relation> relationType);
+    void generateRelationTypeStruct(std::ostream& out, Own<Relation> relationType);
 
     /** Get referenced relations */
-    ram::RelationSet getReferencedRelations(const ram::Operation& op);
-
-    /** Compile a regular expression and return a unique name for it */
-    std::optional<std::size_t> compileRegex(const std::string& pattern);
+    std::set<const ram::Relation*> getReferencedRelations(const ram::Operation& op);
 
     /** Generate code */
     void emitCode(std::ostream& out, const ram::Statement& stmt);
@@ -146,16 +116,9 @@ protected:
         }
     }
 
-    std::string convertSymbolToIdentifier(const std::string& symbol) const;
-
-    /** return the set of relation names accessed/used in the statement */
-    std::set<std::string> accessedRelations(ram::Statement& stmt);
-
-    /** return the set of User-defined functor names used in the statement */
-    std::set<std::string> accessedUserDefinedFunctors(ram::Statement& stmt);
-
 public:
-    explicit Synthesiser(ram::TranslationUnit& tUnit) : translationUnit(tUnit), glb(tUnit.global()) {
+    explicit Synthesiser(/*const std::size_t laneCount, */ ram::TranslationUnit& tUnit)
+            : /*recordTable(laneCount),*/ translationUnit(tUnit) {
         visit(tUnit.getProgram(),
                 [&](const ram::Relation& relation) { relationMap[relation.getName()] = &relation; });
     }
@@ -168,6 +131,6 @@ public:
     }
 
     /** Generate code */
-    void generateCode(GenDb& db, const std::string& id, bool& withSharedLibrary);
+    void generateCode(std::ostream& os, const std::string& id, bool& withSharedLibrary);
 };
 }  // namespace souffle::synthesiser
diff --git a/src/tests/graph_utils_test.cpp b/src/tests/graph_utils_test.cpp
index 64863f5..b3da73d 100644
--- a/src/tests/graph_utils_test.cpp
+++ b/src/tests/graph_utils_test.cpp
@@ -17,7 +17,6 @@
 #include "tests/test.h"
 
 #include "GraphUtils.h"
-#include "souffle/datastructure/Graph.h"
 #include "souffle/utility/StringUtil.h"
 #include <functional>
 #include <map>
diff --git a/src/tests/record_table_test.cpp b/src/tests/record_table_test.cpp
index 76e0ad5..79f35c4 100644
--- a/src/tests/record_table_test.cpp
+++ b/src/tests/record_table_test.cpp
@@ -70,27 +70,6 @@ TEST(Pack, InitListHelper) {
     EXPECT_EQ(3, ptr[2]);
 }
 
-TEST(Enumerate, Empty) {
-    SpecializedRecordTable<2> recordTable;
-
-    std::size_t count = 0;
-    recordTable.enumerate([&](const RamDomain*, std::size_t, RamDomain) { count += 1; });
-    EXPECT_EQ(0, count);
-}
-
-TEST(Enumerate, Three) {
-    SpecializedRecordTable<3> recordTable;
-    RamDomain ref = pack(recordTable, {1, 2, 3});
-
-    recordTable.enumerate([&](const RamDomain* t, std::size_t arity, RamDomain idx) {
-        EXPECT_EQ(3, arity);
-        EXPECT_EQ(ref, idx);
-        EXPECT_EQ(1, t[0]);
-        EXPECT_EQ(2, t[1]);
-        EXPECT_EQ(3, t[2]);
-    });
-}
-
 // Generate random tuples
 // pack them all
 // unpack and test for equality
diff --git a/src/tests/visitor_test.cpp b/src/tests/visitor_test.cpp
index 977c454..86ab678 100644
--- a/src/tests/visitor_test.cpp
+++ b/src/tests/visitor_test.cpp
@@ -44,7 +44,7 @@ namespace {
 template <typename A, typename... XS>
 auto asVec(XS&&... xs) {
     vector<A> v;
-    (v.push_back(std::forward<XS>(xs)), ...);
+    (v.push_back(forward<XS>(xs)), ...);
     return v;
 }
 
@@ -54,7 +54,7 @@ struct Node {
     VecOwn<Node> kids;
 
     template <typename... A>
-    Node(A&&... xs) : kids(asVec<Own<Node>>(std::forward<A>(xs)...)) {}
+    Node(A&&... xs) : kids(asVec<Own<Node>>(forward<A>(xs)...)) {}
 
     virtual vector<Node const*> getChildNodes() const {
         return toPtrVector<Node const>(kids);
@@ -151,7 +151,7 @@ template <typename A, typename B>
 void TEST_INSTANTIATION_MAPPER() {
     A x;
     mapPost(x, [&](Own<B> x) { return x; });
-    mapFrontier(x, [&](Own<B> x) { return pair{std::move(x), false}; });
+    mapFrontier(x, [&](Own<B> x) { return pair{move(x), false}; });
 }
 
 // Check that visitor function instantiates successfully.
@@ -209,7 +209,7 @@ TEST(NodeMapper, mapPrePost_BarToFoo) {
 
     auto go = [](Own<NBar> n) {
         auto x = mk<NFoo>();
-        x->kids = std::move(n->kids);
+        x->kids = move(n->kids);
         return x;
     };
     EXPECT_EQ(*expected, *mapPre(mkTree(), go));
@@ -229,8 +229,8 @@ TEST(NodeMapper, mapFrontier_FooToBar) {
 
     auto go = [](Own<NFoo> n) {
         auto x = mk<NBar>();
-        x->kids = std::move(n->kids);
-        return pair{std::move(x), true};
+        x->kids = move(n->kids);
+        return pair{move(x), true};
     };
     auto&& [produced, n] = mapFrontier(mkTree(), go);
 
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 41ee14a..c632e03 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -17,5 +17,3 @@ add_subdirectory(interface)
 add_subdirectory(provenance)
 add_subdirectory(profile)
 add_subdirectory(scheduler)
-add_subdirectory(link)
-add_subdirectory(libsouffle_interface)
diff --git a/tests/evaluation/CMakeLists.txt b/tests/evaluation/CMakeLists.txt
index 7d7898b..96e6f09 100644
--- a/tests/evaluation/CMakeLists.txt
+++ b/tests/evaluation/CMakeLists.txt
@@ -7,7 +7,7 @@
 include(SouffleTests)
 
 function(POSITIVE_TEST NAME)
-    souffle_positive_test(${NAME} evaluation ${ARGN})
+    souffle_positive_test(${NAME} evaluation)
 endfunction()
 
 positive_test(access1)
@@ -29,7 +29,6 @@ positive_test(aggregate_witnesses)
 positive_test(aliases)
 positive_test(arithm)
 positive_test(average)
-positive_test(bad_regex)
 positive_test(binop)
 positive_test(cat)
 positive_test(choice_advisor)
@@ -85,8 +84,8 @@ positive_test(inline_records)
 positive_test(inline_underscore)
 positive_test(inline_unification)
 positive_test(list)
-positive_test(magic_2sat COMPILED_SPLITTED)
-positive_test(magic_aggregates COMPILED_SPLITTED)
+positive_test(magic_2sat)
+positive_test(magic_aggregates)
 positive_test(magic_bindings)
 positive_test(magic_centroids)
 positive_test(magic_circuit_sat)
@@ -116,13 +115,12 @@ positive_test(magic_poslabel)
 positive_test(magic_records4)
 positive_test(magic_samegen)
 positive_test(magic_strategies)
-positive_test(magic_string_substr COMPILED_SPLITTED)
+positive_test(magic_string_substr)
 positive_test(magic_turing1)
 positive_test(match2)
 positive_test(match3)
 positive_test(match4)
-positive_test(match5)
-positive_test(match COMPILED_SPLITTED)
+positive_test(match)
 # TODO (see issue #298) positive_test(math)
 positive_test(max)
 positive_test(minmax)
@@ -161,10 +159,8 @@ positive_test(subtype2)
 positive_test(subtype)
 positive_test(sum-aggregate)
 positive_test(sum-aggregate2)
-positive_test(symbol_operations)
 positive_test(term)
 positive_test(unpacking)
 positive_test(unsigned_operations)
 positive_test(unused_constraints)
 positive_test(x9)
-positive_test(issue2160)
diff --git a/tests/example/CMakeLists.txt b/tests/example/CMakeLists.txt
index 7c4b448..54445d8 100644
--- a/tests/example/CMakeLists.txt
+++ b/tests/example/CMakeLists.txt
@@ -7,7 +7,7 @@
 include(SouffleTests)
 
 function(POSITIVE_TEST NAME)
-    souffle_positive_test(${NAME} example ${ARGN})
+    souffle_positive_test(${NAME} example)
 endfunction()
 
 function(NEGATIVE_TEST NAME)
diff --git a/tests/interface/CMakeLists.txt b/tests/interface/CMakeLists.txt
index d4770d5..e5ba049 100644
--- a/tests/interface/CMakeLists.txt
+++ b/tests/interface/CMakeLists.txt
@@ -5,19 +5,14 @@
 # - <souffle root>/licenses/SOUFFLE-UPL.txt
 
 # Make sure that the functor library is built
-add_subdirectory(aggregates)
 add_subdirectory(functors)
 add_subdirectory(graph_coloring)
 add_subdirectory(pathseq)
-add_subdirectory(lattice1)
-add_subdirectory(lattice2)
-add_subdirectory(lattice3)
 
 # swig test which will run python, java or both
 function(SOUFFLE_POSITIVE_FUNCTOR_TEST TEST_NAME)
         souffle_run_test_helper(TEST_NAME ${TEST_NAME} FUNCTORS ${ARGN})
         souffle_run_test_helper(TEST_NAME ${TEST_NAME} COMPILED FUNCTORS ${ARGN})
-        souffle_run_test_helper(TEST_NAME ${TEST_NAME} COMPILED_SPLITTED FUNCTORS ${ARGN})
 endfunction()
 
 function(SOUFFLE_RUN_CPP_TEST)
@@ -158,13 +153,9 @@ function(SOUFFLE_POSITIVE_CPP_TEST TEST_NAME)
     souffle_run_cpp_test_helper(TEST_NAME ${TEST_NAME} ${ARGN})
 endfunction()
 
-souffle_positive_functor_test(aggregates CATEGORY interface)
 souffle_positive_functor_test(functors CATEGORY interface)
 souffle_positive_functor_test(pathseq CATEGORY interface)
 souffle_positive_functor_test(graph_coloring CATEGORY interface)
-souffle_positive_functor_test(lattice1 CATEGORY interface)
-souffle_positive_functor_test(lattice2 CATEGORY interface)
-souffle_positive_functor_test(lattice3 CATEGORY interface)
 souffle_positive_cpp_test(contain_insert)
 souffle_positive_cpp_test(get_symboltabletype)
 souffle_positive_cpp_test(insert_for)
diff --git a/tests/interface/functors/CMakeLists.txt b/tests/interface/functors/CMakeLists.txt
index 753c24c..e76a298 100644
--- a/tests/interface/functors/CMakeLists.txt
+++ b/tests/interface/functors/CMakeLists.txt
@@ -47,9 +47,3 @@ if (SOUFFLE_DOMAIN_64BIT)
     target_compile_definitions(functors
                                PUBLIC RAM_DOMAIN_SIZE=64)
 endif()
-
-if (SOUFFLE_USE_LIBFFI)
-    target_compile_definitions(functors
-                               PUBLIC USE_LIBFFI)
-endif()
-
diff --git a/tests/interface/functors/functors.dl b/tests/interface/functors/functors.dl
index 1ad7d1e..a96678a 100644
--- a/tests/interface/functors/functors.dl
+++ b/tests/interface/functors/functors.dl
@@ -12,6 +12,7 @@
 .functor factorial(unsigned):unsigned
 .functor rnd(float):number
 .functor incr(float):float
+.functor concat(float, number, unsigned, symbol):symbol
 
 .decl A(x:number)
 A(@foo(1,"123")) :- true.
@@ -61,16 +62,10 @@ I(@incr(1)) :- true.
 .output I
 
 .decl CC(f:float, i:number, u:unsigned, s:symbol, res:symbol)
-.output CC
-#if defined (USE_LIBFFI)
-// when Souffle is built with libffi we can call stateless functors with arbitrary arguments
-.functor concat(float, number, unsigned, symbol):symbol
 CC(f,i,u,s,res) :-
   f = 1.25, i=-4, u=1000u, s="message",
   res = @concat(1.25, -4, 1000, "message").
-#else
-CC(1.25, -4, 1000u, "message", "1.250000-41000message").
-#endif
+.output CC
 
 
 // Testing stateful functors
diff --git a/tests/interface/insert_print/driver.cpp b/tests/interface/insert_print/driver.cpp
index 931cedb..c5e5125 100644
--- a/tests/interface/insert_print/driver.cpp
+++ b/tests/interface/insert_print/driver.cpp
@@ -46,7 +46,7 @@ int main(int /* argc */, char** /* argv */) {
             }
 
             // run program
-            prog->runAll("", "", false, true);
+            prog->run();
 
             // print all relations to CSV files in current directory
             // NB: Defaul is current directory
diff --git a/tests/profile/CMakeLists.txt b/tests/profile/CMakeLists.txt
index 9ffb9c7..37f37a5 100644
--- a/tests/profile/CMakeLists.txt
+++ b/tests/profile/CMakeLists.txt
@@ -119,8 +119,6 @@ function(SOUFFLE_POSITIVE_PROF_TEST TEST_NAME)
 endfunction()
 
 if (NOT MSVC)
-if (NOT (APPLE AND ("${CMAKE_HOST_SYSTEM_PROCESSOR}" STREQUAL "arm64")))
 souffle_positive_prof_test(lrg_attr_id)
 souffle_positive_prof_test(recursive)
-endif()
 endif ()
diff --git a/tests/provenance/CMakeLists.txt b/tests/provenance/CMakeLists.txt
index 033c193..dd3bb88 100644
--- a/tests/provenance/CMakeLists.txt
+++ b/tests/provenance/CMakeLists.txt
@@ -6,20 +6,17 @@
 
 include(SouffleTests)
 
-# provenance test
+# provenance test 
 function(SOUFFLE_PROVENANCE_TEST TEST_NAME)
     souffle_run_test_helper(TEST_NAME ${TEST_NAME} CATEGORY provenance)
     souffle_run_test_helper(TEST_NAME ${TEST_NAME} COMPILED CATEGORY provenance)
-    if (${ARGN} MATCHES "COMPILED_SPLITTED")
-        souffle_run_test_helper(TEST_NAME ${TEST_NAME} COMPILED_SPLITTED CATEGORY provenance)
-    endif()
 endfunction()
 
 if (NOT MSVC)
-souffle_provenance_test(components COMPILED_SPLITTED)
+souffle_provenance_test(components)
 souffle_provenance_test(constraints)
 souffle_provenance_test(cprog1)
-souffle_provenance_test(eqrel_tests3 COMPILED_SPLITTED)
+souffle_provenance_test(eqrel_tests3)
 souffle_provenance_test(explain_float_unsigned)
 souffle_provenance_test(high_arity)
 souffle_provenance_test(negation)
diff --git a/tests/scheduler/CMakeLists.txt b/tests/scheduler/CMakeLists.txt
index 0fd3c24..100437e 100644
--- a/tests/scheduler/CMakeLists.txt
+++ b/tests/scheduler/CMakeLists.txt
@@ -24,7 +24,7 @@ function(SOUFFLE_ADD_SCHEDULER_TEST TEST_NAME)
 
     set(QUALIFIED_TEST_NAME scheduler/${TEST_NAME}_stats_collection)
     # Run stats collection
-    set(SOUFFLE_PARAMS "-p" "${OUTPUT_DIR}/${TEST_NAME}.prof" "--emit-statistics")
+    set(SOUFFLE_PARAMS "-p" "${OUTPUT_DIR}/${TEST_NAME}.prof" "--index-stats")
     add_test(NAME ${QUALIFIED_TEST_NAME}
       COMMAND
       ${Python3_EXECUTABLE} ${PROJECT_SOURCE_DIR}/cmake/redirect.py
@@ -93,5 +93,4 @@ endfunction()
 
 if (NOT MSVC)
     souffle_add_scheduler_test(functionality)
-    souffle_add_scheduler_test(eqrel)
 endif()
diff --git a/tests/semantic/CMakeLists.txt b/tests/semantic/CMakeLists.txt
index 35f653d..049b5b2 100644
--- a/tests/semantic/CMakeLists.txt
+++ b/tests/semantic/CMakeLists.txt
@@ -11,16 +11,10 @@ if (NOT ${CMAKE_SYSTEM_NAME} MATCHES "Linux")
 endif()
 
 add_subdirectory(functor_fact)
-add_subdirectory(issue2373)
 
 
 function(positive_test NAME)
-    souffle_positive_test(${NAME} semantic ${ARGN})
-endfunction()
-
-function(positive_output_stdout_test NAME)
-    souffle_run_test_helper(TEST_NAME ${NAME} CATEGORY semantic OUTPUT_STDOUT ${ARGV})
-    souffle_run_test_helper(TEST_NAME ${NAME} CATEGORY semantic OUTPUT_STDOUT ${ARGV} COMPILED)
+    souffle_positive_test(${NAME} semantic)
 endfunction()
 
 function(negative_test NAME)
@@ -47,7 +41,7 @@ positive_test(agg_nested)
 positive_test(alias)
 negative_test(attrib_dupl)
 positive_test(bin1)
-positive_test(bin COMPILED_SPLITTED)
+positive_test(bin)
 positive_test(binhex)
 positive_test(bitwise)
 positive_test(bool)
@@ -68,7 +62,7 @@ positive_test(counter)
 negative_test(disjoint_names)
 # TODO (see issue #231) negative_test(divide_by_zero)
 positive_test(duplicates)
-positive_test(eqrel_tests COMPILED_SPLITTED)
+positive_test(eqrel_tests)
 positive_test(eqrel_tests2)
 positive_test(eqrel_tests3)
 positive_test(eqrel_tests4)
@@ -105,33 +99,30 @@ souffle_run_test(TEST_NAME jsonfile CATEGORY semantic EXTRA_DATA json)
 negative_test(keys)
 positive_test(keys1)
 positive_test(keys2)
-positive_test(leq COMPILED_SPLITTED)
+positive_test(leq)
 positive_test(limitsize)
-negative_test(load2)
-negative_test(load3)
-negative_test(load4)
+positive_test(load2)
+positive_test(load3)
+positive_test(load4)
 if (SOUFFLE_USE_ZLIB)
 positive_test(load6)
 endif ()
 positive_test(load7)
 positive_test(load8)
 positive_test(load9)
-negative_test(load10)
-positive_test(load11)
-positive_test(load12)
-positive_test(load13)
+positive_test(load10)
 positive_test(load_adt)
 positive_test(load_adt2)
 positive_test(load_adt3)
 positive_test(load_record_delimiter)
 positive_test(load_record_large)
 positive_test(load_record_large2)
-negative_test(load_record_invalid_parenthesis)
+positive_test(load_record_invalid_parenthesis)
 positive_test(load_simple_record)
 positive_test(load_simple_record2)
 positive_test(load_symbol_in_record)
 positive_test(logical)
-positive_test(lrg_attr_id COMPILED_SPLITTED)
+positive_test(lrg_attr_id)
 positive_test(lrg_rel_id1)
 positive_test(lrg_rel_id2)
 positive_test(negative_numbers)
@@ -189,11 +180,11 @@ positive_test(store_record_one_level)
 positive_test(strconv)
 positive_test(string_len)
 positive_test(string_minmax)
-positive_test(string_substr1 COMPILED_SPLITTED)
-positive_test(string_substr COMPILED_SPLITTED)
+positive_test(string_substr1)
+positive_test(string_substr)
 positive_test(suppress_warnings)
 negative_test(subsumption)
-positive_test(subsumption_multiple_rules COMPILED_SPLITTED)
+positive_test(subsumption_multiple_rules)
 positive_test(type_as)
 negative_test(type_as2)
 negative_test(type_as3)
@@ -262,16 +253,3 @@ positive_test(inherit_instance_override)
 positive_test(instantiate_from_inherited)
 positive_test(instantiate_from_inherited_override)
 souffle_positive_functor_test(functor_fact CATEGORY semantic)
-positive_test(underscore5)
-negative_test(mutually_dependent_aggregate)
-positive_test(independent_aggregate)
-positive_test(independent_aggregate2)
-souffle_positive_functor_test(issue2373 CATEGORY semantic)
-negative_test(error_deduce_type)
-positive_output_stdout_test(output_stdout)
-positive_test(iteration_counter)
-positive_test(issue1896)
-positive_test(comp_params)
-positive_test(issue2416)
-positive_test(agg_range)
-positive_test(issue2482)
diff --git a/tests/semantic/agg_checks/agg_checks.err b/tests/semantic/agg_checks/agg_checks.err
index 3b20b7a..d7c7da5 100644
--- a/tests/semantic/agg_checks/agg_checks.err
+++ b/tests/semantic/agg_checks/agg_checks.err
@@ -19,18 +19,21 @@ r("X",Y) :- Y = min X : { X != Y, !a(X,Y) }.
 Error: Unable to deduce type for variable X in file agg_checks.dl at line 11
 r("X",Y) :- Y = min X : { X != Y, !a(X,Y) }.
 --------------------^------------------------
-Following constraints are incompatible:
-   Type of variable 'X' should be a subtype of 'symbol'
-   var(min X : { X != Y0,!a(X,Y0) }) <: var(X)
 Error: Ungrounded variable X in file agg_checks.dl at line 11
 r("X",Y) :- Y = min X : { X != Y, !a(X,Y) }.
 --------------------^------------------------
+Error: Unable to deduce type for variable X in file agg_checks.dl at line 11
+r("X",Y) :- Y = min X : { X != Y, !a(X,Y) }.
+--------------------------^------------------
 Error: Unable to deduce type for variable Y0 in file agg_checks.dl at line 11
 r("X",Y) :- Y = min X : { X != Y, !a(X,Y) }.
 -------------------------------^-------------
 Error: Ungrounded variable Y0 in file agg_checks.dl at line 11
 r("X",Y) :- Y = min X : { X != Y, !a(X,Y) }.
 -------------------------------^-------------
+Error: Unable to deduce type for variable X in file agg_checks.dl at line 11
+r("X",Y) :- Y = min X : { X != Y, !a(X,Y) }.
+-------------------------------------^-------
 Error: Unable to deduce type for variable Y0 in file agg_checks.dl at line 11
 r("X",Y) :- Y = min X : { X != Y, !a(X,Y) }.
 ---------------------------------------^-----
@@ -55,11 +58,9 @@ r("X",Y) :- Y = min X : a(X,_).
 Error: Unable to deduce type for variable X in file agg_checks.dl at line 20
 r("X",Y) :- Y = min X : a(X,_).
 --------------------^-----------
-Following constraints are incompatible:
-   Type of variable 'X' should be a subtype of 'symbol' in file agg_checks.dl at line 20
+Error: Unable to deduce type for variable X in file agg_checks.dl at line 20
 r("X",Y) :- Y = min X : a(X,_).
-------------------------^-------
-   var(min X : { a(X,_) }) <: var(X)
+--------------------------^-----
 Error: Undefined relation nonexistent in file agg_checks.dl at line 31
 r("X",count: { nonexistent(_,_) }).
 ---------------^--------------------
@@ -73,4 +74,4 @@ Relation r in file agg_checks.dl at line 6
 has cyclic aggregation in file agg_checks.dl at line 28
 r("X",Y) :- Y = min Y : r("X",Y).
 ------------------------^---------
-19 errors generated, evaluation aborted
\ No newline at end of file
+22 errors generated, evaluation aborted
diff --git a/tests/semantic/bad_functor_types/bad_functor_types.err b/tests/semantic/bad_functor_types/bad_functor_types.err
index 559f20f..725dc34 100644
--- a/tests/semantic/bad_functor_types/bad_functor_types.err
+++ b/tests/semantic/bad_functor_types/bad_functor_types.err
@@ -10,11 +10,9 @@ C(c) :- A(a), c = @good_functor(a, a).
 Error: Unable to deduce type for variable b in file bad_functor_types.dl at line 17
 C(c) :- B(b), c = @good_functor(b).
 ----------^-------------------------
-Following constraints are incompatible:
-   Type of variable 'b' should be a subtype of 'number' in file bad_functor_types.dl at line 17
+Error: Unable to deduce type for variable b in file bad_functor_types.dl at line 17
 C(c) :- B(b), c = @good_functor(b).
---------^---------------------------
-   Type of variable 'b' should be a subtype of 'symbol'
+--------------------------------^---
 Error: Unable to determine type for positional parameter 0 in file bad_functor_types.dl at line 17
 C(c) :- B(b), c = @good_functor(b).
 --------------------------------^---
@@ -30,4 +28,4 @@ Error: Functors which are not stateful cannot use UDTs in file bad_functor_types
 Error: Functors which are not stateful cannot use UDTs in file bad_functor_types.dl at line 23
 .functor bad_not_stateful(List): List
 ---------------------------------^----
-9 errors generated, evaluation aborted
\ No newline at end of file
+10 errors generated, evaluation aborted
diff --git a/tests/semantic/comp_params_inheritance/comp_params_inheritance.err b/tests/semantic/comp_params_inheritance/comp_params_inheritance.err
index b2abde2..6948994 100644
--- a/tests/semantic/comp_params_inheritance/comp_params_inheritance.err
+++ b/tests/semantic/comp_params_inheritance/comp_params_inheritance.err
@@ -1,4 +1,4 @@
-Error: Component T not found in file comp_params_inheritance.dl at line 8
-    .init impl = T
------------------^-
+Error: Undefined relation impl.R in file comp_params_inheritance.dl at line 10
+    Base(x) :- impl.R(x).
+---------------^----------
 1 errors generated, evaluation aborted
diff --git a/tests/semantic/comp_types/comp_types.err b/tests/semantic/comp_types/comp_types.err
index b58d32b..a47dfd4 100644
--- a/tests/semantic/comp_types/comp_types.err
+++ b/tests/semantic/comp_types/comp_types.err
@@ -1,49 +1,37 @@
 Error: Unable to deduce type for variable x in file comp_types.dl at line 32
 relX(x) :- relY(x).
 -----^--------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'x.inner'
-   Type of variable 'x' should be a subtype of 'y.inner' in file comp_types.dl at line 32
+Error: Unable to deduce type for variable x in file comp_types.dl at line 32
 relX(x) :- relY(x).
------------^--------
+----------------^---
 Error: Unable to deduce type for variable x in file comp_types.dl at line 33
 relX(x) :- relZ(x).
 -----^--------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'x.inner'
-   Type of variable 'x' should be a subtype of 'z.inner' in file comp_types.dl at line 33
+Error: Unable to deduce type for variable x in file comp_types.dl at line 33
 relX(x) :- relZ(x).
------------^--------
+----------------^---
 Error: Unable to deduce type for variable x in file comp_types.dl at line 35
 relY(x) :- relX(x).
 -----^--------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'x.inner' in file comp_types.dl at line 35
+Error: Unable to deduce type for variable x in file comp_types.dl at line 35
 relY(x) :- relX(x).
------------^--------
-   Type of variable 'x' should be a subtype of 'y.inner'
+----------------^---
 Error: Unable to deduce type for variable x in file comp_types.dl at line 37
 relY(x) :- relZ(x).
 -----^--------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'y.inner'
-   Type of variable 'x' should be a subtype of 'z.inner' in file comp_types.dl at line 37
+Error: Unable to deduce type for variable x in file comp_types.dl at line 37
 relY(x) :- relZ(x).
------------^--------
+----------------^---
 Error: Unable to deduce type for variable x in file comp_types.dl at line 39
 relZ(x) :- relX(x).
 -----^--------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'x.inner' in file comp_types.dl at line 39
+Error: Unable to deduce type for variable x in file comp_types.dl at line 39
 relZ(x) :- relX(x).
------------^--------
-   Type of variable 'x' should be a subtype of 'z.inner'
+----------------^---
 Error: Unable to deduce type for variable x in file comp_types.dl at line 40
 relZ(x) :- relY(x).
 -----^--------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'y.inner' in file comp_types.dl at line 40
+Error: Unable to deduce type for variable x in file comp_types.dl at line 40
 relZ(x) :- relY(x).
------------^--------
-   Type of variable 'x' should be a subtype of 'z.inner'
-6 errors generated, evaluation aborted
\ No newline at end of file
+----------------^---
+12 errors generated, evaluation aborted
diff --git a/tests/semantic/execution_plan/execution_plan.dl b/tests/semantic/execution_plan/execution_plan.dl
index 4d3ca71..474342b 100644
--- a/tests/semantic/execution_plan/execution_plan.dl
+++ b/tests/semantic/execution_plan/execution_plan.dl
@@ -23,28 +23,3 @@ r3(a,d) :- r3(a,b),r3(b,c),r3(c,d).
 // this one is not
 r4(a,d) :- r4(a,b),r4(b,c),r4(c,d).
         .plan 0: (1,2,2), 1: (3,2), 2: (2,3,1,3)
-
-.decl y(a:S)
-.output y
-
-y(a) :- r1(a,_), r2(a,_), r3(a,_).
-        .plan 0:(1,2,3)
-
-.decl x1(a:number)
-.decl x2(a:number)
-.decl x3(a:number)
-.output x1
-.output x2
-.output x3
-
-// ok
-x1(a) <= x1(b) :- a < b.
-        .plan 0:(1,2)
-
-// Invalid plan: order is only 2.
-x2(a) <= x2(b) :- a < b.
-        .plan 0:(1,2,3)
-
-// Invalid plan: incomplete
-x3(a) <= x3(b) :- a < b.
-        .plan 0:(1,3)
diff --git a/tests/semantic/execution_plan/execution_plan.err b/tests/semantic/execution_plan/execution_plan.err
index 2ee01cb..6ea555d 100644
--- a/tests/semantic/execution_plan/execution_plan.err
+++ b/tests/semantic/execution_plan/execution_plan.err
@@ -2,22 +2,13 @@ Error: execution plan for version 3 in file execution_plan.dl at line 21
         .plan 1: (1,2,3), 2: (3,2,1), 3: (2,3,1)
 -----------------------------------------^-------
 only versions 0..2 permitted
-Error: Invalid execution order in plan (incomplete) in file execution_plan.dl at line 25
+Error: Invalid execution order in plan in file execution_plan.dl at line 25
         .plan 0: (1,2,2), 1: (3,2), 2: (2,3,1,3)
 -----------------^-------------------------------
-Error: Invalid execution order in plan (expected 3 atoms, not 2) in file execution_plan.dl at line 25
+Error: Invalid execution order in plan in file execution_plan.dl at line 25
         .plan 0: (1,2,2), 1: (3,2), 2: (2,3,1,3)
 -----------------------------^-------------------
-Error: Invalid execution order in plan (expected 3 atoms, not 4) in file execution_plan.dl at line 25
+Error: Invalid execution order in plan in file execution_plan.dl at line 25
         .plan 0: (1,2,2), 1: (3,2), 2: (2,3,1,3)
 ---------------------------------------^---------
-Error: Ignored execution plan for non-recursive clause in file execution_plan.dl at line 31
-        .plan 0:(1,2,3)
-----------------^-------
-Error: Invalid execution order in plan (expected 2 atoms, not 3) in file execution_plan.dl at line 46
-        .plan 0:(1,2,3)
-----------------^-------
-Error: Invalid execution order in plan (incomplete) in file execution_plan.dl at line 50
-        .plan 0:(1,3)
-----------------^-----
-7 errors generated, evaluation aborted
+4 errors generated, evaluation aborted
diff --git a/tests/semantic/fact_plus/fact_plus.err b/tests/semantic/fact_plus/fact_plus.err
index 2b170dd..d26aa6a 100644
--- a/tests/semantic/fact_plus/fact_plus.err
+++ b/tests/semantic/fact_plus/fact_plus.err
@@ -1,4 +1,7 @@
 Error: Argument in fact is not constant in file fact_plus.dl at line 10
 F(1+a,"AA").
 --^----------
+Warning: Variable a only occurs once in file fact_plus.dl at line 10
+F(1+a,"AA").
+----^--------
 1 errors generated, evaluation aborted
diff --git a/tests/semantic/fact_variable/fact_variable.err b/tests/semantic/fact_variable/fact_variable.err
index fd654ce..36f3a63 100644
--- a/tests/semantic/fact_variable/fact_variable.err
+++ b/tests/semantic/fact_variable/fact_variable.err
@@ -1,4 +1,7 @@
 Error: Argument in fact is not constant in file fact_variable.dl at line 7
 F(BB,"AA").
 --^---------
+Warning: Variable BB only occurs once in file fact_variable.dl at line 7
+F(BB,"AA").
+--^---------
 1 errors generated, evaluation aborted
diff --git a/tests/semantic/leq/leq.dl b/tests/semantic/leq/leq.dl
index 36f19d2..b0ec177 100644
--- a/tests/semantic/leq/leq.dl
+++ b/tests/semantic/leq/leq.dl
@@ -79,4 +79,4 @@ Values(n, v, [lb, ub]) :-
     Values(n, v, [lb1, ub1]),
     Values(n, v, [lb2, ub2]),
     lb = min(lb1, lb2),
-    ub = max(ub1, ub2).
\ No newline at end of file
+    ub = max(ub1, ub2).
diff --git a/tests/semantic/load10/load10.err b/tests/semantic/load10/load10.err
index 310107c..e718605 100644
--- a/tests/semantic/load10/load10.err
+++ b/tests/semantic/load10/load10.err
@@ -1,2 +1,10 @@
 Error loading Float data: Error converting <0.12e> in column 1 in line 3; cannot parse fact file Float.facts!
 
+Error loading Signed1 data: Error converting <0x1> in column 2 in line 1; cannot parse fact file Signed1.facts!
+
+Error loading Signed2 data: Error converting <0b1> in column 1 in line 2; cannot parse fact file Signed2.facts!
+
+Error loading Signed3 data: Error converting <-0x1> in column 1 in line 1; cannot parse fact file Signed3.facts!
+
+Error loading Signed4 data: Error converting <3.01> in column 1 in line 3; cannot parse fact file Signed4.facts!
+
diff --git a/tests/semantic/load10/oFloat.csv b/tests/semantic/load10/oFloat.csv
index e69de29..dd028bd 100644
--- a/tests/semantic/load10/oFloat.csv
+++ b/tests/semantic/load10/oFloat.csv
@@ -0,0 +1,2 @@
+-0.5	1
+0.5	42.5
diff --git a/tests/semantic/load10/oSigned.csv b/tests/semantic/load10/oSigned.csv
index e69de29..59c2b66 100644
--- a/tests/semantic/load10/oSigned.csv
+++ b/tests/semantic/load10/oSigned.csv
@@ -0,0 +1,3 @@
+-1	0
+1	1
+1	2
diff --git a/tests/semantic/load3/load3.out b/tests/semantic/load3/load3.out
index e69de29..58e5b13 100644
--- a/tests/semantic/load3/load3.out
+++ b/tests/semantic/load3/load3.out
@@ -0,0 +1 @@
+A	1
diff --git a/tests/semantic/load4/load4.out b/tests/semantic/load4/load4.out
index e69de29..360aa26 100644
--- a/tests/semantic/load4/load4.out
+++ b/tests/semantic/load4/load4.out
@@ -0,0 +1 @@
+B	1
diff --git a/tests/semantic/plan1/plan1.err b/tests/semantic/plan1/plan1.err
index 046c351..de3f32f 100644
--- a/tests/semantic/plan1/plan1.err
+++ b/tests/semantic/plan1/plan1.err
@@ -1,4 +1,4 @@
-Error: Invalid execution order in plan (incomplete) in file plan1.dl at line 15
+Error: Invalid execution order in plan in file plan1.dl at line 15
 A(v1,v4) :- B(v1,v2), v1 < v2, C(v2,v3), D(v3,v4), !E(v1,v4). .plan 0:(1,2,4)
 ----------------------------------------------------------------------^-------
 1 errors generated, evaluation aborted
diff --git a/tests/semantic/rule_typecompat/rule_typecompat.err b/tests/semantic/rule_typecompat/rule_typecompat.err
index 249d21a..53b9075 100644
--- a/tests/semantic/rule_typecompat/rule_typecompat.err
+++ b/tests/semantic/rule_typecompat/rule_typecompat.err
@@ -22,26 +22,24 @@ The argument's declared type is T in file rule_typecompat.dl at line 6
 Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 18
 A(x) :- F(x,x).
 --^-------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'R' in file rule_typecompat.dl at line 18
+Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 18
 A(x) :- F(x,x).
---------^-------
-   Type of variable 'x' should be a subtype of 'T' in file rule_typecompat.dl at line 18
+----------^-----
+Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 18
 A(x) :- F(x,x).
---------^-------
+------------^---
 Warning: Variable y only occurs once in file rule_typecompat.dl at line 20
 A(x) :- F(y,x).
 ----------^-----
 Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 23
 A(x) :- G(x,x).
 --^-------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'R' in file rule_typecompat.dl at line 23
+Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 23
 A(x) :- G(x,x).
---------^-------
-   Type of variable 'x' should be a subtype of 'T' in file rule_typecompat.dl at line 23
+----------^-----
+Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 23
 A(x) :- G(x,x).
---------^-------
+------------^---
 Warning: Variable y only occurs once in file rule_typecompat.dl at line 25
 A(x) :- G(x,y).
 ------------^---
@@ -54,16 +52,18 @@ The argument's declared type is R in file rule_typecompat.dl at line 12
 Error: Ungrounded variable y in file rule_typecompat.dl at line 30
 G(x,y) :- A(x).
 ----^-----------
+Warning: Variable y only occurs once in file rule_typecompat.dl at line 30
+G(x,y) :- A(x).
+----^-----------
 Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 33
 A(x) :- B(x), C(x).
 --^-----------------
-Following constraints are incompatible:
-   Type of variable 'x' should be a subtype of 'Q' in file rule_typecompat.dl at line 33
+Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 33
 A(x) :- B(x), C(x).
---------------^-----
-   Type of variable 'x' should be a subtype of 'S' in file rule_typecompat.dl at line 33
+----------^---------
+Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 33
 A(x) :- B(x), C(x).
---------^-----------
+----------------^---
 Warning: Variable y only occurs once in file rule_typecompat.dl at line 36
 A(x) :- A(x), B(y), C(z).
 ----------------^---------
@@ -79,52 +79,45 @@ The argument's declared type is T in file rule_typecompat.dl at line 11
 Error: Ungrounded variable y in file rule_typecompat.dl at line 41
 F(x,y) :- F(x,z), G(z,x).
 ----^---------------------
+Warning: Variable y only occurs once in file rule_typecompat.dl at line 41
+F(x,y) :- F(x,z), G(z,x).
+----^---------------------
 Error: Unable to deduce type for variable v in file rule_typecompat.dl at line 47
 F(x,y) :- F(x,v), F(w,y), A(v), D(v).
 --------------^-----------------------
-Following constraints are incompatible:
-   Type of variable 'v' should be a subtype of 'R' in file rule_typecompat.dl at line 47
-F(x,y) :- F(x,v), F(w,y), A(v), D(v).
---------------------------------^-----
-   Type of variable 'v' should be a subtype of 'T' in file rule_typecompat.dl at line 47
-F(x,y) :- F(x,v), F(w,y), A(v), D(v).
-----------^---------------------------
 Warning: Variable w only occurs once in file rule_typecompat.dl at line 47
 F(x,y) :- F(x,v), F(w,y), A(v), D(v).
 --------------------^-----------------
+Error: Unable to deduce type for variable v in file rule_typecompat.dl at line 47
+F(x,y) :- F(x,v), F(w,y), A(v), D(v).
+----------------------------^---------
+Error: Unable to deduce type for variable v in file rule_typecompat.dl at line 47
+F(x,y) :- F(x,v), F(w,y), A(v), D(v).
+----------------------------------^---
 Warning: Variable v only occurs once in file rule_typecompat.dl at line 48
 F(x,y) :- F(x,v), F(w,y), A(w), D(w).
 --------------^-----------------------
 Error: Unable to deduce type for variable w in file rule_typecompat.dl at line 48
 F(x,y) :- F(x,v), F(w,y), A(w), D(w).
 --------------------^-----------------
-Following constraints are incompatible:
-   Type of variable 'w' should be a subtype of 'R' in file rule_typecompat.dl at line 48
+Error: Unable to deduce type for variable w in file rule_typecompat.dl at line 48
 F(x,y) :- F(x,v), F(w,y), A(w), D(w).
-------------------^-------------------
-   Type of variable 'w' should be a subtype of 'T' in file rule_typecompat.dl at line 48
+----------------------------^---------
+Error: Unable to deduce type for variable w in file rule_typecompat.dl at line 48
 F(x,y) :- F(x,v), F(w,y), A(w), D(w).
---------------------------^-----------
+----------------------------------^---
 Error: Unable to deduce type for variable v in file rule_typecompat.dl at line 49
 F(x,y) :- F(x,v), F(w,y), A(w), D(v).
 --------------^-----------------------
-Following constraints are incompatible:
-   Type of variable 'v' should be a subtype of 'R' in file rule_typecompat.dl at line 49
-F(x,y) :- F(x,v), F(w,y), A(w), D(v).
---------------------------------^-----
-   Type of variable 'v' should be a subtype of 'T' in file rule_typecompat.dl at line 49
-F(x,y) :- F(x,v), F(w,y), A(w), D(v).
-----------^---------------------------
 Error: Unable to deduce type for variable w in file rule_typecompat.dl at line 49
 F(x,y) :- F(x,v), F(w,y), A(w), D(v).
 --------------------^-----------------
-Following constraints are incompatible:
-   Type of variable 'w' should be a subtype of 'R' in file rule_typecompat.dl at line 49
+Error: Unable to deduce type for variable w in file rule_typecompat.dl at line 49
 F(x,y) :- F(x,v), F(w,y), A(w), D(v).
-------------------^-------------------
-   Type of variable 'w' should be a subtype of 'T' in file rule_typecompat.dl at line 49
+----------------------------^---------
+Error: Unable to deduce type for variable v in file rule_typecompat.dl at line 49
 F(x,y) :- F(x,v), F(w,y), A(w), D(v).
---------------------------^-----------
+----------------------------------^---
 Warning: Variable w only occurs once in file rule_typecompat.dl at line 52
 F(x,y) :- F(x,v), F(w,y), !H(v), !D(v).
 --------------------^-------------------
@@ -134,23 +127,33 @@ F(x,y) :- F(x,v), F(w,y), !H(w), !D(w).
 Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 57
 F(x,y) :- F(x,y), x > y.
 --^----------------------
-Following constraints are incompatible:
-   var(y) <: var(x)
 Error: Unable to deduce type for variable y in file rule_typecompat.dl at line 57
 F(x,y) :- F(x,y), x > y.
 ----^--------------------
-Following constraints are incompatible:
-   var(x) <: var(y)
+Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 57
+F(x,y) :- F(x,y), x > y.
+------------^------------
+Error: Unable to deduce type for variable y in file rule_typecompat.dl at line 57
+F(x,y) :- F(x,y), x > y.
+--------------^----------
+Error: Unable to deduce type for variable x in file rule_typecompat.dl at line 57
+F(x,y) :- F(x,y), x > y.
+------------------^------
+Error: Unable to deduce type for variable y in file rule_typecompat.dl at line 57
+F(x,y) :- F(x,y), x > y.
+----------------------^--
 Error: Unable to deduce type for variable v in file rule_typecompat.dl at line 59
 F(x,y) :- F(x,v), F(w,y), w != v.
 --------------^-------------------
-Following constraints are incompatible:
-   var(w) <: var(v)
 Error: Unable to deduce type for variable w in file rule_typecompat.dl at line 59
 F(x,y) :- F(x,v), F(w,y), w != v.
 --------------------^-------------
-Following constraints are incompatible:
-   var(v) <: var(w)
+Error: Unable to deduce type for variable w in file rule_typecompat.dl at line 59
+F(x,y) :- F(x,v), F(w,y), w != v.
+--------------------------^-------
+Error: Unable to deduce type for variable v in file rule_typecompat.dl at line 59
+F(x,y) :- F(x,v), F(w,y), w != v.
+-------------------------------^--
 Error: Ungrounded variable t in file rule_typecompat.dl at line 62
 F(x,y) :- F(x,y), x > t.
 ----------------------^--
@@ -163,4 +166,4 @@ F(x,y) :- F(x,y), t < x.
 Warning: Variable t only occurs once in file rule_typecompat.dl at line 63
 F(x,y) :- F(x,y), t < x.
 ------------------^------
-18 errors generated, evaluation aborted
+36 errors generated, evaluation aborted
diff --git a/tests/semantic/strconv/A.csv b/tests/semantic/strconv/A.csv
index 7b74cda..a8cc0eb 100644
--- a/tests/semantic/strconv/A.csv
+++ b/tests/semantic/strconv/A.csv
@@ -1,8 +1,2 @@
--10
--4
--48879
--51966
-4
 10
-48879
-51966
+-10
diff --git a/tests/semantic/strconv/strconv.dl b/tests/semantic/strconv/strconv.dl
index 79b55c0..6b2a6c8 100644
--- a/tests/semantic/strconv/strconv.dl
+++ b/tests/semantic/strconv/strconv.dl
@@ -12,12 +12,6 @@
 
 A(x) :- x=to_number("10").
 A(x) :- x=to_number("-10").
-A(x) :- x=to_number("0xcafe").
-A(x) :- x=to_number("-0xcafe").
-A(x) :- x=to_number("0xBEEF").
-A(x) :- x=to_number("-0xBEEF").
-A(x) :- x=to_number("0b100").
-A(x) :- x=to_number("-0b100").
 
 .output A
 
diff --git a/tests/semantic/subsumption/subsumption.err b/tests/semantic/subsumption/subsumption.err
index 9d1eed8..b70f449 100644
--- a/tests/semantic/subsumption/subsumption.err
+++ b/tests/semantic/subsumption/subsumption.err
@@ -1,4 +1,4 @@
-Error: Subsumptive relation "A" must not be a nullary relation in file subsumption.dl at line 9
+Error: Subsumptive relation "A"  must not be a nullary relation in file subsumption.dl at line 9
 .decl A() btree_delete
 ------^----------------
 Warning: No subsumptive rule for relation C in file subsumption.dl at line 17
diff --git a/tests/semantic/subsumption_multiple_rules/subsumption_multiple_rules.dl b/tests/semantic/subsumption_multiple_rules/subsumption_multiple_rules.dl
index 9241d9a..9bcad02 100644
--- a/tests/semantic/subsumption_multiple_rules/subsumption_multiple_rules.dl
+++ b/tests/semantic/subsumption_multiple_rules/subsumption_multiple_rules.dl
@@ -111,3 +111,5 @@ mx(n) <= mx(n) :- my(n).
 .decl nx(x:number)
 nx(n) <= nx(n) :- nx(n).
 .output nx
+
+
diff --git a/tests/semantic/union_types/union_types.err b/tests/semantic/union_types/union_types.err
index 39ef9e9..2927484 100644
--- a/tests/semantic/union_types/union_types.err
+++ b/tests/semantic/union_types/union_types.err
@@ -10,17 +10,22 @@ The argument's declared type is one in file union_types.dl at line 20
 Error: Unable to deduce type for variable X in file union_types.dl at line 36
 E(X) :- F(X), A(X), B(X). // error
 --^--------------------------------
-Following constraints are incompatible:
-   Type of variable 'X' should be a subtype of 'one' in file union_types.dl at line 36
+Error: Unable to deduce type for variable X in file union_types.dl at line 36
+E(X) :- F(X), A(X), B(X). // error
+----------^------------------------
+Error: Unable to deduce type for variable X in file union_types.dl at line 36
 E(X) :- F(X), A(X), B(X). // error
---------------^--------------------
-   Type of variable 'X' should be a subtype of 'two' in file union_types.dl at line 36
+----------------^------------------
+Error: Unable to deduce type for variable X in file union_types.dl at line 36
 E(X) :- F(X), A(X), B(X). // error
---------------------^--------------
+----------------------^------------
 Error: Unable to deduce type for variable X in file union_types.dl at line 38
 C(X) :- D(X), !A(X). // error
 --^---------------------------
-Following constraints are incompatible:
-   Type of variable 'X' should be a subtype of 'number'
-   Type of variable 'X' should be a subtype of 'symbol'
-3 errors generated, evaluation aborted
\ No newline at end of file
+Error: Unable to deduce type for variable X in file union_types.dl at line 38
+C(X) :- D(X), !A(X). // error
+----------^-------------------
+Error: Unable to deduce type for variable X in file union_types.dl at line 38
+C(X) :- D(X), !A(X). // error
+-----------------^------------
+8 errors generated, evaluation aborted
diff --git a/tests/semantic/var_single/var_single.err b/tests/semantic/var_single/var_single.err
index 7c60660..99a244c 100644
--- a/tests/semantic/var_single/var_single.err
+++ b/tests/semantic/var_single/var_single.err
@@ -1,6 +1,9 @@
 Error: Ungrounded variable X in file var_single.dl at line 8
 A(X) :- A(Y).
 --^-----------
+Warning: Variable X only occurs once in file var_single.dl at line 8
+A(X) :- A(Y).
+--^-----------
 Warning: Variable Y only occurs once in file var_single.dl at line 8
 A(X) :- A(Y).
 ----------^---
diff --git a/tests/syntactic/CMakeLists.txt b/tests/syntactic/CMakeLists.txt
index de2ba1a..90caee1 100644
--- a/tests/syntactic/CMakeLists.txt
+++ b/tests/syntactic/CMakeLists.txt
@@ -7,14 +7,14 @@
 include(SouffleTests)
 
 function(POSITIVE_TEST NAME)
-    souffle_positive_test(${NAME} syntactic ${ARGN})
+    souffle_positive_test(${NAME} syntactic)
 endfunction()
 
 function(NEGATIVE_TEST NAME)
     souffle_negative_test(${NAME} syntactic)
 endfunction()
 
-positive_test(binary COMPILED_SPLITTED)
+positive_test(binary)
 positive_test(comment)
 positive_test(comment2)
 if (FALSE)
@@ -27,17 +27,17 @@ positive_test(duplicates)
 positive_test(empty)
 negative_test(execution_plan)
 negative_test(input)
-positive_test(input_directive3 COMPILED_SPLITTED)
+positive_test(input_directive3)
 positive_test(input_directive4)
-negative_test(input_directive_quotes2)
+positive_test(input_directive_quotes2)
 positive_test(input_directive_quotes4)
-negative_test(input_directive_quotes)
+positive_test(input_directive_quotes)
 positive_test(liberal_identifiers)
 positive_test(multiple_heads)
 positive_test(name_clash)
 positive_test(ordered_constraints)
 negative_test(output)
-positive_test(output_directive1 COMPILED_SPLITTED)
+positive_test(output_directive1)
 positive_test(output_directive_quotes2)
 positive_test(output_directive_quotes3)
 negative_test(printsize)
@@ -64,10 +64,7 @@ positive_test(type)
 positive_test(union_comp_type)
 positive_test(dot_identifiers)
 positive_test(input_adt_names1)
-positive_test(input_adt_names2)
 positive_test(input_directive_rfc4180)
-positive_test(equivalent_types_in_negation)
-negative_test(issue2408)
 if (NOT MSVC)
 # does not pass with Visual Studio pre-processor because it preserves all whitespaces
 positive_test(whitespaces)
@@ -88,70 +85,3 @@ souffle_run_test(
   CATEGORY syntactic
   NO_PREPROCESSOR
   )
-souffle_run_test(
-  TEST_NAME include_directive4
-  CATEGORY syntactic
-  INCLUDE_DIRS q1 q2
-  NO_PREPROCESSOR
-  )
-souffle_run_test(
-  TEST_NAME sourceloc1
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  NEGATIVE
-  )
-souffle_run_test(
-  TEST_NAME sourceloc2
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  NEGATIVE
-  )
-souffle_run_test(
-  TEST_NAME sourceloc3
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  NEGATIVE
-  )
-souffle_run_test(
-  TEST_NAME sourceloc4
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  NEGATIVE
-  )
-souffle_run_test(
-  TEST_NAME sourceloc5
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  NEGATIVE
-  )
-souffle_run_test(
-  TEST_NAME unterminated_comment
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  NEGATIVE
-  )
-souffle_run_test(
-  TEST_NAME annotations
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  POSITIVE
-  )
-souffle_run_test( TEST_NAME doc_comment CATEGORY syntactic NO_PREPROCESSOR POSITIVE)
-souffle_run_test(
-  TEST_NAME doc_comment_dangling1
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  POSITIVE
-  )
-souffle_run_test(
-  TEST_NAME doc_comment_dangling2
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  POSITIVE
-  )
-souffle_run_test(
-  TEST_NAME doc_comment_dangling3
-  CATEGORY syntactic
-  NO_PREPROCESSOR
-  NEGATIVE
-  )
diff --git a/tests/syntactic/dot_identifiers/dot_identifiers.dl b/tests/syntactic/dot_identifiers/dot_identifiers.dl
index 3146a52..f502e06 100644
--- a/tests/syntactic/dot_identifiers/dot_identifiers.dl
+++ b/tests/syntactic/dot_identifiers/dot_identifiers.dl
@@ -13,7 +13,6 @@
     .decl overrideA(u: number)
     .decl pragmaA(u: number)
     .decl planA(u: number)
-    .decl latticeA(u: number)
 }
 
 .init pt = ParserTest
@@ -31,4 +30,3 @@ pt.symbol_typeA(3).
 pt.overrideA(3).
 pt.pragmaA(3).
 pt.planA(3).
-pt.latticeA(3).
diff --git a/tests/syntactic/qualifiers4/qualifiers4.err b/tests/syntactic/qualifiers4/qualifiers4.err
index d85f059..62706a9 100644
--- a/tests/syntactic/qualifiers4/qualifiers4.err
+++ b/tests/syntactic/qualifiers4/qualifiers4.err
@@ -1,4 +1,4 @@
-Error: syntax error, unexpected BTREE datastructure qualifier in file qualifiers4.dl at line 12
+Error: syntax error, unexpected BTREE datastructure qualifier, expecting end of file in file qualifiers4.dl at line 12
 .decl rel3(x:symbol, y:symbol) choice-domain x,y btree
 -------------------------------------------------^-----
 1 errors generated, evaluation aborted
diff --git a/tests/syntactic/syntax1/syntax1.err b/tests/syntactic/syntax1/syntax1.err
index dce0047..4bf5f3f 100644
--- a/tests/syntactic/syntax1/syntax1.err
+++ b/tests/syntactic/syntax1/syntax1.err
@@ -1,4 +1,4 @@
-Error: syntax error, unexpected + in file syntax1.dl at line 13
+Error: syntax error, unexpected +, expecting end of file in file syntax1.dl at line 13
                     reachable(Z,Y). +
 ------------------------------------^-
 1 errors generated, evaluation aborted
diff --git a/tests/syntactic/syntax10/syntax10.err b/tests/syntactic/syntax10/syntax10.err
index b25ff8b..f653d0d 100644
--- a/tests/syntactic/syntax10/syntax10.err
+++ b/tests/syntactic/syntax10/syntax10.err
@@ -1,4 +1,4 @@
-Error: syntax error, unexpected * in file syntax10.dl at line 1
+Error: syntax error, unexpected *, expecting end of file in file syntax10.dl at line 1
 *
 ^-
 1 errors generated, evaluation aborted
diff --git a/tests/syntactic/syntax5/syntax5.err b/tests/syntactic/syntax5/syntax5.err
index 6ccc4bb..9d2bd35 100644
--- a/tests/syntactic/syntax5/syntax5.err
+++ b/tests/syntactic/syntax5/syntax5.err
@@ -1,4 +1,4 @@
-Error: syntax error, unexpected + in file syntax5.dl at line 11
+Error: syntax error, unexpected +, expecting end of file in file syntax5.dl at line 11
 +
 ^-
 1 errors generated, evaluation aborted
diff --git a/tests/syntactic/syntax6/syntax6.err b/tests/syntactic/syntax6/syntax6.err
index 9414e3e..3e7709f 100644
--- a/tests/syntactic/syntax6/syntax6.err
+++ b/tests/syntactic/syntax6/syntax6.err
@@ -1,4 +1,4 @@
-Error: syntax error, unexpected + in file syntax6.dl at line 3
+Error: syntax error, unexpected +, expecting end of file in file syntax6.dl at line 3
 +
 ^-
 1 errors generated, evaluation aborted
diff --git a/tests/syntactic/syntax8/syntax8.err b/tests/syntactic/syntax8/syntax8.err
index e7f8ef1..5b76579 100644
--- a/tests/syntactic/syntax8/syntax8.err
+++ b/tests/syntactic/syntax8/syntax8.err
@@ -1,4 +1,4 @@
-Error: syntax error, unexpected / in file syntax8.dl at line 3
+Error: syntax error, unexpected /, expecting end of file in file syntax8.dl at line 3
     / blah
 ----^------
 1 errors generated, evaluation aborted
-- 
2.32.1 (Apple Git-133)

