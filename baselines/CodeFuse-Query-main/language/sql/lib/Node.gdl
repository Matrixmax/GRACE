/**
 * @filename: Node
 * @brief: Node provides classes and predicates for working with SQL AST nodes.
 * This file is auto-generated by SQL extractor's jinja template. Do not modify. See ../extractor/README.md
 * in the source code repository for how to generate this file.
 */
schema SQLObject extends SqlObjectDO {
    
}
impl SQLObject {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLObject {
        for (tmp in SqlObjectDO(db)) {
            yield SQLObject {
                oid_ : tmp.oid_,
                parent_oid_ : tmp.parent_oid_,
                location_oid_ : tmp.location_oid_,
                node_type_ : tmp.node_type_,
                index_in_parent_ : tmp.index_in_parent_,
                after_comments_direct_ : tmp.after_comments_direct_,
                before_comments_direct_ : tmp.before_comments_direct_,
                db_type_ : tmp.db_type_,
                printable_text : tmp.printable_text
            }
        }
    }
    /**
     * @brief gets the location for the element.
     * @return Location
     */
    pub fn getLocation(self) -> Location {
        for (loc in Location(__all_data__)) {
            if (loc.oid_ = self.getLocationOid()) {
                return loc
            }
        }
    }
    /**
     * @brief gets the parent of the node.
     * @return SQLObject 
     */
    pub fn getParent(self) -> SQLObject {
        for (s in SQLObject(__all_data__)) {
            if (s.oid_ = self.getParentOid()) {
                return s
            }
        }
    }
    /**
     * @brief gets an ancestor of the element.
     * @return SQLObject 
     */
    pub fn getAnAncestor(self) -> SQLObject {
        for (ancestor in SQLObject(__all_data__)) {
            if (ancestor = self.getParent()) {
                return ancestor
            }
            if (ancestor = self.getAnAncestor().getParent()) {
                return ancestor
            }
        }
    }
    /**
     * @brief gets a hint of the element.
     * @return SQLCommentHint 
     */
    pub fn getHint(self) -> SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self = x.getParent()) {
                return x
            }
        }
    }
}
schema SQLAdhocTableSource extends SQLTableSourceImpl {
    
}
impl SQLAdhocTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAdhocTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in SqlAdhocTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAdhocTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the definition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLAdhocTableSource.getDefinition:SQLCreateTableStatement()`.
     * @return SQLCreateTableStatement
     */
    pub fn getDefinition(self) -> SQLCreateTableStatement {
        for (s in SQLCreateTableStatement(__all_data__),
            x in SqlAdhocTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefinitionOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAnnIndex extends SQLObject {
    
}
impl SQLAnnIndex {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAnnIndex {
        for (tmp in SQLObject(db)) {
            for (x in SqlAnnIndexDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAnnIndex {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the distance of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLAnnIndex.getDistance:Distance()`.
     * @return string
     */
    pub fn getDistance(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAnnIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDistance()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLAnnIndex.getIndexType:int()`.
     * @return int
     */
    pub fn getIndexType(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAnnIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIndexType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the rt index type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLAnnIndex.getRtIndexType:int()`.
     * @return int
     */
    pub fn getRtIndexType(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAnnIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRtIndexType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLArgument extends SQLObject {
    
}
impl SQLArgument {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLArgument {
        for (tmp in SQLObject(db)) {
            for (x in SqlArgumentDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLArgument {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArgument.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlArgumentDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArgument.getType:ParameterType()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlArgumentDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLArrayDataType extends SQLObject {
    
}
impl SQLArrayDataType {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLArrayDataType {
        for (tmp in SQLObject(db)) {
            for (x in SqlArrayDataTypeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLArrayDataType {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the component type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArrayDataType.getComponentType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getComponentType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlArrayDataTypeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getComponentTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is int of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArrayDataType.isInt:boolean()`.
     * @return int
     */
    pub fn isInt(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlArrayDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInt()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is numberic of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArrayDataType.isNumberic:boolean()`.
     * @return int
     */
    pub fn isNumberic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlArrayDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNumberic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is string of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArrayDataType.isString:boolean()`.
     * @return int
     */
    pub fn isString(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlArrayDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsString()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with local time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArrayDataType.isWithLocalTimeZone:boolean()`.
     * @return int
     */
    pub fn isWithLocalTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlArrayDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithLocalTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArrayDataType.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlArrayDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArrayDataType.getWithTimeZone:Boolean()`.
     * @return int
     */
    pub fn getWithTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlArrayDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the arguments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLArrayDataType.getArguments:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getArguments(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCommentHint extends SQLObject {
    
}
impl SQLCommentHint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCommentHint {
        for (tmp in SQLObject(db)) {
            for (x in SqlCommentHintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCommentHint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the text of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLCommentHint.getText:String()`.
     * @return string
     */
    pub fn getText(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCommentHintDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getText()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCurrentTimeExpr extends SQLExprImpl {
    
}
impl SQLCurrentTimeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCurrentTimeExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlCurrentTimeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCurrentTimeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLCurrentTimeExpr.getType:Type()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCurrentTimeExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCurrentUserExpr extends SQLExprImpl {
    
}
impl SQLCurrentUserExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCurrentUserExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlCurrentUserExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCurrentUserExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLDataTypeImpl extends SQLObject {
    
}
impl SQLDataTypeImpl {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDataTypeImpl {
        for (tmp in SQLObject(db)) {
            for (x in SqlDataTypeImplDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDataTypeImpl {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.getIndexBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIndexBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDataTypeImplDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is int of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.isInt:boolean()`.
     * @return int
     */
    pub fn isInt(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDataTypeImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInt()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is numberic of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.isNumberic:boolean()`.
     * @return int
     */
    pub fn isNumberic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDataTypeImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNumberic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is string of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.isString:boolean()`.
     * @return int
     */
    pub fn isString(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDataTypeImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsString()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is unsigned of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.isUnsigned:boolean()`.
     * @return int
     */
    pub fn isUnsigned(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDataTypeImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUnsigned()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with local time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.isWithLocalTimeZone:boolean()`.
     * @return int
     */
    pub fn isWithLocalTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDataTypeImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithLocalTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is zerofill of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.isZerofill:boolean()`.
     * @return int
     */
    pub fn isZerofill(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDataTypeImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsZerofill()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDataTypeImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.getWithTimeZone:Boolean()`.
     * @return int
     */
    pub fn getWithTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDataTypeImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the arguments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeImpl.getArguments:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getArguments(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLDataTypeRefExpr extends SQLExprImpl {
    
}
impl SQLDataTypeRefExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDataTypeRefExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlDataTypeRefExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDataTypeRefExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDataTypeRefExpr.getDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlDataTypeRefExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataTypeOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDeclareItem extends SQLObject {
    
}
impl SQLDeclareItem {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDeclareItem {
        for (tmp in SQLObject(db)) {
            for (x in SqlDeclareItemDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDeclareItem {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDeclareItem.getDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlDeclareItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDeclareItem.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDeclareItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved object of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDeclareItem.getResolvedObject:SQLObject()`.
     * @return string
     */
    pub fn getResolvedObject(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDeclareItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getResolvedObject()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDeclareItem.getType:Type()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDeclareItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDeclareItem.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDeclareItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table element list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLDeclareItem.getTableElementList:List<SQLTableElement>()`.
     * @return SQLTableElement
     */
    pub fn getTableElementList(self) -> *SQLTableElement {
        for (x in SQLTableElement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLIndexDefinition extends SQLObject {
    
}
impl SQLIndexDefinition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLIndexDefinition {
        for (tmp in SQLObject(db)) {
            for (x in SqlIndexDefinitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLIndexDefinition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getAlgorithm:String()`.
     * @return string
     */
    pub fn getAlgorithm(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the analyzer name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getAnalyzerName:SQLName()`.
     * @return SQLName
     */
    pub fn getAnalyzerName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAnalyzerNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the db partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getDbPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the distance measure of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getDistanceMeasure:String()`.
     * @return string
     */
    pub fn getDistanceMeasure(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDistanceMeasure()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index analyzer name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getIndexAnalyzerName:SQLName()`.
     * @return SQLName
     */
    pub fn getIndexAnalyzerName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexAnalyzerNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is hash map type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.isHashMapType:boolean()`.
     * @return int
     */
    pub fn isHashMapType(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHashMapType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is hash type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.isHashType:boolean()`.
     * @return int
     */
    pub fn isHashType(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHashType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is index of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.isIndex:boolean()`.
     * @return int
     */
    pub fn isIndex(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIndex()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.isKey:boolean()`.
     * @return int
     */
    pub fn isKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsKey()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the options oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getOptions:SQLIndexOptions()`.
     * @return SQLIndexOptions
     */
    pub fn getOptions(self) -> SQLIndexOptions {
        for (s in SQLIndexOptions(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOptionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the query analyzer name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getQueryAnalyzerName:SQLName()`.
     * @return SQLName
     */
    pub fn getQueryAnalyzerName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getQueryAnalyzerNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the symbol oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getSymbol:SQLName()`.
     * @return SQLName
     */
    pub fn getSymbol(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSymbolOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getTable:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getTable(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the tb partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getTbPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTbPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the tb partitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getTbPartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTbPartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTbPartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getType:String()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIndexDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with dic name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getWithDicName:SQLName()`.
     * @return SQLName
     */
    pub fn getWithDicName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlIndexDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWithDicNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getColumns:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getColumns(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the compatible options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getCompatibleOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getCompatibleOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the covering of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexDefinition.getCovering:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getCovering(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLIndexOptions extends SQLObject {
    
}
impl SQLIndexOptions {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLIndexOptions {
        for (tmp in SQLObject(db)) {
            for (x in SqlIndexOptionsDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLIndexOptions {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.getAlgorithm:String()`.
     * @return string
     */
    pub fn getAlgorithm(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIndexOptionsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlIndexOptionsDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.getIndexType:String()`.
     * @return string
     */
    pub fn getIndexType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIndexOptionsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIndexType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexOptionsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is invisible of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.isInvisible:boolean()`.
     * @return int
     */
    pub fn isInvisible(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexOptionsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInvisible()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexOptionsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is visible of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.isVisible:boolean()`.
     * @return int
     */
    pub fn isVisible(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlIndexOptionsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsVisible()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the key block size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.getKeyBlockSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getKeyBlockSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlIndexOptionsDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getKeyBlockSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the lock of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.getLock:String()`.
     * @return string
     */
    pub fn getLock(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIndexOptionsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLock()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parser name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.getParserName:String()`.
     * @return string
     */
    pub fn getParserName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIndexOptionsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getParserName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the other options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLIndexOptions.getOtherOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOtherOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLKeep extends SQLObject {
    
}
impl SQLKeep {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLKeep {
        for (tmp in SQLObject(db)) {
            for (x in SqlKeepDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLKeep {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the dense rank of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLKeep.getDenseRank:DenseRank()`.
     * @return string
     */
    pub fn getDenseRank(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlKeepDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDenseRank()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLKeep.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlKeepDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLLimit extends SQLObject {
    
}
impl SQLLimit {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLLimit {
        for (tmp in SQLObject(db)) {
            for (x in SqlLimitDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLLimit {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the offset oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLLimit.getOffset:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOffset(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlLimitDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOffsetOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the row count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLLimit.getRowCount:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRowCount(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlLimitDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowCountOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLLimit.getBy:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getBy(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLMapDataType extends SQLObject {
    
}
impl SQLMapDataType {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLMapDataType {
        for (tmp in SQLObject(db)) {
            for (x in SqlMapDataTypeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLMapDataType {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is int of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.isInt:boolean()`.
     * @return int
     */
    pub fn isInt(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlMapDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInt()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is numberic of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.isNumberic:boolean()`.
     * @return int
     */
    pub fn isNumberic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlMapDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNumberic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is string of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.isString:boolean()`.
     * @return int
     */
    pub fn isString(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlMapDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsString()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with local time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.isWithLocalTimeZone:boolean()`.
     * @return int
     */
    pub fn isWithLocalTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlMapDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithLocalTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the key type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.getKeyType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getKeyType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlMapDataTypeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getKeyTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlMapDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.getValueType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getValueType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlMapDataTypeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.getWithTimeZone:Boolean()`.
     * @return int
     */
    pub fn getWithTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlMapDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the arguments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLMapDataType.getArguments:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getArguments(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLOrderBy extends SQLObject {
    
}
impl SQLOrderBy {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLOrderBy {
        for (tmp in SQLObject(db)) {
            for (x in SqlOrderByDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLOrderBy {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is siblings of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOrderBy.isSiblings:boolean()`.
     * @return int
     */
    pub fn isSiblings(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlOrderByDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSiblings()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOrderBy.getItems:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getItems(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLOver extends SQLObject {
    
}
impl SQLOver {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLOver {
        for (tmp in SQLObject(db)) {
            for (x in SqlOverDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLOver {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cluster by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getClusterBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getClusterBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlOverDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getClusterByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the distribute by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getDistributeBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getDistributeBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlOverDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDistributeByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is exclude current row of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.isExcludeCurrentRow:boolean()`.
     * @return int
     */
    pub fn isExcludeCurrentRow(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlOverDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExcludeCurrentRow()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is windowing between end following of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.isWindowingBetweenEndFollowing:boolean()`.
     * @return int
     */
    pub fn isWindowingBetweenEndFollowing(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlOverDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWindowingBetweenEndFollowing()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is windowing between end preceding of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.isWindowingBetweenEndPreceding:boolean()`.
     * @return int
     */
    pub fn isWindowingBetweenEndPreceding(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlOverDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWindowingBetweenEndPreceding()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is windowing preceding of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.isWindowingPreceding:boolean()`.
     * @return int
     */
    pub fn isWindowingPreceding(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlOverDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWindowingPreceding()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the of oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getOf:SQLName()`.
     * @return SQLName
     */
    pub fn getOf(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlOverDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOfOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlOverDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the sort by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getSortBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getSortBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlOverDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSortByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the windowing between begin oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getWindowingBetweenBegin:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWindowingBetweenBegin(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlOverDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWindowingBetweenBeginOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the windowing between begin bound of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getWindowingBetweenBeginBound:WindowingBound()`.
     * @return string
     */
    pub fn getWindowingBetweenBeginBound(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlOverDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWindowingBetweenBeginBound()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the windowing between end oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getWindowingBetweenEnd:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWindowingBetweenEnd(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlOverDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWindowingBetweenEndOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the windowing between end bound of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getWindowingBetweenEndBound:WindowingBound()`.
     * @return string
     */
    pub fn getWindowingBetweenEndBound(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlOverDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWindowingBetweenEndBound()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the windowing type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getWindowingType:WindowingType()`.
     * @return string
     */
    pub fn getWindowingType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlOverDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWindowingType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLOver.getPartitionBy:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getPartitionBy(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLParameter extends SQLObject {
    
}
impl SQLParameter {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLParameter {
        for (tmp in SQLObject(db)) {
            for (x in SqlParameterDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLParameter {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cursor name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.getCursorName:SQLName()`.
     * @return SQLName
     */
    pub fn getCursorName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlParameterDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCursorNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.getDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlParameterDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the default value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.getDefaultValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDefaultValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlParameterDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefaultValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is constant of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.isConstant:boolean()`.
     * @return int
     */
    pub fn isConstant(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlParameterDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsConstant()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is map of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.isMap:boolean()`.
     * @return int
     */
    pub fn isMap(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlParameterDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsMap()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is member of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.isMember:boolean()`.
     * @return int
     */
    pub fn isMember(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlParameterDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsMember()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no copy of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.isNoCopy:boolean()`.
     * @return int
     */
    pub fn isNoCopy(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlParameterDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoCopy()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is order of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.isOrder:boolean()`.
     * @return int
     */
    pub fn isOrder(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlParameterDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrder()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlParameterDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the param type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.getParamType:ParameterType()`.
     * @return string
     */
    pub fn getParamType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlParameterDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getParamType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cursor parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLParameter.getCursorParameters:List<SQLParameter>()`.
     * @return SQLParameter
     */
    pub fn getCursorParameters(self) -> *SQLParameter {
        for (x in SQLParameter(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLPartition extends OracleSegmentAttributesImpl {
    
}
impl SQLPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPartition {
        for (tmp in OracleSegmentAttributesImpl(db)) {
            for (x in SqlPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the data directory oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getDataDirectory:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDataDirectory(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataDirectoryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index directory oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getIndexDirectory:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIndexDirectory(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexDirectoryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is segment creation deferred of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.isSegmentCreationDeferred:boolean()`.
     * @return int
     */
    pub fn isSegmentCreationDeferred(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSegmentCreationDeferred()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is segment creation immediate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.isSegmentCreationImmediate:boolean()`.
     * @return int
     */
    pub fn isSegmentCreationImmediate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSegmentCreationImmediate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lob storage of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getLobStorage:SQLObject()`.
     * @return string
     */
    pub fn getLobStorage(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLobStorage()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the locality oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getLocality:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLocality(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocalityOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the max rows oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getMaxRows:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxRows(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxRowsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the min rows oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getMinRows:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMinRows(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMinRowsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the sub partitions count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getSubPartitionsCount:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSubPartitionsCount(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubPartitionsCountOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the values oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getValues:SQLPartitionValue()`.
     * @return SQLPartitionValue
     */
    pub fn getValues(self) -> SQLPartitionValue {
        for (s in SQLPartitionValue(__all_data__),
            x in SqlPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValuesOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the sub partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartition.getSubPartitions:List<SQLSubPartition>()`.
     * @return SQLSubPartition
     */
    pub fn getSubPartitions(self) -> *SQLSubPartition {
        for (x in SQLSubPartition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLPartitionByHash extends SQLPartitionBy {
    
}
impl SQLPartitionByHash {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPartitionByHash {
        for (tmp in SQLPartitionBy(db)) {
            for (x in SqlPartitionByHashDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPartitionByHash {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByHash.isKey:boolean()`.
     * @return int
     */
    pub fn isKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPartitionByHashDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsKey()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is unique of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByHash.isUnique:boolean()`.
     * @return int
     */
    pub fn isUnique(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPartitionByHashDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUnique()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLPartitionByList extends SQLPartitionBy {
    
}
impl SQLPartitionByList {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPartitionByList {
        for (tmp in SQLPartitionBy(db)) {
            for (x in SqlPartitionByListDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPartitionByList {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLPartitionByRange extends SQLPartitionBy {
    
}
impl SQLPartitionByRange {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPartitionByRange {
        for (tmp in SQLPartitionBy(db)) {
            for (x in SqlPartitionByRangeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPartitionByRange {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expire after oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByRange.getExpireAfter:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getExpireAfter(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in SqlPartitionByRangeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExpireAfterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the interval oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByRange.getInterval:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInterval(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionByRangeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntervalOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByRange.isColumns:boolean()`.
     * @return int
     */
    pub fn isColumns(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPartitionByRangeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsColumns()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is disable schedule of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByRange.isDisableSchedule:boolean()`.
     * @return int
     */
    pub fn isDisableSchedule(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPartitionByRangeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDisableSchedule()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pivot date expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByRange.getPivotDateExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPivotDateExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionByRangeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPivotDateExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the pre allocate oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByRange.getPreAllocate:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getPreAllocate(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in SqlPartitionByRangeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPreAllocateOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the start with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionByRange.getStartWith:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStartWith(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPartitionByRangeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStartWithOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLPartitionByValue extends SQLPartitionBy {
    
}
impl SQLPartitionByValue {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPartitionByValue {
        for (tmp in SQLPartitionBy(db)) {
            for (x in SqlPartitionByValueDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPartitionByValue {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLPartitionSpec extends SQLObject {
    
}
impl SQLPartitionSpec {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPartitionSpec {
        for (tmp in SQLObject(db)) {
            for (x in SqlPartitionSpecDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPartitionSpec {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionSpec.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlPartitionSpecDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema SQLPartitionValue extends OracleSegmentAttributesImpl {
    
}
impl SQLPartitionValue {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPartitionValue {
        for (tmp in OracleSegmentAttributesImpl(db)) {
            for (x in SqlPartitionValueDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPartitionValue {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the operator of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionValue.getOperator:Operator()`.
     * @return string
     */
    pub fn getOperator(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlPartitionValueDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOperator()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLPartitionValue.getItems:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getItems(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLRecordDataType extends SQLDataTypeImpl {
    
}
impl SQLRecordDataType {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLRecordDataType {
        for (tmp in SQLDataTypeImpl(db)) {
            for (x in SqlRecordDataTypeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLRecordDataType {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRecordDataType.getColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLRowDataType extends SQLObject {
    
}
impl SQLRowDataType {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLRowDataType {
        for (tmp in SQLObject(db)) {
            for (x in SqlRowDataTypeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLRowDataType {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the fields of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRowDataType.getFields:List<Field>()`.
     * @return string
     */
    pub fn getFields(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlRowDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFields()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is int of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRowDataType.isInt:boolean()`.
     * @return int
     */
    pub fn isInt(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlRowDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInt()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is numberic of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRowDataType.isNumberic:boolean()`.
     * @return int
     */
    pub fn isNumberic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlRowDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNumberic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is string of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRowDataType.isString:boolean()`.
     * @return int
     */
    pub fn isString(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlRowDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsString()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with local time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRowDataType.isWithLocalTimeZone:boolean()`.
     * @return int
     */
    pub fn isWithLocalTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlRowDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithLocalTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRowDataType.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlRowDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRowDataType.getWithTimeZone:Boolean()`.
     * @return int
     */
    pub fn getWithTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlRowDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the arguments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLRowDataType.getArguments:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getArguments(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLStructDataType extends SQLObject {
    
}
impl SQLStructDataType {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLStructDataType {
        for (tmp in SQLObject(db)) {
            for (x in SqlStructDataTypeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLStructDataType {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the fields of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLStructDataType.getFields:List<Field>()`.
     * @return string
     */
    pub fn getFields(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlStructDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFields()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is int of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLStructDataType.isInt:boolean()`.
     * @return int
     */
    pub fn isInt(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStructDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInt()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is numberic of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLStructDataType.isNumberic:boolean()`.
     * @return int
     */
    pub fn isNumberic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStructDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNumberic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is string of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLStructDataType.isString:boolean()`.
     * @return int
     */
    pub fn isString(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStructDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsString()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with local time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLStructDataType.isWithLocalTimeZone:boolean()`.
     * @return int
     */
    pub fn isWithLocalTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStructDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithLocalTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLStructDataType.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlStructDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLStructDataType.getWithTimeZone:Boolean()`.
     * @return int
     */
    pub fn getWithTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStructDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the arguments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLStructDataType.getArguments:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getArguments(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLSubPartition extends OracleSegmentAttributesImpl {
    
}
impl SQLSubPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSubPartition {
        for (tmp in OracleSegmentAttributesImpl(db)) {
            for (x in SqlSubPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSubPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the data directory oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getDataDirectory:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDataDirectory(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataDirectoryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index directory oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getIndexDirectory:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIndexDirectory(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexDirectoryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the max rows oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getMaxRows:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxRows(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxRowsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the min rows oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getMinRows:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMinRows(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMinRowsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table space oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getTableSpace:SQLName()`.
     * @return SQLName
     */
    pub fn getTableSpace(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSpaceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the values oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartition.getValues:SQLPartitionValue()`.
     * @return SQLPartitionValue
     */
    pub fn getValues(self) -> SQLPartitionValue {
        for (s in SQLPartitionValue(__all_data__),
            x in SqlSubPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValuesOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLSubPartitionByHash extends SQLSubPartitionBy {
    
}
impl SQLSubPartitionByHash {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSubPartitionByHash {
        for (tmp in SQLSubPartitionBy(db)) {
            for (x in SqlSubPartitionByHashDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSubPartitionByHash {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartitionByHash.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSubPartitionByHashDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartitionByHash.isKey:boolean()`.
     * @return int
     */
    pub fn isKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSubPartitionByHashDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsKey()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLSubPartitionByList extends SQLSubPartitionBy {
    
}
impl SQLSubPartitionByList {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSubPartitionByList {
        for (tmp in SQLSubPartitionBy(db)) {
            for (x in SqlSubPartitionByListDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSubPartitionByList {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartitionByList.getColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlSubPartitionByListDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLSubPartitionByRange extends SQLSubPartitionBy {
    
}
impl SQLSubPartitionByRange {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSubPartitionByRange {
        for (tmp in SQLSubPartitionBy(db)) {
            for (x in SqlSubPartitionByRangeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSubPartitionByRange {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLSubPartitionByRange.getColumns:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getColumns(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLTableDataType extends SQLObject {
    
}
impl SQLTableDataType {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLTableDataType {
        for (tmp in SQLObject(db)) {
            for (x in SqlTableDataTypeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLTableDataType {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is int of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLTableDataType.isInt:boolean()`.
     * @return int
     */
    pub fn isInt(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInt()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is numberic of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLTableDataType.isNumberic:boolean()`.
     * @return int
     */
    pub fn isNumberic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNumberic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is string of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLTableDataType.isString:boolean()`.
     * @return int
     */
    pub fn isString(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsString()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with local time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLTableDataType.isWithLocalTimeZone:boolean()`.
     * @return int
     */
    pub fn isWithLocalTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithLocalTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLTableDataType.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlTableDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLTableDataType.getWithTimeZone:Boolean()`.
     * @return int
     */
    pub fn getWithTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the arguments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLTableDataType.getArguments:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getArguments(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLTableDataType.getColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLUnionDataType extends SQLDataTypeImpl {
    
}
impl SQLUnionDataType {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUnionDataType {
        for (tmp in SQLDataTypeImpl(db)) {
            for (x in SqlUnionDataTypeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUnionDataType {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLUnionDataType.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlUnionDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLUnionDataType.getItems:List<SQLDataType>()`.
     * @return SQLDataType
     */
    pub fn getItems(self) -> *SQLDataType {
        for (x in SQLDataType(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLWindow extends SQLObject {
    
}
impl SQLWindow {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLWindow {
        for (tmp in SQLObject(db)) {
            for (x in SqlWindowDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLWindow {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLWindow.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlWindowDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the over oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLWindow.getOver:SQLOver()`.
     * @return SQLOver
     */
    pub fn getOver(self) -> SQLOver {
        for (s in SQLOver(__all_data__),
            x in SqlWindowDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOverOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLZOrderBy extends SQLObject {
    
}
impl SQLZOrderBy {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLZOrderBy {
        for (tmp in SQLObject(db)) {
            for (x in SqlzOrderByDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLZOrderBy {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is sibings of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLZOrderBy.isSibings:boolean()`.
     * @return int
     */
    pub fn isSibings(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlzOrderByDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSibings()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.SQLZOrderBy.getItems:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getItems(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAggregateExpr extends SQLMethodInvokeExpr {
    
}
impl SQLAggregateExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAggregateExpr {
        for (tmp in SQLMethodInvokeExpr(db)) {
            for (x in SqlAggregateExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAggregateExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the filter oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.getFilter:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFilter(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAggregateExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFilterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the ignore nulls of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.getIgnoreNulls:Boolean()`.
     * @return int
     */
    pub fn getIgnoreNulls(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAggregateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIgnoreNulls()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is distinct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.isDistinct:boolean()`.
     * @return int
     */
    pub fn isDistinct(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAggregateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDistinct()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore nulls of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.isIgnoreNulls:boolean()`.
     * @return int
     */
    pub fn isIgnoreNulls(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAggregateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnoreNulls()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is within group of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.isWithinGroup:boolean()`.
     * @return int
     */
    pub fn isWithinGroup(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAggregateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithinGroup()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the keep oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.getKeep:SQLKeep()`.
     * @return SQLKeep
     */
    pub fn getKeep(self) -> SQLKeep {
        for (s in SQLKeep(__all_data__),
            x in SqlAggregateExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getKeepOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.getOption:SQLAggregateOption()`.
     * @return string
     */
    pub fn getOption(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAggregateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlAggregateExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the over oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.getOver:SQLOver()`.
     * @return SQLOver
     */
    pub fn getOver(self) -> SQLOver {
        for (s in SQLOver(__all_data__),
            x in SqlAggregateExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOverOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the over ref oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAggregateExpr.getOverRef:SQLName()`.
     * @return SQLName
     */
    pub fn getOverRef(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAggregateExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOverRefOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAllColumnExpr extends SQLExprImpl {
    
}
impl SQLAllColumnExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAllColumnExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlAllColumnExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAllColumnExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAllColumnExpr.getResolvedTableSource:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getResolvedTableSource(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlAllColumnExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedTableSourceOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAllExpr extends SQLExprImpl {
    
}
impl SQLAllExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAllExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlAllExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAllExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAllExpr.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlAllExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAnyExpr extends SQLExprImpl {
    
}
impl SQLAnyExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAnyExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlAnyExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAnyExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLAnyExpr.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlAnyExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLArrayExpr extends SQLExprImpl {
    
}
impl SQLArrayExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLArrayExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlArrayExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLArrayExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLArrayExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlArrayExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLArrayExpr.getValues:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getValues(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLBetweenExpr extends SQLExprImpl {
    
}
impl SQLBetweenExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBetweenExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlBetweenExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBetweenExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the begin expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBetweenExpr.getBeginExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getBeginExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlBetweenExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getBeginExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the end expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBetweenExpr.getEndExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEndExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlBetweenExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEndExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is not of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBetweenExpr.isNot:boolean()`.
     * @return int
     */
    pub fn isNot(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBetweenExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNot()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the test expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBetweenExpr.getTestExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTestExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlBetweenExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTestExprOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLBigIntExpr extends SQLNumericLiteralExpr {
    
}
impl SQLBigIntExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBigIntExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlBigIntExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBigIntExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBigIntExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlBigIntExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBigIntExpr.getValue:Long()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlBigIntExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLBinaryExpr extends SQLExprImpl {
    
}
impl SQLBinaryExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBinaryExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlBinaryExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBinaryExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the text of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryExpr.getText:String()`.
     * @return string
     */
    pub fn getText(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlBinaryExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getText()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryExpr.getValue:Number()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlBinaryExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLBinaryOpExpr extends SQLExprImpl {
    
}
impl SQLBinaryOpExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBinaryOpExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlBinaryOpExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBinaryOpExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is both name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.isBothName:boolean()`.
     * @return int
     */
    pub fn isBothName(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBinaryOpExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBothName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is left function and right literal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.isLeftFunctionAndRightLiteral:boolean()`.
     * @return int
     */
    pub fn isLeftFunctionAndRightLiteral(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBinaryOpExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLeftFunctionAndRightLiteral()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is left literal and right name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.isLeftLiteralAndRightName:boolean()`.
     * @return int
     */
    pub fn isLeftLiteralAndRightName(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBinaryOpExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLeftLiteralAndRightName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is left name and right literal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.isLeftNameAndRightLiteral:boolean()`.
     * @return int
     */
    pub fn isLeftNameAndRightLiteral(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBinaryOpExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLeftNameAndRightLiteral()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is name and literal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.isNameAndLiteral:boolean()`.
     * @return int
     */
    pub fn isNameAndLiteral(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBinaryOpExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNameAndLiteral()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is parenthesized of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.isParenthesized:boolean()`.
     * @return int
     */
    pub fn isParenthesized(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBinaryOpExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsParenthesized()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the left oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.getLeft:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLeft(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlBinaryOpExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLeftOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the operator of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.getOperator:SQLBinaryOperator()`.
     * @return string
     */
    pub fn getOperator(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlBinaryOpExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOperator()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the right oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.getRight:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRight(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlBinaryOpExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRightOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the merged list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr.getMergedList:List<SQLObject>()`.
     * @return SQLObject
     */
    pub fn getMergedList(self) -> *SQLObject {
        for (x in SQLObject(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLBinaryOpExprGroup extends SQLExprImpl {
    
}
impl SQLBinaryOpExprGroup {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBinaryOpExprGroup {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlBinaryOpExprGroupDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBinaryOpExprGroup {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the operator of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExprGroup.getOperator:SQLBinaryOperator()`.
     * @return string
     */
    pub fn getOperator(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlBinaryOpExprGroupDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOperator()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBinaryOpExprGroup.getItems:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getItems(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLBooleanExpr extends SQLExprImpl {
    
}
impl SQLBooleanExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBooleanExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlBooleanExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBooleanExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the boolean value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBooleanExpr.getBooleanValue:boolean()`.
     * @return int
     */
    pub fn getBooleanValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBooleanExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getBooleanValue()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLBooleanExpr.getValue:Boolean()`.
     * @return int
     */
    pub fn getValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBooleanExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCaseExpr extends SQLExprImpl {
    
}
impl SQLCaseExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCaseExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlCaseExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCaseExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the else expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCaseExpr.getElseExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getElseExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCaseExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getElseExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCaseExpr.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCaseExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCaseExpr.getValueExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValueExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCaseExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueExprOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLCaseStatement extends SQLStatementImpl {
    
}
impl SQLCaseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCaseStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCaseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCaseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCaseStatement.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCaseStatement.getValueExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValueExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the else statements of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCaseStatement.getElseStatements:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getElseStatements(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCastExpr extends SQLExprImpl {
    
}
impl SQLCastExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCastExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlCastExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCastExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCastExpr.getDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlCastExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCastExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCastExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is try of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCastExpr.isTry:boolean()`.
     * @return int
     */
    pub fn isTry(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCastExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTry()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCharExpr extends SQLTextLiteralExpr {
    
}
impl SQLCharExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCharExpr {
        for (tmp in SQLTextLiteralExpr(db)) {
            for (x in SqlCharExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCharExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCharExpr.getValue:Object()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCharExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLContainsExpr extends SQLExprImpl {
    
}
impl SQLContainsExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLContainsExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlContainsExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLContainsExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLContainsExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlContainsExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is not of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLContainsExpr.isNot:boolean()`.
     * @return int
     */
    pub fn isNot(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlContainsExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNot()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the target list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLContainsExpr.getTargetList:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getTargetList(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCurrentOfCursorExpr extends SQLExprImpl {
    
}
impl SQLCurrentOfCursorExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCurrentOfCursorExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlCurrentOfCursorExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCurrentOfCursorExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cursor name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLCurrentOfCursorExpr.getCursorName:SQLName()`.
     * @return SQLName
     */
    pub fn getCursorName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCurrentOfCursorExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCursorNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDateExpr extends SQLExprImpl {
    
}
impl SQLDateExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDateExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlDateExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDateExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the date of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDateExpr.getDate:Date()`.
     * @return string
     */
    pub fn getDate(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the literal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDateExpr.getLiteral:String()`.
     * @return string
     */
    pub fn getLiteral(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLiteral()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDateExpr.getValue:String()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDateTimeExpr extends SQLExprImpl {
    
}
impl SQLDateTimeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDateTimeExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlDateTimeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDateTimeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the literal oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDateTimeExpr.getLiteral:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLiteral(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDateTimeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLiteralOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDateTimeExpr.getValue:String()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDateTimeExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDbLinkExpr extends SQLExprImpl {
    
}
impl SQLDbLinkExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDbLinkExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlDbLinkExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDbLinkExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the db link of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDbLinkExpr.getDbLink:String()`.
     * @return string
     */
    pub fn getDbLink(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDbLinkExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDbLink()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDbLinkExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDbLinkExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDbLinkExpr.getResolvedColumn:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getResolvedColumn(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in SqlDbLinkExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the simple name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDbLinkExpr.getSimpleName:String()`.
     * @return string
     */
    pub fn getSimpleName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDbLinkExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSimpleName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDecimalExpr extends SQLNumericLiteralExpr {
    
}
impl SQLDecimalExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDecimalExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlDecimalExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDecimalExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the literal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDecimalExpr.getLiteral:String()`.
     * @return string
     */
    pub fn getLiteral(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDecimalExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLiteral()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDecimalExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDecimalExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDecimalExpr.getValue:BigDecimal()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDecimalExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDefaultExpr extends SQLExprImpl {
    
}
impl SQLDefaultExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDefaultExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlDefaultExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDefaultExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLDoubleExpr extends SQLNumericLiteralExpr {
    
}
impl SQLDoubleExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDoubleExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlDoubleExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDoubleExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDoubleExpr.getNumber:Double()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDoubleExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLDoubleExpr.getValue:Double()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDoubleExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLExistsExpr extends SQLExprImpl {
    
}
impl SQLExistsExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExistsExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlExistsExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExistsExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is not of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLExistsExpr.isNot:boolean()`.
     * @return int
     */
    pub fn isNot(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExistsExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNot()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLExistsExpr.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlExistsExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLExtractExpr extends SQLExprImpl {
    
}
impl SQLExtractExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExtractExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlExtractExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExtractExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the unit of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLExtractExpr.getUnit:SQLIntervalUnit()`.
     * @return string
     */
    pub fn getUnit(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlExtractExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUnit()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLExtractExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExtractExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLFlashbackExpr extends SQLExprImpl {
    
}
impl SQLFlashbackExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLFlashbackExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlFlashbackExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLFlashbackExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLFlashbackExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlFlashbackExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLFlashbackExpr.getType:Type()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlFlashbackExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLFloatExpr extends SQLNumericLiteralExpr {
    
}
impl SQLFloatExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLFloatExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlFloatExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLFloatExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLFloatExpr.getNumber:Float()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlFloatExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLFloatExpr.getValue:Float()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlFloatExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLGroupingSetExpr extends SQLExprImpl {
    
}
impl SQLGroupingSetExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLGroupingSetExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlGroupingSetExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLGroupingSetExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLGroupingSetExpr.getParameters:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getParameters(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLHexExpr extends SQLExprImpl {
    
}
impl SQLHexExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLHexExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlHexExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLHexExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hex of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLHexExpr.getHex:String()`.
     * @return string
     */
    pub fn getHex(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlHexExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHex()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLHexExpr.getValue:byte[]()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlHexExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLIdentifierExpr extends SQLExprImpl {
    
}
impl SQLIdentifierExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLIdentifierExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlIdentifierExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLIdentifierExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lower name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getLowerName:String()`.
     * @return string
     */
    pub fn getLowerName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIdentifierExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLowerName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIdentifierExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved column object of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getResolvedColumnObject:SQLObject()`.
     * @return string
     */
    pub fn getResolvedColumnObject(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIdentifierExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getResolvedColumnObject()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getResolvedColumn:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getResolvedColumn(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in SqlIdentifierExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved declare item oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getResolvedDeclareItem:SQLDeclareItem()`.
     * @return SQLDeclareItem
     */
    pub fn getResolvedDeclareItem(self) -> SQLDeclareItem {
        for (s in SQLDeclareItem(__all_data__),
            x in SqlIdentifierExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedDeclareItemOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved owner object of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getResolvedOwnerObject:SQLObject()`.
     * @return string
     */
    pub fn getResolvedOwnerObject(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIdentifierExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getResolvedOwnerObject()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved parameter oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getResolvedParameter:SQLParameter()`.
     * @return SQLParameter
     */
    pub fn getResolvedParameter(self) -> SQLParameter {
        for (s in SQLParameter(__all_data__),
            x in SqlIdentifierExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedParameterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved select item oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getResolvedSelectItem:SQLSelectItem()`.
     * @return SQLSelectItem
     */
    pub fn getResolvedSelectItem(self) -> SQLSelectItem {
        for (s in SQLSelectItem(__all_data__),
            x in SqlIdentifierExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedSelectItemOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getResolvedTableSource:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getResolvedTableSource(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlIdentifierExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the simple name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIdentifierExpr.getSimpleName:String()`.
     * @return string
     */
    pub fn getSimpleName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIdentifierExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSimpleName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLInListExpr extends SQLExprImpl {
    
}
impl SQLInListExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLInListExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlInListExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLInListExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInListExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlInListExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hint oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInListExpr.getHint:SQLCommentHint()`.
     * @return SQLCommentHint
     */
    pub fn getHint(self) -> SQLCommentHint {
        for (s in SQLCommentHint(__all_data__),
            x in SqlInListExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getHintOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is not of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInListExpr.isNot:boolean()`.
     * @return int
     */
    pub fn isNot(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlInListExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNot()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the target list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInListExpr.getTargetList:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getTargetList(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLInSubQueryExpr extends SQLExprImpl {
    
}
impl SQLInSubQueryExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLInSubQueryExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlInSubQueryExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLInSubQueryExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlInSubQueryExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hint oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr.getHint:SQLCommentHint()`.
     * @return SQLCommentHint
     */
    pub fn getHint(self) -> SQLCommentHint {
        for (s in SQLCommentHint(__all_data__),
            x in SqlInSubQueryExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getHintOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlInSubQueryExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is not of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr.isNot:boolean()`.
     * @return int
     */
    pub fn isNot(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlInSubQueryExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNot()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLInSubQueryExpr.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlInSubQueryExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLIntegerExpr extends SQLNumericLiteralExpr {
    
}
impl SQLIntegerExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLIntegerExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlIntegerExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLIntegerExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIntegerExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIntegerExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIntegerExpr.getType:String()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIntegerExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIntegerExpr.getValue:Object()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIntegerExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLIntervalExpr extends SQLExprImpl {
    
}
impl SQLIntervalExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLIntervalExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlIntervalExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLIntervalExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the unit of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIntervalExpr.getUnit:SQLIntervalUnit()`.
     * @return string
     */
    pub fn getUnit(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIntervalExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUnit()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLIntervalExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlIntervalExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLJSONExpr extends SQLExprImpl {
    
}
impl SQLJSONExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLJSONExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqljsonExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLJSONExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the literal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLJSONExpr.getLiteral:String()`.
     * @return string
     */
    pub fn getLiteral(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqljsonExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLiteral()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLJSONExpr.getValue:String()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqljsonExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLListExpr extends SQLExprImpl {
    
}
impl SQLListExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLListExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlListExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLListExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLListExpr.getItems:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getItems(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLMatchAgainstExpr extends SQLExprImpl {
    
}
impl SQLMatchAgainstExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLMatchAgainstExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlMatchAgainstExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLMatchAgainstExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the against oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMatchAgainstExpr.getAgainst:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAgainst(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlMatchAgainstExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAgainstOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the search modifier of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMatchAgainstExpr.getSearchModifier:SearchModifier()`.
     * @return string
     */
    pub fn getSearchModifier(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlMatchAgainstExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSearchModifier()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMatchAgainstExpr.getColumns:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getColumns(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLMethodInvokeExpr extends SQLExprImpl {
    
}
impl SQLMethodInvokeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLMethodInvokeExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlMethodInvokeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLMethodInvokeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the for oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getFor:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFor(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlMethodInvokeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getFrom:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFrom(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlMethodInvokeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the method name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getMethodName:String()`.
     * @return string
     */
    pub fn getMethodName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlMethodInvokeExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getMethodName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the owner oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getOwner:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOwner(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlMethodInvokeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOwnerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved return data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getResolvedReturnDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getResolvedReturnDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlMethodInvokeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedReturnDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the trim option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getTrimOption:String()`.
     * @return string
     */
    pub fn getTrimOption(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlMethodInvokeExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTrimOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getUsing:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUsing(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlMethodInvokeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the arguments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getArguments:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getArguments(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLMethodInvokeExpr.getParameters:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getParameters(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLNCharExpr extends SQLTextLiteralExpr {
    
}
impl SQLNCharExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLNCharExpr {
        for (tmp in SQLTextLiteralExpr(db)) {
            for (x in SqlnCharExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLNCharExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLNotExpr extends SQLExprImpl {
    
}
impl SQLNotExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLNotExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlNotExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLNotExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLNotExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlNotExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLNullExpr extends SQLExprImpl {
    
}
impl SQLNullExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLNullExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlNullExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLNullExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLNullExpr.getValue:Object()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlNullExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLNumberExpr extends SQLNumericLiteralExpr {
    
}
impl SQLNumberExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLNumberExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlNumberExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLNumberExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the literal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLNumberExpr.getLiteral:String()`.
     * @return string
     */
    pub fn getLiteral(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlNumberExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLiteral()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLNumberExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlNumberExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLNumberExpr.getValue:Number()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlNumberExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLPropertyExpr extends SQLExprImpl {
    
}
impl SQLPropertyExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPropertyExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlPropertyExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPropertyExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLPropertyExpr.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlPropertyExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the owner oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLPropertyExpr.getOwner:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOwner(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPropertyExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOwnerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the owner name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLPropertyExpr.getOwnerName:String()`.
     * @return string
     */
    pub fn getOwnerName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlPropertyExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOwnerName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLPropertyExpr.getResolvedColumn:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getResolvedColumn(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in SqlPropertyExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved owner object of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLPropertyExpr.getResolvedOwnerObject:SQLObject()`.
     * @return string
     */
    pub fn getResolvedOwnerObject(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlPropertyExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getResolvedOwnerObject()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved procudure oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLPropertyExpr.getResolvedProcudure:SQLCreateProcedureStatement()`.
     * @return SQLCreateProcedureStatement
     */
    pub fn getResolvedProcudure(self) -> SQLCreateProcedureStatement {
        for (s in SQLCreateProcedureStatement(__all_data__),
            x in SqlPropertyExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedProcudureOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resolved table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLPropertyExpr.getResolvedTableSource:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getResolvedTableSource(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlPropertyExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the simple name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLPropertyExpr.getSimpleName:String()`.
     * @return string
     */
    pub fn getSimpleName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlPropertyExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSimpleName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLQueryExpr extends SQLExprImpl {
    
}
impl SQLQueryExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLQueryExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlQueryExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLQueryExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLQueryExpr.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlQueryExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLRealExpr extends SQLNumericLiteralExpr {
    
}
impl SQLRealExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLRealExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlRealExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLRealExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLRealExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlRealExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLRealExpr.getValue:Float()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlRealExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLSequenceExpr extends SQLExprImpl {
    
}
impl SQLSequenceExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSequenceExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlSequenceExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSequenceExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the function of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLSequenceExpr.getFunction:Function()`.
     * @return string
     */
    pub fn getFunction(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSequenceExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFunction()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sequence oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLSequenceExpr.getSequence:SQLName()`.
     * @return SQLName
     */
    pub fn getSequence(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlSequenceExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSequenceOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLSizeExpr extends SQLExprImpl {
    
}
impl SQLSizeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSizeExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlSizeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSizeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the unit of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLSizeExpr.getUnit:Unit()`.
     * @return string
     */
    pub fn getUnit(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSizeExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUnit()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLSizeExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSizeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLSmallIntExpr extends SQLNumericLiteralExpr {
    
}
impl SQLSmallIntExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSmallIntExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlSmallIntExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSmallIntExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLSmallIntExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSmallIntExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLSmallIntExpr.getValue:Short()`.
     * @return int
     */
    pub fn getValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSmallIntExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLSomeExpr extends SQLExprImpl {
    
}
impl SQLSomeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSomeExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlSomeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSomeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLSomeExpr.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlSomeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLTimeExpr extends SQLExprImpl {
    
}
impl SQLTimeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLTimeExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlTimeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLTimeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the literal oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLTimeExpr.getLiteral:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLiteral(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlTimeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLiteralOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLTimeExpr.getValue:String()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlTimeExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLTimestampExpr extends SQLExprImpl {
    
}
impl SQLTimestampExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLTimestampExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlTimestampExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLTimestampExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLTimestampExpr.isWithTimeZone:boolean()`.
     * @return int
     */
    pub fn isWithTimeZone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTimestampExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the literal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLTimestampExpr.getLiteral:String()`.
     * @return string
     */
    pub fn getLiteral(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlTimestampExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLiteral()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the time zone of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLTimestampExpr.getTimeZone:String()`.
     * @return string
     */
    pub fn getTimeZone(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlTimestampExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTimeZone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLTimestampExpr.getValue:String()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlTimestampExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLTinyIntExpr extends SQLNumericLiteralExpr {
    
}
impl SQLTinyIntExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLTinyIntExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in SqlTinyIntExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLTinyIntExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLTinyIntExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlTinyIntExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLTinyIntExpr.getValue:Byte()`.
     * @return int
     */
    pub fn getValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTinyIntExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLUnaryExpr extends SQLExprImpl {
    
}
impl SQLUnaryExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUnaryExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlUnaryExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUnaryExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLUnaryExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlUnaryExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the operator of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLUnaryExpr.getOperator:SQLUnaryOperator()`.
     * @return string
     */
    pub fn getOperator(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlUnaryExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOperator()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLValuesExpr extends SQLExprImpl {
    
}
impl SQLValuesExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLValuesExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlValuesExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLValuesExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLValuesExpr.getValues:List<SQLListExpr>()`.
     * @return SQLListExpr
     */
    pub fn getValues(self) -> *SQLListExpr {
        for (x in SQLListExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLVariantRefExpr extends SQLExprImpl {
    
}
impl SQLVariantRefExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLVariantRefExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlVariantRefExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLVariantRefExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLVariantRefExpr.getIndex:int()`.
     * @return int
     */
    pub fn getIndex(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlVariantRefExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIndex()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLVariantRefExpr.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlVariantRefExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is session of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLVariantRefExpr.isSession:boolean()`.
     * @return int
     */
    pub fn isSession(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlVariantRefExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSession()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.expr.SQLVariantRefExpr.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlVariantRefExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLAlterCharacter extends SQLObject {
    
}
impl SQLAlterCharacter {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterCharacter {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterCharacterDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterCharacter {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the character set oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterCharacter.getCharacterSet:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCharacterSet(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterCharacterDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCharacterSetOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the collate oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterCharacter.getCollate:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCollate(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterCharacterDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCollateOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterDatabaseStatement extends SQLStatementImpl {
    
}
impl SQLAlterDatabaseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterDatabaseStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterDatabaseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterDatabaseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the character oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterDatabaseStatement.getCharacter:SQLAlterCharacter()`.
     * @return SQLAlterCharacter
     */
    pub fn getCharacter(self) -> SQLAlterCharacter {
        for (s in SQLAlterCharacter(__all_data__),
            x in SqlAlterDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCharacterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is upgrade data directory name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterDatabaseStatement.isUpgradeDataDirectoryName:boolean()`.
     * @return int
     */
    pub fn isUpgradeDataDirectoryName(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUpgradeDataDirectoryName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the item oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterDatabaseStatement.getItem:SQLAlterDatabaseItem()`.
     * @return SQLAlterDatabaseItem
     */
    pub fn getItem(self) -> SQLAlterDatabaseItem {
        for (s in SQLAlterDatabaseItem(__all_data__),
            x in SqlAlterDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getItemOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterDatabaseStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterDatabaseStatement.getProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterFunctionStatement extends SQLStatementImpl {
    
}
impl SQLAlterFunctionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterFunctionStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterFunctionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterFunctionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterFunctionStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is contains sql of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterFunctionStatement.isContainsSql:boolean()`.
     * @return int
     */
    pub fn isContainsSql(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsContainsSql()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is debug of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterFunctionStatement.isDebug:boolean()`.
     * @return int
     */
    pub fn isDebug(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDebug()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is language sql of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterFunctionStatement.isLanguageSql:boolean()`.
     * @return int
     */
    pub fn isLanguageSql(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLanguageSql()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is reuse settings of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterFunctionStatement.isReuseSettings:boolean()`.
     * @return int
     */
    pub fn isReuseSettings(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReuseSettings()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterFunctionStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the sql security oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterFunctionStatement.getSqlSecurity:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSqlSecurity(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSqlSecurityOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterIndexStatement extends SQLStatementImpl {
    
}
impl SQLAlterIndexStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterIndexStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterIndexStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterIndexStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the db partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getDbPartitionBy:SQLPartitionBy()`.
     * @return SQLPartitionBy
     */
    pub fn getDbPartitionBy(self) -> SQLPartitionBy {
        for (s in SQLPartitionBy(__all_data__),
            x in SqlAlterIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compile of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.isCompile:boolean()`.
     * @return int
     */
    pub fn isCompile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is unusable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.isUnusable:boolean()`.
     * @return int
     */
    pub fn isUnusable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUnusable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the monitoring usage of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getMonitoringUsage:Boolean()`.
     * @return int
     */
    pub fn getMonitoringUsage(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getMonitoringUsage()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the parallel oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getParallel:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getParallel(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getParallelOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the rebuild of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getRebuild:Rebuild()`.
     * @return string
     */
    pub fn getRebuild(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRebuild()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the rename to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getRenameTo:SQLName()`.
     * @return SQLName
     */
    pub fn getRenameTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRenameToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlAlterIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterIndexStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterMaterializedViewStatement extends SQLStatementImpl {
    
}
impl SQLAlterMaterializedViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterMaterializedViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterMaterializedViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterMaterializedViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable query rewrite of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.getEnableQueryRewrite:Boolean()`.
     * @return int
     */
    pub fn getEnableQueryRewrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnableQueryRewrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is rebuild of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRebuild:boolean()`.
     * @return int
     */
    pub fn isRebuild(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRebuild()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefresh:boolean()`.
     * @return int
     */
    pub fn isRefresh(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefresh()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh complete of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefreshComplete:boolean()`.
     * @return int
     */
    pub fn isRefreshComplete(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshComplete()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh fast of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefreshFast:boolean()`.
     * @return int
     */
    pub fn isRefreshFast(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshFast()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefreshForce:boolean()`.
     * @return int
     */
    pub fn isRefreshForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh next of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefreshNext:boolean()`.
     * @return int
     */
    pub fn isRefreshNext(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshNext()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh on commit of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefreshOnCommit:boolean()`.
     * @return int
     */
    pub fn isRefreshOnCommit(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshOnCommit()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh on demand of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefreshOnDemand:boolean()`.
     * @return int
     */
    pub fn isRefreshOnDemand(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshOnDemand()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh on over write of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefreshOnOverWrite:boolean()`.
     * @return int
     */
    pub fn isRefreshOnOverWrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshOnOverWrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh start with of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.isRefreshStartWith:boolean()`.
     * @return int
     */
    pub fn isRefreshStartWith(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshStartWith()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the next oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.getNext:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNext(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNextOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the start with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.getStartWith:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStartWith(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStartWithOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterMaterializedViewStatement.getPartitions:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getPartitions(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterOutlineStatement extends SQLStatementImpl {
    
}
impl SQLAlterOutlineStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterOutlineStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterOutlineStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterOutlineStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is disable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterOutlineStatement.isDisable:boolean()`.
     * @return int
     */
    pub fn isDisable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterOutlineStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDisable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterOutlineStatement.isEnable:boolean()`.
     * @return int
     */
    pub fn isEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterOutlineStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is resync of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterOutlineStatement.isResync:boolean()`.
     * @return int
     */
    pub fn isResync(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterOutlineStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsResync()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterOutlineStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterOutlineStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterProcedureStatement extends SQLStatementImpl {
    
}
impl SQLAlterProcedureStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterProcedureStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterProcedureStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterProcedureStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterProcedureStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is compile of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterProcedureStatement.isCompile:boolean()`.
     * @return int
     */
    pub fn isCompile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is contains sql of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterProcedureStatement.isContainsSql:boolean()`.
     * @return int
     */
    pub fn isContainsSql(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsContainsSql()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is language sql of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterProcedureStatement.isLanguageSql:boolean()`.
     * @return int
     */
    pub fn isLanguageSql(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLanguageSql()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is reuse settings of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterProcedureStatement.isReuseSettings:boolean()`.
     * @return int
     */
    pub fn isReuseSettings(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReuseSettings()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterProcedureStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the sql security oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterProcedureStatement.getSqlSecurity:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSqlSecurity(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSqlSecurityOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterSequenceStatement extends SQLStatementImpl {
    
}
impl SQLAlterSequenceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterSequenceStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterSequenceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterSequenceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getCache:Boolean()`.
     * @return int
     */
    pub fn getCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cache value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getCacheValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCacheValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCacheValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the cycle of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getCycle:Boolean()`.
     * @return int
     */
    pub fn getCycle(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCycle()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the increment by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getIncrementBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIncrementBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIncrementByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is change to group of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.isChangeToGroup:boolean()`.
     * @return int
     */
    pub fn isChangeToGroup(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsChangeToGroup()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is change to simple of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.isChangeToSimple:boolean()`.
     * @return int
     */
    pub fn isChangeToSimple(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsChangeToSimple()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is change to time of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.isChangeToTime:boolean()`.
     * @return int
     */
    pub fn isChangeToTime(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsChangeToTime()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no max value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.isNoMaxValue:boolean()`.
     * @return int
     */
    pub fn isNoMaxValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoMaxValue()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no min value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.isNoMinValue:boolean()`.
     * @return int
     */
    pub fn isNoMinValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoMinValue()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restart of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.isRestart:boolean()`.
     * @return int
     */
    pub fn isRestart(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestart()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the max value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getMaxValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the min value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getMinValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMinValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMinValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getOrder:Boolean()`.
     * @return int
     */
    pub fn getOrder(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOrder()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the restart with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getRestartWith:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRestartWith(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRestartWithOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the start with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getStartWith:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStartWith(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStartWithOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSequenceStatement.getWithCache:Boolean()`.
     * @return int
     */
    pub fn getWithCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithCache()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLAlterSystemGetConfigStatement extends SQLStatementImpl {
    
}
impl SQLAlterSystemGetConfigStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterSystemGetConfigStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterSystemGetConfigStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterSystemGetConfigStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSystemGetConfigStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterSystemGetConfigStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterSystemSetConfigStatement extends SQLStatementImpl {
    
}
impl SQLAlterSystemSetConfigStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterSystemSetConfigStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterSystemSetConfigStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterSystemSetConfigStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterSystemSetConfigStatement.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableAddClusteringKey extends SQLObject {
    
}
impl SQLAlterTableAddClusteringKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAddClusteringKey {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAddClusteringKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAddClusteringKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddClusteringKey.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableAddClusteringKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddClusteringKey.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableAddColumn extends SQLObject {
    
}
impl SQLAlterTableAddColumn {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAddColumn {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAddColumnDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAddColumn {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the after column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddColumn.getAfterColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getAfterColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableAddColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAfterColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the first column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddColumn.getFirstColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getFirstColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableAddColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFirstColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddColumn.isCascade:boolean()`.
     * @return int
     */
    pub fn isCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is first of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddColumn.isFirst:boolean()`.
     * @return int
     */
    pub fn isFirst(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFirst()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddColumn.isRestrict:boolean()`.
     * @return int
     */
    pub fn isRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestrict()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddColumn.getRestrict:Boolean()`.
     * @return int
     */
    pub fn getRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRestrict()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddColumn.getColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableAddConstraint extends SQLObject {
    
}
impl SQLAlterTableAddConstraint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAddConstraint {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAddConstraintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAddConstraint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the constraint oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddConstraint.getConstraint:SQLConstraint()`.
     * @return SQLConstraint
     */
    pub fn getConstraint(self) -> SQLConstraint {
        for (s in SQLConstraint(__all_data__),
            x in SqlAlterTableAddConstraintDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConstraintOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is with no check of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddConstraint.isWithNoCheck:boolean()`.
     * @return int
     */
    pub fn isWithNoCheck(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddConstraintDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithNoCheck()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLAlterTableAddExtPartition extends SQLObject {
    
}
impl SQLAlterTableAddExtPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAddExtPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAddExtPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAddExtPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the ext partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddExtPartition.getExtPartition:MySqlExtPartition()`.
     * @return MySqlExtPartition
     */
    pub fn getExtPartition(self) -> MySqlExtPartition {
        for (s in MySqlExtPartition(__all_data__),
            x in SqlAlterTableAddExtPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExtPartitionOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableAddIndex extends SQLObject {
    
}
impl SQLAlterTableAddIndex {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAddIndex {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAddIndexDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAddIndex {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getAlgorithm:String()`.
     * @return string
     */
    pub fn getAlgorithm(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAddIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the db partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getDbPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAddIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the distance measure of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getDistanceMeasure:String()`.
     * @return string
     */
    pub fn getDistanceMeasure(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDistanceMeasure()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index definition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getIndexDefinition:SQLIndexDefinition()`.
     * @return SQLIndexDefinition
     */
    pub fn getIndexDefinition(self) -> SQLIndexDefinition {
        for (s in SQLIndexDefinition(__all_data__),
            x in SqlAlterTableAddIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexDefinitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is hash map type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.isHashMapType:boolean()`.
     * @return int
     */
    pub fn isHashMapType(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHashMapType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.isKey:boolean()`.
     * @return int
     */
    pub fn isKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsKey()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is unique of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.isUnique:boolean()`.
     * @return int
     */
    pub fn isUnique(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUnique()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the key block size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getKeyBlockSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getKeyBlockSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAddIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getKeyBlockSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableAddIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the parser name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getParserName:String()`.
     * @return string
     */
    pub fn getParserName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getParserName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getTablePartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAddIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table partitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getTablePartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAddIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getType:String()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getUsing:String()`.
     * @return string
     */
    pub fn getUsing(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAddIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUsing()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getColumns:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getColumns(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the covering of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getCovering:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getCovering(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getItems:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getItems(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddIndex.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableAddPartition extends SQLObject {
    
}
impl SQLAlterTableAddPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAddPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAddPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAddPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddPartition.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAddPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the location oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddPartition.getLocation:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLocation(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAddPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddPartition.getPartitionCount:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPartitionCount(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAddPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionCountOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddPartition.getPartitions:List<SQLObject>()`.
     * @return SQLObject
     */
    pub fn getPartitions(self) -> *SQLObject {
        for (x in SQLObject(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableAddSupplemental extends SQLObject {
    
}
impl SQLAlterTableAddSupplemental {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAddSupplemental {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAddSupplementalDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAddSupplemental {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the element oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAddSupplemental.getElement:SQLTableElement()`.
     * @return SQLTableElement
     */
    pub fn getElement(self) -> SQLTableElement {
        for (s in SQLTableElement(__all_data__),
            x in SqlAlterTableAddSupplementalDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getElementOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableAlterColumn extends SQLObject {
    
}
impl SQLAlterTableAlterColumn {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAlterColumn {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAlterColumnDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAlterColumn {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the after oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.getAfter:SQLName()`.
     * @return SQLName
     */
    pub fn getAfter(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableAlterColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAfterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.getColumn:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumn(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in SqlAlterTableAlterColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.getDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlAlterTableAlterColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is drop default of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.isDropDefault:boolean()`.
     * @return int
     */
    pub fn isDropDefault(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAlterColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDropDefault()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is drop not null of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.isDropNotNull:boolean()`.
     * @return int
     */
    pub fn isDropNotNull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAlterColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDropNotNull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is first of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.isFirst:boolean()`.
     * @return int
     */
    pub fn isFirst(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAlterColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFirst()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is set not null of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.isSetNotNull:boolean()`.
     * @return int
     */
    pub fn isSetNotNull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAlterColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSetNotNull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the origin column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.getOriginColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getOriginColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableAlterColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOriginColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the set default oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterColumn.getSetDefault:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSetDefault(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAlterColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSetDefaultOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableAlterIndex extends SQLObject {
    
}
impl SQLAlterTableAlterIndex {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAlterIndex {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAlterIndexDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAlterIndex {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getAlgorithm:String()`.
     * @return string
     */
    pub fn getAlgorithm(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAlterIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the db partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getDbPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAlterIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the distance measure of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getDistanceMeasure:String()`.
     * @return string
     */
    pub fn getDistanceMeasure(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDistanceMeasure()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index definition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getIndexDefinition:SQLIndexDefinition()`.
     * @return SQLIndexDefinition
     */
    pub fn getIndexDefinition(self) -> SQLIndexDefinition {
        for (s in SQLIndexDefinition(__all_data__),
            x in SqlAlterTableAlterIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexDefinitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is hash map type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.isHashMapType:boolean()`.
     * @return int
     */
    pub fn isHashMapType(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHashMapType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.isKey:boolean()`.
     * @return int
     */
    pub fn isKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsKey()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is unique of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.isUnique:boolean()`.
     * @return int
     */
    pub fn isUnique(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUnique()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the key block size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getKeyBlockSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getKeyBlockSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAlterIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getKeyBlockSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableAlterIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the parser name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getParserName:String()`.
     * @return string
     */
    pub fn getParserName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getParserName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getTablePartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAlterIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table partitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getTablePartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableAlterIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getType:String()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getUsing:String()`.
     * @return string
     */
    pub fn getUsing(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableAlterIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUsing()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getColumns:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getColumns(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the covering of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getCovering:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getCovering(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getItems:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getItems(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAlterIndex.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableAnalyzePartition extends SQLObject {
    
}
impl SQLAlterTableAnalyzePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableAnalyzePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableAnalyzePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableAnalyzePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableAnalyzePartition.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableArchivePartition extends SQLObject {
    
}
impl SQLAlterTableArchivePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableArchivePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableArchivePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableArchivePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableArchivePartition.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableBlockSize extends SQLObject {
    
}
impl SQLAlterTableBlockSize {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableBlockSize {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableBlockSizeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableBlockSize {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableBlockSize.getSize:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getSize(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in SqlAlterTableBlockSizeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSizeOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableChangeOwner extends SQLObject {
    
}
impl SQLAlterTableChangeOwner {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableChangeOwner {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableChangeOwnerDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableChangeOwner {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the owner oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableChangeOwner.getOwner:SQLName()`.
     * @return SQLName
     */
    pub fn getOwner(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableChangeOwnerDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOwnerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableChangeOwner.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableCheckPartition extends SQLObject {
    
}
impl SQLAlterTableCheckPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableCheckPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableCheckPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableCheckPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableCheckPartition.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableCoalescePartition extends SQLObject {
    
}
impl SQLAlterTableCoalescePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableCoalescePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableCoalescePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableCoalescePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableCoalescePartition.getCount:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCount(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableCoalescePartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCountOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableCompression extends SQLObject {
    
}
impl SQLAlterTableCompression {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableCompression {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableCompressionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableCompression {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableCompression.getName:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getName(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in SqlAlterTableCompressionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableConvertCharSet extends SQLObject {
    
}
impl SQLAlterTableConvertCharSet {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableConvertCharSet {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableConvertCharSetDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableConvertCharSet {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the charset oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableConvertCharSet.getCharset:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCharset(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableConvertCharSetDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCharsetOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the collate oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableConvertCharSet.getCollate:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCollate(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableConvertCharSetDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCollateOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableDeleteByCondition extends SQLObject {
    
}
impl SQLAlterTableDeleteByCondition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDeleteByCondition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDeleteByConditionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDeleteByCondition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDeleteByCondition.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableDeleteByConditionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableDisableConstraint extends SQLObject {
    
}
impl SQLAlterTableDisableConstraint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDisableConstraint {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDisableConstraintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDisableConstraint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the constraint name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDisableConstraint.getConstraintName:SQLName()`.
     * @return SQLName
     */
    pub fn getConstraintName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableDisableConstraintDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConstraintNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableDisableKeys extends SQLObject {
    
}
impl SQLAlterTableDisableKeys {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDisableKeys {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDisableKeysDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDisableKeys {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLAlterTableDisableLifecycle extends SQLObject {
    
}
impl SQLAlterTableDisableLifecycle {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDisableLifecycle {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDisableLifecycleDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDisableLifecycle {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDisableLifecycle.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableDiscardPartition extends SQLObject {
    
}
impl SQLAlterTableDiscardPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDiscardPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDiscardPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDiscardPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is tablespace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDiscardPartition.isTablespace:boolean()`.
     * @return int
     */
    pub fn isTablespace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableDiscardPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTablespace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDiscardPartition.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableDropClusteringKey extends SQLObject {
    
}
impl SQLAlterTableDropClusteringKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropClusteringKey {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropClusteringKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropClusteringKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the key name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropClusteringKey.getKeyName:SQLName()`.
     * @return SQLName
     */
    pub fn getKeyName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableDropClusteringKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getKeyNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableDropColumnItem extends SQLObject {
    
}
impl SQLAlterTableDropColumnItem {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropColumnItem {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropColumnItemDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropColumnItem {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropColumnItem.isCascade:boolean()`.
     * @return int
     */
    pub fn isCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableDropColumnItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropColumnItem.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableDropConstraint extends SQLObject {
    
}
impl SQLAlterTableDropConstraint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropConstraint {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropConstraintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropConstraint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the constraint name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropConstraint.getConstraintName:SQLName()`.
     * @return SQLName
     */
    pub fn getConstraintName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableDropConstraintDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConstraintNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropConstraint.isCascade:boolean()`.
     * @return int
     */
    pub fn isCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableDropConstraintDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropConstraint.isRestrict:boolean()`.
     * @return int
     */
    pub fn isRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableDropConstraintDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestrict()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLAlterTableDropExtPartition extends SQLObject {
    
}
impl SQLAlterTableDropExtPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropExtPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropExtPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropExtPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the ext partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropExtPartition.getExtPartition:MySqlExtPartition()`.
     * @return MySqlExtPartition
     */
    pub fn getExtPartition(self) -> MySqlExtPartition {
        for (s in MySqlExtPartition(__all_data__),
            x in SqlAlterTableDropExtPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExtPartitionOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableDropForeignKey extends SQLObject {
    
}
impl SQLAlterTableDropForeignKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropForeignKey {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropForeignKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropForeignKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropForeignKey.getIndexName:SQLName()`.
     * @return SQLName
     */
    pub fn getIndexName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableDropForeignKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableDropIndex extends SQLObject {
    
}
impl SQLAlterTableDropIndex {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropIndex {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropIndexDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropIndex {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropIndex.getIndexName:SQLName()`.
     * @return SQLName
     */
    pub fn getIndexName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableDropIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableDropKey extends SQLObject {
    
}
impl SQLAlterTableDropKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropKey {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the key name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropKey.getKeyName:SQLName()`.
     * @return SQLName
     */
    pub fn getKeyName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableDropKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getKeyNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableDropPartition extends SQLObject {
    
}
impl SQLAlterTableDropPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropPartition.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableDropPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is purge of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropPartition.isPurge:boolean()`.
     * @return int
     */
    pub fn isPurge(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableDropPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPurge()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropPartition.getPartitions:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getPartitions(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableDropPrimaryKey extends SQLObject {
    
}
impl SQLAlterTableDropPrimaryKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropPrimaryKey {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropPrimaryKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropPrimaryKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLAlterTableDropSubpartition extends SQLObject {
    
}
impl SQLAlterTableDropSubpartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableDropSubpartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableDropSubpartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableDropSubpartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropSubpartition.getPartitionIds:List<SQLIntegerExpr>()`.
     * @return SQLIntegerExpr
     */
    pub fn getPartitionIds(self) -> *SQLIntegerExpr {
        for (x in SQLIntegerExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the subpartition ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableDropSubpartition.getSubpartitionIds:List<SQLIntegerExpr>()`.
     * @return SQLIntegerExpr
     */
    pub fn getSubpartitionIds(self) -> *SQLIntegerExpr {
        for (x in SQLIntegerExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableEnableConstraint extends SQLObject {
    
}
impl SQLAlterTableEnableConstraint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableEnableConstraint {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableEnableConstraintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableEnableConstraint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the constraint name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableEnableConstraint.getConstraintName:SQLName()`.
     * @return SQLName
     */
    pub fn getConstraintName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableEnableConstraintDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConstraintNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableEnableKeys extends SQLObject {
    
}
impl SQLAlterTableEnableKeys {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableEnableKeys {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableEnableKeysDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableEnableKeys {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLAlterTableEnableLifecycle extends SQLObject {
    
}
impl SQLAlterTableEnableLifecycle {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableEnableLifecycle {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableEnableLifecycleDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableEnableLifecycle {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableEnableLifecycle.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableExchangePartition extends SQLObject {
    
}
impl SQLAlterTableExchangePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableExchangePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableExchangePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableExchangePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableExchangePartition.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlAlterTableExchangePartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the validation of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableExchangePartition.getValidation:Boolean()`.
     * @return int
     */
    pub fn getValidation(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableExchangePartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValidation()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableExchangePartition.getPartitions:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getPartitions(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableGroupStatement extends SQLStatementImpl {
    
}
impl SQLAlterTableGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableGroupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterTableGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableGroupStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableGroupStatement.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableImportPartition extends SQLObject {
    
}
impl SQLAlterTableImportPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableImportPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableImportPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableImportPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is tablespace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableImportPartition.isTablespace:boolean()`.
     * @return int
     */
    pub fn isTablespace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableImportPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTablespace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableImportPartition.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableMergePartition extends SQLObject {
    
}
impl SQLAlterTableMergePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableMergePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableMergePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableMergePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableMergePartition.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableMergePartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is purge of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableMergePartition.isPurge:boolean()`.
     * @return int
     */
    pub fn isPurge(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableMergePartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPurge()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the overwrite partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableMergePartition.getOverwritePartition:SQLPartitionSpec()`.
     * @return SQLPartitionSpec
     */
    pub fn getOverwritePartition(self) -> SQLPartitionSpec {
        for (s in SQLPartitionSpec(__all_data__),
            x in SqlAlterTableMergePartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOverwritePartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableMergePartition.getPartitions:List<SQLPartitionSpec>()`.
     * @return SQLPartitionSpec
     */
    pub fn getPartitions(self) -> *SQLPartitionSpec {
        for (x in SQLPartitionSpec(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableModifyClusteredBy extends SQLObject {
    
}
impl SQLAlterTableModifyClusteredBy {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableModifyClusteredBy {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableModifyClusteredByDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableModifyClusteredBy {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cluster columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableModifyClusteredBy.getClusterColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getClusterColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableOptimizePartition extends SQLObject {
    
}
impl SQLAlterTableOptimizePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableOptimizePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableOptimizePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableOptimizePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableOptimizePartition.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTablePartition extends SQLObject {
    
}
impl SQLAlterTablePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTablePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTablePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTablePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTablePartition.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTablePartitionCount extends SQLObject {
    
}
impl SQLAlterTablePartitionCount {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTablePartitionCount {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTablePartitionCountDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTablePartitionCount {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTablePartitionCount.getCount:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getCount(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in SqlAlterTablePartitionCountDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCountOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTablePartitionLifecycle extends SQLObject {
    
}
impl SQLAlterTablePartitionLifecycle {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTablePartitionLifecycle {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTablePartitionLifecycleDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTablePartitionLifecycle {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lifecycle oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTablePartitionLifecycle.getLifecycle:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getLifecycle(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in SqlAlterTablePartitionLifecycleDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLifecycleOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTablePartitionSetProperties extends SQLObject {
    
}
impl SQLAlterTablePartitionSetProperties {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTablePartitionSetProperties {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTablePartitionSetPropertiesDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTablePartitionSetProperties {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTablePartitionSetProperties.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partition properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTablePartitionSetProperties.getPartitionProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitionProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableReOrganizePartition extends SQLObject {
    
}
impl SQLAlterTableReOrganizePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableReOrganizePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableReOrganizePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableReOrganizePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the names of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableReOrganizePartition.getNames:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getNames(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableReOrganizePartition.getPartitions:List<SQLObject>()`.
     * @return SQLObject
     */
    pub fn getPartitions(self) -> *SQLObject {
        for (x in SQLObject(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableRebuildPartition extends SQLObject {
    
}
impl SQLAlterTableRebuildPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableRebuildPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableRebuildPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableRebuildPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRebuildPartition.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableRecoverPartitions extends SQLObject {
    
}
impl SQLAlterTableRecoverPartitions {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableRecoverPartitions {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableRecoverPartitionsDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableRecoverPartitions {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRecoverPartitions.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableRename extends SQLObject {
    
}
impl SQLAlterTableRename {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableRename {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableRenameDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableRename {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the to name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRename.getToName:SQLName()`.
     * @return SQLName
     */
    pub fn getToName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableRenameDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRename.getTo:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTo(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlAlterTableRenameDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableRenameColumn extends SQLObject {
    
}
impl SQLAlterTableRenameColumn {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableRenameColumn {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableRenameColumnDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableRenameColumn {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRenameColumn.getColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableRenameColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRenameColumn.getTo:SQLName()`.
     * @return SQLName
     */
    pub fn getTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableRenameColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableRenameIndex extends SQLObject {
    
}
impl SQLAlterTableRenameIndex {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableRenameIndex {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableRenameIndexDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableRenameIndex {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRenameIndex.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableRenameIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRenameIndex.getTo:SQLName()`.
     * @return SQLName
     */
    pub fn getTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableRenameIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableRenamePartition extends SQLObject {
    
}
impl SQLAlterTableRenamePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableRenamePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableRenamePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableRenamePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRenamePartition.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableRenamePartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRenamePartition.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the to of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRenamePartition.getTo:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getTo(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableRepairPartition extends SQLObject {
    
}
impl SQLAlterTableRepairPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableRepairPartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableRepairPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableRepairPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableRepairPartition.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableReplaceColumn extends SQLObject {
    
}
impl SQLAlterTableReplaceColumn {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableReplaceColumn {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableReplaceColumnDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableReplaceColumn {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the after column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableReplaceColumn.getAfterColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getAfterColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableReplaceColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAfterColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the first column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableReplaceColumn.getFirstColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getFirstColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableReplaceColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFirstColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is first of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableReplaceColumn.isFirst:boolean()`.
     * @return int
     */
    pub fn isFirst(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableReplaceColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFirst()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableReplaceColumn.getColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableSetComment extends SQLObject {
    
}
impl SQLAlterTableSetComment {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableSetComment {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableSetCommentDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableSetComment {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableSetComment.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableSetCommentDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableSetLifecycle extends SQLObject {
    
}
impl SQLAlterTableSetLifecycle {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableSetLifecycle {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableSetLifecycleDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableSetLifecycle {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lifecycle oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableSetLifecycle.getLifecycle:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLifecycle(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableSetLifecycleDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLifecycleOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableSetLocation extends SQLObject {
    
}
impl SQLAlterTableSetLocation {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableSetLocation {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableSetLocationDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableSetLocation {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the location oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableSetLocation.getLocation:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLocation(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAlterTableSetLocationDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocationOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableSetOption extends SQLObject {
    
}
impl SQLAlterTableSetOption {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableSetOption {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableSetOptionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableSetOption {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableSetOption.getOn:SQLName()`.
     * @return SQLName
     */
    pub fn getOn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableSetOptionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableSetOption.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableStatement extends SQLStatementImpl {
    
}
impl SQLAlterTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the buckets of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getBuckets:int()`.
     * @return int
     */
    pub fn getBuckets(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getBuckets()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isIgnore:boolean()`.
     * @return int
     */
    pub fn isIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is invalidate global indexes of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isInvalidateGlobalIndexes:boolean()`.
     * @return int
     */
    pub fn isInvalidateGlobalIndexes(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInvalidateGlobalIndexes()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is merge small files of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isMergeSmallFiles:boolean()`.
     * @return int
     */
    pub fn isMergeSmallFiles(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsMergeSmallFiles()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is not clustered of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isNotClustered:boolean()`.
     * @return int
     */
    pub fn isNotClustered(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNotClustered()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is offline of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isOffline:boolean()`.
     * @return int
     */
    pub fn isOffline(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOffline()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is online of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isOnline:boolean()`.
     * @return int
     */
    pub fn isOnline(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnline()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is range of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isRange:boolean()`.
     * @return int
     */
    pub fn isRange(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRange()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is remove patiting of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isRemovePatiting:boolean()`.
     * @return int
     */
    pub fn isRemovePatiting(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRemovePatiting()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is update global indexes of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isUpdateGlobalIndexes:boolean()`.
     * @return int
     */
    pub fn isUpdateGlobalIndexes(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUpdateGlobalIndexes()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is upgrade patiting of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.isUpgradePatiting:boolean()`.
     * @return int
     */
    pub fn isUpgradePatiting(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUpgradePatiting()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getPartition:SQLPartitionBy()`.
     * @return SQLPartitionBy
     */
    pub fn getPartition(self) -> SQLPartitionBy {
        for (s in SQLPartitionBy(__all_data__),
            x in SqlAlterTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the shards of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getShards:int()`.
     * @return int
     */
    pub fn getShards(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getShards()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getTableName:String()`.
     * @return string
     */
    pub fn getTableName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTableName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlAlterTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the clustered by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getClusteredBy:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getClusteredBy(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getItems:List<SQLAlterTableItem>()`.
     * @return SQLAlterTableItem
     */
    pub fn getItems(self) -> *SQLAlterTableItem {
        for (x in SQLAlterTableItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the sorted by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getSortedBy:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getSortedBy(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the table options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableStatement.getTableOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getTableOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableSubpartitionAvailablePartitionNum extends SQLObject {
    
}
impl SQLAlterTableSubpartitionAvailablePartitionNum {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableSubpartitionAvailablePartitionNum {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableSubpartitionAvailablePartitionNumDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableSubpartitionAvailablePartitionNum {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableSubpartitionAvailablePartitionNum.getNumber:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getNumber(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in SqlAlterTableSubpartitionAvailablePartitionNumDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNumberOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterTableSubpartitionLifecycle extends SQLObject {
    
}
impl SQLAlterTableSubpartitionLifecycle {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableSubpartitionLifecycle {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableSubpartitionLifecycleDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableSubpartitionLifecycle {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableSubpartitionLifecycle.getPartitionIds:List<SQLIntegerExpr>()`.
     * @return SQLIntegerExpr
     */
    pub fn getPartitionIds(self) -> *SQLIntegerExpr {
        for (x in SQLIntegerExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the subpartition life cycle of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableSubpartitionLifecycle.getSubpartitionLifeCycle:List<SQLIntegerExpr>()`.
     * @return SQLIntegerExpr
     */
    pub fn getSubpartitionLifeCycle(self) -> *SQLIntegerExpr {
        for (x in SQLIntegerExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableTouch extends SQLObject {
    
}
impl SQLAlterTableTouch {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableTouch {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableTouchDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableTouch {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableTouch.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableTruncatePartition extends SQLObject {
    
}
impl SQLAlterTableTruncatePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableTruncatePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableTruncatePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableTruncatePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableTruncatePartition.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTableUnarchivePartition extends SQLObject {
    
}
impl SQLAlterTableUnarchivePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTableUnarchivePartition {
        for (tmp in SQLObject(db)) {
            for (x in SqlAlterTableUnarchivePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTableUnarchivePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTableUnarchivePartition.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAlterTypeStatement extends SQLStatementImpl {
    
}
impl SQLAlterTypeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterTypeStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterTypeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterTypeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is body of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTypeStatement.isBody:boolean()`.
     * @return int
     */
    pub fn isBody(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBody()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compile of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTypeStatement.isCompile:boolean()`.
     * @return int
     */
    pub fn isCompile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is debug of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTypeStatement.isDebug:boolean()`.
     * @return int
     */
    pub fn isDebug(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDebug()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is reuse settings of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTypeStatement.isReuseSettings:boolean()`.
     * @return int
     */
    pub fn isReuseSettings(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReuseSettings()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterTypeStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterViewRenameStatement extends SQLStatementImpl {
    
}
impl SQLAlterViewRenameStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterViewRenameStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterViewRenameStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterViewRenameStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the change owner to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewRenameStatement.getChangeOwnerTo:SQLName()`.
     * @return SQLName
     */
    pub fn getChangeOwnerTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterViewRenameStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getChangeOwnerToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewRenameStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterViewRenameStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewRenameStatement.getTo:SQLName()`.
     * @return SQLName
     */
    pub fn getTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterViewRenameStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLAlterViewStatement extends SQLStatementImpl {
    
}
impl SQLAlterViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getAlgorithm:String()`.
     * @return string
     */
    pub fn getAlgorithm(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getComment:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getComment(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in SqlAlterViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the definer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getDefiner:SQLName()`.
     * @return SQLName
     */
    pub fn getDefiner(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefinerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.isForce:boolean()`.
     * @return int
     */
    pub fn isForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with cascaded of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.isWithCascaded:boolean()`.
     * @return int
     */
    pub fn isWithCascaded(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithCascaded()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with check option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.isWithCheckOption:boolean()`.
     * @return int
     */
    pub fn isWithCheckOption(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithCheckOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.isWithLocal:boolean()`.
     * @return int
     */
    pub fn isWithLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with read only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.isWithReadOnly:boolean()`.
     * @return int
     */
    pub fn isWithReadOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithReadOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sql security of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getSqlSecurity:String()`.
     * @return string
     */
    pub fn getSqlSecurity(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSqlSecurity()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlAlterViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlAlterViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAlterViewStatement.getColumns:List<SQLTableElement>()`.
     * @return SQLTableElement
     */
    pub fn getColumns(self) -> *SQLTableElement {
        for (x in SQLTableElement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAnalyzeTableStatement extends SQLStatementImpl {
    
}
impl SQLAnalyzeTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAnalyzeTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAnalyzeTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAnalyzeTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the adb schema oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.getAdbSchema:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getAdbSchema(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in SqlAnalyzeTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAdbSchemaOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the adb where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.getAdbWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAdbWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAnalyzeTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAdbWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is cache metadata of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.isCacheMetadata:boolean()`.
     * @return int
     */
    pub fn isCacheMetadata(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAnalyzeTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCacheMetadata()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compute statistics of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.isComputeStatistics:boolean()`.
     * @return int
     */
    pub fn isComputeStatistics(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAnalyzeTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsComputeStatistics()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is for colums of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.isForColums:boolean()`.
     * @return int
     */
    pub fn isForColums(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAnalyzeTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForColums()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is noscan of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.isNoscan:boolean()`.
     * @return int
     */
    pub fn isNoscan(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAnalyzeTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoscan()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.getPartition:SQLPartitionRef()`.
     * @return SQLPartitionRef
     */
    pub fn getPartition(self) -> SQLPartitionRef {
        for (s in SQLPartitionRef(__all_data__),
            x in SqlAnalyzeTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlAnalyzeTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the adb columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.getAdbColumns:List<SQLIdentifierExpr>()`.
     * @return SQLIdentifierExpr
     */
    pub fn getAdbColumns(self) -> *SQLIdentifierExpr {
        for (x in SQLIdentifierExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the adb columns group of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.getAdbColumnsGroup:List<SQLIdentifierExpr>()`.
     * @return SQLIdentifierExpr
     */
    pub fn getAdbColumnsGroup(self) -> *SQLIdentifierExpr {
        for (x in SQLIdentifierExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the tables of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAnalyzeTableStatement.getTables:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTables(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLArchiveTableStatement extends SQLStatementImpl {
    
}
impl SQLArchiveTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLArchiveTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlArchiveTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLArchiveTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLArchiveTableStatement.getTable:SQLName()`.
     * @return SQLName
     */
    pub fn getTable(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlArchiveTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLArchiveTableStatement.getType:SQLName()`.
     * @return SQLName
     */
    pub fn getType(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlArchiveTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the p id list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLArchiveTableStatement.getpIdList:List<SQLIntegerExpr>()`.
     * @return SQLIntegerExpr
     */
    pub fn getpIdList(self) -> *SQLIntegerExpr {
        for (x in SQLIntegerExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the sp id list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLArchiveTableStatement.getSpIdList:List<SQLIntegerExpr>()`.
     * @return SQLIntegerExpr
     */
    pub fn getSpIdList(self) -> *SQLIntegerExpr {
        for (x in SQLIntegerExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLAssignItem extends SQLExprImpl {
    
}
impl SQLAssignItem {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAssignItem {
        for (tmp in SQLExprImpl(db)) {
            for (x in SqlAssignItemDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAssignItem {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the target oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAssignItem.getTarget:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTarget(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAssignItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTargetOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLAssignItem.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlAssignItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLBackupStatement extends SQLStatementImpl {
    
}
impl SQLBackupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBackupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlBackupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBackupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the action oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBackupStatement.getAction:SQLName()`.
     * @return SQLName
     */
    pub fn getAction(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlBackupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getActionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBackupStatement.getType:SQLName()`.
     * @return SQLName
     */
    pub fn getType(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlBackupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBackupStatement.getProperties:List<SQLCharExpr>()`.
     * @return SQLCharExpr
     */
    pub fn getProperties(self) -> *SQLCharExpr {
        for (x in SQLCharExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLBlockStatement extends SQLStatementImpl {
    
}
impl SQLBlockStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBlockStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlBlockStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBlockStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the end label of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBlockStatement.getEndLabel:String()`.
     * @return string
     */
    pub fn getEndLabel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlBlockStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEndLabel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the exception oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBlockStatement.getException:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getException(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlBlockStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExceptionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is end of commit of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBlockStatement.isEndOfCommit:boolean()`.
     * @return int
     */
    pub fn isEndOfCommit(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBlockStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsEndOfCommit()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBlockStatement.getLabelName:String()`.
     * @return string
     */
    pub fn getLabelName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlBlockStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabelName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBlockStatement.getParameters:List<SQLParameter>()`.
     * @return SQLParameter
     */
    pub fn getParameters(self) -> *SQLParameter {
        for (x in SQLParameter(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the statement list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBlockStatement.getStatementList:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getStatementList(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLBuildTableStatement extends SQLStatementImpl {
    
}
impl SQLBuildTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLBuildTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlBuildTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLBuildTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBuildTableStatement.isForce:boolean()`.
     * @return int
     */
    pub fn isForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBuildTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with split of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBuildTableStatement.isWithSplit:boolean()`.
     * @return int
     */
    pub fn isWithSplit(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlBuildTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithSplit()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBuildTableStatement.getTable:SQLName()`.
     * @return SQLName
     */
    pub fn getTable(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlBuildTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the version oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLBuildTableStatement.getVersion:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getVersion(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in SqlBuildTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getVersionOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLCallStatement extends SQLStatementImpl {
    
}
impl SQLCallStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCallStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCallStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCallStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is brace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCallStatement.isBrace:boolean()`.
     * @return int
     */
    pub fn isBrace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCallStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBrace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the out parameter oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCallStatement.getOutParameter:SQLVariantRefExpr()`.
     * @return SQLVariantRefExpr
     */
    pub fn getOutParameter(self) -> SQLVariantRefExpr {
        for (s in SQLVariantRefExpr(__all_data__),
            x in SqlCallStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOutParameterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the procedure name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCallStatement.getProcedureName:SQLName()`.
     * @return SQLName
     */
    pub fn getProcedureName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCallStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getProcedureNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCallStatement.getParameters:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getParameters(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCancelJobStatement extends SQLStatementImpl {
    
}
impl SQLCancelJobStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCancelJobStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCancelJobStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCancelJobStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is import of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCancelJobStatement.isImport:boolean()`.
     * @return int
     */
    pub fn isImport(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCancelJobStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsImport()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCancelJobStatement.getJobName:SQLName()`.
     * @return SQLName
     */
    pub fn getJobName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCancelJobStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getJobNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLCharacterDataType extends SQLDataTypeImpl {
    
}
impl SQLCharacterDataType {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCharacterDataType {
        for (tmp in SQLDataTypeImpl(db)) {
            for (x in SqlCharacterDataTypeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCharacterDataType {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the char set name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCharacterDataType.getCharSetName:String()`.
     * @return string
     */
    pub fn getCharSetName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCharacterDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCharSetName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the char type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCharacterDataType.getCharType:String()`.
     * @return string
     */
    pub fn getCharType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCharacterDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCharType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the collate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCharacterDataType.getCollate:String()`.
     * @return string
     */
    pub fn getCollate(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCharacterDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCollate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is has binary of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCharacterDataType.isHasBinary:boolean()`.
     * @return int
     */
    pub fn isHasBinary(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCharacterDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHasBinary()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the length of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCharacterDataType.getLength:int()`.
     * @return int
     */
    pub fn getLength(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCharacterDataTypeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLength()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCharacterDataType.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCheck extends SQLConstraintImpl {
    
}
impl SQLCheck {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCheck {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlCheckDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCheck {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enforced of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCheck.getEnforced:Boolean()`.
     * @return int
     */
    pub fn getEnforced(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCheckDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnforced()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCheck.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCheckDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLCloneTableStatement extends SQLStatementImpl {
    
}
impl SQLCloneTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCloneTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCloneTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCloneTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCloneTableStatement.getFrom:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getFrom(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCloneTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is if exists ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCloneTableStatement.isIfExistsIgnore:boolean()`.
     * @return int
     */
    pub fn isIfExistsIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCloneTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExistsIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists overwrite of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCloneTableStatement.isIfExistsOverwrite:boolean()`.
     * @return int
     */
    pub fn isIfExistsOverwrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCloneTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExistsOverwrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the to name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCloneTableStatement.getToName:SQLName()`.
     * @return SQLName
     */
    pub fn getToName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCloneTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCloneTableStatement.getTo:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTo(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCloneTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCloneTableStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCloseStatement extends SQLStatementImpl {
    
}
impl SQLCloseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCloseStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCloseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCloseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cursor name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCloseStatement.getCursorName:SQLName()`.
     * @return SQLName
     */
    pub fn getCursorName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCloseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCursorNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLColumnCheck extends SQLConstraintImpl {
    
}
impl SQLColumnCheck {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLColumnCheck {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlColumnCheckDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLColumnCheck {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enforced of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnCheck.getEnforced:Boolean()`.
     * @return int
     */
    pub fn getEnforced(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnCheckDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnforced()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnCheck.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnCheckDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLColumnDefinition extends SQLObject {
    
}
impl SQLColumnDefinition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLColumnDefinition {
        for (tmp in SQLObject(db)) {
            for (x in SqlColumnDefinitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLColumnDefinition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the ann index oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getAnnIndex:SQLAnnIndex()`.
     * @return SQLAnnIndex
     */
    pub fn getAnnIndex(self) -> SQLAnnIndex {
        for (s in SQLAnnIndex(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAnnIndexOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the as expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getAsExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAsExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAsExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the charset expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getCharsetExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCharsetExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCharsetExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the collate expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getCollateExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCollateExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCollateExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the column name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getColumnName:String()`.
     * @return string
     */
    pub fn getColumnName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getColumnName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the compression oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getCompression:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getCompression(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCompressionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the default expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getDefaultExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDefaultExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefaultExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the delimiter oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getDelimiter:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDelimiter(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDelimiterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the delimiter tokenizer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getDelimiterTokenizer:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDelimiterTokenizer(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDelimiterTokenizerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the encode oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getEncode:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getEncode(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEncodeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the format oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getFormat:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFormat(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFormatOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the generated alaws as oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getGeneratedAlawsAs:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getGeneratedAlawsAs(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getGeneratedAlawsAsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the identity of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getIdentity:Identity()`.
     * @return string
     */
    pub fn getIdentity(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIdentity()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is auto increment of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isAutoIncrement:boolean()`.
     * @return int
     */
    pub fn isAutoIncrement(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAutoIncrement()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is disable index of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isDisableIndex:boolean()`.
     * @return int
     */
    pub fn isDisableIndex(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDisableIndex()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is only primary key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isOnlyPrimaryKey:boolean()`.
     * @return int
     */
    pub fn isOnlyPrimaryKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnlyPrimaryKey()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is partition by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isPartitionBy:boolean()`.
     * @return int
     */
    pub fn isPartitionBy(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPartitionBy()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is pre sort of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isPreSort:boolean()`.
     * @return int
     */
    pub fn isPreSort(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPreSort()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is primary key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isPrimaryKey:boolean()`.
     * @return int
     */
    pub fn isPrimaryKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPrimaryKey()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is stored of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isStored:boolean()`.
     * @return int
     */
    pub fn isStored(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsStored()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is virtual of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isVirtual:boolean()`.
     * @return int
     */
    pub fn isVirtual(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsVirtual()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is visible of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.isVisible:boolean()`.
     * @return int
     */
    pub fn isVisible(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsVisible()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the json index attrs expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getJsonIndexAttrsExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getJsonIndexAttrsExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getJsonIndexAttrsExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name as string of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getNameAsString:String()`.
     * @return string
     */
    pub fn getNameAsString(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNameAsString()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the nlp tokenizer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getNlpTokenizer:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNlpTokenizer(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNlpTokenizerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the npl tokenizer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getNplTokenizer:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNplTokenizer(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNplTokenizerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on update oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getOnUpdate:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOnUpdate(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnUpdateOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the pre sort order of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getPreSortOrder:int()`.
     * @return int
     */
    pub fn getPreSortOrder(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPreSortOrder()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the rely of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getRely:Boolean()`.
     * @return int
     */
    pub fn getRely(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRely()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sequence type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getSequenceType:AutoIncrementType()`.
     * @return string
     */
    pub fn getSequenceType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSequenceType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the step oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getStep:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStep(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStepOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the storage oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getStorage:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStorage(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStorageOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the unit count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getUnitCount:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUnitCount(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUnitCountOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the unit index oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getUnitIndex:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUnitIndex(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUnitIndexOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the validate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getValidate:Boolean()`.
     * @return int
     */
    pub fn getValidate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlColumnDefinitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValidate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getValueType:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValueType(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlColumnDefinitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the col properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getColProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getColProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the col properties direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getColPropertiesDirect:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getColPropertiesDirect(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the constraints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getConstraints:List<SQLColumnConstraint>()`.
     * @return SQLColumnConstraint
     */
    pub fn getConstraints(self) -> *SQLColumnConstraint {
        for (x in SQLColumnConstraint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the mapped by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getMappedBy:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getMappedBy(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the mapped by direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnDefinition.getMappedByDirect:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getMappedByDirect(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLColumnPrimaryKey extends SQLConstraintImpl {
    
}
impl SQLColumnPrimaryKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLColumnPrimaryKey {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlColumnPrimaryKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLColumnPrimaryKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLColumnReference extends SQLConstraintImpl {
    
}
impl SQLColumnReference {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLColumnReference {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlColumnReferenceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLColumnReference {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on delete of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnReference.getOnDelete:Option()`.
     * @return string
     */
    pub fn getOnDelete(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlColumnReferenceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOnDelete()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on update of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnReference.getOnUpdate:Option()`.
     * @return string
     */
    pub fn getOnUpdate(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlColumnReferenceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOnUpdate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the reference match of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnReference.getReferenceMatch:Match()`.
     * @return string
     */
    pub fn getReferenceMatch(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlColumnReferenceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getReferenceMatch()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnReference.getTable:SQLName()`.
     * @return SQLName
     */
    pub fn getTable(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlColumnReferenceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLColumnReference.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLColumnUniqueKey extends SQLConstraintImpl {
    
}
impl SQLColumnUniqueKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLColumnUniqueKey {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlColumnUniqueKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLColumnUniqueKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLCommentStatement extends SQLStatementImpl {
    
}
impl SQLCommentStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCommentStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCommentStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCommentStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommentStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCommentStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommentStatement.getOn:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getOn(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCommentStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommentStatement.getType:Type()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCommentStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCommitStatement extends SQLStatementImpl {
    
}
impl SQLCommitStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCommitStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCommitStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCommitStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the chain of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommitStatement.getChain:Boolean()`.
     * @return int
     */
    pub fn getChain(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCommitStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getChain()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the delayed durability oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommitStatement.getDelayedDurability:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDelayedDurability(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCommitStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDelayedDurabilityOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the immediate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommitStatement.getImmediate:Boolean()`.
     * @return int
     */
    pub fn getImmediate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCommitStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getImmediate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is work of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommitStatement.isWork:boolean()`.
     * @return int
     */
    pub fn isWork(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCommitStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWork()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is write of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommitStatement.isWrite:boolean()`.
     * @return int
     */
    pub fn isWrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCommitStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the release of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommitStatement.getRelease:Boolean()`.
     * @return int
     */
    pub fn getRelease(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCommitStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRelease()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the transaction name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommitStatement.getTransactionName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTransactionName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCommitStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTransactionNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the wait of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCommitStatement.getWait:Boolean()`.
     * @return int
     */
    pub fn getWait(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCommitStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWait()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCopyFromStatement extends SQLStatementImpl {
    
}
impl SQLCopyFromStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCopyFromStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCopyFromStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCopyFromStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the access key id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCopyFromStatement.getAccessKeyId:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAccessKeyId(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCopyFromStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAccessKeyIdOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the access key secret oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCopyFromStatement.getAccessKeySecret:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAccessKeySecret(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCopyFromStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAccessKeySecretOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCopyFromStatement.getFrom:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFrom(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCopyFromStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCopyFromStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCopyFromStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCopyFromStatement.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCopyFromStatement.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCopyFromStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCreateDatabaseStatement extends SQLStatementImpl {
    
}
impl SQLCreateDatabaseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateDatabaseStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateDatabaseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateDatabaseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the character set of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getCharacterSet:String()`.
     * @return string
     */
    pub fn getCharacterSet(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCharacterSet()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the collate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getCollate:String()`.
     * @return string
     */
    pub fn getCollate(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCollate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the database name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getDatabaseName:String()`.
     * @return string
     */
    pub fn getDatabaseName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDatabaseName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is physical of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.isPhysical:boolean()`.
     * @return int
     */
    pub fn isPhysical(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPhysical()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the location oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getLocation:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLocation(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getOptions:Map<String, SQLExpr>()`.
     * @return string
     */
    pub fn getOptions(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOptions()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the password oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getPassword:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPassword(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPasswordOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the server of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getServer:String()`.
     * @return string
     */
    pub fn getServer(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getServer()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the stored as oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getStoredAs:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStoredAs(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredAsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the stored by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getStoredBy:List<List<SQLAssignItem>>()`.
     * @return string
     */
    pub fn getStoredBy(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getStoredBy()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the stored in oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getStoredIn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStoredIn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredInOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getUser:String()`.
     * @return string
     */
    pub fn getUser(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUser()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the db properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getDbProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getDbProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the stored on of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateDatabaseStatement.getStoredOn:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getStoredOn(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCreateFunctionStatement extends SQLStatementImpl {
    
}
impl SQLCreateFunctionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateFunctionStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateFunctionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateFunctionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the authid oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getAuthid:SQLName()`.
     * @return SQLName
     */
    pub fn getAuthid(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAuthidOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the block oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getBlock:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getBlock(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getBlockOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the comment of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getComment:String()`.
     * @return string
     */
    pub fn getComment(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getComment()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the definer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getDefiner:SQLName()`.
     * @return SQLName
     */
    pub fn getDefiner(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefinerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is aggregate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isAggregate:boolean()`.
     * @return int
     */
    pub fn isAggregate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAggregate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is create of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isCreate:boolean()`.
     * @return int
     */
    pub fn isCreate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCreate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is deterministic of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isDeterministic:boolean()`.
     * @return int
     */
    pub fn isDeterministic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDeterministic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is or replace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isOrReplace:boolean()`.
     * @return int
     */
    pub fn isOrReplace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrReplace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is parallel enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isParallelEnable:boolean()`.
     * @return int
     */
    pub fn isParallelEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsParallelEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is pipelined of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isPipelined:boolean()`.
     * @return int
     */
    pub fn isPipelined(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPipelined()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is result cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isResultCache:boolean()`.
     * @return int
     */
    pub fn isResultCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsResultCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is temporary of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.isTemporary:boolean()`.
     * @return int
     */
    pub fn isTemporary(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTemporary()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the java call spec of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getJavaCallSpec:String()`.
     * @return string
     */
    pub fn getJavaCallSpec(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJavaCallSpec()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the language of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getLanguage:String()`.
     * @return string
     */
    pub fn getLanguage(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLanguage()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the return data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getReturnDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getReturnDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in SqlCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReturnDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getUsing:SQLName()`.
     * @return SQLName
     */
    pub fn getUsing(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the wrapped source of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getWrappedSource:String()`.
     * @return string
     */
    pub fn getWrappedSource(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWrappedSource()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateFunctionStatement.getParameters:List<SQLParameter>()`.
     * @return SQLParameter
     */
    pub fn getParameters(self) -> *SQLParameter {
        for (x in SQLParameter(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCreateIndexStatement extends SQLStatementImpl {
    
}
impl SQLCreateIndexStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateIndexStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateIndexStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateIndexStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the db partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getDbPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the in oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getIn:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getIn(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index definition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getIndexDefinition:SQLIndexDefinition()`.
     * @return SQLIndexDefinition
     */
    pub fn getIndexDefinition(self) -> SQLIndexDefinition {
        for (s in SQLIndexDefinition(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexDefinitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is concurrently of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.isConcurrently:boolean()`.
     * @return int
     */
    pub fn isConcurrently(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsConcurrently()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is defered rebuild of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.isDeferedRebuild:boolean()`.
     * @return int
     */
    pub fn isDeferedRebuild(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDeferedRebuild()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is storing of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.isStoring:boolean()`.
     * @return int
     */
    pub fn isStoring(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsStoring()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the row format oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getRowFormat:SQLExternalRecordFormat()`.
     * @return SQLExternalRecordFormat
     */
    pub fn getRowFormat(self) -> SQLExternalRecordFormat {
        for (s in SQLExternalRecordFormat(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowFormatOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the stored as oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getStoredAs:SQLName()`.
     * @return SQLName
     */
    pub fn getStoredAs(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredAsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getTable:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getTable(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getTableName:String()`.
     * @return string
     */
    pub fn getTableName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTableName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getTablePartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table partitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getTablePartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the tablespace oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getTablespace:SQLName()`.
     * @return SQLName
     */
    pub fn getTablespace(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablespaceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getType:String()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getUsing:String()`.
     * @return string
     */
    pub fn getUsing(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUsing()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getColumns:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getColumns(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the covering of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getCovering:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getCovering(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getItems:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getItems(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the table properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateIndexStatement.getTableProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getTableProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCreateMaterializedViewStatement extends SQLStatementImpl {
    
}
impl SQLCreateMaterializedViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateMaterializedViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateMaterializedViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateMaterializedViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getCache:Boolean()`.
     * @return int
     */
    pub fn getCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the compress of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getCompress:Boolean()`.
     * @return int
     */
    pub fn getCompress(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCompress()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the compress level of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getCompressLevel:Integer()`.
     * @return int
     */
    pub fn getCompressLevel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCompressLevel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the distributed by type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getDistributedByType:SQLName()`.
     * @return SQLName
     */
    pub fn getDistributedByType(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDistributedByTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the enable query rewrite of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getEnableQueryRewrite:Boolean()`.
     * @return int
     */
    pub fn getEnableQueryRewrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnableQueryRewrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the free lists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getFreeLists:Integer()`.
     * @return int
     */
    pub fn getFreeLists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFreeLists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the initrans of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getInitrans:Integer()`.
     * @return int
     */
    pub fn getInitrans(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInitrans()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is build deferred of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isBuildDeferred:boolean()`.
     * @return int
     */
    pub fn isBuildDeferred(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBuildDeferred()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is build immediate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isBuildImmediate:boolean()`.
     * @return int
     */
    pub fn isBuildImmediate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBuildImmediate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compress for oltp of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isCompressForOltp:boolean()`.
     * @return int
     */
    pub fn isCompressForOltp(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompressForOltp()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefresh:boolean()`.
     * @return int
     */
    pub fn isRefresh(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefresh()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh complete of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefreshComplete:boolean()`.
     * @return int
     */
    pub fn isRefreshComplete(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshComplete()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh fast of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefreshFast:boolean()`.
     * @return int
     */
    pub fn isRefreshFast(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshFast()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefreshForce:boolean()`.
     * @return int
     */
    pub fn isRefreshForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh next of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefreshNext:boolean()`.
     * @return int
     */
    pub fn isRefreshNext(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshNext()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh on commit of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefreshOnCommit:boolean()`.
     * @return int
     */
    pub fn isRefreshOnCommit(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshOnCommit()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh on demand of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefreshOnDemand:boolean()`.
     * @return int
     */
    pub fn isRefreshOnDemand(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshOnDemand()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh on over write of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefreshOnOverWrite:boolean()`.
     * @return int
     */
    pub fn isRefreshOnOverWrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshOnOverWrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is refresh start with of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isRefreshStartWith:boolean()`.
     * @return int
     */
    pub fn isRefreshStartWith(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRefreshStartWith()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with row id of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.isWithRowId:boolean()`.
     * @return int
     */
    pub fn isWithRowId(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithRowId()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lify cycle oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getLifyCycle:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLifyCycle(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLifyCycleOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the logging of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getLogging:Boolean()`.
     * @return int
     */
    pub fn getLogging(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLogging()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the maxtrans of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getMaxtrans:Integer()`.
     * @return int
     */
    pub fn getMaxtrans(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getMaxtrans()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the next oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getNext:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNext(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNextOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the parallel of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getParallel:Boolean()`.
     * @return int
     */
    pub fn getParallel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getParallel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parallel value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getParallelValue:Integer()`.
     * @return int
     */
    pub fn getParallelValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getParallelValue()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getPartitionBy:SQLPartitionBy()`.
     * @return SQLPartitionBy
     */
    pub fn getPartitionBy(self) -> SQLPartitionBy {
        for (s in SQLPartitionBy(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the pctfree of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getPctfree:Integer()`.
     * @return int
     */
    pub fn getPctfree(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctfree()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctincrease of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getPctincrease:Integer()`.
     * @return int
     */
    pub fn getPctincrease(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctincrease()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctthreshold of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getPctthreshold:Integer()`.
     * @return int
     */
    pub fn getPctthreshold(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctthreshold()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctused of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getPctused:Integer()`.
     * @return int
     */
    pub fn getPctused(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctused()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the start with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getStartWith:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStartWith(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStartWithOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the storage of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getStorage:SQLObject()`.
     * @return string
     */
    pub fn getStorage(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getStorage()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the tablespace oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getTablespace:SQLName()`.
     * @return SQLName
     */
    pub fn getTablespace(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablespaceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the distributed by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getDistributedBy:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getDistributedBy(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partitioned on of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getPartitionedOn:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitionedOn(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the table element list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getTableElementList:List<SQLTableElement>()`.
     * @return SQLTableElement
     */
    pub fn getTableElementList(self) -> *SQLTableElement {
        for (x in SQLTableElement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the table options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateMaterializedViewStatement.getTableOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getTableOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCreateOutlineStatement extends SQLStatementImpl {
    
}
impl SQLCreateOutlineStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateOutlineStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateOutlineStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateOutlineStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateOutlineStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateOutlineStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateOutlineStatement.getOn:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getOn(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlCreateOutlineStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateOutlineStatement.getTo:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getTo(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlCreateOutlineStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateOutlineStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateOutlineStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLCreateProcedureStatement extends SQLStatementImpl {
    
}
impl SQLCreateProcedureStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateProcedureStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateProcedureStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateProcedureStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the authid oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.getAuthid:SQLName()`.
     * @return SQLName
     */
    pub fn getAuthid(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAuthidOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the block oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.getBlock:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getBlock(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlCreateProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getBlockOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.getComment:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getComment(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in SqlCreateProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the definer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.getDefiner:SQLName()`.
     * @return SQLName
     */
    pub fn getDefiner(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefinerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is contains sql of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.isContainsSql:boolean()`.
     * @return int
     */
    pub fn isContainsSql(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsContainsSql()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is create of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.isCreate:boolean()`.
     * @return int
     */
    pub fn isCreate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCreate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is deterministic of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.isDeterministic:boolean()`.
     * @return int
     */
    pub fn isDeterministic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDeterministic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is language sql of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.isLanguageSql:boolean()`.
     * @return int
     */
    pub fn isLanguageSql(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLanguageSql()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is modifies sql data of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.isModifiesSqlData:boolean()`.
     * @return int
     */
    pub fn isModifiesSqlData(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsModifiesSqlData()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no sql of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.isNoSql:boolean()`.
     * @return int
     */
    pub fn isNoSql(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoSql()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is or replace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.isOrReplace:boolean()`.
     * @return int
     */
    pub fn isOrReplace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrReplace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is read sql data of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.isReadSqlData:boolean()`.
     * @return int
     */
    pub fn isReadSqlData(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReadSqlData()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the java call spec of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.getJavaCallSpec:String()`.
     * @return string
     */
    pub fn getJavaCallSpec(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJavaCallSpec()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the wrapped source of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.getWrappedSource:String()`.
     * @return string
     */
    pub fn getWrappedSource(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWrappedSource()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateProcedureStatement.getParameters:List<SQLParameter>()`.
     * @return SQLParameter
     */
    pub fn getParameters(self) -> *SQLParameter {
        for (x in SQLParameter(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCreateRoleStatement extends SQLStatementImpl {
    
}
impl SQLCreateRoleStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateRoleStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateRoleStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateRoleStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateRoleStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateRoleStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateRoleStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateRoleStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLCreateSequenceStatement extends SQLStatementImpl {
    
}
impl SQLCreateSequenceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateSequenceStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateSequenceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateSequenceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getCache:Boolean()`.
     * @return int
     */
    pub fn getCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cache value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getCacheValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCacheValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCacheValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the cycle of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getCycle:Boolean()`.
     * @return int
     */
    pub fn getCycle(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCycle()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the increment by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getIncrementBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIncrementBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIncrementByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is group of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.isGroup:boolean()`.
     * @return int
     */
    pub fn isGroup(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGroup()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no max value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.isNoMaxValue:boolean()`.
     * @return int
     */
    pub fn isNoMaxValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoMaxValue()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no min value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.isNoMinValue:boolean()`.
     * @return int
     */
    pub fn isNoMinValue(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoMinValue()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is simple of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.isSimple:boolean()`.
     * @return int
     */
    pub fn isSimple(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSimple()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is time of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.isTime:boolean()`.
     * @return int
     */
    pub fn isTime(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTime()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the max value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getMaxValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the min value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getMinValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMinValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMinValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getOrder:Boolean()`.
     * @return int
     */
    pub fn getOrder(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOrder()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the start with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getStartWith:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStartWith(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStartWithOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the step oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getStep:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStep(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStepOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the unit count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getUnitCount:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUnitCount(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUnitCountOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the unit index oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getUnitIndex:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUnitIndex(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUnitIndexOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateSequenceStatement.getWithCache:Boolean()`.
     * @return int
     */
    pub fn getWithCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithCache()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCreateTableGroupStatement extends SQLStatementImpl {
    
}
impl SQLCreateTableGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateTableGroupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateTableGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateTableGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableGroupStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableGroupStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateTableGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition num oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableGroupStatement.getPartitionNum:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPartitionNum(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateTableGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionNumOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableGroupStatement.getSchemaName:String()`.
     * @return string
     */
    pub fn getSchemaName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchemaName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table group name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableGroupStatement.getTableGroupName:String()`.
     * @return string
     */
    pub fn getTableGroupName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTableGroupName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCreateTableStatement extends SQLStatementImpl {
    
}
impl SQLCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the body before comments direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getBodyBeforeCommentsDirect:List<String>()`.
     * @return string
     */
    pub fn getBodyBeforeCommentsDirect(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getBodyBeforeCommentsDirect()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the buckets of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getBuckets:int()`.
     * @return int
     */
    pub fn getBuckets(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getBuckets()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the catalog of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getCatalog:String()`.
     * @return string
     */
    pub fn getCatalog(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCatalog()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the clustering type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getClusteringType:ClusteringType()`.
     * @return string
     */
    pub fn getClusteringType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getClusteringType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column comments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getColumnComments:List<String>()`.
     * @return string
     */
    pub fn getColumnComments(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getColumnComments()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the compress of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getCompress:Boolean()`.
     * @return int
     */
    pub fn getCompress(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCompress()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the inherits oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getInherits:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getInherits(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInheritsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is dimension of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.isDimension:boolean()`.
     * @return int
     */
    pub fn isDimension(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDimension()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is external of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.isExternal:boolean()`.
     * @return int
     */
    pub fn isExternal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExternal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.isIgnore:boolean()`.
     * @return int
     */
    pub fn isIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on commit preserve rows of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.isOnCommitPreserveRows:boolean()`.
     * @return int
     */
    pub fn isOnCommitPreserveRows(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnCommitPreserveRows()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is replace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.isReplace:boolean()`.
     * @return int
     */
    pub fn isReplace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReplace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is single of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.isSingle:boolean()`.
     * @return int
     */
    pub fn isSingle(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSingle()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getLike:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getLike(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the local partitioning oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getLocalPartitioning:SQLPartitionBy()`.
     * @return SQLPartitionBy
     */
    pub fn getLocalPartitioning(self) -> SQLPartitionBy {
        for (s in SQLPartitionBy(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocalPartitioningOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the location oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getLocation:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLocation(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the logging of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getLogging:Boolean()`.
     * @return int
     */
    pub fn getLogging(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLogging()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitioning oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getPartitioning:SQLPartitionBy()`.
     * @return SQLPartitionBy
     */
    pub fn getPartitioning(self) -> SQLPartitionBy {
        for (s in SQLPartitionBy(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitioningOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the primary key names of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getPrimaryKeyNames:List<String>()`.
     * @return string
     */
    pub fn getPrimaryKeyNames(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPrimaryKeyNames()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the row format oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getRowFormat:SQLExternalRecordFormat()`.
     * @return SQLExternalRecordFormat
     */
    pub fn getRowFormat(self) -> SQLExternalRecordFormat {
        for (s in SQLExternalRecordFormat(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowFormatOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the shards of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getShards:int()`.
     * @return int
     */
    pub fn getShards(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getShards()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the stored as oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getStoredAs:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStoredAs(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredAsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getTableName:String()`.
     * @return string
     */
    pub fn getTableName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTableName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the tablespace oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getTablespace:SQLName()`.
     * @return SQLName
     */
    pub fn getTablespace(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablespaceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getType:Type()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the clustered by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getClusteredBy:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getClusteredBy(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the column definitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getColumnDefinitions:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumnDefinitions(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partition columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getPartitionColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getPartitionColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the sorted by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getSortedBy:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getSortedBy(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the table element list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getTableElementList:List<SQLTableElement>()`.
     * @return SQLTableElement
     */
    pub fn getTableElementList(self) -> *SQLTableElement {
        for (x in SQLTableElement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the table options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getTableOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getTableOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the tbl properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTableStatement.getTblProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getTblProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCreateTriggerStatement extends SQLStatementImpl {
    
}
impl SQLCreateTriggerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateTriggerStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateTriggerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateTriggerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the body oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.getBody:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getBody(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlCreateTriggerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getBodyOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the definer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.getDefiner:SQLName()`.
     * @return SQLName
     */
    pub fn getDefiner(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateTriggerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefinerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is delete of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.isDelete:boolean()`.
     * @return int
     */
    pub fn isDelete(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDelete()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is for each row of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.isForEachRow:boolean()`.
     * @return int
     */
    pub fn isForEachRow(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForEachRow()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is insert of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.isInsert:boolean()`.
     * @return int
     */
    pub fn isInsert(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInsert()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is or replace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.isOrReplace:boolean()`.
     * @return int
     */
    pub fn isOrReplace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrReplace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is update of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.isUpdate:boolean()`.
     * @return int
     */
    pub fn isUpdate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUpdate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateTriggerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.getOn:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getOn(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCreateTriggerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the trigger events of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.getTriggerEvents:List<TriggerEvent>()`.
     * @return string
     */
    pub fn getTriggerEvents(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTriggerEvents()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the trigger type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.getTriggerType:TriggerType()`.
     * @return string
     */
    pub fn getTriggerType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTriggerType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the when oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.getWhen:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhen(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateTriggerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhenOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the update of columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateTriggerStatement.getUpdateOfColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getUpdateOfColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLCreateUserStatement extends SQLStatementImpl {
    
}
impl SQLCreateUserStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateUserStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateUserStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateUserStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the password oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateUserStatement.getPassword:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPassword(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlCreateUserStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPasswordOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateUserStatement.getUser:SQLName()`.
     * @return SQLName
     */
    pub fn getUser(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateUserStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLCreateViewStatement extends SQLStatementImpl {
    
}
impl SQLCreateViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getAlgorithm:String()`.
     * @return string
     */
    pub fn getAlgorithm(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getComment:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getComment(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the definer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getDefiner:SQLName()`.
     * @return SQLName
     */
    pub fn getDefiner(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefinerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.isForce:boolean()`.
     * @return int
     */
    pub fn isForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on cluster of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.isOnCluster:boolean()`.
     * @return int
     */
    pub fn isOnCluster(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnCluster()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is or replace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.isOrReplace:boolean()`.
     * @return int
     */
    pub fn isOrReplace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrReplace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with cascaded of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.isWithCascaded:boolean()`.
     * @return int
     */
    pub fn isWithCascaded(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithCascaded()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with check option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.isWithCheckOption:boolean()`.
     * @return int
     */
    pub fn isWithCheckOption(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithCheckOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.isWithLocal:boolean()`.
     * @return int
     */
    pub fn isWithLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with read only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.isWithReadOnly:boolean()`.
     * @return int
     */
    pub fn isWithReadOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithReadOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the returns data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getReturnsDataType:SQLTableDataType()`.
     * @return SQLTableDataType
     */
    pub fn getReturnsDataType(self) -> SQLTableDataType {
        for (s in SQLTableDataType(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReturnsDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the returns oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getReturns:SQLVariantRefExpr()`.
     * @return SQLVariantRefExpr
     */
    pub fn getReturns(self) -> SQLVariantRefExpr {
        for (s in SQLVariantRefExpr(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReturnsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the script oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getScript:SQLBlockStatement()`.
     * @return SQLBlockStatement
     */
    pub fn getScript(self) -> SQLBlockStatement {
        for (s in SQLBlockStatement(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getScriptOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the sql security of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getSqlSecurity:String()`.
     * @return string
     */
    pub fn getSqlSecurity(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSqlSecurity()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getTo:SQLName()`.
     * @return SQLName
     */
    pub fn getTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLCreateViewStatement.getColumns:List<SQLTableElement>()`.
     * @return SQLTableElement
     */
    pub fn getColumns(self) -> *SQLTableElement {
        for (x in SQLTableElement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLDeclareStatement extends SQLStatementImpl {
    
}
impl SQLDeclareStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDeclareStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDeclareStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDeclareStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeclareStatement.getItems:List<SQLDeclareItem>()`.
     * @return SQLDeclareItem
     */
    pub fn getItems(self) -> *SQLDeclareItem {
        for (x in SQLDeclareItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLDefault extends SQLConstraintImpl {
    
}
impl SQLDefault {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDefault {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlDefaultDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDefault {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDefault.getColumn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getColumn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDefaultDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDefault.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDefaultDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is with values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDefault.isWithValues:boolean()`.
     * @return int
     */
    pub fn isWithValues(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDefaultDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithValues()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDeleteStatement extends SQLStatementImpl {
    
}
impl SQLDeleteStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDeleteStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDeleteStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDeleteStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.getAlias:String()`.
     * @return string
     */
    pub fn getAlias(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.getExprTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getExprTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.getFrom:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getFrom(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.isOnly:boolean()`.
     * @return int
     */
    pub fn isOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.getTableName:SQLName()`.
     * @return SQLName
     */
    pub fn getTableName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.getTableSource:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getTableSource(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.getUsing:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getUsing(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDeleteStatement.getWith:SQLWithSubqueryClause()`.
     * @return SQLWithSubqueryClause
     */
    pub fn getWith(self) -> SQLWithSubqueryClause {
        for (s in SQLWithSubqueryClause(__all_data__),
            x in SqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWithOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDescribeStatement extends SQLStatementImpl {
    
}
impl SQLDescribeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDescribeStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDescribeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDescribeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDescribeStatement.getColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDescribeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is extended of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDescribeStatement.isExtended:boolean()`.
     * @return int
     */
    pub fn isExtended(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDescribeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExtended()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is formatted of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDescribeStatement.isFormatted:boolean()`.
     * @return int
     */
    pub fn isFormatted(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDescribeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFormatted()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the object oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDescribeStatement.getObject:SQLName()`.
     * @return SQLName
     */
    pub fn getObject(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDescribeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getObjectOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the object type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDescribeStatement.getObjectType:SQLObjectType()`.
     * @return string
     */
    pub fn getObjectType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDescribeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getObjectType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDescribeStatement.getPartition:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getPartition(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLDropCatalogStatement extends SQLStatementImpl {
    
}
impl SQLDropCatalogStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropCatalogStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropCatalogStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropCatalogStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is external of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropCatalogStatement.isExternal:boolean()`.
     * @return int
     */
    pub fn isExternal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropCatalogStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExternal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropCatalogStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropCatalogStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropCatalogStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropCatalogStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropDatabaseStatement extends SQLStatementImpl {
    
}
impl SQLDropDatabaseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropDatabaseStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropDatabaseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropDatabaseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.getDatabase:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDatabase(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the database name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.getDatabaseName:String()`.
     * @return string
     */
    pub fn getDatabaseName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDropDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDatabaseName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.isCascade:boolean()`.
     * @return int
     */
    pub fn isCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is physical of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.isPhysical:boolean()`.
     * @return int
     */
    pub fn isPhysical(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPhysical()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.isRestrict:boolean()`.
     * @return int
     */
    pub fn isRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestrict()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.getRestrict:Boolean()`.
     * @return int
     */
    pub fn getRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRestrict()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the server of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropDatabaseStatement.getServer:String()`.
     * @return string
     */
    pub fn getServer(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDropDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getServer()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDropEventStatement extends SQLStatementImpl {
    
}
impl SQLDropEventStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropEventStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropEventStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropEventStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropEventStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropEventStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropEventStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropFunctionStatement extends SQLStatementImpl {
    
}
impl SQLDropFunctionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropFunctionStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropFunctionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropFunctionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropFunctionStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is temporary of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropFunctionStatement.isTemporary:boolean()`.
     * @return int
     */
    pub fn isTemporary(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTemporary()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropFunctionStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropIndexStatement extends SQLStatementImpl {
    
}
impl SQLDropIndexStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropIndexStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropIndexStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropIndexStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropIndexStatement.getAlgorithm:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAlgorithm(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAlgorithmOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropIndexStatement.getIndexName:SQLName()`.
     * @return SQLName
     */
    pub fn getIndexName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropIndexStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lock option oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropIndexStatement.getLockOption:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLockOption(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLockOptionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropIndexStatement.getTableName:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableName(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlDropIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropLogFileGroupStatement extends SQLStatementImpl {
    
}
impl SQLDropLogFileGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropLogFileGroupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropLogFileGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropLogFileGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropLogFileGroupStatement.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropLogFileGroupStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropMaterializedViewStatement extends SQLStatementImpl {
    
}
impl SQLDropMaterializedViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropMaterializedViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropMaterializedViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropMaterializedViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropMaterializedViewStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropMaterializedViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropMaterializedViewStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropOutlineStatement extends SQLStatementImpl {
    
}
impl SQLDropOutlineStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropOutlineStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropOutlineStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropOutlineStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropOutlineStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropOutlineStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropOutlineStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropOutlineStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropProcedureStatement extends SQLStatementImpl {
    
}
impl SQLDropProcedureStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropProcedureStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropProcedureStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropProcedureStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropProcedureStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropProcedureStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropProcedureStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropResourceGroupStatement extends SQLStatementImpl {
    
}
impl SQLDropResourceGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropResourceGroupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropResourceGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropResourceGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropResourceGroupStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropResourceGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropResourceGroupStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropResourceGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropResourceStatement extends SQLStatementImpl {
    
}
impl SQLDropResourceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropResourceStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropResourceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropResourceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropResourceStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropResourceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropResourceStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropResourceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropRoleStatement extends SQLStatementImpl {
    
}
impl SQLDropRoleStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropRoleStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropRoleStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropRoleStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropRoleStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropRoleStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropRoleStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropRoleStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropSequenceStatement extends SQLStatementImpl {
    
}
impl SQLDropSequenceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropSequenceStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropSequenceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropSequenceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropSequenceStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropSequenceStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropSequenceStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDropSequenceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDropServerStatement extends SQLStatementImpl {
    
}
impl SQLDropServerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropServerStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropServerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropServerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropServerStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropServerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropServerStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropSynonymStatement extends SQLStatementImpl {
    
}
impl SQLDropSynonymStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropSynonymStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropSynonymStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropSynonymStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropSynonymStatement.isForce:boolean()`.
     * @return int
     */
    pub fn isForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropSynonymStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropSynonymStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropSynonymStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is public of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropSynonymStatement.isPublic:boolean()`.
     * @return int
     */
    pub fn isPublic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropSynonymStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPublic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropSynonymStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropSynonymStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropSynonymStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDropSynonymStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDropTableGroupStatement extends SQLStatementImpl {
    
}
impl SQLDropTableGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropTableGroupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropTableGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropTableGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableGroupStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableGroupStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropTableGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table group name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableGroupStatement.getTableGroupName:String()`.
     * @return string
     */
    pub fn getTableGroupName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDropTableGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTableGroupName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDropTableSpaceStatement extends SQLStatementImpl {
    
}
impl SQLDropTableSpaceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropTableSpaceStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropTableSpaceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropTableSpaceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableSpaceStatement.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableSpaceStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableSpaceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableSpaceStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table space name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableSpaceStatement.getTableSpaceName:String()`.
     * @return string
     */
    pub fn getTableSpaceName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlDropTableSpaceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTableSpaceName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLDropTableStatement extends SQLStatementImpl {
    
}
impl SQLDropTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.isCascade:boolean()`.
     * @return int
     */
    pub fn isCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is drop partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.isDropPartition:boolean()`.
     * @return int
     */
    pub fn isDropPartition(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDropPartition()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is external of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.isExternal:boolean()`.
     * @return int
     */
    pub fn isExternal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExternal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is purge of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.isPurge:boolean()`.
     * @return int
     */
    pub fn isPurge(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPurge()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.isRestrict:boolean()`.
     * @return int
     */
    pub fn isRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestrict()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is temporary of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.isTemporary:boolean()`.
     * @return int
     */
    pub fn isTemporary(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTemporary()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the table sources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTableStatement.getTableSources:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSources(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLDropTriggerStatement extends SQLStatementImpl {
    
}
impl SQLDropTriggerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropTriggerStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropTriggerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropTriggerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTriggerStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTriggerStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlDropTriggerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropTypeStatement extends SQLStatementImpl {
    
}
impl SQLDropTypeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropTypeStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropTypeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropTypeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTypeStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropTypeStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlDropTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLDropUserStatement extends SQLStatementImpl {
    
}
impl SQLDropUserStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropUserStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropUserStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropUserStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropUserStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropUserStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the users of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropUserStatement.getUsers:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getUsers(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLDropViewStatement extends SQLStatementImpl {
    
}
impl SQLDropViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDropViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDropViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDropViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropViewStatement.isCascade:boolean()`.
     * @return int
     */
    pub fn isCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropViewStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropViewStatement.isRestrict:boolean()`.
     * @return int
     */
    pub fn isRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDropViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestrict()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table sources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDropViewStatement.getTableSources:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSources(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLDumpStatement extends SQLStatementImpl {
    
}
impl SQLDumpStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLDumpStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlDumpStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLDumpStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDumpStatement.getInto:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getInto(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlDumpStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is overwrite of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDumpStatement.isOverwrite:boolean()`.
     * @return int
     */
    pub fn isOverwrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlDumpStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOverwrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLDumpStatement.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlDumpStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLErrorLoggingClause extends SQLObject {
    
}
impl SQLErrorLoggingClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLErrorLoggingClause {
        for (tmp in SQLObject(db)) {
            for (x in SqlErrorLoggingClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLErrorLoggingClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLErrorLoggingClause.getInto:SQLName()`.
     * @return SQLName
     */
    pub fn getInto(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlErrorLoggingClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLErrorLoggingClause.getLimit:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLimit(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlErrorLoggingClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the simple expression oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLErrorLoggingClause.getSimpleExpression:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSimpleExpression(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlErrorLoggingClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSimpleExpressionOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLExplainAnalyzeStatement extends SQLStatementImpl {
    
}
impl SQLExplainAnalyzeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExplainAnalyzeStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlExplainAnalyzeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExplainAnalyzeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainAnalyzeStatement.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlExplainAnalyzeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLExplainStatement extends SQLStatementImpl {
    
}
impl SQLExplainStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExplainStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlExplainStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExplainStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the format of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.getFormat:String()`.
     * @return string
     */
    pub fn getFormat(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFormat()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is authorization of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.isAuthorization:boolean()`.
     * @return int
     */
    pub fn isAuthorization(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAuthorization()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is dependency of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.isDependency:boolean()`.
     * @return int
     */
    pub fn isDependency(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDependency()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is extended of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.isExtended:boolean()`.
     * @return int
     */
    pub fn isExtended(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExtended()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is optimizer of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.isOptimizer:boolean()`.
     * @return int
     */
    pub fn isOptimizer(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOptimizer()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is parenthesis of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.isParenthesis:boolean()`.
     * @return int
     */
    pub fn isParenthesis(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsParenthesis()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statement oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.getStatement:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getStatement(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlExplainStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatementOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.getType:String()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExplainStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLExportDatabaseStatement extends SQLStatementImpl {
    
}
impl SQLExportDatabaseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExportDatabaseStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlExportDatabaseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExportDatabaseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the db oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExportDatabaseStatement.getDb:SQLName()`.
     * @return SQLName
     */
    pub fn getDb(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlExportDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is realtime of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExportDatabaseStatement.isRealtime:boolean()`.
     * @return int
     */
    pub fn isRealtime(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExportDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRealtime()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLExportTableStatement extends SQLStatementImpl {
    
}
impl SQLExportTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExportTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlExportTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExportTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the for replication oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExportTableStatement.getForReplication:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getForReplication(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExportTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForReplicationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExportTableStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlExportTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExportTableStatement.getTo:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTo(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExportTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExportTableStatement.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLExprHint extends SQLObject {
    
}
impl SQLExprHint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExprHint {
        for (tmp in SQLObject(db)) {
            for (x in SqlExprHintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExprHint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprHint.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExprHintDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLExprStatement extends SQLStatementImpl {
    
}
impl SQLExprStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExprStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlExprStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExprStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprStatement.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExprStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLExprTableSource extends SQLTableSourceImpl {
    
}
impl SQLExprTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExprTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in SqlExprTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExprTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the catalog of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getCatalog:String()`.
     * @return string
     */
    pub fn getCatalog(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlExprTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCatalog()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExprTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlExprTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getPartitionSize:int()`.
     * @return int
     */
    pub fn getPartitionSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExprTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPartitionSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sampling oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getSampling:SQLTableSampling()`.
     * @return SQLTableSampling
     */
    pub fn getSampling(self) -> SQLTableSampling {
        for (s in SQLTableSampling(__all_data__),
            x in SqlExprTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSamplingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlExprTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the schema object of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getSchemaObject:SchemaObject()`.
     * @return string
     */
    pub fn getSchemaObject(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlExprTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchemaObject()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getTableName:String()`.
     * @return string
     */
    pub fn getTableName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlExprTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTableName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the columns direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getColumnsDirect:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumnsDirect(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExprTableSource.getPartitions:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getPartitions(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLExternalRecordFormat extends SQLObject {
    
}
impl SQLExternalRecordFormat {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLExternalRecordFormat {
        for (tmp in SQLObject(db)) {
            for (x in SqlExternalRecordFormatDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLExternalRecordFormat {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the badfile of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getBadfile:Boolean()`.
     * @return int
     */
    pub fn getBadfile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExternalRecordFormatDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getBadfile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the collection items terminated by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getCollectionItemsTerminatedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCollectionItemsTerminatedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExternalRecordFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCollectionItemsTerminatedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the delimited by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getDelimitedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDelimitedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExternalRecordFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDelimitedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the escaped by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getEscapedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEscapedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExternalRecordFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEscapedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is ltrim of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.isLtrim:boolean()`.
     * @return int
     */
    pub fn isLtrim(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExternalRecordFormatDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLtrim()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is missing field values are null of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.isMissingFieldValuesAreNull:boolean()`.
     * @return int
     */
    pub fn isMissingFieldValuesAreNull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExternalRecordFormatDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsMissingFieldValuesAreNull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is reject rows with all null fields of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.isRejectRowsWithAllNullFields:boolean()`.
     * @return int
     */
    pub fn isRejectRowsWithAllNullFields(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExternalRecordFormatDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRejectRowsWithAllNullFields()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lines terminated by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getLinesTerminatedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLinesTerminatedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExternalRecordFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLinesTerminatedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the logfile of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getLogfile:Boolean()`.
     * @return int
     */
    pub fn getLogfile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlExternalRecordFormatDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLogfile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the map keys terminated by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getMapKeysTerminatedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMapKeysTerminatedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExternalRecordFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMapKeysTerminatedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the null defined as oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getNullDefinedAs:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNullDefinedAs(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExternalRecordFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNullDefinedAsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the serde oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getSerde:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSerde(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExternalRecordFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSerdeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the terminated by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLExternalRecordFormat.getTerminatedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTerminatedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlExternalRecordFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTerminatedByOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLFetchStatement extends SQLStatementImpl {
    
}
impl SQLFetchStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLFetchStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlFetchStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLFetchStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cursor name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLFetchStatement.getCursorName:SQLName()`.
     * @return SQLName
     */
    pub fn getCursorName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlFetchStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCursorNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is bulk collect of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLFetchStatement.isBulkCollect:boolean()`.
     * @return int
     */
    pub fn isBulkCollect(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlFetchStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBulkCollect()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLFetchStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in SqlFetchStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the into of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLFetchStatement.getInto:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getInto(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLForStatement extends SQLStatementImpl {
    
}
impl SQLForStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLForStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlForStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLForStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForStatement.getIndex:SQLName()`.
     * @return SQLName
     */
    pub fn getIndex(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlForStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the range oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForStatement.getRange:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRange(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlForStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRangeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the statements of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForStatement.getStatements:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getStatements(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLForeignKeyImpl extends SQLConstraintImpl {
    
}
impl SQLForeignKeyImpl {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLForeignKeyImpl {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlForeignKeyImplDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLForeignKeyImpl {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is disable novalidate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForeignKeyImpl.isDisableNovalidate:boolean()`.
     * @return int
     */
    pub fn isDisableNovalidate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlForeignKeyImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDisableNovalidate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on delete cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForeignKeyImpl.isOnDeleteCascade:boolean()`.
     * @return int
     */
    pub fn isOnDeleteCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlForeignKeyImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnDeleteCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on delete set null of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForeignKeyImpl.isOnDeleteSetNull:boolean()`.
     * @return int
     */
    pub fn isOnDeleteSetNull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlForeignKeyImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnDeleteSetNull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the referenced table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForeignKeyImpl.getReferencedTableName:SQLName()`.
     * @return SQLName
     */
    pub fn getReferencedTableName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlForeignKeyImplDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReferencedTableNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the referenced table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForeignKeyImpl.getReferencedTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getReferencedTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlForeignKeyImplDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReferencedTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the referenced columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForeignKeyImpl.getReferencedColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getReferencedColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the referencing columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLForeignKeyImpl.getReferencingColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getReferencingColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLGrantStatement extends SQLPrivilegeStatement {
    
}
impl SQLGrantStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLGrantStatement {
        for (tmp in SQLPrivilegeStatement(db)) {
            for (x in SqlGrantStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLGrantStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the identified by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.getIdentifiedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIdentifiedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlGrantStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIdentifiedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the identified by password of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.getIdentifiedByPassword:String()`.
     * @return string
     */
    pub fn getIdentifiedByPassword(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlGrantStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIdentifiedByPassword()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is admin option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.isAdminOption:boolean()`.
     * @return int
     */
    pub fn isAdminOption(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlGrantStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAdminOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the max connections per hour oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.getMaxConnectionsPerHour:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxConnectionsPerHour(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlGrantStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxConnectionsPerHourOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the max queries per hour oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.getMaxQueriesPerHour:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxQueriesPerHour(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlGrantStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxQueriesPerHourOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the max updates per hour oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.getMaxUpdatesPerHour:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxUpdatesPerHour(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlGrantStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxUpdatesPerHourOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the max user connections oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.getMaxUserConnections:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxUserConnections(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlGrantStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxUserConnectionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resource type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.getResourceType:SQLObjectType()`.
     * @return string
     */
    pub fn getResourceType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlGrantStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getResourceType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with grant option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLGrantStatement.getWithGrantOption:boolean()`.
     * @return int
     */
    pub fn getWithGrantOption(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlGrantStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithGrantOption()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLIfStatement extends SQLStatementImpl {
    
}
impl SQLIfStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLIfStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlIfStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLIfStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the condition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLIfStatement.getCondition:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCondition(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlIfStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConditionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the else if list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLIfStatement.getElseIfList:List<ElseIf>()`.
     * @return string
     */
    pub fn getElseIfList(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIfStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getElseIfList()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the else item of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLIfStatement.getElseItem:Else()`.
     * @return string
     */
    pub fn getElseItem(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlIfStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getElseItem()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statements of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLIfStatement.getStatements:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getStatements(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLImportDatabaseStatement extends SQLStatementImpl {
    
}
impl SQLImportDatabaseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLImportDatabaseStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlImportDatabaseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLImportDatabaseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the db oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportDatabaseStatement.getDb:SQLName()`.
     * @return SQLName
     */
    pub fn getDb(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlImportDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the status oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportDatabaseStatement.getStatus:SQLName()`.
     * @return SQLName
     */
    pub fn getStatus(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlImportDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatusOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLImportTableStatement extends SQLStatementImpl {
    
}
impl SQLImportTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLImportTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlImportTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLImportTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportTableStatement.getFrom:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFrom(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlImportTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is extenal of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportTableStatement.isExtenal:boolean()`.
     * @return int
     */
    pub fn isExtenal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlImportTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExtenal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is using build of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportTableStatement.isUsingBuild:boolean()`.
     * @return int
     */
    pub fn isUsingBuild(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlImportTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUsingBuild()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the location oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportTableStatement.getLocation:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLocation(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlImportTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportTableStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlImportTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the version oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportTableStatement.getVersion:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getVersion(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in SqlImportTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getVersionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLImportTableStatement.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLInsertStatement extends SQLInsertInto {
    
}
impl SQLInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLInsertStatement {
        for (tmp in SQLInsertInto(db)) {
            for (x in SqlInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is after semi of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLInsertStatement.isAfterSemi:boolean()`.
     * @return int
     */
    pub fn isAfterSemi(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAfterSemi()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is upsert of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLInsertStatement.isUpsert:boolean()`.
     * @return int
     */
    pub fn isUpsert(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUpsert()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLInsertStatement.getWith:SQLWithSubqueryClause()`.
     * @return SQLWithSubqueryClause
     */
    pub fn getWith(self) -> SQLWithSubqueryClause {
        for (s in SQLWithSubqueryClause(__all_data__),
            x in SqlInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWithOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLJoinTableSource extends SQLTableSourceImpl {
    
}
impl SQLJoinTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLJoinTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in SqlJoinTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLJoinTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the condition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.getCondition:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCondition(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlJoinTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConditionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is asof of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.isAsof:boolean()`.
     * @return int
     */
    pub fn isAsof(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlJoinTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAsof()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlJoinTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is natural of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.isNatural:boolean()`.
     * @return int
     */
    pub fn isNatural(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlJoinTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNatural()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the join type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.getJoinType:JoinType()`.
     * @return string
     */
    pub fn getJoinType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlJoinTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJoinType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the left oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.getLeft:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getLeft(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlJoinTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLeftOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the right oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.getRight:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getRight(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlJoinTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRightOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the udj of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.getUdj:UDJ()`.
     * @return string
     */
    pub fn getUdj(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlJoinTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUdj()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLJoinTableSource.getUsing:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getUsing(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLLateralViewTableSource extends SQLTableSourceImpl {
    
}
impl SQLLateralViewTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLLateralViewTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in SqlLateralViewTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLLateralViewTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is outer of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLLateralViewTableSource.isOuter:boolean()`.
     * @return int
     */
    pub fn isOuter(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlLateralViewTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOuter()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the method oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLLateralViewTableSource.getMethod:SQLMethodInvokeExpr()`.
     * @return SQLMethodInvokeExpr
     */
    pub fn getMethod(self) -> SQLMethodInvokeExpr {
        for (s in SQLMethodInvokeExpr(__all_data__),
            x in SqlLateralViewTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMethodOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLLateralViewTableSource.getOn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlLateralViewTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLLateralViewTableSource.getTableSource:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getTableSource(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlLateralViewTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLLateralViewTableSource.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLLoopStatement extends SQLStatementImpl {
    
}
impl SQLLoopStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLLoopStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlLoopStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLLoopStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLLoopStatement.getLabelName:String()`.
     * @return string
     */
    pub fn getLabelName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlLoopStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabelName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statements of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLLoopStatement.getStatements:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getStatements(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLMergeStatement extends SQLStatementImpl {
    
}
impl SQLMergeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLMergeStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlMergeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLMergeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLMergeStatement.getAlias:String()`.
     * @return string
     */
    pub fn getAlias(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlMergeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the error logging clause oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLMergeStatement.getErrorLoggingClause:SQLErrorLoggingClause()`.
     * @return SQLErrorLoggingClause
     */
    pub fn getErrorLoggingClause(self) -> SQLErrorLoggingClause {
        for (s in SQLErrorLoggingClause(__all_data__),
            x in SqlMergeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getErrorLoggingClauseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the insert clause of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLMergeStatement.getInsertClause:MergeInsertClause()`.
     * @return string
     */
    pub fn getInsertClause(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlMergeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInsertClause()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLMergeStatement.getInto:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getInto(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlMergeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLMergeStatement.getOn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlMergeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the update clause of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLMergeStatement.getUpdateClause:MergeUpdateClause()`.
     * @return string
     */
    pub fn getUpdateClause(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlMergeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUpdateClause()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLMergeStatement.getUsing:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getUsing(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlMergeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLMergeStatement.getHints:List<SQLHint>()`.
     * @return SQLHint
     */
    pub fn getHints(self) -> *SQLHint {
        for (x in SQLHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLNotNullConstraint extends SQLConstraintImpl {
    
}
impl SQLNotNullConstraint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLNotNullConstraint {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlNotNullConstraintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLNotNullConstraint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLNullConstraint extends SQLConstraintImpl {
    
}
impl SQLNullConstraint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLNullConstraint {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlNullConstraintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLNullConstraint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLOpenStatement extends SQLStatementImpl {
    
}
impl SQLOpenStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLOpenStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlOpenStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLOpenStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cursor name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOpenStatement.getCursorName:SQLName()`.
     * @return SQLName
     */
    pub fn getCursorName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlOpenStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCursorNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the for oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOpenStatement.getFor:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFor(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlOpenStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOpenStatement.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the using of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOpenStatement.getUsing:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getUsing(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLOptimizeStatement extends SQLStatementImpl {
    
}
impl SQLOptimizeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLOptimizeStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlOptimizeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLOptimizeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cluster oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOptimizeStatement.getCluster:SQLName()`.
     * @return SQLName
     */
    pub fn getCluster(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlOptimizeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getClusterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the deduplicate by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOptimizeStatement.getDeduplicateBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDeduplicateBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlOptimizeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDeduplicateByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is deduplicate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOptimizeStatement.isDeduplicate:boolean()`.
     * @return int
     */
    pub fn isDeduplicate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlOptimizeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDeduplicate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is final of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOptimizeStatement.isFinal:boolean()`.
     * @return int
     */
    pub fn isFinal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlOptimizeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFinal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table sources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLOptimizeStatement.getTableSources:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSources(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLPartitionRef extends SQLObject {
    
}
impl SQLPartitionRef {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPartitionRef {
        for (tmp in SQLObject(db)) {
            for (x in SqlPartitionRefDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPartitionRef {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPartitionRef.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlPartitionRefDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema SQLPrimaryKeyImpl extends SQLUnique {
    
}
impl SQLPrimaryKeyImpl {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPrimaryKeyImpl {
        for (tmp in SQLUnique(db)) {
            for (x in SqlPrimaryKeyImplDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPrimaryKeyImpl {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is clustered of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPrimaryKeyImpl.isClustered:boolean()`.
     * @return int
     */
    pub fn isClustered(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPrimaryKeyImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsClustered()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is disable novalidate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPrimaryKeyImpl.isDisableNovalidate:boolean()`.
     * @return int
     */
    pub fn isDisableNovalidate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPrimaryKeyImplDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDisableNovalidate()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLPrivilegeItem extends SQLObject {
    
}
impl SQLPrivilegeItem {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPrivilegeItem {
        for (tmp in SQLObject(db)) {
            for (x in SqlPrivilegeItemDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPrivilegeItem {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the action oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPrivilegeItem.getAction:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAction(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPrivilegeItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getActionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPrivilegeItem.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLPurgeLogsStatement extends SQLStatementImpl {
    
}
impl SQLPurgeLogsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPurgeLogsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlPurgeLogsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPurgeLogsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the before oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeLogsStatement.getBefore:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getBefore(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPurgeLogsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getBeforeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is all of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeLogsStatement.isAll:boolean()`.
     * @return int
     */
    pub fn isAll(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPurgeLogsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAll()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is binary of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeLogsStatement.isBinary:boolean()`.
     * @return int
     */
    pub fn isBinary(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPurgeLogsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBinary()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is master of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeLogsStatement.isMaster:boolean()`.
     * @return int
     */
    pub fn isMaster(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPurgeLogsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsMaster()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeLogsStatement.getTo:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTo(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlPurgeLogsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLPurgeRecyclebinStatement extends SQLStatementImpl {
    
}
impl SQLPurgeRecyclebinStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPurgeRecyclebinStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlPurgeRecyclebinStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPurgeRecyclebinStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLPurgeTableStatement extends SQLStatementImpl {
    
}
impl SQLPurgeTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPurgeTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlPurgeTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPurgeTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the count of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeTableStatement.getCount:int()`.
     * @return int
     */
    pub fn getCount(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPurgeTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCount()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is all of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeTableStatement.isAll:boolean()`.
     * @return int
     */
    pub fn isAll(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlPurgeTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAll()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeTableStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlPurgeTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLPurgeTemporaryOutputStatement extends SQLStatementImpl {
    
}
impl SQLPurgeTemporaryOutputStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLPurgeTemporaryOutputStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlPurgeTemporaryOutputStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLPurgeTemporaryOutputStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLPurgeTemporaryOutputStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlPurgeTemporaryOutputStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLRefreshMaterializedViewStatement extends SQLStatementImpl {
    
}
impl SQLRefreshMaterializedViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLRefreshMaterializedViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlRefreshMaterializedViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLRefreshMaterializedViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRefreshMaterializedViewStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlRefreshMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLReleaseSavePointStatement extends SQLStatementImpl {
    
}
impl SQLReleaseSavePointStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLReleaseSavePointStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlReleaseSavePointStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLReleaseSavePointStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReleaseSavePointStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlReleaseSavePointStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLRenameUserStatement extends SQLStatementImpl {
    
}
impl SQLRenameUserStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLRenameUserStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlRenameUserStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLRenameUserStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRenameUserStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlRenameUserStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRenameUserStatement.getTo:SQLName()`.
     * @return SQLName
     */
    pub fn getTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlRenameUserStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLReplaceStatement extends SQLStatementImpl {
    
}
impl SQLReplaceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLReplaceStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlReplaceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLReplaceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hints size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.getHintsSize:int()`.
     * @return int
     */
    pub fn getHintsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlReplaceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is delayed of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.isDelayed:boolean()`.
     * @return int
     */
    pub fn isDelayed(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlReplaceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDelayed()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is low priority of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.isLowPriority:boolean()`.
     * @return int
     */
    pub fn isLowPriority(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlReplaceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLowPriority()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.getQuery:SQLQueryExpr()`.
     * @return SQLQueryExpr
     */
    pub fn getQuery(self) -> SQLQueryExpr {
        for (s in SQLQueryExpr(__all_data__),
            x in SqlReplaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.getTableName:SQLName()`.
     * @return SQLName
     */
    pub fn getTableName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlReplaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlReplaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the values list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.getValuesList:List<ValuesClause>()`.
     * @return string
     */
    pub fn getValuesList(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlReplaceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValuesList()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.getColumns:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getColumns(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReplaceStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLRestoreStatement extends SQLStatementImpl {
    
}
impl SQLRestoreStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLRestoreStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlRestoreStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLRestoreStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRestoreStatement.getType:SQLName()`.
     * @return SQLName
     */
    pub fn getType(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlRestoreStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRestoreStatement.getProperties:List<SQLCharExpr>()`.
     * @return SQLCharExpr
     */
    pub fn getProperties(self) -> *SQLCharExpr {
        for (x in SQLCharExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLReturnStatement extends SQLStatementImpl {
    
}
impl SQLReturnStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLReturnStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlReturnStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLReturnStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLReturnStatement.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlReturnStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLRevokeStatement extends SQLPrivilegeStatement {
    
}
impl SQLRevokeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLRevokeStatement {
        for (tmp in SQLPrivilegeStatement(db)) {
            for (x in SqlRevokeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLRevokeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is grant option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRevokeStatement.isGrantOption:boolean()`.
     * @return int
     */
    pub fn isGrantOption(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlRevokeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGrantOption()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLRollbackStatement extends SQLStatementImpl {
    
}
impl SQLRollbackStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLRollbackStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlRollbackStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLRollbackStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the chain of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRollbackStatement.getChain:Boolean()`.
     * @return int
     */
    pub fn getChain(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlRollbackStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getChain()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the force oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRollbackStatement.getForce:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getForce(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlRollbackStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the release of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRollbackStatement.getRelease:Boolean()`.
     * @return int
     */
    pub fn getRelease(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlRollbackStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRelease()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLRollbackStatement.getTo:SQLName()`.
     * @return SQLName
     */
    pub fn getTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlRollbackStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLSavePointStatement extends SQLStatementImpl {
    
}
impl SQLSavePointStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSavePointStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlSavePointStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSavePointStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSavePointStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSavePointStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLScriptCommitStatement extends SQLStatementImpl {
    
}
impl SQLScriptCommitStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLScriptCommitStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlScriptCommitStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLScriptCommitStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLSelect extends SQLObject {
    
}
impl SQLSelect {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSelect {
        for (tmp in SQLObject(db)) {
            for (x in SqlSelectDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSelect {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the first query block oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getFirstQueryBlock:SQLSelectQueryBlock()`.
     * @return SQLSelectQueryBlock
     */
    pub fn getFirstQueryBlock(self) -> SQLSelectQueryBlock {
        for (s in SQLSelectQueryBlock(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFirstQueryBlockOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the for xml options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getForXmlOptions:List<String>()`.
     * @return string
     */
    pub fn getForXmlOptions(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getForXmlOptions()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the for xml options size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getForXmlOptionsSize:int()`.
     * @return int
     */
    pub fn getForXmlOptionsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getForXmlOptionsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the head hint oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getHeadHint:SQLHint()`.
     * @return SQLHint
     */
    pub fn getHeadHint(self) -> SQLHint {
        for (s in SQLHint(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getHeadHintOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getHintsSize:int()`.
     * @return int
     */
    pub fn getHintsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is for browse of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.isForBrowse:boolean()`.
     * @return int
     */
    pub fn isForBrowse(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForBrowse()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is simple of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.isSimple:boolean()`.
     * @return int
     */
    pub fn isSimple(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSimple()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the offset oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getOffset:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOffset(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOffsetOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getQuery:SQLSelectQuery()`.
     * @return SQLSelectQuery
     */
    pub fn getQuery(self) -> SQLSelectQuery {
        for (s in SQLSelectQuery(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the query block oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getQueryBlock:SQLSelectQueryBlock()`.
     * @return SQLSelectQueryBlock
     */
    pub fn getQueryBlock(self) -> SQLSelectQueryBlock {
        for (s in SQLSelectQueryBlock(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getQueryBlockOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the restriction of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getRestriction:SQLObject()`.
     * @return string
     */
    pub fn getRestriction(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRestriction()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the row count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getRowCount:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRowCount(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowCountOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getWithSubQuery:SQLWithSubqueryClause()`.
     * @return SQLWithSubqueryClause
     */
    pub fn getWithSubQuery(self) -> SQLWithSubqueryClause {
        for (s in SQLWithSubqueryClause(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWithSubQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the xml path oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getXmlPath:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getXmlPath(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getXmlPathOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelect.getHints:List<SQLHint>()`.
     * @return SQLHint
     */
    pub fn getHints(self) -> *SQLHint {
        for (x in SQLHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLSelectGroupByClause extends SQLObject {
    
}
impl SQLSelectGroupByClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSelectGroupByClause {
        for (tmp in SQLObject(db)) {
            for (x in SqlSelectGroupByClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSelectGroupByClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the having oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause.getHaving:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getHaving(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectGroupByClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getHavingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hint oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause.getHint:SQLCommentHint()`.
     * @return SQLCommentHint
     */
    pub fn getHint(self) -> SQLCommentHint {
        for (s in SQLCommentHint(__all_data__),
            x in SqlSelectGroupByClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getHintOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is distinct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause.isDistinct:boolean()`.
     * @return int
     */
    pub fn isDistinct(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectGroupByClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDistinct()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is paren of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause.isParen:boolean()`.
     * @return int
     */
    pub fn isParen(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectGroupByClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsParen()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with cube of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause.isWithCube:boolean()`.
     * @return int
     */
    pub fn isWithCube(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectGroupByClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithCube()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with roll up of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause.isWithRollUp:boolean()`.
     * @return int
     */
    pub fn isWithRollUp(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectGroupByClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithRollUp()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectGroupByClause.getItems:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getItems(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLSelectItem extends SQLObject {
    
}
impl SQLSelectItem {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSelectItem {
        for (tmp in SQLObject(db)) {
            for (x in SqlSelectItemDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSelectItem {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectItem.getAlias:String()`.
     * @return string
     */
    pub fn getAlias(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias2 of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectItem.getAlias2:String()`.
     * @return string
     */
    pub fn getAlias2(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias2()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectItem.getAliasList:List<String>()`.
     * @return string
     */
    pub fn getAliasList(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAliasList()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectItem.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is connect by root of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectItem.isConnectByRoot:boolean()`.
     * @return int
     */
    pub fn isConnectByRoot(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsConnectByRoot()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is udtf select item of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectItem.isUDTFSelectItem:boolean()`.
     * @return int
     */
    pub fn isUDTFSelectItem(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUdtfSelectItem()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLSelectOrderByItem extends SQLObject {
    
}
impl SQLSelectOrderByItem {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSelectOrderByItem {
        for (tmp in SQLObject(db)) {
            for (x in SqlSelectOrderByItemDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSelectOrderByItem {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the collate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem.getCollate:String()`.
     * @return string
     */
    pub fn getCollate(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectOrderByItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCollate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectOrderByItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is cluster by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem.isClusterBy:boolean()`.
     * @return int
     */
    pub fn isClusterBy(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectOrderByItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsClusterBy()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is distribute by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem.isDistributeBy:boolean()`.
     * @return int
     */
    pub fn isDistributeBy(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectOrderByItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDistributeBy()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is sort by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem.isSortBy:boolean()`.
     * @return int
     */
    pub fn isSortBy(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectOrderByItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSortBy()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the nulls order type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem.getNullsOrderType:NullsOrderType()`.
     * @return string
     */
    pub fn getNullsOrderType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectOrderByItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNullsOrderType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved select item oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem.getResolvedSelectItem:SQLSelectItem()`.
     * @return SQLSelectItem
     */
    pub fn getResolvedSelectItem(self) -> SQLSelectItem {
        for (s in SQLSelectItem(__all_data__),
            x in SqlSelectOrderByItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedSelectItemOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectOrderByItem.getType:SQLOrderingSpecification()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectOrderByItemDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLSelectQueryBlock extends SQLSelectQueryBase {
    
}
impl SQLSelectQueryBlock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSelectQueryBlock {
        for (tmp in SQLSelectQueryBase(db)) {
            for (x in SqlSelectQueryBlockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSelectQueryBlock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cached select list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getCachedSelectList:String()`.
     * @return string
     */
    pub fn getCachedSelectList(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCachedSelectList()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cached select list hash of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getCachedSelectListHash:long()`.
     * @return string
     */
    pub fn getCachedSelectListHash(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCachedSelectListHash()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the connect by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getConnectBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getConnectBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConnectByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the distion option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getDistionOption:int()`.
     * @return int
     */
    pub fn getDistionOption(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDistionOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the first oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getFirst:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFirst(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFirstOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the for update of size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getForUpdateOfSize:int()`.
     * @return int
     */
    pub fn getForUpdateOfSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getForUpdateOfSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getFrom:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getFrom(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the group by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getGroupBy:SQLSelectGroupByClause()`.
     * @return SQLSelectGroupByClause
     */
    pub fn getGroupBy(self) -> SQLSelectGroupByClause {
        for (s in SQLSelectGroupByClause(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getGroupByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getHintsSize:int()`.
     * @return int
     */
    pub fn getHintsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getInto:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getInto(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is distinct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.isDistinct:boolean()`.
     * @return int
     */
    pub fn isDistinct(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDistinct()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is for share of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.isForShare:boolean()`.
     * @return int
     */
    pub fn isForShare(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForShare()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is for update of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.isForUpdate:boolean()`.
     * @return int
     */
    pub fn isForUpdate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForUpdate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no cycle of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.isNoCycle:boolean()`.
     * @return int
     */
    pub fn isNoCycle(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoCycle()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no wait of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.isNoWait:boolean()`.
     * @return int
     */
    pub fn isNoWait(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoWait()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is prior of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.isPrior:boolean()`.
     * @return int
     */
    pub fn isPrior(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPrior()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is skip locked of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.isSkipLocked:boolean()`.
     * @return int
     */
    pub fn isSkipLocked(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSkipLocked()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the offset oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getOffset:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOffset(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOffsetOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by siblings oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getOrderBySiblings:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBySiblings(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderBySiblingsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the start with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getStartWith:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStartWith(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStartWithOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the wait time oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getWaitTime:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWaitTime(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWaitTimeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the cluster by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getClusterBy:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getClusterBy(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the cluster by direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getClusterByDirect:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getClusterByDirect(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the distribute by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getDistributeBy:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getDistributeBy(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the distribute by direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getDistributeByDirect:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getDistributeByDirect(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the for update of of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getForUpdateOf:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getForUpdateOf(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the hints direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getHintsDirect:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHintsDirect(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the mapp join table sources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getMappJoinTableSources:List<SQLTableSource>()`.
     * @return SQLTableSource
     */
    pub fn getMappJoinTableSources(self) -> *SQLTableSource {
        for (x in SQLTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the select list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getSelectList:List<SQLSelectItem>()`.
     * @return SQLSelectItem
     */
    pub fn getSelectList(self) -> *SQLSelectItem {
        for (x in SQLSelectItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the sort by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getSortBy:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getSortBy(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the sort by direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getSortByDirect:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getSortByDirect(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the windows of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock.getWindows:List<SQLWindow>()`.
     * @return SQLWindow
     */
    pub fn getWindows(self) -> *SQLWindow {
        for (x in SQLWindow(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLSelectStatement extends SQLStatementImpl {
    
}
impl SQLSelectStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSelectStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlSelectStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSelectStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSelectStatement.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlSelectStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLSetStatement extends SQLStatementImpl {
    
}
impl SQLSetStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSetStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlSetStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSetStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSetStatement.getOption:Option()`.
     * @return string
     */
    pub fn getOption(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlSetStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSetStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSetStatement.getItems:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getItems(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLShowACLStatement extends SQLStatementImpl {
    
}
impl SQLShowACLStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowACLStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowAclStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowACLStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowACLStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlShowAclStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowCatalogsStatement extends SQLStatementImpl {
    
}
impl SQLShowCatalogsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowCatalogsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowCatalogsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowCatalogsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowCatalogsStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowCatalogsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowColumnsStatement extends SQLStatementImpl {
    
}
impl SQLShowColumnsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowColumnsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowColumnsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowColumnsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowColumnsStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowColumnsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowColumnsStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowColumnsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowColumnsStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowColumnsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowColumnsStatement.getTable:SQLName()`.
     * @return SQLName
     */
    pub fn getTable(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowColumnsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowColumnsStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowColumnsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowCreateMaterializedViewStatement extends SQLStatementImpl {
    
}
impl SQLShowCreateMaterializedViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowCreateMaterializedViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowCreateMaterializedViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowCreateMaterializedViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowCreateMaterializedViewStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowCreateMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowCreateTableStatement extends SQLStatementImpl {
    
}
impl SQLShowCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowCreateTableStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is all of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowCreateTableStatement.isAll:boolean()`.
     * @return int
     */
    pub fn isAll(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAll()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like mapping oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowCreateTableStatement.getLikeMapping:SQLName()`.
     * @return SQLName
     */
    pub fn getLikeMapping(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeMappingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowCreateTableStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowCreateViewStatement extends SQLStatementImpl {
    
}
impl SQLShowCreateViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowCreateViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowCreateViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowCreateViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowCreateViewStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowCreateViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowDatabasesStatement extends SQLStatementImpl {
    
}
impl SQLShowDatabasesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowDatabasesStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowDatabasesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowDatabasesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowDatabasesStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowDatabasesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is extra of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowDatabasesStatement.isExtra:boolean()`.
     * @return int
     */
    pub fn isExtra(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowDatabasesStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExtra()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowDatabasesStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowDatabasesStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is physical of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowDatabasesStatement.isPhysical:boolean()`.
     * @return int
     */
    pub fn isPhysical(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowDatabasesStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPhysical()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowDatabasesStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowDatabasesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowDatabasesStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowDatabasesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowErrorsStatement extends SQLStatementImpl {
    
}
impl SQLShowErrorsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowErrorsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowErrorsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowErrorsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLShowFunctionsStatement extends SQLStatementImpl {
    
}
impl SQLShowFunctionsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowFunctionsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowFunctionsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowFunctionsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowFunctionsStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowFunctionsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowGrantsStatement extends SQLStatementImpl {
    
}
impl SQLShowGrantsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowGrantsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowGrantsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowGrantsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowGrantsStatement.getOn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowGrantsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowGrantsStatement.getUser:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUser(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowGrantsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowHistoryStatement extends SQLStatementImpl {
    
}
impl SQLShowHistoryStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowHistoryStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowHistoryStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowHistoryStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is tables of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowHistoryStatement.isTables:boolean()`.
     * @return int
     */
    pub fn isTables(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowHistoryStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTables()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowHistoryStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlShowHistoryStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowHistoryStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowHistoryStatement.getProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLShowIndexesStatement extends SQLStatementImpl {
    
}
impl SQLShowIndexesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowIndexesStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowIndexesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowIndexesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowIndexesStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowIndexesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowIndexesStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlShowIndexesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowIndexesStatement.getType:String()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlShowIndexesStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowIndexesStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowIndexesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowIndexesStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLShowMaterializedViewStatement extends SQLStatementImpl {
    
}
impl SQLShowMaterializedViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowMaterializedViewStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowMaterializedViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowMaterializedViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowMaterializedViewStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowMaterializedViewStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowMaterializedViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowOutlinesStatement extends SQLStatementImpl {
    
}
impl SQLShowOutlinesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowOutlinesStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowOutlinesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowOutlinesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowOutlinesStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in SqlShowOutlinesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowOutlinesStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlShowOutlinesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowOutlinesStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowOutlinesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowPackagesStatement extends SQLStatementImpl {
    
}
impl SQLShowPackagesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowPackagesStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowPackagesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowPackagesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLShowPartitionsStmt extends SQLStatementImpl {
    
}
impl SQLShowPartitionsStmt {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowPartitionsStmt {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowPartitionsStmtDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowPartitionsStmt {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowPartitionsStmt.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlShowPartitionsStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowPartitionsStmt.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowPartitionsStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowPartitionsStmt.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLShowProcessListStatement extends SQLStatementImpl {
    
}
impl SQLShowProcessListStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowProcessListStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowProcessListStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowProcessListStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowProcessListStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowProcessListStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is mpp of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowProcessListStatement.isMpp:boolean()`.
     * @return int
     */
    pub fn isMpp(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowProcessListStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsMpp()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowProcessListStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in SqlShowProcessListStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowProcessListStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlShowProcessListStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowProcessListStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowProcessListStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowQueryTaskStatement extends SQLStatementImpl {
    
}
impl SQLShowQueryTaskStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowQueryTaskStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowQueryTaskStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowQueryTaskStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the for oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowQueryTaskStatement.getFor:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFor(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowQueryTaskStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowQueryTaskStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowQueryTaskStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowQueryTaskStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in SqlShowQueryTaskStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowQueryTaskStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlShowQueryTaskStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowQueryTaskStatement.getUser:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUser(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowQueryTaskStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowQueryTaskStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowQueryTaskStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowRecylebinStatement extends SQLStatementImpl {
    
}
impl SQLShowRecylebinStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowRecylebinStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowRecylebinStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowRecylebinStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLShowRoleStatement extends SQLStatementImpl {
    
}
impl SQLShowRoleStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowRoleStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowRoleStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowRoleStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the grant oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowRoleStatement.getGrant:SQLName()`.
     * @return SQLName
     */
    pub fn getGrant(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowRoleStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getGrantOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowRolesStatement extends SQLStatementImpl {
    
}
impl SQLShowRolesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowRolesStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowRolesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowRolesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLShowSessionStatement extends SQLStatementImpl {
    
}
impl SQLShowSessionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowSessionStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowSessionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowSessionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowSessionStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowSessionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowStatisticListStmt extends SQLStatementImpl {
    
}
impl SQLShowStatisticListStmt {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowStatisticListStmt {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowStatisticListStmtDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowStatisticListStmt {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowStatisticListStmt.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowStatisticListStmtDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowStatisticListStmt.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlShowStatisticListStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowStatisticStmt extends SQLStatementImpl {
    
}
impl SQLShowStatisticStmt {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowStatisticStmt {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowStatisticStmtDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowStatisticStmt {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowStatisticStmt.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowStatisticStmtDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowStatisticStmt.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlShowStatisticStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowStatisticStmt.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowStatisticStmt.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLShowTableGroupsStatement extends SQLStatementImpl {
    
}
impl SQLShowTableGroupsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowTableGroupsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowTableGroupsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowTableGroupsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowTableGroupsStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowTableGroupsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowTablesStatement extends SQLStatementImpl {
    
}
impl SQLShowTablesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowTablesStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowTablesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowTablesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowTablesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement.getFrom:SQLName()`.
     * @return SQLName
     */
    pub fn getFrom(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowTablesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is extended of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement.isExtended:boolean()`.
     * @return int
     */
    pub fn isExtended(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowTablesStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExtended()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowTablesStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowTablesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowTablesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowUsersStatement extends SQLStatementImpl {
    
}
impl SQLShowUsersStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowUsersStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowUsersStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowUsersStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLShowVariantsStatement extends SQLStatementImpl {
    
}
impl SQLShowVariantsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowVariantsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowVariantsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowVariantsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowVariantsStatement.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowVariantsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is session of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowVariantsStatement.isSession:boolean()`.
     * @return int
     */
    pub fn isSession(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlShowVariantsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSession()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowVariantsStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowVariantsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowVariantsStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowVariantsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLShowViewsStatement extends SQLStatementImpl {
    
}
impl SQLShowViewsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLShowViewsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlShowViewsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLShowViewsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowViewsStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlShowViewsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLShowViewsStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlShowViewsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLStartTransactionStatement extends SQLStatementImpl {
    
}
impl SQLStartTransactionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLStartTransactionStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlStartTransactionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLStartTransactionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is begin of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLStartTransactionStatement.isBegin:boolean()`.
     * @return int
     */
    pub fn isBegin(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStartTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBegin()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is consistent snapshot of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLStartTransactionStatement.isConsistentSnapshot:boolean()`.
     * @return int
     */
    pub fn isConsistentSnapshot(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStartTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsConsistentSnapshot()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is read only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLStartTransactionStatement.isReadOnly:boolean()`.
     * @return int
     */
    pub fn isReadOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStartTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReadOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is work of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLStartTransactionStatement.isWork:boolean()`.
     * @return int
     */
    pub fn isWork(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlStartTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWork()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the isolation level of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLStartTransactionStatement.getIsolationLevel:IsolationLevel()`.
     * @return string
     */
    pub fn getIsolationLevel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlStartTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsolationLevel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLStartTransactionStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlStartTransactionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLStartTransactionStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLSubmitJobStatement extends SQLStatementImpl {
    
}
impl SQLSubmitJobStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSubmitJobStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlSubmitJobStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSubmitJobStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is await of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSubmitJobStatement.isAwait:boolean()`.
     * @return int
     */
    pub fn isAwait(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSubmitJobStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAwait()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSubmitJobStatement.getStatment:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getStatment(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlSubmitJobStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatmentOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLSubqueryTableSource extends SQLTableSourceImpl {
    
}
impl SQLSubqueryTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSubqueryTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in SqlSubqueryTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSubqueryTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSubqueryTableSource.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in SqlSubqueryTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSubqueryTableSource.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLSyncMetaStatement extends SQLStatementImpl {
    
}
impl SQLSyncMetaStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLSyncMetaStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlSyncMetaStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLSyncMetaStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSyncMetaStatement.getFrom:SQLName()`.
     * @return SQLName
     */
    pub fn getFrom(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlSyncMetaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSyncMetaStatement.getIgnore:Boolean()`.
     * @return int
     */
    pub fn getIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSyncMetaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSyncMetaStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlSyncMetaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLSyncMetaStatement.getRestrict:Boolean()`.
     * @return int
     */
    pub fn getRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlSyncMetaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRestrict()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLTableLike extends SQLObject {
    
}
impl SQLTableLike {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLTableLike {
        for (tmp in SQLObject(db)) {
            for (x in SqlTableLikeDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLTableLike {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is exclude properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableLike.isExcludeProperties:boolean()`.
     * @return int
     */
    pub fn isExcludeProperties(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableLikeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExcludeProperties()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is include properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableLike.isIncludeProperties:boolean()`.
     * @return int
     */
    pub fn isIncludeProperties(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableLikeDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIncludeProperties()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableLike.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlTableLikeDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLTableSampling extends SQLObject {
    
}
impl SQLTableSampling {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLTableSampling {
        for (tmp in SQLObject(db)) {
            for (x in SqlTableSamplingDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLTableSampling {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the bucket oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableSampling.getBucket:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getBucket(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlTableSamplingDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getBucketOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the byte length oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableSampling.getByteLength:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getByteLength(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlTableSamplingDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getByteLengthOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is bernoulli of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableSampling.isBernoulli:boolean()`.
     * @return int
     */
    pub fn isBernoulli(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableSamplingDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBernoulli()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is system of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableSampling.isSystem:boolean()`.
     * @return int
     */
    pub fn isSystem(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTableSamplingDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSystem()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableSampling.getOn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlTableSamplingDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the out of oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableSampling.getOutOf:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOutOf(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlTableSamplingDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOutOfOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the percent oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableSampling.getPercent:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPercent(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlTableSamplingDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPercentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the rows oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTableSampling.getRows:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRows(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlTableSamplingDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowsOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLTruncateStatement extends SQLStatementImpl {
    
}
impl SQLTruncateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLTruncateStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlTruncateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLTruncateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.getCascade:Boolean()`.
     * @return int
     */
    pub fn getCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is continue identity of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isContinueIdentity:boolean()`.
     * @return int
     */
    pub fn isContinueIdentity(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsContinueIdentity()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is drop storage of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isDropStorage:boolean()`.
     * @return int
     */
    pub fn isDropStorage(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDropStorage()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore delete triggers of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isIgnoreDeleteTriggers:boolean()`.
     * @return int
     */
    pub fn isIgnoreDeleteTriggers(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnoreDeleteTriggers()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is immediate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isImmediate:boolean()`.
     * @return int
     */
    pub fn isImmediate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsImmediate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isOnly:boolean()`.
     * @return int
     */
    pub fn isOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is partition all of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isPartitionAll:boolean()`.
     * @return int
     */
    pub fn isPartitionAll(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPartitionAll()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is purge snapshot log of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isPurgeSnapshotLog:boolean()`.
     * @return int
     */
    pub fn isPurgeSnapshotLog(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPurgeSnapshotLog()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restrict when delete triggers of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isRestrictWhenDeleteTriggers:boolean()`.
     * @return int
     */
    pub fn isRestrictWhenDeleteTriggers(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestrictWhenDeleteTriggers()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is reuse storage of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.isReuseStorage:boolean()`.
     * @return int
     */
    pub fn isReuseStorage(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReuseStorage()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the restart identity of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.getRestartIdentity:Boolean()`.
     * @return int
     */
    pub fn getRestartIdentity(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlTruncateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRestartIdentity()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partitions for adb of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.getPartitionsForADB:List<SQLIntegerExpr>()`.
     * @return SQLIntegerExpr
     */
    pub fn getPartitionsForADB(self) -> *SQLIntegerExpr {
        for (x in SQLIntegerExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the table sources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLTruncateStatement.getTableSources:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSources(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLUnionQuery extends SQLSelectQueryBase {
    
}
impl SQLUnionQuery {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUnionQuery {
        for (tmp in SQLSelectQueryBase(db)) {
            for (x in SqlUnionQueryDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUnionQuery {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the first query block oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQuery.getFirstQueryBlock:SQLSelectQueryBlock()`.
     * @return SQLSelectQueryBlock
     */
    pub fn getFirstQueryBlock(self) -> SQLSelectQueryBlock {
        for (s in SQLSelectQueryBlock(__all_data__),
            x in SqlUnionQueryDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFirstQueryBlockOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is empty of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQuery.isEmpty:boolean()`.
     * @return int
     */
    pub fn isEmpty(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlUnionQueryDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsEmpty()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the left oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQuery.getLeft:SQLSelectQuery()`.
     * @return SQLSelectQuery
     */
    pub fn getLeft(self) -> SQLSelectQuery {
        for (s in SQLSelectQuery(__all_data__),
            x in SqlUnionQueryDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLeftOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQuery.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in SqlUnionQueryDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the operator of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQuery.getOperator:SQLUnionOperator()`.
     * @return string
     */
    pub fn getOperator(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlUnionQueryDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOperator()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQuery.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlUnionQueryDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the right oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQuery.getRight:SQLSelectQuery()`.
     * @return SQLSelectQuery
     */
    pub fn getRight(self) -> SQLSelectQuery {
        for (s in SQLSelectQuery(__all_data__),
            x in SqlUnionQueryDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRightOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the relations of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQuery.getRelations:List<SQLSelectQuery>()`.
     * @return SQLSelectQuery
     */
    pub fn getRelations(self) -> *SQLSelectQuery {
        for (x in SQLSelectQuery(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLUnionQueryTableSource extends SQLTableSourceImpl {
    
}
impl SQLUnionQueryTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUnionQueryTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in SqlUnionQueryTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUnionQueryTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the union oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQueryTableSource.getUnion:SQLUnionQuery()`.
     * @return SQLUnionQuery
     */
    pub fn getUnion(self) -> SQLUnionQuery {
        for (s in SQLUnionQuery(__all_data__),
            x in SqlUnionQueryTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUnionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnionQueryTableSource.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLUnique extends SQLConstraintImpl {
    
}
impl SQLUnique {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUnique {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in SqlUniqueDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUnique {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnique.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlUniqueDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index definition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnique.getIndexDefinition:SQLIndexDefinition()`.
     * @return SQLIndexDefinition
     */
    pub fn getIndexDefinition(self) -> SQLIndexDefinition {
        for (s in SQLIndexDefinition(__all_data__),
            x in SqlUniqueDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexDefinitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnique.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlUniqueDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnique.getColumns:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getColumns(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the covering of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnique.getCovering:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getCovering(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLUnnestTableSource extends SQLTableSourceImpl {
    
}
impl SQLUnnestTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUnnestTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in SqlUnnestTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUnnestTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ordinality of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnnestTableSource.isOrdinality:boolean()`.
     * @return int
     */
    pub fn isOrdinality(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlUnnestTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrdinality()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnnestTableSource.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUnnestTableSource.getItems:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getItems(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLUpdateSetItem extends SQLObject {
    
}
impl SQLUpdateSetItem {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUpdateSetItem {
        for (tmp in SQLObject(db)) {
            for (x in SqlUpdateSetItemDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUpdateSetItem {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateSetItem.getColumn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getColumn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlUpdateSetItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateSetItem.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlUpdateSetItemDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLUpdateStatement extends SQLStatementImpl {
    
}
impl SQLUpdateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUpdateStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlUpdateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUpdateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getFrom:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getFrom(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in SqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getTableName:SQLName()`.
     * @return SQLName
     */
    pub fn getTableName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getTableSource:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getTableSource(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in SqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getWith:SQLWithSubqueryClause()`.
     * @return SQLWithSubqueryClause
     */
    pub fn getWith(self) -> SQLWithSubqueryClause {
        for (s in SQLWithSubqueryClause(__all_data__),
            x in SqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWithOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getItems:List<SQLUpdateSetItem>()`.
     * @return SQLUpdateSetItem
     */
    pub fn getItems(self) -> *SQLUpdateSetItem {
        for (x in SQLUpdateSetItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the returning of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUpdateStatement.getReturning:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getReturning(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLUseStatement extends SQLStatementImpl {
    
}
impl SQLUseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLUseStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlUseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLUseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLUseStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlUseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLValuesQuery extends SQLSelectQueryBase {
    
}
impl SQLValuesQuery {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLValuesQuery {
        for (tmp in SQLSelectQueryBase(db)) {
            for (x in SqlValuesQueryDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLValuesQuery {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLValuesQuery.getValues:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getValues(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLValuesTableSource extends SQLTableSourceImpl {
    
}
impl SQLValuesTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLValuesTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in SqlValuesTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLValuesTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is parenthesized of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLValuesTableSource.isParenthesized:boolean()`.
     * @return int
     */
    pub fn isParenthesized(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlValuesTableSourceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsParenthesized()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLValuesTableSource.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLValuesTableSource.getValues:List<SQLListExpr>()`.
     * @return SQLListExpr
     */
    pub fn getValues(self) -> *SQLListExpr {
        for (x in SQLListExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLWhileStatement extends SQLStatementImpl {
    
}
impl SQLWhileStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLWhileStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlWhileStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLWhileStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the condition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLWhileStatement.getCondition:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCondition(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlWhileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConditionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the label name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLWhileStatement.getLabelName:String()`.
     * @return string
     */
    pub fn getLabelName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlWhileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabelName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statements of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLWhileStatement.getStatements:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getStatements(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLWhoamiStatement extends SQLStatementImpl {
    
}
impl SQLWhoamiStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLWhoamiStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlWhoamiStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLWhoamiStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema SQLWithSubqueryClause extends SQLObject {
    
}
impl SQLWithSubqueryClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLWithSubqueryClause {
        for (tmp in SQLObject(db)) {
            for (x in SqlWithSubqueryClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLWithSubqueryClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the entries of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLWithSubqueryClause.getEntries:List<Entry>()`.
     * @return string
     */
    pub fn getEntries(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlWithSubqueryClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEntries()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the recursive of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.ast.statement.SQLWithSubqueryClause.getRecursive:Boolean()`.
     * @return int
     */
    pub fn getRecursive(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlWithSubqueryClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getRecursive()) {
                        return s
                    }
                }
            }
        }
    }
}
schema AntsparkCreateTableStatement extends SQLCreateTableStatement {
    
}
impl AntsparkCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *AntsparkCreateTableStatement {
        for (tmp in SQLCreateTableStatement(db)) {
            for (x in AntsparkCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield AntsparkCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the datasource oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.antspark.ast.AntsparkCreateTableStatement.getDatasource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getDatasource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in AntsparkCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatasourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the meta life cycle oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.antspark.ast.AntsparkCreateTableStatement.getMetaLifeCycle:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMetaLifeCycle(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in AntsparkCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMetaLifeCycleOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the serde properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.antspark.ast.AntsparkCreateTableStatement.getSerdeProperties:Map<String, SQLObject>()`.
     * @return string
     */
    pub fn getSerdeProperties(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in AntsparkCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSerdeProperties()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the mapped by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.antspark.ast.AntsparkCreateTableStatement.getMappedBy:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getMappedBy(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the skewed by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.antspark.ast.AntsparkCreateTableStatement.getSkewedBy:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getSkewedBy(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the skewed by on of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.antspark.ast.AntsparkCreateTableStatement.getSkewedByOn:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getSkewedByOn(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema BlinkCreateTableStatement extends SQLCreateTableStatement {
    
}
impl BlinkCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *BlinkCreateTableStatement {
        for (tmp in SQLCreateTableStatement(db)) {
            for (x in BlinkCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield BlinkCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the period for oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.blink.ast.BlinkCreateTableStatement.getPeriodFor:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPeriodFor(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in BlinkCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPeriodForOid()) {
                    return s
                }
            }
        }
    }
}
schema ClickhouseCreateTableStatement extends SQLCreateTableStatement {
    
}
impl ClickhouseCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *ClickhouseCreateTableStatement {
        for (tmp in SQLCreateTableStatement(db)) {
            for (x in ClickhouseCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield ClickhouseCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.clickhouse.ast.ClickhouseCreateTableStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in ClickhouseCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.clickhouse.ast.ClickhouseCreateTableStatement.getPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in ClickhouseCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the sample by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.clickhouse.ast.ClickhouseCreateTableStatement.getSampleBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSampleBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in ClickhouseCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSampleByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the settings of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.clickhouse.ast.ClickhouseCreateTableStatement.getSettings:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getSettings(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema DB2CreateTableStatement extends SQLCreateTableStatement {
    
}
impl DB2CreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DB2CreateTableStatement {
        for (tmp in SQLCreateTableStatement(db)) {
            for (x in Db2CreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DB2CreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2CreateTableStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in Db2CreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index in oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2CreateTableStatement.getIndexIn:SQLName()`.
     * @return SQLName
     */
    pub fn getIndexIn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in Db2CreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexInOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is data capture changes of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2CreateTableStatement.isDataCaptureChanges:boolean()`.
     * @return int
     */
    pub fn isDataCaptureChanges(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in Db2CreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDataCaptureChanges()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is data capture none of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2CreateTableStatement.isDataCaptureNone:boolean()`.
     * @return int
     */
    pub fn isDataCaptureNone(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in Db2CreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDataCaptureNone()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the validproc oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2CreateTableStatement.getValidproc:SQLName()`.
     * @return SQLName
     */
    pub fn getValidproc(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in Db2CreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValidprocOid()) {
                    return s
                }
            }
        }
    }
}
schema DB2SelectQueryBlock extends SQLSelectQueryBlock {
    
}
impl DB2SelectQueryBlock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DB2SelectQueryBlock {
        for (tmp in SQLSelectQueryBlock(db)) {
            for (x in Db2SelectQueryBlockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DB2SelectQueryBlock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is for read only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2SelectQueryBlock.isForReadOnly:boolean()`.
     * @return int
     */
    pub fn isForReadOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in Db2SelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForReadOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the isolation of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2SelectQueryBlock.getIsolation:Isolation()`.
     * @return string
     */
    pub fn getIsolation(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in Db2SelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsolation()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the optimize for oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2SelectQueryBlock.getOptimizeFor:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOptimizeFor(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in Db2SelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOptimizeForOid()) {
                    return s
                }
            }
        }
    }
}
schema DB2ValuesStatement extends DB2StatementImpl {
    
}
impl DB2ValuesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DB2ValuesStatement {
        for (tmp in DB2StatementImpl(db)) {
            for (x in Db2ValuesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DB2ValuesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.db2.ast.stmt.DB2ValuesStatement.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in Db2ValuesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema HiveInputOutputFormat extends SQLExprImpl {
    
}
impl HiveInputOutputFormat {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *HiveInputOutputFormat {
        for (tmp in SQLExprImpl(db)) {
            for (x in HiveInputOutputFormatDO(db)) {
                if (tmp.key_eq(x)) {
                    yield HiveInputOutputFormat {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the input oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveInputOutputFormat.getInput:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInput(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveInputOutputFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInputOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the output oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveInputOutputFormat.getOutput:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOutput(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveInputOutputFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOutputOid()) {
                    return s
                }
            }
        }
    }
}
schema HiveInsert extends SQLInsertInto {
    
}
impl HiveInsert {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *HiveInsert {
        for (tmp in SQLInsertInto(db)) {
            for (x in HiveInsertDO(db)) {
                if (tmp.key_eq(x)) {
                    yield HiveInsert {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveInsert.getQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in HiveInsertDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveInsert.getTableSource:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSource(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in HiveInsertDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableSourceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the values list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveInsert.getValuesList:List<ValuesClause>()`.
     * @return string
     */
    pub fn getValuesList(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in HiveInsertDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValuesList()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema HiveInsertStatement extends SQLInsertStatement {
    
}
impl HiveInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *HiveInsertStatement {
        for (tmp in SQLInsertStatement(db)) {
            for (x in HiveInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield HiveInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveInsertStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in HiveInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the head hints direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveInsertStatement.getHeadHintsDirect:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHeadHintsDirect(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema HiveMultiInsertStatement extends SQLStatementImpl {
    
}
impl HiveMultiInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *HiveMultiInsertStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in HiveMultiInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield HiveMultiInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveMultiInsertStatement.getFrom:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getFrom(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in HiveMultiInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveMultiInsertStatement.getWith:SQLWithSubqueryClause()`.
     * @return SQLWithSubqueryClause
     */
    pub fn getWith(self) -> SQLWithSubqueryClause {
        for (s in SQLWithSubqueryClause(__all_data__),
            x in HiveMultiInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWithOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.ast.HiveMultiInsertStatement.getItems:List<HiveInsert>()`.
     * @return HiveInsert
     */
    pub fn getItems(self) -> *HiveInsert {
        for (x in HiveInsert(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema HiveCreateFunctionStatement extends SQLCreateFunctionStatement {
    
}
impl HiveCreateFunctionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *HiveCreateFunctionStatement {
        for (tmp in SQLCreateFunctionStatement(db)) {
            for (x in HiveCreateFunctionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield HiveCreateFunctionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the class name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateFunctionStatement.getClassName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getClassName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getClassNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the code of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateFunctionStatement.getCode:String()`.
     * @return string
     */
    pub fn getCode(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in HiveCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCode()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is declare of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateFunctionStatement.isDeclare:boolean()`.
     * @return int
     */
    pub fn isDeclare(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in HiveCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDeclare()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the location oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateFunctionStatement.getLocation:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLocation(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the resource type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateFunctionStatement.getResourceType:ResourceType()`.
     * @return string
     */
    pub fn getResourceType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in HiveCreateFunctionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getResourceType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the symbol oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateFunctionStatement.getSymbol:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSymbol(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSymbolOid()) {
                    return s
                }
            }
        }
    }
}
schema HiveCreateTableStatement extends SQLCreateTableStatement {
    
}
impl HiveCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *HiveCreateTableStatement {
        for (tmp in SQLCreateTableStatement(db)) {
            for (x in HiveCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield HiveCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into buckets oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateTableStatement.getIntoBuckets:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIntoBuckets(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntoBucketsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is like query of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateTableStatement.isLikeQuery:boolean()`.
     * @return int
     */
    pub fn isLikeQuery(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in HiveCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLikeQuery()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the meta life cycle oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateTableStatement.getMetaLifeCycle:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMetaLifeCycle(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMetaLifeCycleOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the serde properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateTableStatement.getSerdeProperties:Map<String, SQLObject>()`.
     * @return string
     */
    pub fn getSerdeProperties(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in HiveCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSerdeProperties()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateTableStatement.getUsing:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUsing(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the mapped by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateTableStatement.getMappedBy:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getMappedBy(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the skewed by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateTableStatement.getSkewedBy:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getSkewedBy(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the skewed by on of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveCreateTableStatement.getSkewedByOn:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getSkewedByOn(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema HiveLoadDataStatement extends SQLStatementImpl {
    
}
impl HiveLoadDataStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *HiveLoadDataStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in HiveLoadDataStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield HiveLoadDataStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the format oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getFormat:SQLExternalRecordFormat()`.
     * @return SQLExternalRecordFormat
     */
    pub fn getFormat(self) -> SQLExternalRecordFormat {
        for (s in SQLExternalRecordFormat(__all_data__),
            x in HiveLoadDataStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFormatOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the inpath oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getInpath:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInpath(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveLoadDataStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInpathOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getInto:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getInto(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in HiveLoadDataStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in HiveLoadDataStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is overwrite of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.isOverwrite:boolean()`.
     * @return int
     */
    pub fn isOverwrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in HiveLoadDataStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOverwrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the row format oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getRowFormat:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRowFormat(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveLoadDataStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowFormatOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the serde properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getSerdeProperties:Map<String, SQLObject>()`.
     * @return string
     */
    pub fn getSerdeProperties(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in HiveLoadDataStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSerdeProperties()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the stored as oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getStoredAs:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStoredAs(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveLoadDataStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredAsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the stored by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getStoredBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStoredBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveLoadDataStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getUsing:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUsing(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in HiveLoadDataStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveLoadDataStatement.getPartition:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getPartition(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema HiveMsckRepairStatement extends SQLStatementImpl {
    
}
impl HiveMsckRepairStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *HiveMsckRepairStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in HiveMsckRepairStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield HiveMsckRepairStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveMsckRepairStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in HiveMsckRepairStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is add partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveMsckRepairStatement.isAddPartitions:boolean()`.
     * @return int
     */
    pub fn isAddPartitions(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in HiveMsckRepairStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAddPartitions()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.hive.stmt.HiveMsckRepairStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in HiveMsckRepairStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlForceIndexHint extends MySqlIndexHintImpl {
    
}
impl MySqlForceIndexHint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlForceIndexHint {
        for (tmp in MySqlIndexHintImpl(db)) {
            for (x in MySqlForceIndexHintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlForceIndexHint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlIgnoreIndexHint extends MySqlIndexHintImpl {
    
}
impl MySqlIgnoreIndexHint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlIgnoreIndexHint {
        for (tmp in MySqlIndexHintImpl(db)) {
            for (x in MySqlIgnoreIndexHintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlIgnoreIndexHint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlKey extends SQLUnique {
    
}
impl MySqlKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlKey {
        for (tmp in SQLUnique(db)) {
            for (x in MySqlKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MySqlKey.getIndexType:String()`.
     * @return string
     */
    pub fn getIndexType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIndexType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is has constraint of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MySqlKey.isHasConstraint:boolean()`.
     * @return int
     */
    pub fn isHasConstraint(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHasConstraint()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the key block size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MySqlKey.getKeyBlockSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getKeyBlockSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getKeyBlockSizeOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlPrimaryKey extends MySqlKey {
    
}
impl MySqlPrimaryKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlPrimaryKey {
        for (tmp in MySqlKey(db)) {
            for (x in MySqlPrimaryKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlPrimaryKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlUnique extends MySqlKey {
    
}
impl MySqlUnique {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlUnique {
        for (tmp in MySqlKey(db)) {
            for (x in MySqlUniqueDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlUnique {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the db partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MySqlUnique.getDbPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlUniqueDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MySqlUnique.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUniqueDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MySqlUnique.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUniqueDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MySqlUnique.getTablePartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlUniqueDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table partitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MySqlUnique.getTablePartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlUniqueDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionsOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlUseIndexHint extends MySqlIndexHintImpl {
    
}
impl MySqlUseIndexHint {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlUseIndexHint {
        for (tmp in MySqlIndexHintImpl(db)) {
            for (x in MySqlUseIndexHintDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlUseIndexHint {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MysqlForeignKey extends SQLForeignKeyImpl {
    
}
impl MysqlForeignKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlForeignKey {
        for (tmp in SQLForeignKeyImpl(db)) {
            for (x in MysqlForeignKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlForeignKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MysqlForeignKey.getIndexName:SQLName()`.
     * @return SQLName
     */
    pub fn getIndexName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlForeignKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is has constraint of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MysqlForeignKey.isHasConstraint:boolean()`.
     * @return int
     */
    pub fn isHasConstraint(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MysqlForeignKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHasConstraint()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on delete of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MysqlForeignKey.getOnDelete:Option()`.
     * @return string
     */
    pub fn getOnDelete(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlForeignKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOnDelete()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on update of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MysqlForeignKey.getOnUpdate:Option()`.
     * @return string
     */
    pub fn getOnUpdate(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlForeignKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOnUpdate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the reference match of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.MysqlForeignKey.getReferenceMatch:Match()`.
     * @return string
     */
    pub fn getReferenceMatch(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlForeignKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getReferenceMatch()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlCaseStatement extends MySqlStatementImpl {
    
}
impl MySqlCaseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCaseStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCaseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCaseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the condition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlCaseStatement.getCondition:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCondition(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConditionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the else item of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlCaseStatement.getElseItem:Else()`.
     * @return string
     */
    pub fn getElseItem(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlCaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getElseItem()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the when list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlCaseStatement.getWhenList:List<MySqlWhenStatement>()`.
     * @return string
     */
    pub fn getWhenList(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlCaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWhenList()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema MySqlCursorDeclareStatement extends MySqlStatementImpl {
    
}
impl MySqlCursorDeclareStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCursorDeclareStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCursorDeclareStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCursorDeclareStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cursor name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlCursorDeclareStatement.getCursorName:SQLName()`.
     * @return SQLName
     */
    pub fn getCursorName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCursorDeclareStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCursorNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlCursorDeclareStatement.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in MySqlCursorDeclareStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlDeclareConditionStatement extends MySqlStatementImpl {
    
}
impl MySqlDeclareConditionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlDeclareConditionStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlDeclareConditionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlDeclareConditionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the condition name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlDeclareConditionStatement.getConditionName:String()`.
     * @return string
     */
    pub fn getConditionName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlDeclareConditionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getConditionName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the condition value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlDeclareConditionStatement.getConditionValue:ConditionValue()`.
     * @return string
     */
    pub fn getConditionValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlDeclareConditionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getConditionValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlDeclareHandlerStatement extends MySqlStatementImpl {
    
}
impl MySqlDeclareHandlerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlDeclareHandlerStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlDeclareHandlerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlDeclareHandlerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the condition values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlDeclareHandlerStatement.getConditionValues:List<ConditionValue>()`.
     * @return string
     */
    pub fn getConditionValues(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlDeclareHandlerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getConditionValues()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the handle type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlDeclareHandlerStatement.getHandleType:MySqlHandlerType()`.
     * @return string
     */
    pub fn getHandleType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlDeclareHandlerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHandleType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sp statement oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlDeclareHandlerStatement.getSpStatement:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getSpStatement(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in MySqlDeclareHandlerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSpStatementOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlDeclareStatement extends MySqlStatementImpl {
    
}
impl MySqlDeclareStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlDeclareStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlDeclareStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlDeclareStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the var list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlDeclareStatement.getVarList:List<SQLDeclareItem>()`.
     * @return SQLDeclareItem
     */
    pub fn getVarList(self) -> *SQLDeclareItem {
        for (x in SQLDeclareItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlIterateStatement extends MySqlStatementImpl {
    
}
impl MySqlIterateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlIterateStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlIterateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlIterateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlIterateStatement.getLabelName:String()`.
     * @return string
     */
    pub fn getLabelName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlIterateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabelName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlLeaveStatement extends MySqlStatementImpl {
    
}
impl MySqlLeaveStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlLeaveStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlLeaveStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlLeaveStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlLeaveStatement.getLabelName:String()`.
     * @return string
     */
    pub fn getLabelName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlLeaveStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabelName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlRepeatStatement extends MySqlStatementImpl {
    
}
impl MySqlRepeatStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlRepeatStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlRepeatStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlRepeatStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the condition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlRepeatStatement.getCondition:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getCondition(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlRepeatStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConditionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the label name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlRepeatStatement.getLabelName:String()`.
     * @return string
     */
    pub fn getLabelName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlRepeatStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabelName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statements of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlRepeatStatement.getStatements:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getStatements(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlSelectIntoStatement extends MySqlStatementImpl {
    
}
impl MySqlSelectIntoStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlSelectIntoStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlSelectIntoStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlSelectIntoStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlSelectIntoStatement.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in MySqlSelectIntoStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the var list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.clause.MySqlSelectIntoStatement.getVarList:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getVarList(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlCharExpr extends SQLCharExpr {
    
}
impl MySqlCharExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCharExpr {
        for (tmp in SQLCharExpr(db)) {
            for (x in MySqlCharExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCharExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the charset of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlCharExpr.getCharset:String()`.
     * @return string
     */
    pub fn getCharset(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlCharExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCharset()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the collate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlCharExpr.getCollate:String()`.
     * @return string
     */
    pub fn getCollate(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlCharExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCollate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlCharExpr.getType:String()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlCharExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlJSONTableExpr extends MySqlExprImpl {
    
}
impl MySqlJSONTableExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlJSONTableExpr {
        for (tmp in MySqlExprImpl(db)) {
            for (x in MySqlJsonTableExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlJSONTableExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlJSONTableExpr.getColumns:List<Column>()`.
     * @return string
     */
    pub fn getColumns(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlJsonTableExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getColumns()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlJSONTableExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlJsonTableExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the path oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlJSONTableExpr.getPath:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPath(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlJsonTableExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPathOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlOrderingExpr extends SQLExprImpl {
    
}
impl MySqlOrderingExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlOrderingExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in MySqlOrderingExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlOrderingExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOrderingExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlOrderingExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOrderingExpr.getType:SQLOrderingSpecification()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlOrderingExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlOutFileExpr extends MySqlObjectImpl {
    
}
impl MySqlOutFileExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlOutFileExpr {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlOutFileExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlOutFileExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the charset of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.getCharset:String()`.
     * @return string
     */
    pub fn getCharset(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlOutFileExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCharset()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns enclosed by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.getColumnsEnclosedBy:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getColumnsEnclosedBy(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlOutFileExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnsEnclosedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns escaped oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.getColumnsEscaped:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getColumnsEscaped(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlOutFileExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnsEscapedOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns terminated by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.getColumnsTerminatedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getColumnsTerminatedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlOutFileExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnsTerminatedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the file oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.getFile:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFile(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlOutFileExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFileOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the ignore lines number oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.getIgnoreLinesNumber:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIgnoreLinesNumber(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlOutFileExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIgnoreLinesNumberOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is columns enclosed optionally of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.isColumnsEnclosedOptionally:boolean()`.
     * @return int
     */
    pub fn isColumnsEnclosedOptionally(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlOutFileExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsColumnsEnclosedOptionally()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lines starting by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.getLinesStartingBy:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getLinesStartingBy(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlOutFileExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLinesStartingByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the lines terminated by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlOutFileExpr.getLinesTerminatedBy:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getLinesTerminatedBy(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlOutFileExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLinesTerminatedByOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlUserName extends MySqlExprImpl {
    
}
impl MySqlUserName {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlUserName {
        for (tmp in MySqlExprImpl(db)) {
            for (x in MySqlUserNameDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlUserName {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the host of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlUserName.getHost:String()`.
     * @return string
     */
    pub fn getHost(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlUserNameDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHost()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the identified by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlUserName.getIdentifiedBy:String()`.
     * @return string
     */
    pub fn getIdentifiedBy(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlUserNameDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIdentifiedBy()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the normalize user name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlUserName.getNormalizeUserName:String()`.
     * @return string
     */
    pub fn getNormalizeUserName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlUserNameDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNormalizeUserName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlUserName.getResolvedColumn:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getResolvedColumn(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in MySqlUserNameDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the simple name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlUserName.getSimpleName:String()`.
     * @return string
     */
    pub fn getSimpleName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlUserNameDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSimpleName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the user name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.expr.MySqlUserName.getUserName:String()`.
     * @return string
     */
    pub fn getUserName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlUserNameDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUserName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema CobarShowStatus extends MySqlStatementImpl {
    
}
impl CobarShowStatus {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *CobarShowStatus {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in CobarShowStatusDO(db)) {
                if (tmp.key_eq(x)) {
                    yield CobarShowStatus {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema DrdsBaselineStatement extends MySqlStatementImpl {
    
}
impl DrdsBaselineStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsBaselineStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsBaselineStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsBaselineStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the baseline ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsBaselineStatement.getBaselineIds:List<Long>()`.
     * @return string
     */
    pub fn getBaselineIds(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsBaselineStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getBaselineIds()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the operation of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsBaselineStatement.getOperation:String()`.
     * @return string
     */
    pub fn getOperation(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsBaselineStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOperation()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsBaselineStatement.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in DrdsBaselineStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
}
schema DrdsCancelDDLJob extends MySqlStatementImpl {
    
}
impl DrdsCancelDDLJob {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsCancelDDLJob {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsCancelDdlJobDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsCancelDDLJob {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsCancelDDLJob.getJobIds:List<Long>()`.
     * @return string
     */
    pub fn getJobIds(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsCancelDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJobIds()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema DrdsChangeDDLJob extends MySqlStatementImpl {
    
}
impl DrdsChangeDDLJob {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsChangeDDLJob {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsChangeDdlJobDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsChangeDDLJob {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the group and table name list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsChangeDDLJob.getGroupAndTableNameList:List<String>()`.
     * @return string
     */
    pub fn getGroupAndTableNameList(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsChangeDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getGroupAndTableNameList()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is add of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsChangeDDLJob.isAdd:boolean()`.
     * @return int
     */
    pub fn isAdd(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in DrdsChangeDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAdd()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is skip of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsChangeDDLJob.isSkip:boolean()`.
     * @return int
     */
    pub fn isSkip(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in DrdsChangeDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSkip()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job id of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsChangeDDLJob.getJobId:long()`.
     * @return string
     */
    pub fn getJobId(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsChangeDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJobId()) {
                        return s
                    }
                }
            }
        }
    }
}
schema DrdsClearDDLJobCache extends MySqlStatementImpl {
    
}
impl DrdsClearDDLJobCache {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsClearDDLJobCache {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsClearDdlJobCacheDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsClearDDLJobCache {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is all jobs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsClearDDLJobCache.isAllJobs:boolean()`.
     * @return int
     */
    pub fn isAllJobs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in DrdsClearDdlJobCacheDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAllJobs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsClearDDLJobCache.getJobIds:List<Long>()`.
     * @return string
     */
    pub fn getJobIds(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsClearDdlJobCacheDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJobIds()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema DrdsInspectDDLJobCache extends MySqlStatementImpl {
    
}
impl DrdsInspectDDLJobCache {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsInspectDDLJobCache {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsInspectDdlJobCacheDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsInspectDDLJobCache {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema DrdsRecoverDDLJob extends MySqlStatementImpl {
    
}
impl DrdsRecoverDDLJob {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsRecoverDDLJob {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsRecoverDdlJobDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsRecoverDDLJob {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is all jobs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsRecoverDDLJob.isAllJobs:boolean()`.
     * @return int
     */
    pub fn isAllJobs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in DrdsRecoverDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAllJobs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsRecoverDDLJob.getJobIds:List<Long>()`.
     * @return string
     */
    pub fn getJobIds(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsRecoverDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJobIds()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema DrdsRemoveDDLJob extends MySqlStatementImpl {
    
}
impl DrdsRemoveDDLJob {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsRemoveDDLJob {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsRemoveDdlJobDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsRemoveDDLJob {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is all completed of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsRemoveDDLJob.isAllCompleted:boolean()`.
     * @return int
     */
    pub fn isAllCompleted(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in DrdsRemoveDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAllCompleted()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is all pending of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsRemoveDDLJob.isAllPending:boolean()`.
     * @return int
     */
    pub fn isAllPending(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in DrdsRemoveDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAllPending()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsRemoveDDLJob.getJobIds:List<Long>()`.
     * @return string
     */
    pub fn getJobIds(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsRemoveDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJobIds()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema DrdsRollbackDDLJob extends MySqlStatementImpl {
    
}
impl DrdsRollbackDDLJob {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsRollbackDDLJob {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsRollbackDdlJobDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsRollbackDDLJob {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsRollbackDDLJob.getJobIds:List<Long>()`.
     * @return string
     */
    pub fn getJobIds(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsRollbackDdlJobDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJobIds()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema DrdsShowDDLJobs extends MySqlStatementImpl {
    
}
impl DrdsShowDDLJobs {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsShowDDLJobs {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsShowDdlJobsDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsShowDDLJobs {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsShowDDLJobs.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in DrdsShowDdlJobsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsShowDDLJobs.getJobIds:List<Long>()`.
     * @return string
     */
    pub fn getJobIds(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in DrdsShowDdlJobsDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getJobIds()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema DrdsShowGlobalIndex extends MySqlStatementImpl {
    
}
impl DrdsShowGlobalIndex {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsShowGlobalIndex {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsShowGlobalIndexDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsShowGlobalIndex {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsShowGlobalIndex.getTableName:SQLName()`.
     * @return SQLName
     */
    pub fn getTableName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in DrdsShowGlobalIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableNameOid()) {
                    return s
                }
            }
        }
    }
}
schema DrdsShowMetadataLock extends MySqlStatementImpl {
    
}
impl DrdsShowMetadataLock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *DrdsShowMetadataLock {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in DrdsShowMetadataLockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield DrdsShowMetadataLock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the schema name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.DrdsShowMetadataLock.getSchemaName:SQLName()`.
     * @return SQLName
     */
    pub fn getSchemaName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in DrdsShowMetadataLockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterDatabaseKillJob extends MySqlObjectImpl {
    
}
impl MySqlAlterDatabaseKillJob {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterDatabaseKillJob {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterDatabaseKillJobDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterDatabaseKillJob {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the job id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterDatabaseKillJob.getJobId:SQLName()`.
     * @return SQLName
     */
    pub fn getJobId(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterDatabaseKillJobDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getJobIdOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the job type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterDatabaseKillJob.getJobType:SQLName()`.
     * @return SQLName
     */
    pub fn getJobType(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterDatabaseKillJobDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getJobTypeOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterDatabaseSetOption extends MySqlObjectImpl {
    
}
impl MySqlAlterDatabaseSetOption {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterDatabaseSetOption {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterDatabaseSetOptionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterDatabaseSetOption {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterDatabaseSetOption.getOn:SQLName()`.
     * @return SQLName
     */
    pub fn getOn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterDatabaseSetOptionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterDatabaseSetOption.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlAlterEventStatement extends MySqlStatementImpl {
    
}
impl MySqlAlterEventStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterEventStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlAlterEventStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterEventStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the definer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.getDefiner:SQLName()`.
     * @return SQLName
     */
    pub fn getDefiner(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefinerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterEventStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the event body oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.getEventBody:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getEventBody(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in MySqlAlterEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEventBodyOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is disable on slave of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.isDisableOnSlave:boolean()`.
     * @return int
     */
    pub fn isDisableOnSlave(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterEventStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDisableOnSlave()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on completion preserve of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.isOnCompletionPreserve:boolean()`.
     * @return int
     */
    pub fn isOnCompletionPreserve(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterEventStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnCompletionPreserve()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the rename to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.getRenameTo:SQLName()`.
     * @return SQLName
     */
    pub fn getRenameTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRenameToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schedule oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterEventStatement.getSchedule:MySqlEventSchedule()`.
     * @return MySqlEventSchedule
     */
    pub fn getSchedule(self) -> MySqlEventSchedule {
        for (s in MySqlEventSchedule(__all_data__),
            x in MySqlAlterEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getScheduleOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterLogFileGroupStatement extends MySqlStatementImpl {
    
}
impl MySqlAlterLogFileGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterLogFileGroupStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlAlterLogFileGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterLogFileGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the add undo file oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterLogFileGroupStatement.getAddUndoFile:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAddUndoFile(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAddUndoFileOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterLogFileGroupStatement.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initial size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterLogFileGroupStatement.getInitialSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInitialSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInitialSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is wait of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterLogFileGroupStatement.isWait:boolean()`.
     * @return int
     */
    pub fn isWait(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterLogFileGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWait()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterLogFileGroupStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterServerStatement extends MySqlStatementImpl {
    
}
impl MySqlAlterServerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterServerStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlAlterServerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterServerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterServerStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterServerStatement.getUser:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUser(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterTableAlterColumn extends MySqlObjectImpl {
    
}
impl MySqlAlterTableAlterColumn {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableAlterColumn {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableAlterColumnDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableAlterColumn {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableAlterColumn.getColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTableAlterColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the default expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableAlterColumn.getDefaultExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDefaultExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterTableAlterColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefaultExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is drop default of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableAlterColumn.isDropDefault:boolean()`.
     * @return int
     */
    pub fn isDropDefault(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterTableAlterColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDropDefault()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlAlterTableAlterFullTextIndex extends MySqlObjectImpl {
    
}
impl MySqlAlterTableAlterFullTextIndex {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableAlterFullTextIndex {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableAlterFullTextIndexDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableAlterFullTextIndex {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the analyzer name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableAlterFullTextIndex.getAnalyzerName:SQLName()`.
     * @return SQLName
     */
    pub fn getAnalyzerName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTableAlterFullTextIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAnalyzerNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the analyzer type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableAlterFullTextIndex.getAnalyzerType:AnalyzerIndexType()`.
     * @return string
     */
    pub fn getAnalyzerType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlAlterTableAlterFullTextIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAnalyzerType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableAlterFullTextIndex.getIndexName:SQLName()`.
     * @return SQLName
     */
    pub fn getIndexName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTableAlterFullTextIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterTableChangeColumn extends MySqlObjectImpl {
    
}
impl MySqlAlterTableChangeColumn {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableChangeColumn {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableChangeColumnDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableChangeColumn {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the after column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableChangeColumn.getAfterColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getAfterColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTableChangeColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAfterColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the column name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableChangeColumn.getColumnName:SQLName()`.
     * @return SQLName
     */
    pub fn getColumnName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTableChangeColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the first column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableChangeColumn.getFirstColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getFirstColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTableChangeColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFirstColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is first of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableChangeColumn.isFirst:boolean()`.
     * @return int
     */
    pub fn isFirst(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterTableChangeColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFirst()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the new column definition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableChangeColumn.getNewColumnDefinition:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getNewColumnDefinition(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in MySqlAlterTableChangeColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNewColumnDefinitionOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterTableDiscardTablespace extends MySqlObjectImpl {
    
}
impl MySqlAlterTableDiscardTablespace {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableDiscardTablespace {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableDiscardTablespaceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableDiscardTablespace {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlAlterTableForce extends MySqlObjectImpl {
    
}
impl MySqlAlterTableForce {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableForce {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableForceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableForce {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlAlterTableImportTablespace extends MySqlObjectImpl {
    
}
impl MySqlAlterTableImportTablespace {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableImportTablespace {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableImportTablespaceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableImportTablespace {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlAlterTableLock extends MySqlObjectImpl {
    
}
impl MySqlAlterTableLock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableLock {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableLockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableLock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lock type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableLock.getLockType:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLockType(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterTableLockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLockTypeOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterTableModifyColumn extends MySqlObjectImpl {
    
}
impl MySqlAlterTableModifyColumn {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableModifyColumn {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableModifyColumnDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableModifyColumn {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the after column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableModifyColumn.getAfterColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getAfterColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTableModifyColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAfterColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the first column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableModifyColumn.getFirstColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getFirstColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTableModifyColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFirstColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is first of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableModifyColumn.isFirst:boolean()`.
     * @return int
     */
    pub fn isFirst(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterTableModifyColumnDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFirst()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the new column definition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableModifyColumn.getNewColumnDefinition:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getNewColumnDefinition(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in MySqlAlterTableModifyColumnDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNewColumnDefinitionOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterTableOption extends MySqlObjectImpl {
    
}
impl MySqlAlterTableOption {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableOption {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableOptionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableOption {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableOption.getName:String()`.
     * @return string
     */
    pub fn getName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlAlterTableOptionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableOption.getValue:SQLObject()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlAlterTableOptionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlAlterTableOrderBy extends MySqlObjectImpl {
    
}
impl MySqlAlterTableOrderBy {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableOrderBy {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableOrderByDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableOrderBy {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableOrderBy.getColumns:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getColumns(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlAlterTableValidation extends MySqlObjectImpl {
    
}
impl MySqlAlterTableValidation {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTableValidation {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlAlterTableValidationDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTableValidation {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with validation of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTableValidation.isWithValidation:boolean()`.
     * @return int
     */
    pub fn isWithValidation(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterTableValidationDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithValidation()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlAlterTablespaceStatement extends MySqlStatementImpl {
    
}
impl MySqlAlterTablespaceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterTablespaceStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlAlterTablespaceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterTablespaceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the add data file oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTablespaceStatement.getAddDataFile:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAddDataFile(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterTablespaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAddDataFileOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the drop data file oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTablespaceStatement.getDropDataFile:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDropDataFile(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterTablespaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDropDataFileOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTablespaceStatement.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterTablespaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initial size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTablespaceStatement.getInitialSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInitialSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlAlterTablespaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInitialSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is wait of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTablespaceStatement.isWait:boolean()`.
     * @return int
     */
    pub fn isWait(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterTablespaceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWait()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterTablespaceStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlAlterTablespaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlAlterUserStatement extends MySqlStatementImpl {
    
}
impl MySqlAlterUserStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAlterUserStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlAlterUserStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAlterUserStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alter users of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterUserStatement.getAlterUsers:List<AlterUser>()`.
     * @return string
     */
    pub fn getAlterUsers(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlAlterUserStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlterUsers()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterUserStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAlterUserStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the password option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterUserStatement.getPasswordOption:PasswordOption()`.
     * @return string
     */
    pub fn getPasswordOption(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlAlterUserStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPasswordOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the users of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAlterUserStatement.getUsers:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getUsers(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlAnalyzeStatement extends SQLAnalyzeTableStatement {
    
}
impl MySqlAnalyzeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlAnalyzeStatement {
        for (tmp in SQLAnalyzeTableStatement(db)) {
            for (x in MySqlAnalyzeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlAnalyzeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAnalyzeStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAnalyzeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no write to binlog of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAnalyzeStatement.isNoWriteToBinlog:boolean()`.
     * @return int
     */
    pub fn isNoWriteToBinlog(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlAnalyzeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoWriteToBinlog()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table sources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlAnalyzeStatement.getTableSources:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSources(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlBinlogStatement extends MySqlStatementImpl {
    
}
impl MySqlBinlogStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlBinlogStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlBinlogStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlBinlogStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlBinlogStatement.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlBinlogStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlCheckTableStatement extends MySqlStatementImpl {
    
}
impl MySqlCheckTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCheckTableStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCheckTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCheckTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the tables of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCheckTableStatement.getTables:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTables(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlChecksumTableStatement extends MySqlStatementImpl {
    
}
impl MySqlChecksumTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlChecksumTableStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlChecksumTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlChecksumTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is extended of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlChecksumTableStatement.isExtended:boolean()`.
     * @return int
     */
    pub fn isExtended(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlChecksumTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsExtended()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is quick of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlChecksumTableStatement.isQuick:boolean()`.
     * @return int
     */
    pub fn isQuick(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlChecksumTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsQuick()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the tables of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlChecksumTableStatement.getTables:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTables(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlClearPlanCacheStatement extends MySqlStatementImpl {
    
}
impl MySqlClearPlanCacheStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlClearPlanCacheStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlClearPlanCacheStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlClearPlanCacheStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlCreateAddLogFileGroupStatement extends MySqlStatementImpl {
    
}
impl MySqlCreateAddLogFileGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCreateAddLogFileGroupStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCreateAddLogFileGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCreateAddLogFileGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the add undo file oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.getAddUndoFile:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAddUndoFile(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAddUndoFileOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initial size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.getInitialSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInitialSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInitialSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is wait of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.isWait:boolean()`.
     * @return int
     */
    pub fn isWait(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWait()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the node group oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.getNodeGroup:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNodeGroup(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNodeGroupOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the redo buffer size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.getRedoBufferSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRedoBufferSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRedoBufferSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the undo buffer size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateAddLogFileGroupStatement.getUndoBufferSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUndoBufferSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateAddLogFileGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUndoBufferSizeOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlCreateEventStatement extends MySqlStatementImpl {
    
}
impl MySqlCreateEventStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCreateEventStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCreateEventStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCreateEventStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the definer oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.getDefiner:SQLName()`.
     * @return SQLName
     */
    pub fn getDefiner(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefinerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateEventStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the event body oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.getEventBody:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getEventBody(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in MySqlCreateEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEventBodyOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is disable on slave of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.isDisableOnSlave:boolean()`.
     * @return int
     */
    pub fn isDisableOnSlave(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateEventStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDisableOnSlave()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateEventStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on completion preserve of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.isOnCompletionPreserve:boolean()`.
     * @return int
     */
    pub fn isOnCompletionPreserve(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateEventStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnCompletionPreserve()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the rename to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.getRenameTo:SQLName()`.
     * @return SQLName
     */
    pub fn getRenameTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRenameToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schedule oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateEventStatement.getSchedule:MySqlEventSchedule()`.
     * @return MySqlEventSchedule
     */
    pub fn getSchedule(self) -> MySqlEventSchedule {
        for (s in MySqlEventSchedule(__all_data__),
            x in MySqlCreateEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getScheduleOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlCreateExternalCatalogStatement extends MySqlStatementImpl {
    
}
impl MySqlCreateExternalCatalogStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCreateExternalCatalogStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCreateExternalCatalogStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCreateExternalCatalogStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateExternalCatalogStatement.getComment:SQLName()`.
     * @return SQLName
     */
    pub fn getComment(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateExternalCatalogStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateExternalCatalogStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateExternalCatalogStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateExternalCatalogStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateExternalCatalogStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateExternalCatalogStatement.getProperties:Map<SQLName, SQLName>()`.
     * @return string
     */
    pub fn getProperties(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlCreateExternalCatalogStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getProperties()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlCreateServerStatement extends MySqlStatementImpl {
    
}
impl MySqlCreateServerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCreateServerStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCreateServerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCreateServerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getDatabase:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDatabase(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the foreign data wrapper oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getForeignDataWrapper:SQLName()`.
     * @return SQLName
     */
    pub fn getForeignDataWrapper(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForeignDataWrapperOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the host oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getHost:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getHost(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getHostOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the owner oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getOwner:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOwner(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOwnerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the password oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getPassword:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPassword(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPasswordOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the port oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getPort:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPort(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPortOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the socket oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getSocket:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSocket(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSocketOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateServerStatement.getUser:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUser(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateServerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlCreateTableSpaceStatement extends MySqlStatementImpl {
    
}
impl MySqlCreateTableSpaceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCreateTableSpaceStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCreateTableSpaceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCreateTableSpaceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the add data file oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getAddDataFile:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAddDataFile(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAddDataFileOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the auto extent size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getAutoExtentSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAutoExtentSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAutoExtentSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the extent size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getExtentSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExtentSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExtentSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the file block size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getFileBlockSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFileBlockSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFileBlockSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initial size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getInitialSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInitialSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInitialSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is wait of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.isWait:boolean()`.
     * @return int
     */
    pub fn isWait(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWait()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the log file group oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getLogFileGroup:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLogFileGroup(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLogFileGroupOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the max size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getMaxSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the node group oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableSpaceStatement.getNodeGroup:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNodeGroup(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableSpaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNodeGroupOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlCreateTableStatement extends SQLCreateTableStatement {
    
}
impl MySqlCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCreateTableStatement {
        for (tmp in SQLCreateTableStatement(db)) {
            for (x in MySqlCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the archive by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getArchiveBy:SQLName()`.
     * @return SQLName
     */
    pub fn getArchiveBy(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getArchiveByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the db partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getDbPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the db partitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getDbPartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbPartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the dbpartitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getDbpartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbpartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbpartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the distribute by type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getDistributeByType:SQLName()`.
     * @return SQLName
     */
    pub fn getDistributeByType(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDistributeByTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the engine oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getEngine:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEngine(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEngineOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the ext partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getExtPartition:MySqlExtPartition()`.
     * @return MySqlExtPartition
     */
    pub fn getExtPartition(self) -> MySqlExtPartition {
        for (s in MySqlExtPartition(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExtPartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is broad cast of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.isBroadCast:boolean()`.
     * @return int
     */
    pub fn isBroadCast(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBroadCast()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the stored by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getStoredBy:SQLName()`.
     * @return SQLName
     */
    pub fn getStoredBy(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table group oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getTableGroup:SQLName()`.
     * @return SQLName
     */
    pub fn getTableGroup(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableGroupOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getTablePartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table partitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getTablePartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the tbpartitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getTbpartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTbpartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTbpartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getWith:Map<String, SQLName>()`.
     * @return string
     */
    pub fn getWith(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWith()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the with data of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getWithData:Boolean()`.
     * @return int
     */
    pub fn getWithData(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWithData()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the distribute by of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getDistributeBy:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getDistributeBy(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the mysql indexes of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getMysqlIndexes:List<MySqlTableIndex>()`.
     * @return MySqlTableIndex
     */
    pub fn getMysqlIndexes(self) -> *MySqlTableIndex {
        for (x in MySqlTableIndex(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the mysql keys of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getMysqlKeys:List<MySqlKey>()`.
     * @return MySqlKey
     */
    pub fn getMysqlKeys(self) -> *MySqlKey {
        for (x in MySqlKey(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the option hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateTableStatement.getOptionHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getOptionHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlCreateUserStatement extends MySqlStatementImpl {
    
}
impl MySqlCreateUserStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlCreateUserStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlCreateUserStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlCreateUserStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateUserStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlCreateUserStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the users of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlCreateUserStatement.getUsers:List<UserSpecification>()`.
     * @return string
     */
    pub fn getUsers(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlCreateUserStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUsers()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema MySqlDeleteStatement extends SQLDeleteStatement {
    
}
impl MySqlDeleteStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlDeleteStatement {
        for (tmp in SQLDeleteStatement(db)) {
            for (x in MySqlDeleteStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlDeleteStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the force partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.getForcePartition:SQLName()`.
     * @return SQLName
     */
    pub fn getForcePartition(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForcePartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.getHintsSize:int()`.
     * @return int
     */
    pub fn getHintsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is force all partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.isForceAllPartitions:boolean()`.
     * @return int
     */
    pub fn isForceAllPartitions(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForceAllPartitions()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is fulltext dictionary of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.isFulltextDictionary:boolean()`.
     * @return int
     */
    pub fn isFulltextDictionary(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFulltextDictionary()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.isIgnore:boolean()`.
     * @return int
     */
    pub fn isIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is low priority of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.isLowPriority:boolean()`.
     * @return int
     */
    pub fn isLowPriority(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLowPriority()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is quick of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.isQuick:boolean()`.
     * @return int
     */
    pub fn isQuick(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsQuick()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlDeleteStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlDisabledPlanCacheStatement extends MySqlStatementImpl {
    
}
impl MySqlDisabledPlanCacheStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlDisabledPlanCacheStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlDisabledPlanCacheStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlDisabledPlanCacheStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlEventSchedule extends MySqlObjectImpl {
    
}
impl MySqlEventSchedule {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlEventSchedule {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlEventScheduleDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlEventSchedule {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the at oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlEventSchedule.getAt:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAt(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlEventScheduleDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAtOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the ends oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlEventSchedule.getEnds:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEnds(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlEventScheduleDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEndsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the every oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlEventSchedule.getEvery:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEvery(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlEventScheduleDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEveryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the starts oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlEventSchedule.getStarts:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStarts(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlEventScheduleDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStartsOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlExecuteForAdsStatement extends MySqlStatementImpl {
    
}
impl MySqlExecuteForAdsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlExecuteForAdsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlExecuteForAdsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlExecuteForAdsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the action oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExecuteForAdsStatement.getAction:SQLName()`.
     * @return SQLName
     */
    pub fn getAction(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlExecuteForAdsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getActionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the role oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExecuteForAdsStatement.getRole:SQLName()`.
     * @return SQLName
     */
    pub fn getRole(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlExecuteForAdsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRoleOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the status oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExecuteForAdsStatement.getStatus:SQLName()`.
     * @return SQLName
     */
    pub fn getStatus(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlExecuteForAdsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatusOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the target id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExecuteForAdsStatement.getTargetId:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getTargetId(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlExecuteForAdsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTargetIdOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlExecuteStatement extends MySqlStatementImpl {
    
}
impl MySqlExecuteStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlExecuteStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlExecuteStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlExecuteStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statement name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExecuteStatement.getStatementName:SQLName()`.
     * @return SQLName
     */
    pub fn getStatementName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlExecuteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatementNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExecuteStatement.getParameters:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getParameters(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlExplainPlanCacheStatement extends MySqlStatementImpl {
    
}
impl MySqlExplainPlanCacheStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlExplainPlanCacheStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlExplainPlanCacheStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlExplainPlanCacheStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlExplainStatement extends SQLExplainStatement {
    
}
impl MySqlExplainStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlExplainStatement {
        for (tmp in SQLExplainStatement(db)) {
            for (x in MySqlExplainStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlExplainStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExplainStatement.getColumnName:SQLName()`.
     * @return SQLName
     */
    pub fn getColumnName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlExplainStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the connection id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExplainStatement.getConnectionId:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getConnectionId(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlExplainStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getConnectionIdOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is describe of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExplainStatement.isDescribe:boolean()`.
     * @return int
     */
    pub fn isDescribe(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDescribe()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is distribute info of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExplainStatement.isDistributeInfo:boolean()`.
     * @return int
     */
    pub fn isDistributeInfo(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlExplainStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDistributeInfo()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExplainStatement.getTableName:SQLName()`.
     * @return SQLName
     */
    pub fn getTableName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlExplainStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the wild oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExplainStatement.getWild:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWild(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlExplainStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWildOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlExtPartition extends MySqlObjectImpl {
    
}
impl MySqlExtPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlExtPartition {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MySqlExtPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlExtPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlExtPartition.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlExtPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema MySqlFlashbackStatement extends MySqlStatementImpl {
    
}
impl MySqlFlashbackStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlFlashbackStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlFlashbackStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlFlashbackStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlashbackStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlFlashbackStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the rename to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlashbackStatement.getRenameTo:SQLName()`.
     * @return SQLName
     */
    pub fn getRenameTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlFlashbackStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRenameToOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlFlushStatement extends MySqlStatementImpl {
    
}
impl MySqlFlushStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlFlushStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlFlushStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlFlushStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is binary logs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isBinaryLogs:boolean()`.
     * @return int
     */
    pub fn isBinaryLogs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBinaryLogs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is des key file of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isDesKeyFile:boolean()`.
     * @return int
     */
    pub fn isDesKeyFile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDesKeyFile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is engine logs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isEngineLogs:boolean()`.
     * @return int
     */
    pub fn isEngineLogs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsEngineLogs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is error logs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isErrorLogs:boolean()`.
     * @return int
     */
    pub fn isErrorLogs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsErrorLogs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is for export of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isForExport:boolean()`.
     * @return int
     */
    pub fn isForExport(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForExport()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is general logs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isGeneralLogs:boolean()`.
     * @return int
     */
    pub fn isGeneralLogs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGeneralLogs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is hots of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isHots:boolean()`.
     * @return int
     */
    pub fn isHots(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHots()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is logs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isLogs:boolean()`.
     * @return int
     */
    pub fn isLogs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLogs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is master of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isMaster:boolean()`.
     * @return int
     */
    pub fn isMaster(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsMaster()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no write to binlog of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isNoWriteToBinlog:boolean()`.
     * @return int
     */
    pub fn isNoWriteToBinlog(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoWriteToBinlog()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is optimizer costs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isOptimizerCosts:boolean()`.
     * @return int
     */
    pub fn isOptimizerCosts(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOptimizerCosts()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is privileges of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isPrivileges:boolean()`.
     * @return int
     */
    pub fn isPrivileges(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPrivileges()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is query cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isQueryCache:boolean()`.
     * @return int
     */
    pub fn isQueryCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsQueryCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is relay logs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isRelayLogs:boolean()`.
     * @return int
     */
    pub fn isRelayLogs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRelayLogs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is slow logs of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isSlowLogs:boolean()`.
     * @return int
     */
    pub fn isSlowLogs(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSlowLogs()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is status of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isStatus:boolean()`.
     * @return int
     */
    pub fn isStatus(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsStatus()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is table option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isTableOption:boolean()`.
     * @return int
     */
    pub fn isTableOption(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTableOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is user resources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isUserResources:boolean()`.
     * @return int
     */
    pub fn isUserResources(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUserResources()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with read lock of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.isWithReadLock:boolean()`.
     * @return int
     */
    pub fn isWithReadLock(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlFlushStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithReadLock()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the relay logs for channel oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.getRelayLogsForChannel:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRelayLogsForChannel(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlFlushStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRelayLogsForChannelOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the version oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.getVersion:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getVersion(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in MySqlFlushStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getVersionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the tables of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlFlushStatement.getTables:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTables(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlHelpStatement extends MySqlStatementImpl {
    
}
impl MySqlHelpStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlHelpStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlHelpStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlHelpStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the content oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlHelpStatement.getContent:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getContent(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlHelpStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getContentOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlHintStatement extends MySqlStatementImpl {
    
}
impl MySqlHintStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlHintStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlHintStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlHintStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hint version of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlHintStatement.getHintVersion:int()`.
     * @return int
     */
    pub fn getHintVersion(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlHintStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintVersion()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hint statements of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlHintStatement.getHintStatements:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getHintStatements(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlHintStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlInsertStatement extends SQLInsertStatement {
    
}
impl MySqlInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlInsertStatement {
        for (tmp in SQLInsertStatement(db)) {
            for (x in MySqlInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hints size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.getHintsSize:int()`.
     * @return int
     */
    pub fn getHintsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is delayed of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.isDelayed:boolean()`.
     * @return int
     */
    pub fn isDelayed(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDelayed()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is fulltext dictionary of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.isFulltextDictionary:boolean()`.
     * @return int
     */
    pub fn isFulltextDictionary(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFulltextDictionary()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is high priority of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.isHighPriority:boolean()`.
     * @return int
     */
    pub fn isHighPriority(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHighPriority()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.isIgnore:boolean()`.
     * @return int
     */
    pub fn isIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is low priority of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.isLowPriority:boolean()`.
     * @return int
     */
    pub fn isLowPriority(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLowPriority()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is overwrite of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.isOverwrite:boolean()`.
     * @return int
     */
    pub fn isOverwrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOverwrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is rollback on fail of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.isRollbackOnFail:boolean()`.
     * @return int
     */
    pub fn isRollbackOnFail(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRollbackOnFail()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the duplicate key update of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.getDuplicateKeyUpdate:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getDuplicateKeyUpdate(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlInsertStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlKillStatement extends SQLStatementImpl {
    
}
impl MySqlKillStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlKillStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in MySqlKillStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlKillStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the thread id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlKillStatement.getThreadId:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getThreadId(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlKillStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getThreadIdOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlKillStatement.getType:Type()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlKillStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the thread ids of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlKillStatement.getThreadIds:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getThreadIds(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlLoadDataInFileStatement extends MySqlStatementImpl {
    
}
impl MySqlLoadDataInFileStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlLoadDataInFileStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlLoadDataInFileStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlLoadDataInFileStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the charset of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getCharset:String()`.
     * @return string
     */
    pub fn getCharset(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlLoadDataInFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCharset()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns enclosed by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getColumnsEnclosedBy:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getColumnsEnclosedBy(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlLoadDataInFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnsEnclosedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns escaped oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getColumnsEscaped:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getColumnsEscaped(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlLoadDataInFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnsEscapedOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns terminated by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getColumnsTerminatedBy:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getColumnsTerminatedBy(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlLoadDataInFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnsTerminatedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the file name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getFileName:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getFileName(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlLoadDataInFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFileNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the ignore lines number oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getIgnoreLinesNumber:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIgnoreLinesNumber(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlLoadDataInFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIgnoreLinesNumberOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is columns enclosed optionally of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.isColumnsEnclosedOptionally:boolean()`.
     * @return int
     */
    pub fn isColumnsEnclosedOptionally(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadDataInFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsColumnsEnclosedOptionally()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is concurrent of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.isConcurrent:boolean()`.
     * @return int
     */
    pub fn isConcurrent(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadDataInFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsConcurrent()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.isIgnore:boolean()`.
     * @return int
     */
    pub fn isIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadDataInFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadDataInFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is low priority of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.isLowPriority:boolean()`.
     * @return int
     */
    pub fn isLowPriority(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadDataInFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLowPriority()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is replicate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.isReplicate:boolean()`.
     * @return int
     */
    pub fn isReplicate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadDataInFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReplicate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lines starting by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getLinesStartingBy:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getLinesStartingBy(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlLoadDataInFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLinesStartingByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the lines terminated by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getLinesTerminatedBy:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getLinesTerminatedBy(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlLoadDataInFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLinesTerminatedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getTableName:SQLName()`.
     * @return SQLName
     */
    pub fn getTableName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlLoadDataInFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getColumns:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getColumns(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the set list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadDataInFileStatement.getSetList:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getSetList(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlLoadXmlStatement extends MySqlStatementImpl {
    
}
impl MySqlLoadXmlStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlLoadXmlStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlLoadXmlStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlLoadXmlStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the charset of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.getCharset:String()`.
     * @return string
     */
    pub fn getCharset(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlLoadXmlStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCharset()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the file name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.getFileName:SQLLiteralExpr()`.
     * @return SQLLiteralExpr
     */
    pub fn getFileName(self) -> SQLLiteralExpr {
        for (s in SQLLiteralExpr(__all_data__),
            x in MySqlLoadXmlStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFileNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the ignore lines number oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.getIgnoreLinesNumber:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIgnoreLinesNumber(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlLoadXmlStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIgnoreLinesNumberOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is concurrent of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.isConcurrent:boolean()`.
     * @return int
     */
    pub fn isConcurrent(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadXmlStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsConcurrent()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.isIgnore:boolean()`.
     * @return int
     */
    pub fn isIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadXmlStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadXmlStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is low priority of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.isLowPriority:boolean()`.
     * @return int
     */
    pub fn isLowPriority(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadXmlStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLowPriority()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is replicate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.isReplicate:boolean()`.
     * @return int
     */
    pub fn isReplicate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlLoadXmlStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReplicate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the rows identified by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.getRowsIdentifiedBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRowsIdentifiedBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlLoadXmlStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowsIdentifiedByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.getTableName:SQLName()`.
     * @return SQLName
     */
    pub fn getTableName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlLoadXmlStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the set list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLoadXmlStatement.getSetList:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getSetList(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlLockTableStatement extends MySqlStatementImpl {
    
}
impl MySqlLockTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlLockTableStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlLockTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlLockTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlLockTableStatement.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlLockTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema MySqlManageInstanceGroupStatement extends MySqlStatementImpl {
    
}
impl MySqlManageInstanceGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlManageInstanceGroupStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlManageInstanceGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlManageInstanceGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the group names to string of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlManageInstanceGroupStatement.getGroupNamesToString:List<String>()`.
     * @return string
     */
    pub fn getGroupNamesToString(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlManageInstanceGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getGroupNamesToString()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the operation oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlManageInstanceGroupStatement.getOperation:SQLName()`.
     * @return SQLName
     */
    pub fn getOperation(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlManageInstanceGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOperationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the replication oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlManageInstanceGroupStatement.getReplication:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getReplication(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in MySqlManageInstanceGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReplicationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the group names of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlManageInstanceGroupStatement.getGroupNames:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getGroupNames(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlMigrateStatement extends MySqlStatementImpl {
    
}
impl MySqlMigrateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlMigrateStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlMigrateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlMigrateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from ins id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getFromInsId:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getFromInsId(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromInsIdOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the from ins ip oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getFromInsIp:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getFromInsIp(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromInsIpOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the from ins port oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getFromInsPort:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getFromInsPort(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromInsPortOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the from ins status oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getFromInsStatus:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getFromInsStatus(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromInsStatusOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the migrate type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getMigrateType:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getMigrateType(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMigrateTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getSchema:SQLName()`.
     * @return SQLName
     */
    pub fn getSchema(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the shard names oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getShardNames:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getShardNames(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getShardNamesOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to ins id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getToInsId:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getToInsId(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToInsIdOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to ins ip oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getToInsIp:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getToInsIp(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToInsIpOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to ins port oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getToInsPort:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getToInsPort(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToInsPortOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to ins status oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlMigrateStatement.getToInsStatus:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getToInsStatus(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlMigrateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToInsStatusOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlOptimizeStatement extends MySqlStatementImpl {
    
}
impl MySqlOptimizeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlOptimizeStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlOptimizeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlOptimizeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlOptimizeStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlOptimizeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no write to binlog of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlOptimizeStatement.isNoWriteToBinlog:boolean()`.
     * @return int
     */
    pub fn isNoWriteToBinlog(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlOptimizeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoWriteToBinlog()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table sources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlOptimizeStatement.getTableSources:List<SQLExprTableSource>()`.
     * @return SQLExprTableSource
     */
    pub fn getTableSources(self) -> *SQLExprTableSource {
        for (x in SQLExprTableSource(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlPartitionByKey extends SQLPartitionBy {
    
}
impl MySqlPartitionByKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlPartitionByKey {
        for (tmp in SQLPartitionBy(db)) {
            for (x in MySqlPartitionByKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlPartitionByKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlPartitionByKey.getAlgorithm:int()`.
     * @return int
     */
    pub fn getAlgorithm(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlPartitionByKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlPrepareStatement extends MySqlStatementImpl {
    
}
impl MySqlPrepareStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlPrepareStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlPrepareStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlPrepareStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlPrepareStatement.getFrom:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFrom(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlPrepareStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlPrepareStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlPrepareStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlRaftLeaderTransferStatement extends MySqlStatementImpl {
    
}
impl MySqlRaftLeaderTransferStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlRaftLeaderTransferStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlRaftLeaderTransferStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlRaftLeaderTransferStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftLeaderTransferStatement.getFrom:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getFrom(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlRaftLeaderTransferStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the shard oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftLeaderTransferStatement.getShard:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getShard(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlRaftLeaderTransferStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getShardOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the timeout oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftLeaderTransferStatement.getTimeout:SQLIntegerExpr()`.
     * @return SQLIntegerExpr
     */
    pub fn getTimeout(self) -> SQLIntegerExpr {
        for (s in SQLIntegerExpr(__all_data__),
            x in MySqlRaftLeaderTransferStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTimeoutOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftLeaderTransferStatement.getTo:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getTo(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlRaftLeaderTransferStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlRaftMemberChangeStatement extends MySqlStatementImpl {
    
}
impl MySqlRaftMemberChangeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlRaftMemberChangeStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlRaftMemberChangeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlRaftMemberChangeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the host oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftMemberChangeStatement.getHost:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getHost(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlRaftMemberChangeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getHostOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftMemberChangeStatement.isForce:boolean()`.
     * @return int
     */
    pub fn isForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlRaftMemberChangeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no leader of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftMemberChangeStatement.isNoLeader:boolean()`.
     * @return int
     */
    pub fn isNoLeader(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlRaftMemberChangeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoLeader()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the shard oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftMemberChangeStatement.getShard:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getShard(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlRaftMemberChangeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getShardOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the status oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRaftMemberChangeStatement.getStatus:SQLCharExpr()`.
     * @return SQLCharExpr
     */
    pub fn getStatus(self) -> SQLCharExpr {
        for (s in SQLCharExpr(__all_data__),
            x in MySqlRaftMemberChangeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatusOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlRenameSequenceStatement extends MySqlStatementImpl {
    
}
impl MySqlRenameSequenceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlRenameSequenceStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlRenameSequenceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlRenameSequenceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRenameSequenceStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlRenameSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRenameSequenceStatement.getTo:SQLName()`.
     * @return SQLName
     */
    pub fn getTo(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlRenameSequenceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlRenameTableStatement extends MySqlStatementImpl {
    
}
impl MySqlRenameTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlRenameTableStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlRenameTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlRenameTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlRenameTableStatement.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlRenameTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema MySqlResetStatement extends MySqlStatementImpl {
    
}
impl MySqlResetStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlResetStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlResetStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlResetStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlResetStatement.getOptions:List<String>()`.
     * @return string
     */
    pub fn getOptions(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlResetStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOptions()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema MySqlSelectQueryBlock extends SQLSelectQueryBlock {
    
}
impl MySqlSelectQueryBlock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlSelectQueryBlock {
        for (tmp in SQLSelectQueryBlock(db)) {
            for (x in MySqlSelectQueryBlockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlSelectQueryBlock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.getCache:Boolean()`.
     * @return int
     */
    pub fn getCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the force partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.getForcePartition:SQLName()`.
     * @return SQLName
     */
    pub fn getForcePartition(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForcePartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.getHintsSize:int()`.
     * @return int
     */
    pub fn getHintsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is big result of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.isBigResult:boolean()`.
     * @return int
     */
    pub fn isBigResult(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBigResult()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is buffer result of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.isBufferResult:boolean()`.
     * @return int
     */
    pub fn isBufferResult(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBufferResult()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is calc found rows of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.isCalcFoundRows:boolean()`.
     * @return int
     */
    pub fn isCalcFoundRows(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCalcFoundRows()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is hign priority of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.isHignPriority:boolean()`.
     * @return int
     */
    pub fn isHignPriority(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHignPriority()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is lock in share mode of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.isLockInShareMode:boolean()`.
     * @return int
     */
    pub fn isLockInShareMode(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLockInShareMode()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is small result of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.isSmallResult:boolean()`.
     * @return int
     */
    pub fn isSmallResult(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSmallResult()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is straight join of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.isStraightJoin:boolean()`.
     * @return int
     */
    pub fn isStraightJoin(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsStraightJoin()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the procedure name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.getProcedureName:SQLName()`.
     * @return SQLName
     */
    pub fn getProcedureName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getProcedureNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the procedure argument list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock.getProcedureArgumentList:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getProcedureArgumentList(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlSetTransactionStatement extends MySqlStatementImpl {
    
}
impl MySqlSetTransactionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlSetTransactionStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlSetTransactionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlSetTransactionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the access model of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement.getAccessModel:String()`.
     * @return string
     */
    pub fn getAccessModel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlSetTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAccessModel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement.getGlobal:Boolean()`.
     * @return int
     */
    pub fn getGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSetTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSetTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the isolation level of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement.getIsolationLevel:String()`.
     * @return string
     */
    pub fn getIsolationLevel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlSetTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsolationLevel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the policy oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement.getPolicy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPolicy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlSetTransactionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPolicyOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the session of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSetTransactionStatement.getSession:Boolean()`.
     * @return int
     */
    pub fn getSession(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSetTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSession()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlShowAuthorsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowAuthorsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowAuthorsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowAuthorsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowAuthorsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowBinLogEventsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowBinLogEventsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowBinLogEventsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowBinLogEventsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowBinLogEventsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowBinLogEventsStatement.getFrom:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFrom(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowBinLogEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the in oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowBinLogEventsStatement.getIn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getIn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowBinLogEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowBinLogEventsStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowBinLogEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowBinaryLogsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowBinaryLogsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowBinaryLogsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowBinaryLogsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowBinaryLogsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowBroadcastsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowBroadcastsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowBroadcastsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowBroadcastsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowBroadcastsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowBroadcastsStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowBroadcastsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowBroadcastsStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowBroadcastsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowBroadcastsStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowBroadcastsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowCharacterSetStatement extends MySqlStatementImpl {
    
}
impl MySqlShowCharacterSetStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowCharacterSetStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowCharacterSetStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowCharacterSetStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pattern oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCharacterSetStatement.getPattern:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPattern(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCharacterSetStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPatternOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCharacterSetStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCharacterSetStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowClusterNameStatement extends MySqlStatementImpl {
    
}
impl MySqlShowClusterNameStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowClusterNameStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowClusterNameStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowClusterNameStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowCollationStatement extends MySqlStatementImpl {
    
}
impl MySqlShowCollationStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowCollationStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowCollationStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowCollationStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pattern oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCollationStatement.getPattern:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPattern(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCollationStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPatternOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCollationStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCollationStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowConfigStatement extends MySqlStatementImpl {
    
}
impl MySqlShowConfigStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowConfigStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowConfigStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowConfigStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowConfigStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowConfigStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowContributorsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowContributorsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowContributorsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowContributorsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowContributorsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowCreateDatabaseStatement extends MySqlStatementImpl {
    
}
impl MySqlShowCreateDatabaseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowCreateDatabaseStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowCreateDatabaseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowCreateDatabaseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCreateDatabaseStatement.getDatabase:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDatabase(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCreateDatabaseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCreateDatabaseStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowCreateDatabaseStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlShowCreateEventStatement extends MySqlStatementImpl {
    
}
impl MySqlShowCreateEventStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowCreateEventStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowCreateEventStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowCreateEventStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the event name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCreateEventStatement.getEventName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getEventName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCreateEventStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEventNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowCreateFunctionStatement extends MySqlStatementImpl {
    
}
impl MySqlShowCreateFunctionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowCreateFunctionStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowCreateFunctionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowCreateFunctionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCreateFunctionStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCreateFunctionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowCreateProcedureStatement extends MySqlStatementImpl {
    
}
impl MySqlShowCreateProcedureStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowCreateProcedureStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowCreateProcedureStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowCreateProcedureStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCreateProcedureStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCreateProcedureStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowCreateTriggerStatement extends MySqlStatementImpl {
    
}
impl MySqlShowCreateTriggerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowCreateTriggerStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowCreateTriggerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowCreateTriggerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowCreateTriggerStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowCreateTriggerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowDatabaseStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowDatabaseStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowDatabaseStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowDatabaseStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowDatabaseStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDatabaseStatusStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowDatabaseStatusStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDatabaseStatusStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowDatabaseStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDatabaseStatusStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowDatabaseStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDatabaseStatusStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowDatabaseStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDatabaseStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowDatabaseStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowDatasourcesStatement extends MySqlStatementImpl {
    
}
impl MySqlShowDatasourcesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowDatasourcesStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowDatasourcesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowDatasourcesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDatasourcesStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowDatasourcesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDatasourcesStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowDatasourcesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDatasourcesStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowDatasourcesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowDdlStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowDdlStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowDdlStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowDdlStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowDdlStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDdlStatusStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowDdlStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDdlStatusStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowDdlStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDdlStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowDdlStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowDsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowDsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowDsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowDsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowDsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDsStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowDsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDsStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowDsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowDsStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowDsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowEngineStatement extends MySqlStatementImpl {
    
}
impl MySqlShowEngineStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowEngineStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowEngineStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowEngineStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowEngineStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowEngineStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowEngineStatement.getOption:Option()`.
     * @return string
     */
    pub fn getOption(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlShowEngineStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOption()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlShowEnginesStatement extends MySqlStatementImpl {
    
}
impl MySqlShowEnginesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowEnginesStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowEnginesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowEnginesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is storage of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowEnginesStatement.isStorage:boolean()`.
     * @return int
     */
    pub fn isStorage(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowEnginesStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsStorage()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlShowErrorsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowErrorsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowErrorsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowErrorsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowErrorsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is count of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowErrorsStatement.isCount:boolean()`.
     * @return int
     */
    pub fn isCount(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowErrorsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCount()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowErrorsStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowErrorsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowEventsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowEventsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowEventsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowEventsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowEventsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowEventsStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowEventsStatement.getSchema:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSchema(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowEventsStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowFunctionCodeStatement extends MySqlStatementImpl {
    
}
impl MySqlShowFunctionCodeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowFunctionCodeStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowFunctionCodeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowFunctionCodeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowFunctionCodeStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowFunctionCodeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowFunctionStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowFunctionStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowFunctionStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowFunctionStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowFunctionStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowFunctionStatusStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowFunctionStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowFunctionStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowFunctionStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowGrantsStatement extends SQLShowGrantsStatement {
    
}
impl MySqlShowGrantsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowGrantsStatement {
        for (tmp in SQLShowGrantsStatement(db)) {
            for (x in MySqlShowGrantsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowGrantsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowHMSMetaStatement extends MySqlStatementImpl {
    
}
impl MySqlShowHMSMetaStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowHMSMetaStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowHmsMetaStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowHMSMetaStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowHMSMetaStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowHmsMetaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowHMSMetaStatement.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlShowHmsMetaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowHMSMetaStatement.getTableName:String()`.
     * @return string
     */
    pub fn getTableName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlShowHmsMetaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTableName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlShowHelpStatement extends MySqlStatementImpl {
    
}
impl MySqlShowHelpStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowHelpStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowHelpStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowHelpStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowHelpStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowHelpStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowHelpStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowHelpStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowHelpStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowHelpStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowJobStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowJobStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowJobStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowJobStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowJobStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is sync of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowJobStatusStatement.isSync:boolean()`.
     * @return int
     */
    pub fn isSync(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowJobStatusStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSync()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowJobStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowJobStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowMasterLogsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowMasterLogsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowMasterLogsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowMasterLogsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowMasterLogsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowMasterStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowMasterStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowMasterStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowMasterStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowMasterStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowMigrateTaskStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowMigrateTaskStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowMigrateTaskStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowMigrateTaskStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowMigrateTaskStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowMigrateTaskStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowMigrateTaskStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowNodeStatement extends MySqlStatementImpl {
    
}
impl MySqlShowNodeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowNodeStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowNodeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowNodeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowNodeStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowNodeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowNodeStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowNodeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowNodeStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowNodeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowOpenTablesStatement extends MySqlStatementImpl {
    
}
impl MySqlShowOpenTablesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowOpenTablesStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowOpenTablesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowOpenTablesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowOpenTablesStatement.getDatabase:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDatabase(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowOpenTablesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowOpenTablesStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowOpenTablesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowOpenTablesStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowOpenTablesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowPartitionsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowPartitionsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowPartitionsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowPartitionsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowPartitionsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowPartitionsStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowPartitionsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowPhysicalProcesslistStatement extends MySqlStatementImpl {
    
}
impl MySqlShowPhysicalProcesslistStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowPhysicalProcesslistStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowPhysicalProcesslistStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowPhysicalProcesslistStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowPhysicalProcesslistStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowPhysicalProcesslistStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MySqlShowPlanCacheStatement extends MySqlStatementImpl {
    
}
impl MySqlShowPlanCacheStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowPlanCacheStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowPlanCacheStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowPlanCacheStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowPlanCacheStatement.getSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in MySqlShowPlanCacheStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSelectOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowPlanCacheStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowPlanCacheStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowPlanCacheStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowPlanCacheStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowPlanCacheStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowPluginsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowPluginsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowPluginsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowPluginsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowPluginsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowPrivilegesStatement extends MySqlStatementImpl {
    
}
impl MySqlShowPrivilegesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowPrivilegesStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowPrivilegesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowPrivilegesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowProcedureCodeStatement extends MySqlStatementImpl {
    
}
impl MySqlShowProcedureCodeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowProcedureCodeStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowProcedureCodeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowProcedureCodeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowProcedureCodeStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowProcedureCodeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowProcedureStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowProcedureStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowProcedureStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowProcedureStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowProcedureStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowProcedureStatusStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowProcedureStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowProcedureStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowProcedureStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowProcessListStatement extends SQLShowProcessListStatement {
    
}
impl MySqlShowProcessListStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowProcessListStatement {
        for (tmp in SQLShowProcessListStatement(db)) {
            for (x in MySqlShowProcessListStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowProcessListStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowProfileStatement extends MySqlStatementImpl {
    
}
impl MySqlShowProfileStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowProfileStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowProfileStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowProfileStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the for query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowProfileStatement.getForQuery:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getForQuery(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowProfileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowProfileStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowProfileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the types of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowProfileStatement.getTypes:List<Type>()`.
     * @return string
     */
    pub fn getTypes(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlShowProfileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTypes()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema MySqlShowProfilesStatement extends MySqlStatementImpl {
    
}
impl MySqlShowProfilesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowProfilesStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowProfilesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowProfilesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowRelayLogEventsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowRelayLogEventsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowRelayLogEventsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowRelayLogEventsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowRelayLogEventsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRelayLogEventsStatement.getFrom:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFrom(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowRelayLogEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRelayLogEventsStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowRelayLogEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the log name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRelayLogEventsStatement.getLogName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLogName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowRelayLogEventsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLogNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowRuleStatement extends MySqlStatementImpl {
    
}
impl MySqlShowRuleStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowRuleStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowRuleStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowRuleStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowRuleStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is version of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatement.isVersion:boolean()`.
     * @return int
     */
    pub fn isVersion(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowRuleStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsVersion()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowRuleStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowRuleStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowRuleStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowRuleStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowRuleStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowRuleStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowRuleStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowRuleStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowRuleStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatusStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowRuleStatusStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is lite of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatusStatement.isLite:boolean()`.
     * @return int
     */
    pub fn isLite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowRuleStatusStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is version of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatusStatement.isVersion:boolean()`.
     * @return int
     */
    pub fn isVersion(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowRuleStatusStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsVersion()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatusStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowRuleStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatusStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowRuleStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowRuleStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowRuleStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowSequencesStatement extends MySqlStatementImpl {
    
}
impl MySqlShowSequencesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowSequencesStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowSequencesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowSequencesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowSequencesStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowSequencesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowSequencesStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowSequencesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowSequencesStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowSequencesStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowSlaveHostsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowSlaveHostsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowSlaveHostsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowSlaveHostsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowSlaveHostsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowSlaveStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowSlaveStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowSlaveStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowSlaveStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowSlaveStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlShowSlowStatement extends MySqlStatementImpl {
    
}
impl MySqlShowSlowStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowSlowStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowSlowStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowSlowStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowSlowStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowSlowStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is physical of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowSlowStatement.isPhysical:boolean()`.
     * @return int
     */
    pub fn isPhysical(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowSlowStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPhysical()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowSlowStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowSlowStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowSlowStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowSlowStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowSlowStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowSlowStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowStatusStatement.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowStatusStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is session of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowStatusStatement.isSession:boolean()`.
     * @return int
     */
    pub fn isSession(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowStatusStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSession()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowStatusStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowTableStatusStatement extends MySqlStatementImpl {
    
}
impl MySqlShowTableStatusStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowTableStatusStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowTableStatusStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowTableStatusStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTableStatusStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowTableStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTableStatusStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowTableStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table group oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTableStatusStatement.getTableGroup:SQLName()`.
     * @return SQLName
     */
    pub fn getTableGroup(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowTableStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableGroupOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTableStatusStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowTableStatusStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowTopologyStatement extends MySqlStatementImpl {
    
}
impl MySqlShowTopologyStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowTopologyStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowTopologyStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowTopologyStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTopologyStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowTopologyStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTopologyStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowTopologyStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTopologyStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowTopologyStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTopologyStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowTopologyStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTopologyStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowTopologyStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowTraceStatement extends MySqlStatementImpl {
    
}
impl MySqlShowTraceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowTraceStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowTraceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowTraceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTraceStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowTraceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTraceStatement.getOrderBy:SQLOrderBy()`.
     * @return SQLOrderBy
     */
    pub fn getOrderBy(self) -> SQLOrderBy {
        for (s in SQLOrderBy(__all_data__),
            x in MySqlShowTraceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTraceStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowTraceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowTriggersStatement extends MySqlStatementImpl {
    
}
impl MySqlShowTriggersStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowTriggersStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowTriggersStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowTriggersStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTriggersStatement.getDatabase:SQLName()`.
     * @return SQLName
     */
    pub fn getDatabase(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlShowTriggersStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDatabaseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTriggersStatement.getLike:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLike(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowTriggersStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowTriggersStatement.getWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlShowTriggersStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhereOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlShowWarningsStatement extends MySqlStatementImpl {
    
}
impl MySqlShowWarningsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlShowWarningsStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlShowWarningsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlShowWarningsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is count of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowWarningsStatement.isCount:boolean()`.
     * @return int
     */
    pub fn isCount(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlShowWarningsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCount()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlShowWarningsStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlShowWarningsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlSubPartitionByKey extends SQLSubPartitionBy {
    
}
impl MySqlSubPartitionByKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlSubPartitionByKey {
        for (tmp in SQLSubPartitionBy(db)) {
            for (x in MySqlSubPartitionByKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlSubPartitionByKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSubPartitionByKey.getAlgorithm:int()`.
     * @return int
     */
    pub fn getAlgorithm(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlSubPartitionByKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSubPartitionByKey.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlSubPartitionByList extends SQLSubPartitionBy {
    
}
impl MySqlSubPartitionByList {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlSubPartitionByList {
        for (tmp in SQLSubPartitionBy(db)) {
            for (x in MySqlSubPartitionByListDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlSubPartitionByList {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSubPartitionByList.getColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the keys of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSubPartitionByList.getKeys:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getKeys(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlSubPartitionByValue extends SQLSubPartitionBy {
    
}
impl MySqlSubPartitionByValue {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlSubPartitionByValue {
        for (tmp in SQLSubPartitionBy(db)) {
            for (x in MySqlSubPartitionByValueDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlSubPartitionByValue {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSubPartitionByValue.getColumns:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getColumns(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlTableIndex extends SQLConstraintImpl {
    
}
impl MySqlTableIndex {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlTableIndex {
        for (tmp in SQLConstraintImpl(db)) {
            for (x in MySqlTableIndexDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlTableIndex {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the algorithm of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getAlgorithm:String()`.
     * @return string
     */
    pub fn getAlgorithm(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlTableIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlgorithm()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the analyzer name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getAnalyzerName:SQLName()`.
     * @return SQLName
     */
    pub fn getAnalyzerName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAnalyzerNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the db partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getDbPartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDbPartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDbPartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the distance measure of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getDistanceMeasure:String()`.
     * @return string
     */
    pub fn getDistanceMeasure(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlTableIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDistanceMeasure()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index analyzer name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getIndexAnalyzerName:SQLName()`.
     * @return SQLName
     */
    pub fn getIndexAnalyzerName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexAnalyzerNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index definition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getIndexDefinition:SQLIndexDefinition()`.
     * @return SQLIndexDefinition
     */
    pub fn getIndexDefinition(self) -> SQLIndexDefinition {
        for (s in SQLIndexDefinition(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIndexDefinitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the index type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getIndexType:String()`.
     * @return string
     */
    pub fn getIndexType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MySqlTableIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIndexType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlTableIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlTableIndexDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the query analyzer name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getQueryAnalyzerName:SQLName()`.
     * @return SQLName
     */
    pub fn getQueryAnalyzerName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getQueryAnalyzerNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table partition by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getTablePartitionBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitionBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table partitions oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getTablePartitions:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTablePartitions(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablePartitionsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the with dic name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getWithDicName:SQLName()`.
     * @return SQLName
     */
    pub fn getWithDicName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlTableIndexDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWithDicNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getColumns:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getColumns(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the covering of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getCovering:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getCovering(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlTableIndex.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlUnlockTablesStatement extends MySqlStatementImpl {
    
}
impl MySqlUnlockTablesStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlUnlockTablesStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlUnlockTablesStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlUnlockTablesStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MySqlUpdatePlanCacheStatement extends MySqlStatementImpl {
    
}
impl MySqlUpdatePlanCacheStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlUpdatePlanCacheStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MySqlUpdatePlanCacheStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlUpdatePlanCacheStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the form select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdatePlanCacheStatement.getFormSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getFormSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in MySqlUpdatePlanCacheStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFormSelectOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to select oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdatePlanCacheStatement.getToSelect:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getToSelect(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in MySqlUpdatePlanCacheStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToSelectOid()) {
                    return s
                }
            }
        }
    }
}
schema MySqlUpdateStatement extends SQLUpdateStatement {
    
}
impl MySqlUpdateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlUpdateStatement {
        for (tmp in SQLUpdateStatement(db)) {
            for (x in MySqlUpdateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlUpdateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the force partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.getForcePartition:SQLName()`.
     * @return SQLName
     */
    pub fn getForcePartition(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MySqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getForcePartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.getHintsSize:int()`.
     * @return int
     */
    pub fn getHintsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is commit on success of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.isCommitOnSuccess:boolean()`.
     * @return int
     */
    pub fn isCommitOnSuccess(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCommitOnSuccess()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is force all partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.isForceAllPartitions:boolean()`.
     * @return int
     */
    pub fn isForceAllPartitions(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForceAllPartitions()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is ignore of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.isIgnore:boolean()`.
     * @return int
     */
    pub fn isIgnore(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIgnore()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is low priority of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.isLowPriority:boolean()`.
     * @return int
     */
    pub fn isLowPriority(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLowPriority()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is query on pk of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.isQueryOnPk:boolean()`.
     * @return int
     */
    pub fn isQueryOnPk(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsQueryOnPk()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is roll back on fail of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.isRollBackOnFail:boolean()`.
     * @return int
     */
    pub fn isRollBackOnFail(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MySqlUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRollBackOnFail()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.getLimit:SQLLimit()`.
     * @return SQLLimit
     */
    pub fn getLimit(self) -> SQLLimit {
        for (s in SQLLimit(__all_data__),
            x in MySqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the target affect row oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.getTargetAffectRow:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTargetAffectRow(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in MySqlUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTargetAffectRowOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateStatement.getHints:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHints(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MySqlUpdateTableSource extends SQLTableSourceImpl {
    
}
impl MySqlUpdateTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MySqlUpdateTableSource {
        for (tmp in SQLTableSourceImpl(db)) {
            for (x in MySqlUpdateTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MySqlUpdateTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the update oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlUpdateTableSource.getUpdate:MySqlUpdateStatement()`.
     * @return MySqlUpdateStatement
     */
    pub fn getUpdate(self) -> MySqlUpdateStatement {
        for (s in MySqlUpdateStatement(__all_data__),
            x in MySqlUpdateTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUpdateOid()) {
                    return s
                }
            }
        }
    }
}
schema MysqlAlterFullTextStatement extends MySqlStatementImpl {
    
}
impl MysqlAlterFullTextStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlAlterFullTextStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlAlterFullTextStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlAlterFullTextStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the item oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlAlterFullTextStatement.getItem:SQLAssignItem()`.
     * @return SQLAssignItem
     */
    pub fn getItem(self) -> SQLAssignItem {
        for (s in SQLAssignItem(__all_data__),
            x in MysqlAlterFullTextStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getItemOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlAlterFullTextStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlAlterFullTextStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlAlterFullTextStatement.getType:FullTextType()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlAlterFullTextStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MysqlAlterTableAlterCheck extends MySqlObjectImpl {
    
}
impl MysqlAlterTableAlterCheck {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlAlterTableAlterCheck {
        for (tmp in MySqlObjectImpl(db)) {
            for (x in MysqlAlterTableAlterCheckDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlAlterTableAlterCheck {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enforced of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlAlterTableAlterCheck.getEnforced:Boolean()`.
     * @return int
     */
    pub fn getEnforced(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MysqlAlterTableAlterCheckDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnforced()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlAlterTableAlterCheck.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlAlterTableAlterCheckDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MysqlCreateFullTextAnalyzerStatement extends MySqlStatementImpl {
    
}
impl MysqlCreateFullTextAnalyzerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlCreateFullTextAnalyzerStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlCreateFullTextAnalyzerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlCreateFullTextAnalyzerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the charfilters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextAnalyzerStatement.getCharfilters:List<String>()`.
     * @return string
     */
    pub fn getCharfilters(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlCreateFullTextAnalyzerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCharfilters()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextAnalyzerStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlCreateFullTextAnalyzerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the tokenizer of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextAnalyzerStatement.getTokenizer:String()`.
     * @return string
     */
    pub fn getTokenizer(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlCreateFullTextAnalyzerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTokenizer()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the tokenizers of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextAnalyzerStatement.getTokenizers:List<String>()`.
     * @return string
     */
    pub fn getTokenizers(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlCreateFullTextAnalyzerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getTokenizers()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema MysqlCreateFullTextCharFilterStatement extends MySqlStatementImpl {
    
}
impl MysqlCreateFullTextCharFilterStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlCreateFullTextCharFilterStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlCreateFullTextCharFilterStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlCreateFullTextCharFilterStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextCharFilterStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlCreateFullTextCharFilterStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextCharFilterStatement.getTypeName:SQLTextLiteralExpr()`.
     * @return SQLTextLiteralExpr
     */
    pub fn getTypeName(self) -> SQLTextLiteralExpr {
        for (s in SQLTextLiteralExpr(__all_data__),
            x in MysqlCreateFullTextCharFilterStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTypeNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextCharFilterStatement.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MysqlCreateFullTextDictionaryStatement extends MySqlStatementImpl {
    
}
impl MysqlCreateFullTextDictionaryStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlCreateFullTextDictionaryStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlCreateFullTextDictionaryStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlCreateFullTextDictionaryStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextDictionaryStatement.getColumn:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumn(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in MysqlCreateFullTextDictionaryStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the comment of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextDictionaryStatement.getComment:String()`.
     * @return string
     */
    pub fn getComment(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlCreateFullTextDictionaryStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getComment()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextDictionaryStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlCreateFullTextDictionaryStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MysqlCreateFullTextTokenFilterStatement extends MySqlStatementImpl {
    
}
impl MysqlCreateFullTextTokenFilterStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlCreateFullTextTokenFilterStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlCreateFullTextTokenFilterStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlCreateFullTextTokenFilterStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextTokenFilterStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlCreateFullTextTokenFilterStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextTokenFilterStatement.getTypeName:SQLTextLiteralExpr()`.
     * @return SQLTextLiteralExpr
     */
    pub fn getTypeName(self) -> SQLTextLiteralExpr {
        for (s in SQLTextLiteralExpr(__all_data__),
            x in MysqlCreateFullTextTokenFilterStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTypeNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextTokenFilterStatement.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MysqlCreateFullTextTokenizerStatement extends MySqlStatementImpl {
    
}
impl MysqlCreateFullTextTokenizerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlCreateFullTextTokenizerStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlCreateFullTextTokenizerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlCreateFullTextTokenizerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextTokenizerStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlCreateFullTextTokenizerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextTokenizerStatement.getTypeName:SQLTextLiteralExpr()`.
     * @return SQLTextLiteralExpr
     */
    pub fn getTypeName(self) -> SQLTextLiteralExpr {
        for (s in SQLTextLiteralExpr(__all_data__),
            x in MysqlCreateFullTextTokenizerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTypeNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user defined dict oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextTokenizerStatement.getUserDefinedDict:SQLTextLiteralExpr()`.
     * @return SQLTextLiteralExpr
     */
    pub fn getUserDefinedDict(self) -> SQLTextLiteralExpr {
        for (s in SQLTextLiteralExpr(__all_data__),
            x in MysqlCreateFullTextTokenizerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserDefinedDictOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlCreateFullTextTokenizerStatement.getOptions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getOptions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema MysqlDeallocatePrepareStatement extends MySqlStatementImpl {
    
}
impl MysqlDeallocatePrepareStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlDeallocatePrepareStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlDeallocatePrepareStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlDeallocatePrepareStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statement name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlDeallocatePrepareStatement.getStatementName:SQLName()`.
     * @return SQLName
     */
    pub fn getStatementName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlDeallocatePrepareStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatementNameOid()) {
                    return s
                }
            }
        }
    }
}
schema MysqlDropFullTextStatement extends MySqlStatementImpl {
    
}
impl MysqlDropFullTextStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlDropFullTextStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlDropFullTextStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlDropFullTextStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlDropFullTextStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlDropFullTextStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlDropFullTextStatement.getType:FullTextType()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlDropFullTextStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MysqlShowCreateFullTextStatement extends MySqlStatementImpl {
    
}
impl MysqlShowCreateFullTextStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlShowCreateFullTextStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlShowCreateFullTextStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlShowCreateFullTextStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlShowCreateFullTextStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in MysqlShowCreateFullTextStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlShowCreateFullTextStatement.getType:FullTextType()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlShowCreateFullTextStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MysqlShowDbLockStatement extends MySqlStatementImpl {
    
}
impl MysqlShowDbLockStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlShowDbLockStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlShowDbLockStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlShowDbLockStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema MysqlShowFullTextStatement extends MySqlStatementImpl {
    
}
impl MysqlShowFullTextStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlShowFullTextStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlShowFullTextStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlShowFullTextStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlShowFullTextStatement.getType:FullTextType()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in MysqlShowFullTextStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MysqlShowHtcStatement extends MySqlStatementImpl {
    
}
impl MysqlShowHtcStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlShowHtcStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlShowHtcStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlShowHtcStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlShowHtcStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MysqlShowHtcStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is his of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlShowHtcStatement.isHis:boolean()`.
     * @return int
     */
    pub fn isHis(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MysqlShowHtcStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHis()) {
                        return s
                    }
                }
            }
        }
    }
}
schema MysqlShowStcStatement extends MySqlStatementImpl {
    
}
impl MysqlShowStcStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *MysqlShowStcStatement {
        for (tmp in MySqlStatementImpl(db)) {
            for (x in MysqlShowStcStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield MysqlShowStcStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is full of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlShowStcStatement.isFull:boolean()`.
     * @return int
     */
    pub fn isFull(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MysqlShowStcStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFull()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is his of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.MysqlShowStcStatement.isHis:boolean()`.
     * @return int
     */
    pub fn isHis(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in MysqlShowStcStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsHis()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLAlterResourceGroupStatement extends SQLStatementImpl {
    
}
impl SQLAlterResourceGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLAlterResourceGroupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlAlterResourceGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLAlterResourceGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.SQLAlterResourceGroupStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlAlterResourceGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.SQLAlterResourceGroupStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlAlterResourceGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.SQLAlterResourceGroupStatement.getProperties:Map<String, SQLExpr>()`.
     * @return string
     */
    pub fn getProperties(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlAlterResourceGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getProperties()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLCreateResourceGroupStatement extends SQLStatementImpl {
    
}
impl SQLCreateResourceGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLCreateResourceGroupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlCreateResourceGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLCreateResourceGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.SQLCreateResourceGroupStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlCreateResourceGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.SQLCreateResourceGroupStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlCreateResourceGroupStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.mysql.ast.statement.SQLCreateResourceGroupStatement.getProperties:Map<String, SQLExpr>()`.
     * @return string
     */
    pub fn getProperties(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlCreateResourceGroupStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getProperties()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLListResourceGroupStatement extends SQLStatementImpl {
    
}
impl SQLListResourceGroupStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLListResourceGroupStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in SqlListResourceGroupStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLListResourceGroupStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema OdpsAddAccountProviderStatement extends SQLStatementImpl {
    
}
impl OdpsAddAccountProviderStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsAddAccountProviderStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OdpsAddAccountProviderStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsAddAccountProviderStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the provider oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddAccountProviderStatement.getProvider:SQLName()`.
     * @return SQLName
     */
    pub fn getProvider(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OdpsAddAccountProviderStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getProviderOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsAddFileStatement extends OdpsStatementImpl {
    
}
impl OdpsAddFileStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsAddFileStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsAddFileStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsAddFileStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddFileStatement.getAlias:String()`.
     * @return string
     */
    pub fn getAlias(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OdpsAddFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddFileStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsAddFileStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the file of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddFileStatement.getFile:String()`.
     * @return string
     */
    pub fn getFile(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OdpsAddFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddFileStatement.isForce:boolean()`.
     * @return int
     */
    pub fn isForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OdpsAddFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddFileStatement.getType:FileType()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OdpsAddFileStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OdpsAddStatisticStatement extends OdpsStatementImpl {
    
}
impl OdpsAddStatisticStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsAddStatisticStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsAddStatisticStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsAddStatisticStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statistic clause oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddStatisticStatement.getStatisticClause:OdpsStatisticClause()`.
     * @return OdpsStatisticClause
     */
    pub fn getStatisticClause(self) -> OdpsStatisticClause {
        for (s in OdpsStatisticClause(__all_data__),
            x in OdpsAddStatisticStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatisticClauseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddStatisticStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsAddStatisticStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsAddTableStatement extends OdpsStatementImpl {
    
}
impl OdpsAddTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsAddTableStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsAddTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsAddTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the comment oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddTableStatement.getComment:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getComment(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsAddTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCommentOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddTableStatement.isForce:boolean()`.
     * @return int
     */
    pub fn isForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OdpsAddTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddTableStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsAddTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to package oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddTableStatement.getToPackage:SQLName()`.
     * @return SQLName
     */
    pub fn getToPackage(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OdpsAddTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToPackageOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddTableStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the privileges of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddTableStatement.getPrivileges:List<SQLPrivilegeItem>()`.
     * @return SQLPrivilegeItem
     */
    pub fn getPrivileges(self) -> *SQLPrivilegeItem {
        for (x in SQLPrivilegeItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsAddUserStatement extends SQLStatementImpl {
    
}
impl OdpsAddUserStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsAddUserStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OdpsAddUserStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsAddUserStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAddUserStatement.getUser:SQLName()`.
     * @return SQLName
     */
    pub fn getUser(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OdpsAddUserStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsAlterTableSetChangeLogs extends OdpsObjectImpl {
    
}
impl OdpsAlterTableSetChangeLogs {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsAlterTableSetChangeLogs {
        for (tmp in OdpsObjectImpl(db)) {
            for (x in OdpsAlterTableSetChangeLogsDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsAlterTableSetChangeLogs {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAlterTableSetChangeLogs.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsAlterTableSetChangeLogsDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsAlterTableSetFileFormat extends OdpsObjectImpl {
    
}
impl OdpsAlterTableSetFileFormat {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsAlterTableSetFileFormat {
        for (tmp in OdpsObjectImpl(db)) {
            for (x in OdpsAlterTableSetFileFormatDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsAlterTableSetFileFormat {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsAlterTableSetFileFormat.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsAlterTableSetFileFormatDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsCountStatement extends OdpsStatementImpl {
    
}
impl OdpsCountStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsCountStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsCountStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsCountStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsCountStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsCountStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsCountStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsCreateTableStatement extends HiveCreateTableStatement {
    
}
impl OdpsCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsCreateTableStatement {
        for (tmp in HiveCreateTableStatement(db)) {
            for (x in OdpsCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lifecycle oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsCreateTableStatement.getLifecycle:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLifecycle(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLifecycleOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the like oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsCreateTableStatement.getLike:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getLike(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLikeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the stored by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsCreateTableStatement.getStoredBy:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStoredBy(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredByOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partition columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsCreateTableStatement.getPartitionColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getPartitionColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the with serdeproperties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsCreateTableStatement.getWithSerdeproperties:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getWithSerdeproperties(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsDeclareVariableStatement extends OdpsStatementImpl {
    
}
impl OdpsDeclareVariableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsDeclareVariableStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsDeclareVariableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsDeclareVariableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsDeclareVariableStatement.getDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in OdpsDeclareVariableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the init value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsDeclareVariableStatement.getInitValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInitValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsDeclareVariableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInitValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the variant of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsDeclareVariableStatement.getVariant:String()`.
     * @return string
     */
    pub fn getVariant(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OdpsDeclareVariableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getVariant()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OdpsExstoreStatement extends OdpsStatementImpl {
    
}
impl OdpsExstoreStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsExstoreStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsExstoreStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsExstoreStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsExstoreStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsExstoreStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsExstoreStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsGrantStmt extends SQLGrantStatement {
    
}
impl OdpsGrantStmt {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsGrantStmt {
        for (tmp in SQLGrantStatement(db)) {
            for (x in OdpsGrantStmtDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsGrantStmt {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expire oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsGrantStmt.getExpire:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpire(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsGrantStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExpireOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is label of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsGrantStmt.isLabel:boolean()`.
     * @return int
     */
    pub fn isLabel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OdpsGrantStmtDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLabel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is super of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsGrantStmt.isSuper:boolean()`.
     * @return int
     */
    pub fn isSuper(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OdpsGrantStmtDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSuper()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsGrantStmt.getLabel:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLabel(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsGrantStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLabelOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the subject type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsGrantStmt.getSubjectType:SQLObjectType()`.
     * @return string
     */
    pub fn getSubjectType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OdpsGrantStmtDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSubjectType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsGrantStmt.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsInstallPackageStatement extends OdpsStatementImpl {
    
}
impl OdpsInstallPackageStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsInstallPackageStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsInstallPackageStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsInstallPackageStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the package name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsInstallPackageStatement.getPackageName:SQLName()`.
     * @return SQLName
     */
    pub fn getPackageName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OdpsInstallPackageStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPackageNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsListStmt extends SQLStatementImpl {
    
}
impl OdpsListStmt {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsListStmt {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OdpsListStmtDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsListStmt {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the object oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsListStmt.getObject:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getObject(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsListStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getObjectOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsNewExpr extends SQLMethodInvokeExpr {
    
}
impl OdpsNewExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsNewExpr {
        for (tmp in SQLMethodInvokeExpr(db)) {
            for (x in OdpsNewExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsNewExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is array of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsNewExpr.isArray:boolean()`.
     * @return int
     */
    pub fn isArray(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OdpsNewExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsArray()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the init values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsNewExpr.getInitValues:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getInitValues(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the type parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsNewExpr.getTypeParameters:List<SQLDataType>()`.
     * @return SQLDataType
     */
    pub fn getTypeParameters(self) -> *SQLDataType {
        for (x in SQLDataType(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsQueryAliasStatement extends OdpsStatementImpl {
    
}
impl OdpsQueryAliasStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsQueryAliasStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsQueryAliasStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsQueryAliasStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsQueryAliasStatement.isCache:boolean()`.
     * @return int
     */
    pub fn isCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OdpsQueryAliasStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statement oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsQueryAliasStatement.getStatement:SQLSelectStatement()`.
     * @return SQLSelectStatement
     */
    pub fn getStatement(self) -> SQLSelectStatement {
        for (s in SQLSelectStatement(__all_data__),
            x in OdpsQueryAliasStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatementOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the variant of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsQueryAliasStatement.getVariant:String()`.
     * @return string
     */
    pub fn getVariant(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OdpsQueryAliasStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getVariant()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OdpsReadStatement extends OdpsStatementImpl {
    
}
impl OdpsReadStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsReadStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsReadStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsReadStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the row count oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsReadStatement.getRowCount:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getRowCount(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsReadStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowCountOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsReadStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsReadStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsReadStatement.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsReadStatement.getPartition:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartition(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsRemoveStatisticStatement extends OdpsStatementImpl {
    
}
impl OdpsRemoveStatisticStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsRemoveStatisticStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsRemoveStatisticStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsRemoveStatisticStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the statistic clause oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsRemoveStatisticStatement.getStatisticClause:OdpsStatisticClause()`.
     * @return OdpsStatisticClause
     */
    pub fn getStatisticClause(self) -> OdpsStatisticClause {
        for (s in OdpsStatisticClause(__all_data__),
            x in OdpsRemoveStatisticStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatisticClauseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsRemoveStatisticStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsRemoveStatisticStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsRemoveUserStatement extends SQLStatementImpl {
    
}
impl OdpsRemoveUserStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsRemoveUserStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OdpsRemoveUserStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsRemoveUserStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsRemoveUserStatement.getUser:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getUser(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in OdpsRemoveUserStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsRestoreStatement extends OdpsStatementImpl {
    
}
impl OdpsRestoreStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsRestoreStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsRestoreStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsRestoreStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsRestoreStatement.getAlias:String()`.
     * @return string
     */
    pub fn getAlias(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OdpsRestoreStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsRestoreStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsRestoreStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsRestoreStatement.getTo:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTo(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsRestoreStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsRestoreStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsRestoreStatement.getProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsSelectQueryBlock extends SQLSelectQueryBlock {
    
}
impl OdpsSelectQueryBlock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsSelectQueryBlock {
        for (tmp in SQLSelectQueryBlock(db)) {
            for (x in OdpsSelectQueryBlockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsSelectQueryBlock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the z order by oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsSelectQueryBlock.getZOrderBy:SQLZOrderBy()`.
     * @return SQLZOrderBy
     */
    pub fn getZOrderBy(self) -> SQLZOrderBy {
        for (s in SQLZOrderBy(__all_data__),
            x in OdpsSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getZOrderByOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsSetLabelStatement extends OdpsStatementImpl {
    
}
impl OdpsSetLabelStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsSetLabelStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsSetLabelStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsSetLabelStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsSetLabelStatement.getLabel:String()`.
     * @return string
     */
    pub fn getLabel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OdpsSetLabelStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the project oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsSetLabelStatement.getProject:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getProject(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsSetLabelStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getProjectOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsSetLabelStatement.getTable:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getTable(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in OdpsSetLabelStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsSetLabelStatement.getUser:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUser(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsSetLabelStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsSetLabelStatement.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsShowChangelogsStatement extends SQLStatementImpl {
    
}
impl OdpsShowChangelogsStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsShowChangelogsStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OdpsShowChangelogsStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsShowChangelogsStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsShowChangelogsStatement.getId:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getId(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsShowChangelogsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIdOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is tables of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsShowChangelogsStatement.isTables:boolean()`.
     * @return int
     */
    pub fn isTables(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OdpsShowChangelogsStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsTables()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsShowChangelogsStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsShowChangelogsStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsShowChangelogsStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsShowChangelogsStatement.getProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsShowGrantsStmt extends SQLStatementImpl {
    
}
impl OdpsShowGrantsStmt {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsShowGrantsStmt {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OdpsShowGrantsStmtDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsShowGrantsStmt {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is label of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsShowGrantsStmt.isLabel:boolean()`.
     * @return int
     */
    pub fn isLabel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OdpsShowGrantsStmtDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLabel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the object type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsShowGrantsStmt.getObjectType:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getObjectType(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsShowGrantsStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getObjectTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsShowGrantsStmt.getUser:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUser(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsShowGrantsStmtDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
}
schema OdpsTransformExpr extends SQLExprImpl {
    
}
impl OdpsTransformExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsTransformExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in OdpsTransformExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsTransformExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the input row format oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsTransformExpr.getInputRowFormat:SQLExternalRecordFormat()`.
     * @return SQLExternalRecordFormat
     */
    pub fn getInputRowFormat(self) -> SQLExternalRecordFormat {
        for (s in SQLExternalRecordFormat(__all_data__),
            x in OdpsTransformExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInputRowFormatOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the output row format oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsTransformExpr.getOutputRowFormat:SQLExternalRecordFormat()`.
     * @return SQLExternalRecordFormat
     */
    pub fn getOutputRowFormat(self) -> SQLExternalRecordFormat {
        for (s in SQLExternalRecordFormat(__all_data__),
            x in OdpsTransformExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOutputRowFormatOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsTransformExpr.getUsing:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUsing(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsTransformExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the input columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsTransformExpr.getInputColumns:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getInputColumns(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the output columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsTransformExpr.getOutputColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getOutputColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the resources of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsTransformExpr.getResources:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getResources(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsUDTFSQLSelectItem extends SQLSelectItem {
    
}
impl OdpsUDTFSQLSelectItem {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsUDTFSQLSelectItem {
        for (tmp in SQLSelectItem(db)) {
            for (x in OdpsUdtfsqlSelectItemDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsUDTFSQLSelectItem {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema OdpsUndoTableStatement extends OdpsStatementImpl {
    
}
impl OdpsUndoTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsUndoTableStatement {
        for (tmp in OdpsStatementImpl(db)) {
            for (x in OdpsUndoTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsUndoTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUndoTableStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OdpsUndoTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUndoTableStatement.getTo:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTo(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsUndoTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUndoTableStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OdpsUnloadStatement extends SQLStatementImpl {
    
}
impl OdpsUnloadStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OdpsUnloadStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OdpsUnloadStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OdpsUnloadStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the from oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUnloadStatement.getFrom:SQLTableSource()`.
     * @return SQLTableSource
     */
    pub fn getFrom(self) -> SQLTableSource {
        for (s in SQLTableSource(__all_data__),
            x in OdpsUnloadStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFromOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the location oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUnloadStatement.getLocation:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLocation(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsUnloadStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLocationOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the row format oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUnloadStatement.getRowFormat:SQLExternalRecordFormat()`.
     * @return SQLExternalRecordFormat
     */
    pub fn getRowFormat(self) -> SQLExternalRecordFormat {
        for (s in SQLExternalRecordFormat(__all_data__),
            x in OdpsUnloadStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getRowFormatOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the stored as oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUnloadStatement.getStoredAs:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStoredAs(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OdpsUnloadStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStoredAsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUnloadStatement.getPartitions:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getPartitions(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUnloadStatement.getProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the serde properties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.odps.ast.OdpsUnloadStatement.getSerdeProperties:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getSerdeProperties(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleDataTypeIntervalDay extends SQLDataTypeImpl {
    
}
impl OracleDataTypeIntervalDay {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleDataTypeIntervalDay {
        for (tmp in SQLDataTypeImpl(db)) {
            for (x in OracleDataTypeIntervalDayDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleDataTypeIntervalDay {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is to second of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.OracleDataTypeIntervalDay.isToSecond:boolean()`.
     * @return int
     */
    pub fn isToSecond(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleDataTypeIntervalDayDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsToSecond()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the fractional seconds of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.OracleDataTypeIntervalDay.getFractionalSeconds:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getFractionalSeconds(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleDataTypeIntervalYear extends SQLDataTypeImpl {
    
}
impl OracleDataTypeIntervalYear {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleDataTypeIntervalYear {
        for (tmp in SQLDataTypeImpl(db)) {
            for (x in OracleDataTypeIntervalYearDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleDataTypeIntervalYear {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema CycleClause extends OracleSQLObjectImpl {
    
}
impl CycleClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *CycleClause {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in CycleClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield CycleClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the default value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.CycleClause.getDefaultValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDefaultValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in CycleClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDefaultValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the mark oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.CycleClause.getMark:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMark(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in CycleClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMarkOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.CycleClause.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in CycleClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the aliases of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.CycleClause.getAliases:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getAliases(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema ModelClause extends OracleSQLObjectImpl {
    
}
impl ModelClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *ModelClause {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in ModelClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield ModelClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cell reference options of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.ModelClause.getCellReferenceOptions:List<CellReferenceOption>()`.
     * @return string
     */
    pub fn getCellReferenceOptions(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in ModelClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCellReferenceOptions()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the main model of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.ModelClause.getMainModel:MainModelClause()`.
     * @return string
     */
    pub fn getMainModel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in ModelClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getMainModel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the reference model clauses of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.ModelClause.getReferenceModelClauses:List<ReferenceModelClause>()`.
     * @return string
     */
    pub fn getReferenceModelClauses(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in ModelClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getReferenceModelClauses()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the return rows clause of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.ModelClause.getReturnRowsClause:ReturnRowsClause()`.
     * @return string
     */
    pub fn getReturnRowsClause(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in ModelClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getReturnRowsClause()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OracleLobStorageClause extends OracleSegmentAttributesImpl {
    
}
impl OracleLobStorageClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleLobStorageClause {
        for (tmp in OracleSegmentAttributesImpl(db)) {
            for (x in OracleLobStorageClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleLobStorageClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getCache:Boolean()`.
     * @return int
     */
    pub fn getCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLobStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the chunk oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getChunk:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getChunk(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleLobStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getChunkOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the compress of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getCompress:Boolean()`.
     * @return int
     */
    pub fn getCompress(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLobStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCompress()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLobStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is basic file of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.isBasicFile:boolean()`.
     * @return int
     */
    pub fn isBasicFile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLobStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBasicFile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is retention of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.isRetention:boolean()`.
     * @return int
     */
    pub fn isRetention(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLobStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRetention()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is secure file of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.isSecureFile:boolean()`.
     * @return int
     */
    pub fn isSecureFile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLobStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSecureFile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the keep duplicate of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getKeepDuplicate:Boolean()`.
     * @return int
     */
    pub fn getKeepDuplicate(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLobStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getKeepDuplicate()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the logging of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getLogging:Boolean()`.
     * @return int
     */
    pub fn getLogging(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLobStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLogging()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctversion oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getPctversion:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPctversion(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleLobStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPctversionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the segement name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getSegementName:SQLName()`.
     * @return SQLName
     */
    pub fn getSegementName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleLobStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSegementNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the storage clause oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getStorageClause:OracleStorageClause()`.
     * @return OracleStorageClause
     */
    pub fn getStorageClause(self) -> OracleStorageClause {
        for (s in OracleStorageClause(__all_data__),
            x in OracleLobStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStorageClauseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleLobStorageClause.getItems:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getItems(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleReturningClause extends OracleSQLObjectImpl {
    
}
impl OracleReturningClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleReturningClause {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleReturningClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleReturningClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleReturningClause.getItems:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getItems(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleReturningClause.getValues:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getValues(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleStorageClause extends OracleSQLObjectImpl {
    
}
impl OracleStorageClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleStorageClause {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleStorageClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleStorageClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the buffer pool oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getBufferPool:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getBufferPool(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getBufferPoolOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the cell flash cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getCellFlashCache:FlashCacheType()`.
     * @return string
     */
    pub fn getCellFlashCache(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCellFlashCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the flash cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getFlashCache:FlashCacheType()`.
     * @return string
     */
    pub fn getFlashCache(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleStorageClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFlashCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the free list groups oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getFreeListGroups:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFreeListGroups(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFreeListGroupsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the free lists oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getFreeLists:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getFreeLists(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getFreeListsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initial oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getInitial:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInitial(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getInitialOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the max extents oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getMaxExtents:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxExtents(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxExtentsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the max size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getMaxSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMaxSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMaxSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the min extents oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getMinExtents:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getMinExtents(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getMinExtentsOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the next oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getNext:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNext(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNextOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the objno oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getObjno:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getObjno(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getObjnoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the pct increase oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleStorageClause.getPctIncrease:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPctIncrease(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleStorageClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPctIncreaseOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleWithSubqueryEntry extends SQLObject {
    
}
impl OracleWithSubqueryEntry {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleWithSubqueryEntry {
        for (tmp in SQLObject(db)) {
            for (x in OracleWithSubqueryEntryDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleWithSubqueryEntry {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cycle clause oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleWithSubqueryEntry.getCycleClause:CycleClause()`.
     * @return CycleClause
     */
    pub fn getCycleClause(self) -> CycleClause {
        for (s in CycleClause(__all_data__),
            x in OracleWithSubqueryEntryDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getCycleClauseOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the search clause oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.OracleWithSubqueryEntry.getSearchClause:SearchClause()`.
     * @return SearchClause
     */
    pub fn getSearchClause(self) -> SearchClause {
        for (s in SearchClause(__all_data__),
            x in OracleWithSubqueryEntryDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSearchClauseOid()) {
                    return s
                }
            }
        }
    }
}
schema PartitionExtensionClause extends OracleSQLObjectImpl {
    
}
impl PartitionExtensionClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PartitionExtensionClause {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in PartitionExtensionClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PartitionExtensionClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is sub partition of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.PartitionExtensionClause.isSubPartition:boolean()`.
     * @return int
     */
    pub fn isSubPartition(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PartitionExtensionClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSubPartition()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.PartitionExtensionClause.getPartition:SQLName()`.
     * @return SQLName
     */
    pub fn getPartition(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in PartitionExtensionClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the for of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.PartitionExtensionClause.getFor:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getFor(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SampleClause extends OracleSQLObjectImpl {
    
}
impl SampleClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SampleClause {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in SampleClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SampleClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is block of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.SampleClause.isBlock:boolean()`.
     * @return int
     */
    pub fn isBlock(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SampleClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBlock()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the seed value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.SampleClause.getSeedValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSeedValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SampleClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSeedValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the percent of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.SampleClause.getPercent:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getPercent(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SearchClause extends OracleSQLObjectImpl {
    
}
impl SearchClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SearchClause {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in SearchClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SearchClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the ordering column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.SearchClause.getOrderingColumn:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getOrderingColumn(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in SearchClauseDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOrderingColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.SearchClause.getType:Type()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SearchClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.clause.SearchClause.getItems:List<SQLSelectOrderByItem>()`.
     * @return SQLSelectOrderByItem
     */
    pub fn getItems(self) -> *SQLSelectOrderByItem {
        for (x in SQLSelectOrderByItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleAnalytic extends SQLOver {
    
}
impl OracleAnalytic {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAnalytic {
        for (tmp in SQLOver(db)) {
            for (x in OracleAnalyticDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAnalytic {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the windowing oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleAnalytic.getWindowing:OracleAnalyticWindowing()`.
     * @return OracleAnalyticWindowing
     */
    pub fn getWindowing(self) -> OracleAnalyticWindowing {
        for (s in OracleAnalyticWindowing(__all_data__),
            x in OracleAnalyticDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWindowingOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleAnalyticWindowing extends SQLObject {
    
}
impl OracleAnalyticWindowing {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAnalyticWindowing {
        for (tmp in SQLObject(db)) {
            for (x in OracleAnalyticWindowingDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAnalyticWindowing {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleAnalyticWindowing.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleAnalyticWindowingDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleAnalyticWindowing.getType:Type()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleAnalyticWindowingDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OracleArgumentExpr extends OracleSQLObjectImpl {
    
}
impl OracleArgumentExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleArgumentExpr {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleArgumentExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleArgumentExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the argument name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleArgumentExpr.getArgumentName:String()`.
     * @return string
     */
    pub fn getArgumentName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleArgumentExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getArgumentName()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleArgumentExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleArgumentExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleBinaryDoubleExpr extends SQLNumericLiteralExpr {
    
}
impl OracleBinaryDoubleExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleBinaryDoubleExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in OracleBinaryDoubleExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleBinaryDoubleExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleBinaryDoubleExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleBinaryDoubleExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleBinaryDoubleExpr.getValue:Double()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleBinaryDoubleExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OracleBinaryFloatExpr extends SQLNumericLiteralExpr {
    
}
impl OracleBinaryFloatExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleBinaryFloatExpr {
        for (tmp in SQLNumericLiteralExpr(db)) {
            for (x in OracleBinaryFloatExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleBinaryFloatExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the number of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleBinaryFloatExpr.getNumber:Number()`.
     * @return string
     */
    pub fn getNumber(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleBinaryFloatExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNumber()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleBinaryFloatExpr.getValue:Float()`.
     * @return string
     */
    pub fn getValue(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleBinaryFloatExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValue()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OracleCursorExpr extends SQLExprImpl {
    
}
impl OracleCursorExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleCursorExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in OracleCursorExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleCursorExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleCursorExpr.getQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in OracleCursorExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getQueryOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleDatetimeExpr extends OracleSQLObjectImpl {
    
}
impl OracleDatetimeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleDatetimeExpr {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleDatetimeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleDatetimeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleDatetimeExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleDatetimeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the time zone oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleDatetimeExpr.getTimeZone:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTimeZone(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleDatetimeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTimeZoneOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleIntervalExpr extends SQLExprImpl {
    
}
impl OracleIntervalExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleIntervalExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in OracleIntervalExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleIntervalExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the factional seconds precision of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalExpr.getFactionalSecondsPrecision:Integer()`.
     * @return int
     */
    pub fn getFactionalSecondsPrecision(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleIntervalExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFactionalSecondsPrecision()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the precision oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalExpr.getPrecision:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPrecision(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleIntervalExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPrecisionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to factional seconds precision oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalExpr.getToFactionalSecondsPrecision:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getToFactionalSecondsPrecision(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleIntervalExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getToFactionalSecondsPrecisionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the to type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalExpr.getToType:OracleIntervalType()`.
     * @return string
     */
    pub fn getToType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleIntervalExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getToType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalExpr.getType:OracleIntervalType()`.
     * @return string
     */
    pub fn getType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleIntervalExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleIntervalExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleIsOfTypeExpr extends SQLExprImpl {
    
}
impl OracleIsOfTypeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleIsOfTypeExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in OracleIsOfTypeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleIsOfTypeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIsOfTypeExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleIsOfTypeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the types of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIsOfTypeExpr.getTypes:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getTypes(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleIsSetExpr extends SQLExprImpl {
    
}
impl OracleIsSetExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleIsSetExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in OracleIsSetExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleIsSetExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the nested table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIsSetExpr.getNestedTable:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getNestedTable(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleIsSetExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNestedTableOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleOuterExpr extends SQLExprImpl {
    
}
impl OracleOuterExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleOuterExpr {
        for (tmp in SQLExprImpl(db)) {
            for (x in OracleOuterExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleOuterExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleOuterExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleOuterExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleRangeExpr extends OracleSQLObjectImpl {
    
}
impl OracleRangeExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleRangeExpr {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleRangeExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleRangeExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the low bound oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleRangeExpr.getLowBound:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getLowBound(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleRangeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLowBoundOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the up bound oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleRangeExpr.getUpBound:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUpBound(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleRangeExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUpBoundOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleSysdateExpr extends OracleSQLObjectImpl {
    
}
impl OracleSysdateExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSysdateExpr {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleSysdateExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSysdateExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleSysdateExpr.getOption:String()`.
     * @return string
     */
    pub fn getOption(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleSysdateExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOption()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OracleTreatExpr extends OracleSQLObjectImpl {
    
}
impl OracleTreatExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleTreatExpr {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleTreatExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleTreatExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleTreatExpr.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleTreatExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is ref of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleTreatExpr.isRef:boolean()`.
     * @return int
     */
    pub fn isRef(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleTreatExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRef()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleTreatExpr.getType:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getType(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleTreatExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTypeOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleAlterSessionStatement extends OracleStatementImpl {
    
}
impl OracleAlterSessionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterSessionStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleAlterSessionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterSessionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterSessionStatement.getItems:List<SQLAssignItem>()`.
     * @return SQLAssignItem
     */
    pub fn getItems(self) -> *SQLAssignItem {
        for (x in SQLAssignItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleAlterSynonymStatement extends OracleStatementImpl {
    
}
impl OracleAlterSynonymStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterSynonymStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleAlterSynonymStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterSynonymStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterSynonymStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleAlterSynonymStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compile of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterSynonymStatement.isCompile:boolean()`.
     * @return int
     */
    pub fn isCompile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleAlterSynonymStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterSynonymStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleAlterSynonymStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleAlterTableDropPartition extends OracleAlterTableItem {
    
}
impl OracleAlterTableDropPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterTableDropPartition {
        for (tmp in OracleAlterTableItem(db)) {
            for (x in OracleAlterTableDropPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterTableDropPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableDropPartition.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleAlterTableDropPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleAlterTableModify extends OracleAlterTableItem {
    
}
impl OracleAlterTableModify {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterTableModify {
        for (tmp in OracleAlterTableItem(db)) {
            for (x in OracleAlterTableModifyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterTableModify {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableModify.getColumns:List<SQLColumnDefinition>()`.
     * @return SQLColumnDefinition
     */
    pub fn getColumns(self) -> *SQLColumnDefinition {
        for (x in SQLColumnDefinition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleAlterTableMoveTablespace extends OracleAlterTableItem {
    
}
impl OracleAlterTableMoveTablespace {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterTableMoveTablespace {
        for (tmp in OracleAlterTableItem(db)) {
            for (x in OracleAlterTableMoveTablespaceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterTableMoveTablespace {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableMoveTablespace.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleAlterTableMoveTablespaceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleAlterTableSplitPartition extends OracleAlterTableItem {
    
}
impl OracleAlterTableSplitPartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterTableSplitPartition {
        for (tmp in OracleAlterTableItem(db)) {
            for (x in OracleAlterTableSplitPartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterTableSplitPartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableSplitPartition.getInto:List<NestedTablePartitionSpec>()`.
     * @return string
     */
    pub fn getInto(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleAlterTableSplitPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInto()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableSplitPartition.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleAlterTableSplitPartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the update indexes of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableSplitPartition.getUpdateIndexes:UpdateIndexesClause()`.
     * @return string
     */
    pub fn getUpdateIndexes(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleAlterTableSplitPartitionDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getUpdateIndexes()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the at of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableSplitPartition.getAt:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getAt(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableSplitPartition.getValues:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getValues(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleAlterTableTruncatePartition extends OracleAlterTableItem {
    
}
impl OracleAlterTableTruncatePartition {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterTableTruncatePartition {
        for (tmp in OracleAlterTableItem(db)) {
            for (x in OracleAlterTableTruncatePartitionDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterTableTruncatePartition {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTableTruncatePartition.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleAlterTableTruncatePartitionDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleAlterTablespaceAddDataFile extends OracleSQLObjectImpl {
    
}
impl OracleAlterTablespaceAddDataFile {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterTablespaceAddDataFile {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleAlterTablespaceAddDataFileDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterTablespaceAddDataFile {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the files of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTablespaceAddDataFile.getFiles:List<OracleFileSpecification>()`.
     * @return OracleFileSpecification
     */
    pub fn getFiles(self) -> *OracleFileSpecification {
        for (x in OracleFileSpecification(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleAlterTablespaceStatement extends OracleStatementImpl {
    
}
impl OracleAlterTablespaceStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterTablespaceStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleAlterTablespaceStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterTablespaceStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the item oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTablespaceStatement.getItem:OracleAlterTablespaceItem()`.
     * @return OracleAlterTablespaceItem
     */
    pub fn getItem(self) -> OracleAlterTablespaceItem {
        for (s in OracleAlterTablespaceItem(__all_data__),
            x in OracleAlterTablespaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getItemOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTablespaceStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleAlterTablespaceStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleAlterTriggerStatement extends OracleStatementImpl {
    
}
impl OracleAlterTriggerStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterTriggerStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleAlterTriggerStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterTriggerStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTriggerStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleAlterTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compile of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTriggerStatement.isCompile:boolean()`.
     * @return int
     */
    pub fn isCompile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleAlterTriggerStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterTriggerStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleAlterTriggerStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleAlterViewStatement extends OracleStatementImpl {
    
}
impl OracleAlterViewStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleAlterViewStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleAlterViewStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleAlterViewStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterViewStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compile of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterViewStatement.isCompile:boolean()`.
     * @return int
     */
    pub fn isCompile(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleAlterViewStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompile()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterViewStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleAlterViewStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleCheck extends SQLCheck {
    
}
impl OracleCheck {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleCheck {
        for (tmp in SQLCheck(db)) {
            for (x in OracleCheckDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleCheck {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the deferrable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCheck.getDeferrable:Boolean()`.
     * @return int
     */
    pub fn getDeferrable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCheckDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDeferrable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the exceptions into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCheck.getExceptionsInto:SQLName()`.
     * @return SQLName
     */
    pub fn getExceptionsInto(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCheckDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExceptionsIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initially of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCheck.getInitially:Initially()`.
     * @return string
     */
    pub fn getInitially(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleCheckDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInitially()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCheck.getUsing:OracleUsingIndexClause()`.
     * @return OracleUsingIndexClause
     */
    pub fn getUsing(self) -> OracleUsingIndexClause {
        for (s in OracleUsingIndexClause(__all_data__),
            x in OracleCheckDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleContinueStatement extends OracleStatementImpl {
    
}
impl OracleContinueStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleContinueStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleContinueStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleContinueStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleContinueStatement.getLabel:String()`.
     * @return string
     */
    pub fn getLabel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleContinueStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the when oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleContinueStatement.getWhen:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhen(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleContinueStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhenOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleCreateDatabaseDbLinkStatement extends OracleStatementImpl {
    
}
impl OracleCreateDatabaseDbLinkStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleCreateDatabaseDbLinkStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleCreateDatabaseDbLinkStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleCreateDatabaseDbLinkStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the authenticated password of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateDatabaseDbLinkStatement.getAuthenticatedPassword:String()`.
     * @return string
     */
    pub fn getAuthenticatedPassword(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleCreateDatabaseDbLinkStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAuthenticatedPassword()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the authenticated user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateDatabaseDbLinkStatement.getAuthenticatedUser:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAuthenticatedUser(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleCreateDatabaseDbLinkStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAuthenticatedUserOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is public of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateDatabaseDbLinkStatement.isPublic:boolean()`.
     * @return int
     */
    pub fn isPublic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateDatabaseDbLinkStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPublic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is shared of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateDatabaseDbLinkStatement.isShared:boolean()`.
     * @return int
     */
    pub fn isShared(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateDatabaseDbLinkStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsShared()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateDatabaseDbLinkStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateDatabaseDbLinkStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the password of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateDatabaseDbLinkStatement.getPassword:String()`.
     * @return string
     */
    pub fn getPassword(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleCreateDatabaseDbLinkStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPassword()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the user oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateDatabaseDbLinkStatement.getUser:SQLName()`.
     * @return SQLName
     */
    pub fn getUser(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateDatabaseDbLinkStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateDatabaseDbLinkStatement.getUsing:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getUsing(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleCreateDatabaseDbLinkStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleCreateIndexStatement extends SQLCreateIndexStatement {
    
}
impl OracleCreateIndexStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleCreateIndexStatement {
        for (tmp in SQLCreateIndexStatement(db)) {
            for (x in OracleCreateIndexStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleCreateIndexStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the compress of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getCompress:Boolean()`.
     * @return int
     */
    pub fn getCompress(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCompress()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the compress level of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getCompressLevel:Integer()`.
     * @return int
     */
    pub fn getCompressLevel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCompressLevel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the free lists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getFreeLists:Integer()`.
     * @return int
     */
    pub fn getFreeLists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFreeLists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the initrans of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getInitrans:Integer()`.
     * @return int
     */
    pub fn getInitrans(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInitrans()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cluster of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isCluster:boolean()`.
     * @return int
     */
    pub fn isCluster(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCluster()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compress for oltp of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isCompressForOltp:boolean()`.
     * @return int
     */
    pub fn isCompressForOltp(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompressForOltp()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compute statistics of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isComputeStatistics:boolean()`.
     * @return int
     */
    pub fn isComputeStatistics(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsComputeStatistics()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is global of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isGlobal:boolean()`.
     * @return int
     */
    pub fn isGlobal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsGlobal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is index only top level of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isIndexOnlyTopLevel:boolean()`.
     * @return int
     */
    pub fn isIndexOnlyTopLevel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIndexOnlyTopLevel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isLocal:boolean()`.
     * @return int
     */
    pub fn isLocal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no parallel of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isNoParallel:boolean()`.
     * @return int
     */
    pub fn isNoParallel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoParallel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is online of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isOnline:boolean()`.
     * @return int
     */
    pub fn isOnline(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnline()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is reverse of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.isReverse:boolean()`.
     * @return int
     */
    pub fn isReverse(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReverse()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the logging of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getLogging:Boolean()`.
     * @return int
     */
    pub fn getLogging(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLogging()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the maxtrans of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getMaxtrans:Integer()`.
     * @return int
     */
    pub fn getMaxtrans(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getMaxtrans()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parallel oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getParallel:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getParallel(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getParallelOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the pctfree of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getPctfree:Integer()`.
     * @return int
     */
    pub fn getPctfree(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctfree()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctincrease of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getPctincrease:Integer()`.
     * @return int
     */
    pub fn getPctincrease(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctincrease()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctthreshold of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getPctthreshold:Integer()`.
     * @return int
     */
    pub fn getPctthreshold(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctthreshold()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctused of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getPctused:Integer()`.
     * @return int
     */
    pub fn getPctused(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctused()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sort of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getSort:Boolean()`.
     * @return int
     */
    pub fn getSort(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSort()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the storage of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getStorage:SQLObject()`.
     * @return string
     */
    pub fn getStorage(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleCreateIndexStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getStorage()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the tablespace oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getTablespace:SQLName()`.
     * @return SQLName
     */
    pub fn getTablespace(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateIndexStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTablespaceOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the global partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getGlobalPartitions:List<SQLPartitionBy>()`.
     * @return SQLPartitionBy
     */
    pub fn getGlobalPartitions(self) -> *SQLPartitionBy {
        for (x in SQLPartitionBy(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the local partitions of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getLocalPartitions:List<SQLPartition>()`.
     * @return SQLPartition
     */
    pub fn getLocalPartitions(self) -> *SQLPartition {
        for (x in SQLPartition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the local store in of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateIndexStatement.getLocalStoreIn:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getLocalStoreIn(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleCreatePackageStatement extends OracleStatementImpl {
    
}
impl OracleCreatePackageStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleCreatePackageStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleCreatePackageStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleCreatePackageStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is body of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreatePackageStatement.isBody:boolean()`.
     * @return int
     */
    pub fn isBody(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreatePackageStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBody()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is or replace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreatePackageStatement.isOrReplace:boolean()`.
     * @return int
     */
    pub fn isOrReplace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreatePackageStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrReplace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreatePackageStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreatePackageStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the statements of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreatePackageStatement.getStatements:List<SQLStatement>()`.
     * @return SQLStatement
     */
    pub fn getStatements(self) -> *SQLStatement {
        for (x in SQLStatement(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleCreateSynonymStatement extends OracleStatementImpl {
    
}
impl OracleCreateSynonymStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleCreateSynonymStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleCreateSynonymStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleCreateSynonymStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is or replace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateSynonymStatement.isOrReplace:boolean()`.
     * @return int
     */
    pub fn isOrReplace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateSynonymStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrReplace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is public of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateSynonymStatement.isPublic:boolean()`.
     * @return int
     */
    pub fn isPublic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateSynonymStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPublic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateSynonymStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateSynonymStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the object oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateSynonymStatement.getObject:SQLName()`.
     * @return SQLName
     */
    pub fn getObject(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateSynonymStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getObjectOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleCreateTableStatement extends SQLCreateTableStatement {
    
}
impl OracleCreateTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleCreateTableStatement {
        for (tmp in SQLCreateTableStatement(db)) {
            for (x in OracleCreateTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleCreateTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cache of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getCache:Boolean()`.
     * @return int
     */
    pub fn getCache(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCache()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the cluster oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getCluster:SQLName()`.
     * @return SQLName
     */
    pub fn getCluster(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getClusterOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the compress level of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getCompressLevel:Integer()`.
     * @return int
     */
    pub fn getCompressLevel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getCompressLevel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the deferred segment creation of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getDeferredSegmentCreation:DeferredSegmentCreation()`.
     * @return string
     */
    pub fn getDeferredSegmentCreation(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDeferredSegmentCreation()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable row movement of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getEnableRowMovement:Boolean()`.
     * @return int
     */
    pub fn getEnableRowMovement(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnableRowMovement()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the initrans of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getInitrans:Integer()`.
     * @return int
     */
    pub fn getInitrans(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInitrans()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compress for oltp of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.isCompressForOltp:boolean()`.
     * @return int
     */
    pub fn isCompressForOltp(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCompressForOltp()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cursor specific segment of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.isCursorSpecificSegment:boolean()`.
     * @return int
     */
    pub fn isCursorSpecificSegment(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCursorSpecificSegment()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is in memory metadata of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.isInMemoryMetadata:boolean()`.
     * @return int
     */
    pub fn isInMemoryMetadata(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsInMemoryMetadata()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is monitoring of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.isMonitoring:boolean()`.
     * @return int
     */
    pub fn isMonitoring(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsMonitoring()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on commit delete rows of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.isOnCommitDeleteRows:boolean()`.
     * @return int
     */
    pub fn isOnCommitDeleteRows(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnCommitDeleteRows()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lob storage oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getLobStorage:OracleLobStorageClause()`.
     * @return OracleLobStorageClause
     */
    pub fn getLobStorage(self) -> OracleLobStorageClause {
        for (s in OracleLobStorageClause(__all_data__),
            x in OracleCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLobStorageOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the maxtrans of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getMaxtrans:Integer()`.
     * @return int
     */
    pub fn getMaxtrans(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getMaxtrans()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the of oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getOf:SQLName()`.
     * @return SQLName
     */
    pub fn getOf(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOfOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the oid index of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getOidIndex:OIDIndex()`.
     * @return string
     */
    pub fn getOidIndex(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOidIndex()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the organization of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getOrganization:Organization()`.
     * @return string
     */
    pub fn getOrganization(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOrganization()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parallel of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getParallel:Boolean()`.
     * @return int
     */
    pub fn getParallel(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getParallel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parallel value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getParallelValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getParallelValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getParallelValueOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the pctfree of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getPctfree:Integer()`.
     * @return int
     */
    pub fn getPctfree(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctfree()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctincrease of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getPctincrease:Integer()`.
     * @return int
     */
    pub fn getPctincrease(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctincrease()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pctused of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getPctused:Integer()`.
     * @return int
     */
    pub fn getPctused(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPctused()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the storage oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getStorage:OracleStorageClause()`.
     * @return OracleStorageClause
     */
    pub fn getStorage(self) -> OracleStorageClause {
        for (s in OracleStorageClause(__all_data__),
            x in OracleCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStorageOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the xml type column properties oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getXmlTypeColumnProperties:OracleXmlColumnProperties()`.
     * @return OracleXmlColumnProperties
     */
    pub fn getXmlTypeColumnProperties(self) -> OracleXmlColumnProperties {
        for (s in OracleXmlColumnProperties(__all_data__),
            x in OracleCreateTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getXmlTypeColumnPropertiesOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the cluster columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getClusterColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getClusterColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the including of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTableStatement.getIncluding:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getIncluding(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleCreateTypeStatement extends OracleStatementImpl {
    
}
impl OracleCreateTypeStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleCreateTypeStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleCreateTypeStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleCreateTypeStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the auth id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getAuthId:SQLName()`.
     * @return SQLName
     */
    pub fn getAuthId(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAuthIdOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the instantiable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getInstantiable:Boolean()`.
     * @return int
     */
    pub fn getInstantiable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInstantiable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is body of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.isBody:boolean()`.
     * @return int
     */
    pub fn isBody(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsBody()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is final of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getFinal:Boolean()`.
     * @return int
     */
    pub fn getFinal(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsFinal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is force of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.isForce:boolean()`.
     * @return int
     */
    pub fn isForce(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForce()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is object of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.isObject:boolean()`.
     * @return int
     */
    pub fn isObject(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsObject()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is or replace of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.isOrReplace:boolean()`.
     * @return int
     */
    pub fn isOrReplace(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOrReplace()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is paren of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.isParen:boolean()`.
     * @return int
     */
    pub fn isParen(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleCreateTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsParen()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the oid oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getOid:SQLName()`.
     * @return SQLName
     */
    pub fn getOid(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOidOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table of oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getTableOf:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getTableOf(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in OracleCreateTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOfOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the under oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getUnder:SQLName()`.
     * @return SQLName
     */
    pub fn getUnder(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleCreateTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUnderOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the varray data type oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getVarrayDataType:SQLDataType()`.
     * @return SQLDataType
     */
    pub fn getVarrayDataType(self) -> SQLDataType {
        for (s in SQLDataType(__all_data__),
            x in OracleCreateTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getVarrayDataTypeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the varray size limit oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getVarraySizeLimit:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getVarraySizeLimit(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleCreateTypeStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getVarraySizeLimitOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the wrapped source of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getWrappedSource:String()`.
     * @return string
     */
    pub fn getWrappedSource(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleCreateTypeStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getWrappedSource()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleCreateTypeStatement.getParameters:List<SQLParameter>()`.
     * @return SQLParameter
     */
    pub fn getParameters(self) -> *SQLParameter {
        for (x in SQLParameter(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleDeleteStatement extends SQLDeleteStatement {
    
}
impl OracleDeleteStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleDeleteStatement {
        for (tmp in SQLDeleteStatement(db)) {
            for (x in OracleDeleteStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleDeleteStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the returning oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleDeleteStatement.getReturning:OracleReturningClause()`.
     * @return OracleReturningClause
     */
    pub fn getReturning(self) -> OracleReturningClause {
        for (s in OracleReturningClause(__all_data__),
            x in OracleDeleteStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReturningOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleDeleteStatement.getHints:List<SQLHint>()`.
     * @return SQLHint
     */
    pub fn getHints(self) -> *SQLHint {
        for (x in SQLHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleDropDbLinkStatement extends OracleStatementImpl {
    
}
impl OracleDropDbLinkStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleDropDbLinkStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleDropDbLinkStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleDropDbLinkStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is public of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleDropDbLinkStatement.isPublic:boolean()`.
     * @return int
     */
    pub fn isPublic(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleDropDbLinkStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPublic()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleDropDbLinkStatement.getName:SQLName()`.
     * @return SQLName
     */
    pub fn getName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleDropDbLinkStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleExceptionStatement extends OracleStatementImpl {
    
}
impl OracleExceptionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleExceptionStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleExceptionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleExceptionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExceptionStatement.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleExceptionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
}
schema OracleExecuteImmediateStatement extends OracleStatementImpl {
    
}
impl OracleExecuteImmediateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleExecuteImmediateStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleExecuteImmediateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleExecuteImmediateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the dynamic sql oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExecuteImmediateStatement.getDynamicSql:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDynamicSql(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleExecuteImmediateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDynamicSqlOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the arguments of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExecuteImmediateStatement.getArguments:List<SQLArgument>()`.
     * @return SQLArgument
     */
    pub fn getArguments(self) -> *SQLArgument {
        for (x in SQLArgument(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the into of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExecuteImmediateStatement.getInto:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getInto(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the return into of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExecuteImmediateStatement.getReturnInto:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getReturnInto(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleExitStatement extends OracleStatementImpl {
    
}
impl OracleExitStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleExitStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleExitStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleExitStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExitStatement.getLabel:String()`.
     * @return string
     */
    pub fn getLabel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleExitStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLabel()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the when oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExitStatement.getWhen:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWhen(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleExitStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWhenOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleExplainStatement extends SQLExplainStatement {
    
}
impl OracleExplainStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleExplainStatement {
        for (tmp in SQLExplainStatement(db)) {
            for (x in OracleExplainStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleExplainStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExplainStatement.getInto:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getInto(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleExplainStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the statement id oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExplainStatement.getStatementId:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getStatementId(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleExplainStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatementIdOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleFileSpecification extends OracleSQLObjectImpl {
    
}
impl OracleFileSpecification {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleFileSpecification {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleFileSpecificationDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleFileSpecification {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the auto extend on oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleFileSpecification.getAutoExtendOn:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getAutoExtendOn(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleFileSpecificationDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getAutoExtendOnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is auto extend off of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleFileSpecification.isAutoExtendOff:boolean()`.
     * @return int
     */
    pub fn isAutoExtendOff(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleFileSpecificationDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAutoExtendOff()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the size oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleFileSpecification.getSize:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSize(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleFileSpecificationDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSizeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the file names of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleFileSpecification.getFileNames:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getFileNames(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleForStatement extends SQLForStatement {
    
}
impl OracleForStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleForStatement {
        for (tmp in SQLForStatement(db)) {
            for (x in OracleForStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleForStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the end label oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleForStatement.getEndLabel:SQLName()`.
     * @return SQLName
     */
    pub fn getEndLabel(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleForStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getEndLabelOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is all of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleForStatement.isAll:boolean()`.
     * @return int
     */
    pub fn isAll(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleForStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAll()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OracleForeignKey extends SQLForeignKeyImpl {
    
}
impl OracleForeignKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleForeignKey {
        for (tmp in SQLForeignKeyImpl(db)) {
            for (x in OracleForeignKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleForeignKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the deferrable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleForeignKey.getDeferrable:Boolean()`.
     * @return int
     */
    pub fn getDeferrable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleForeignKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDeferrable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the exceptions into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleForeignKey.getExceptionsInto:SQLName()`.
     * @return SQLName
     */
    pub fn getExceptionsInto(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleForeignKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExceptionsIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initially of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleForeignKey.getInitially:Initially()`.
     * @return string
     */
    pub fn getInitially(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleForeignKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInitially()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleForeignKey.getUsing:OracleUsingIndexClause()`.
     * @return OracleUsingIndexClause
     */
    pub fn getUsing(self) -> OracleUsingIndexClause {
        for (s in OracleUsingIndexClause(__all_data__),
            x in OracleForeignKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleGotoStatement extends OracleStatementImpl {
    
}
impl OracleGotoStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleGotoStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleGotoStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleGotoStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleGotoStatement.getLabel:SQLName()`.
     * @return SQLName
     */
    pub fn getLabel(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleGotoStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLabelOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleInsertStatement extends SQLInsertStatement {
    
}
impl OracleInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleInsertStatement {
        for (tmp in SQLInsertStatement(db)) {
            for (x in OracleInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the error logging oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleInsertStatement.getErrorLogging:SQLErrorLoggingClause()`.
     * @return SQLErrorLoggingClause
     */
    pub fn getErrorLogging(self) -> SQLErrorLoggingClause {
        for (s in SQLErrorLoggingClause(__all_data__),
            x in OracleInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getErrorLoggingOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the returning oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleInsertStatement.getReturning:OracleReturningClause()`.
     * @return OracleReturningClause
     */
    pub fn getReturning(self) -> OracleReturningClause {
        for (s in OracleReturningClause(__all_data__),
            x in OracleInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReturningOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the head hints direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleInsertStatement.getHeadHintsDirect:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHeadHintsDirect(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleInsertStatement.getHints:List<SQLHint>()`.
     * @return SQLHint
     */
    pub fn getHints(self) -> *SQLHint {
        for (x in SQLHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleLabelStatement extends OracleStatementImpl {
    
}
impl OracleLabelStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleLabelStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleLabelStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleLabelStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the label oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleLabelStatement.getLabel:SQLName()`.
     * @return SQLName
     */
    pub fn getLabel(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleLabelStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getLabelOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleLockTableStatement extends OracleStatementImpl {
    
}
impl OracleLockTableStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleLockTableStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleLockTableStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleLockTableStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is no wait of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleLockTableStatement.isNoWait:boolean()`.
     * @return int
     */
    pub fn isNoWait(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleLockTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsNoWait()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the lock mode of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleLockTableStatement.getLockMode:LockMode()`.
     * @return string
     */
    pub fn getLockMode(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleLockTableStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLockMode()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleLockTableStatement.getPartition:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getPartition(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleLockTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the table oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleLockTableStatement.getTable:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getTable(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in OracleLockTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTableOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the wait oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleLockTableStatement.getWait:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getWait(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleLockTableStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getWaitOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleMultiInsertStatement extends OracleStatementImpl {
    
}
impl OracleMultiInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleMultiInsertStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleMultiInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleMultiInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the entries of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleMultiInsertStatement.getEntries:List<Entry>()`.
     * @return string
     */
    pub fn getEntries(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleMultiInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEntries()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleMultiInsertStatement.getOption:Option()`.
     * @return string
     */
    pub fn getOption(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleMultiInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the sub query oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleMultiInsertStatement.getSubQuery:SQLSelect()`.
     * @return SQLSelect
     */
    pub fn getSubQuery(self) -> SQLSelect {
        for (s in SQLSelect(__all_data__),
            x in OracleMultiInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSubQueryOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleMultiInsertStatement.getHints:List<SQLHint>()`.
     * @return SQLHint
     */
    pub fn getHints(self) -> *SQLHint {
        for (x in SQLHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OraclePipeRowStatement extends OracleStatementImpl {
    
}
impl OraclePipeRowStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OraclePipeRowStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OraclePipeRowStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OraclePipeRowStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OraclePipeRowStatement.getParameters:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getParameters(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OraclePrimaryKey extends SQLPrimaryKeyImpl {
    
}
impl OraclePrimaryKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OraclePrimaryKey {
        for (tmp in SQLPrimaryKeyImpl(db)) {
            for (x in OraclePrimaryKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OraclePrimaryKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the deferrable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OraclePrimaryKey.getDeferrable:Boolean()`.
     * @return int
     */
    pub fn getDeferrable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OraclePrimaryKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDeferrable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OraclePrimaryKey.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OraclePrimaryKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the exceptions into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OraclePrimaryKey.getExceptionsInto:SQLName()`.
     * @return SQLName
     */
    pub fn getExceptionsInto(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OraclePrimaryKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExceptionsIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initially of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OraclePrimaryKey.getInitially:Initially()`.
     * @return string
     */
    pub fn getInitially(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OraclePrimaryKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInitially()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OraclePrimaryKey.getUsing:OracleUsingIndexClause()`.
     * @return OracleUsingIndexClause
     */
    pub fn getUsing(self) -> OracleUsingIndexClause {
        for (s in OracleUsingIndexClause(__all_data__),
            x in OraclePrimaryKeyDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleRaiseStatement extends OracleStatementImpl {
    
}
impl OracleRaiseStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleRaiseStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleRaiseStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleRaiseStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the exception oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleRaiseStatement.getException:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getException(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleRaiseStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExceptionOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleRunStatement extends SQLStatementImpl {
    
}
impl OracleRunStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleRunStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OracleRunStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleRunStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleRunStatement.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleRunStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleSelectJoin extends SQLJoinTableSource {
    
}
impl OracleSelectJoin {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSelectJoin {
        for (tmp in SQLJoinTableSource(db)) {
            for (x in OracleSelectJoinDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSelectJoin {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pivot oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectJoin.getPivot:OracleSelectPivotBase()`.
     * @return OracleSelectPivotBase
     */
    pub fn getPivot(self) -> OracleSelectPivotBase {
        for (s in OracleSelectPivotBase(__all_data__),
            x in OracleSelectJoinDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPivotOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleSelectPivot extends OracleSelectPivotBase {
    
}
impl OracleSelectPivot {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSelectPivot {
        for (tmp in OracleSelectPivotBase(db)) {
            for (x in OracleSelectPivotDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSelectPivot {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is xml of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectPivot.isXml:boolean()`.
     * @return int
     */
    pub fn isXml(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSelectPivotDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsXml()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectPivot.getItems:List<Item>()`.
     * @return string
     */
    pub fn getItems(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleSelectPivotDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getItems()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pivot in of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectPivot.getPivotIn:List<Item>()`.
     * @return string
     */
    pub fn getPivotIn(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleSelectPivotDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPivotIn()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pivot for of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectPivot.getPivotFor:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getPivotFor(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleSelectQueryBlock extends SQLSelectQueryBlock {
    
}
impl OracleSelectQueryBlock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSelectQueryBlock {
        for (tmp in SQLSelectQueryBlock(db)) {
            for (x in OracleSelectQueryBlockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSelectQueryBlock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is skip locked of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectQueryBlock.isSkipLocked:boolean()`.
     * @return int
     */
    pub fn isSkipLocked(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsSkipLocked()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the model clause oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectQueryBlock.getModelClause:ModelClause()`.
     * @return ModelClause
     */
    pub fn getModelClause(self) -> ModelClause {
        for (s in ModelClause(__all_data__),
            x in OracleSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getModelClauseOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleSelectSubqueryTableSource extends SQLSubqueryTableSource {
    
}
impl OracleSelectSubqueryTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSelectSubqueryTableSource {
        for (tmp in SQLSubqueryTableSource(db)) {
            for (x in OracleSelectSubqueryTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSelectSubqueryTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pivot oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectSubqueryTableSource.getPivot:OracleSelectPivotBase()`.
     * @return OracleSelectPivotBase
     */
    pub fn getPivot(self) -> OracleSelectPivotBase {
        for (s in OracleSelectPivotBase(__all_data__),
            x in OracleSelectSubqueryTableSourceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPivotOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleSelectTableReference extends SQLExprTableSource {
    
}
impl OracleSelectTableReference {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSelectTableReference {
        for (tmp in SQLExprTableSource(db)) {
            for (x in OracleSelectTableReferenceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSelectTableReference {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectTableReference.isOnly:boolean()`.
     * @return int
     */
    pub fn isOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSelectTableReferenceDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the partition oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectTableReference.getPartition:PartitionExtensionClause()`.
     * @return PartitionExtensionClause
     */
    pub fn getPartition(self) -> PartitionExtensionClause {
        for (s in PartitionExtensionClause(__all_data__),
            x in OracleSelectTableReferenceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPartitionOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the pivot oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectTableReference.getPivot:OracleSelectPivotBase()`.
     * @return OracleSelectPivotBase
     */
    pub fn getPivot(self) -> OracleSelectPivotBase {
        for (s in OracleSelectPivotBase(__all_data__),
            x in OracleSelectTableReferenceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getPivotOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the sample clause oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectTableReference.getSampleClause:SampleClause()`.
     * @return SampleClause
     */
    pub fn getSampleClause(self) -> SampleClause {
        for (s in SampleClause(__all_data__),
            x in OracleSelectTableReferenceDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSampleClauseOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleSelectUnPivot extends OracleSelectPivotBase {
    
}
impl OracleSelectUnPivot {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSelectUnPivot {
        for (tmp in OracleSelectPivotBase(db)) {
            for (x in OracleSelectUnPivotDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSelectUnPivot {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the nulls include type of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectUnPivot.getNullsIncludeType:NullsIncludeType()`.
     * @return string
     */
    pub fn getNullsIncludeType(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleSelectUnPivotDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getNullsIncludeType()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the pivot in of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectUnPivot.getPivotIn:List<Item>()`.
     * @return string
     */
    pub fn getPivotIn(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleSelectUnPivotDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getPivotIn()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSelectUnPivot.getItems:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getItems(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleSetTransactionStatement extends OracleStatementImpl {
    
}
impl OracleSetTransactionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSetTransactionStatement {
        for (tmp in OracleStatementImpl(db)) {
            for (x in OracleSetTransactionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSetTransactionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is read only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSetTransactionStatement.isReadOnly:boolean()`.
     * @return int
     */
    pub fn isReadOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSetTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReadOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is write of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSetTransactionStatement.isWrite:boolean()`.
     * @return int
     */
    pub fn isWrite(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSetTransactionStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWrite()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSetTransactionStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OracleSetTransactionStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleSupplementalIdKey extends OracleSQLObjectImpl {
    
}
impl OracleSupplementalIdKey {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSupplementalIdKey {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleSupplementalIdKeyDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSupplementalIdKey {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is all of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSupplementalIdKey.isAll:boolean()`.
     * @return int
     */
    pub fn isAll(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSupplementalIdKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAll()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is foreign key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSupplementalIdKey.isForeignKey:boolean()`.
     * @return int
     */
    pub fn isForeignKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSupplementalIdKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsForeignKey()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is primary key of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSupplementalIdKey.isPrimaryKey:boolean()`.
     * @return int
     */
    pub fn isPrimaryKey(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSupplementalIdKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPrimaryKey()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is unique of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSupplementalIdKey.isUnique:boolean()`.
     * @return int
     */
    pub fn isUnique(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSupplementalIdKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUnique()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is unique index of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSupplementalIdKey.isUniqueIndex:boolean()`.
     * @return int
     */
    pub fn isUniqueIndex(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSupplementalIdKeyDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsUniqueIndex()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OracleSupplementalLogGrp extends OracleSQLObjectImpl {
    
}
impl OracleSupplementalLogGrp {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleSupplementalLogGrp {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleSupplementalLogGrpDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleSupplementalLogGrp {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the group oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSupplementalLogGrp.getGroup:SQLName()`.
     * @return SQLName
     */
    pub fn getGroup(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleSupplementalLogGrpDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getGroupOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is always of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSupplementalLogGrp.isAlways:boolean()`.
     * @return int
     */
    pub fn isAlways(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleSupplementalLogGrpDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAlways()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleSupplementalLogGrp.getColumns:List<SQLName>()`.
     * @return SQLName
     */
    pub fn getColumns(self) -> *SQLName {
        for (x in SQLName(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleUnique extends SQLUnique {
    
}
impl OracleUnique {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleUnique {
        for (tmp in SQLUnique(db)) {
            for (x in OracleUniqueDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleUnique {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the deferrable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUnique.getDeferrable:Boolean()`.
     * @return int
     */
    pub fn getDeferrable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleUniqueDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDeferrable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the exceptions into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUnique.getExceptionsInto:SQLName()`.
     * @return SQLName
     */
    pub fn getExceptionsInto(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleUniqueDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExceptionsIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the initially of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUnique.getInitially:Initially()`.
     * @return string
     */
    pub fn getInitially(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleUniqueDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getInitially()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the using oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUnique.getUsing:OracleUsingIndexClause()`.
     * @return OracleUsingIndexClause
     */
    pub fn getUsing(self) -> OracleUsingIndexClause {
        for (s in OracleUsingIndexClause(__all_data__),
            x in OracleUniqueDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUsingOid()) {
                    return s
                }
            }
        }
    }
}
schema OracleUpdateStatement extends SQLUpdateStatement {
    
}
impl OracleUpdateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleUpdateStatement {
        for (tmp in SQLUpdateStatement(db)) {
            for (x in OracleUpdateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleUpdateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUpdateStatement.getAlias:String()`.
     * @return string
     */
    pub fn getAlias(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hints size of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUpdateStatement.getHintsSize:int()`.
     * @return int
     */
    pub fn getHintsSize(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getHintsSize()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUpdateStatement.isOnly:boolean()`.
     * @return int
     */
    pub fn isOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnly()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the hints of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUpdateStatement.getHints:List<SQLHint>()`.
     * @return SQLHint
     */
    pub fn getHints(self) -> *SQLHint {
        for (x in SQLHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the returning into of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUpdateStatement.getReturningInto:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getReturningInto(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleUsingIndexClause extends OracleSegmentAttributesImpl {
    
}
impl OracleUsingIndexClause {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleUsingIndexClause {
        for (tmp in OracleSegmentAttributesImpl(db)) {
            for (x in OracleUsingIndexClauseDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleUsingIndexClause {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the enable of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUsingIndexClause.getEnable:Boolean()`.
     * @return int
     */
    pub fn getEnable(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleUsingIndexClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getEnable()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the index of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUsingIndexClause.getIndex:SQLObject()`.
     * @return string
     */
    pub fn getIndex(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleUsingIndexClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIndex()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is compute statistics of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUsingIndexClause.isComputeStatistics:boolean()`.
     * @return int
     */
    pub fn isComputeStatistics(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleUsingIndexClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsComputeStatistics()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is reverse of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUsingIndexClause.isReverse:boolean()`.
     * @return int
     */
    pub fn isReverse(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleUsingIndexClauseDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReverse()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the local partition index of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleUsingIndexClause.getLocalPartitionIndex:List<SQLPartition>()`.
     * @return SQLPartition
     */
    pub fn getLocalPartitionIndex(self) -> *SQLPartition {
        for (x in SQLPartition(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OracleXmlColumnProperties extends OracleSQLObjectImpl {
    
}
impl OracleXmlColumnProperties {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OracleXmlColumnProperties {
        for (tmp in OracleSQLObjectImpl(db)) {
            for (x in OracleXmlColumnPropertiesDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OracleXmlColumnProperties {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the allow any schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleXmlColumnProperties.getAllowAnySchema:Boolean()`.
     * @return int
     */
    pub fn getAllowAnySchema(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleXmlColumnPropertiesDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAllowAnySchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the allow non schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleXmlColumnProperties.getAllowNonSchema:Boolean()`.
     * @return int
     */
    pub fn getAllowNonSchema(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OracleXmlColumnPropertiesDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAllowNonSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleXmlColumnProperties.getColumn:SQLName()`.
     * @return SQLName
     */
    pub fn getColumn(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OracleXmlColumnPropertiesDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the storage of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleXmlColumnProperties.getStorage:OracleXMLTypeStorage()`.
     * @return string
     */
    pub fn getStorage(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OracleXmlColumnPropertiesDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getStorage()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OscarTop extends OscarObjectImpl {
    
}
impl OscarTop {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarTop {
        for (tmp in OscarObjectImpl(db)) {
            for (x in OscarTopDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarTop {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.OscarTop.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OscarTopDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is percent of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.OscarTop.isPercent:boolean()`.
     * @return int
     */
    pub fn isPercent(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarTopDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPercent()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with ties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.OscarTop.isWithTies:boolean()`.
     * @return int
     */
    pub fn isWithTies(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarTopDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithTies()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OscarAlterSchemaStatement extends SQLStatementImpl {
    
}
impl OscarAlterSchemaStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarAlterSchemaStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OscarAlterSchemaStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarAlterSchemaStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the new name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarAlterSchemaStatement.getNewName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getNewName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in OscarAlterSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNewNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the new owner oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarAlterSchemaStatement.getNewOwner:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getNewOwner(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in OscarAlterSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNewOwnerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarAlterSchemaStatement.getSchemaName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getSchemaName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in OscarAlterSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OscarConnectToStatement extends SQLStatementImpl {
    
}
impl OscarConnectToStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarConnectToStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OscarConnectToStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarConnectToStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the target oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarConnectToStatement.getTarget:SQLName()`.
     * @return SQLName
     */
    pub fn getTarget(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OscarConnectToStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTargetOid()) {
                    return s
                }
            }
        }
    }
}
schema OscarCreateSchemaStatement extends SQLStatementImpl {
    
}
impl OscarCreateSchemaStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarCreateSchemaStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OscarCreateSchemaStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarCreateSchemaStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is authorization of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarCreateSchemaStatement.isAuthorization:boolean()`.
     * @return int
     */
    pub fn isAuthorization(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarCreateSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAuthorization()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarCreateSchemaStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarCreateSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the schema name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarCreateSchemaStatement.getSchemaName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getSchemaName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in OscarCreateSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarCreateSchemaStatement.getUserName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getUserName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in OscarCreateSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OscarDeleteStatement extends SQLDeleteStatement {
    
}
impl OscarDeleteStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarDeleteStatement {
        for (tmp in SQLDeleteStatement(db)) {
            for (x in OscarDeleteStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarDeleteStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarDeleteStatement.getAlias:String()`.
     * @return string
     */
    pub fn getAlias(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OscarDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is returning of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarDeleteStatement.isReturning:boolean()`.
     * @return int
     */
    pub fn isReturning(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReturning()) {
                        return s
                    }
                }
            }
        }
    }
}
schema OscarDropSchemaStatement extends SQLStatementImpl {
    
}
impl OscarDropSchemaStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarDropSchemaStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OscarDropSchemaStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarDropSchemaStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarDropSchemaStatement.isCascade:boolean()`.
     * @return int
     */
    pub fn isCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarDropSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarDropSchemaStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarDropSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarDropSchemaStatement.isRestrict:boolean()`.
     * @return int
     */
    pub fn isRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarDropSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestrict()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the schema name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarDropSchemaStatement.getSchemaName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getSchemaName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in OscarDropSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaNameOid()) {
                    return s
                }
            }
        }
    }
}
schema OscarFunctionTableSource extends SQLExprTableSource {
    
}
impl OscarFunctionTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarFunctionTableSource {
        for (tmp in SQLExprTableSource(db)) {
            for (x in OscarFunctionTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarFunctionTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarFunctionTableSource.getParameters:List<SQLParameter>()`.
     * @return SQLParameter
     */
    pub fn getParameters(self) -> *SQLParameter {
        for (x in SQLParameter(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OscarInsertStatement extends SQLInsertStatement {
    
}
impl OscarInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarInsertStatement {
        for (tmp in SQLInsertStatement(db)) {
            for (x in OscarInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is default values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.isDefaultValues:boolean()`.
     * @return int
     */
    pub fn isDefaultValues(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDefaultValues()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on conflict do nothing of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.isOnConflictDoNothing:boolean()`.
     * @return int
     */
    pub fn isOnConflictDoNothing(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnConflictDoNothing()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on conflict constraint oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getOnConflictConstraint:SQLName()`.
     * @return SQLName
     */
    pub fn getOnConflictConstraint(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in OscarInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnConflictConstraintOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on conflict update where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getOnConflictUpdateWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOnConflictUpdateWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OscarInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnConflictUpdateWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on conflict where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getOnConflictWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOnConflictWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OscarInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnConflictWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the returning oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getReturning:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getReturning(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OscarInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReturningOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getValues:ValuesClause()`.
     * @return string
     */
    pub fn getValues(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OscarInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValues()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the values list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getValuesList:List<ValuesClause>()`.
     * @return string
     */
    pub fn getValuesList(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in OscarInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValuesList()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the head hints direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getHeadHintsDirect:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHeadHintsDirect(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the on conflict target of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getOnConflictTarget:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getOnConflictTarget(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the on conflict update set items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarInsertStatement.getOnConflictUpdateSetItems:List<SQLUpdateSetItem>()`.
     * @return SQLUpdateSetItem
     */
    pub fn getOnConflictUpdateSetItems(self) -> *SQLUpdateSetItem {
        for (x in SQLUpdateSetItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OscarSelectQueryBlock extends SQLSelectQueryBlock {
    
}
impl OscarSelectQueryBlock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarSelectQueryBlock {
        for (tmp in SQLSelectQueryBlock(db)) {
            for (x in OscarSelectQueryBlockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarSelectQueryBlock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the fetch of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarSelectQueryBlock.getFetch:FetchClause()`.
     * @return string
     */
    pub fn getFetch(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OscarSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFetch()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the for clause of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarSelectQueryBlock.getForClause:ForClause()`.
     * @return string
     */
    pub fn getForClause(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OscarSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getForClause()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into option local of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarSelectQueryBlock.getIntoOptionLocal:IntoOptionLocal()`.
     * @return string
     */
    pub fn getIntoOptionLocal(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OscarSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIntoOptionLocal()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into option temp of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarSelectQueryBlock.getIntoOptionTemp:IntoOptionTemp()`.
     * @return string
     */
    pub fn getIntoOptionTemp(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in OscarSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIntoOptionTemp()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the top oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarSelectQueryBlock.getTop:OscarTop()`.
     * @return OscarTop
     */
    pub fn getTop(self) -> OscarTop {
        for (s in OscarTop(__all_data__),
            x in OscarSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTopOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the distinct on of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarSelectQueryBlock.getDistinctOn:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getDistinctOn(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema OscarSelectStatement extends SQLSelectStatement {
    
}
impl OscarSelectStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarSelectStatement {
        for (tmp in SQLSelectStatement(db)) {
            for (x in OscarSelectStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarSelectStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema OscarShowStatement extends SQLStatementImpl {
    
}
impl OscarShowStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarShowStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OscarShowStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarShowStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarShowStatement.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in OscarShowStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema OscarStartTransactionStatement extends SQLStatementImpl {
    
}
impl OscarStartTransactionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarStartTransactionStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in OscarStartTransactionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarStartTransactionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema OscarUpdateStatement extends SQLUpdateStatement {
    
}
impl OscarUpdateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *OscarUpdateStatement {
        for (tmp in SQLUpdateStatement(db)) {
            for (x in OscarUpdateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield OscarUpdateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarUpdateStatement.isOnly:boolean()`.
     * @return int
     */
    pub fn isOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in OscarUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnly()) {
                        return s
                    }
                }
            }
        }
    }
}
schema PGBoxExpr extends PGExprImpl {
    
}
impl PGBoxExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGBoxExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgBoxExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGBoxExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGBoxExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgBoxExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema PGCidrExpr extends PGExprImpl {
    
}
impl PGCidrExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGCidrExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgCidrExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGCidrExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGCidrExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgCidrExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema PGCircleExpr extends PGExprImpl {
    
}
impl PGCircleExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGCircleExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgCircleExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGCircleExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGCircleExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgCircleExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema PGExtractExpr extends PGExprImpl {
    
}
impl PGExtractExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGExtractExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgExtractExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGExtractExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the field of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGExtractExpr.getField:PGDateField()`.
     * @return string
     */
    pub fn getField(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in PgExtractExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getField()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the source oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGExtractExpr.getSource:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getSource(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgExtractExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSourceOid()) {
                    return s
                }
            }
        }
    }
}
schema PGInetExpr extends PGExprImpl {
    
}
impl PGInetExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGInetExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgInetExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGInetExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGInetExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgInetExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema PGLineSegmentsExpr extends PGExprImpl {
    
}
impl PGLineSegmentsExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGLineSegmentsExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgLineSegmentsExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGLineSegmentsExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGLineSegmentsExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgLineSegmentsExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema PGMacAddrExpr extends PGExprImpl {
    
}
impl PGMacAddrExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGMacAddrExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgMacAddrExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGMacAddrExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGMacAddrExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgMacAddrExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema PGPointExpr extends PGExprImpl {
    
}
impl PGPointExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGPointExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgPointExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGPointExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGPointExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgPointExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema PGPolygonExpr extends PGExprImpl {
    
}
impl PGPolygonExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGPolygonExpr {
        for (tmp in PGExprImpl(db)) {
            for (x in PgPolygonExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGPolygonExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the value oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.expr.PGPolygonExpr.getValue:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getValue(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgPolygonExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getValueOid()) {
                    return s
                }
            }
        }
    }
}
schema PGTypeCastExpr extends SQLCastExpr {
    
}
impl PGTypeCastExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGTypeCastExpr {
        for (tmp in SQLCastExpr(db)) {
            for (x in PgTypeCastExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGTypeCastExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema PGAlterSchemaStatement extends SQLStatementImpl {
    
}
impl PGAlterSchemaStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGAlterSchemaStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in PgAlterSchemaStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGAlterSchemaStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the new name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGAlterSchemaStatement.getNewName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getNewName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in PgAlterSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNewNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the new owner oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGAlterSchemaStatement.getNewOwner:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getNewOwner(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in PgAlterSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNewOwnerOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGAlterSchemaStatement.getSchemaName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getSchemaName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in PgAlterSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaNameOid()) {
                    return s
                }
            }
        }
    }
}
schema PGConnectToStatement extends SQLStatementImpl {
    
}
impl PGConnectToStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGConnectToStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in PgConnectToStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGConnectToStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the target oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGConnectToStatement.getTarget:SQLName()`.
     * @return SQLName
     */
    pub fn getTarget(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in PgConnectToStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTargetOid()) {
                    return s
                }
            }
        }
    }
}
schema PGCreateSchemaStatement extends SQLStatementImpl {
    
}
impl PGCreateSchemaStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGCreateSchemaStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in PgCreateSchemaStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGCreateSchemaStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is authorization of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGCreateSchemaStatement.isAuthorization:boolean()`.
     * @return int
     */
    pub fn isAuthorization(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgCreateSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsAuthorization()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if not exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGCreateSchemaStatement.isIfNotExists:boolean()`.
     * @return int
     */
    pub fn isIfNotExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgCreateSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfNotExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the schema name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGCreateSchemaStatement.getSchemaName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getSchemaName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in PgCreateSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the user name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGCreateSchemaStatement.getUserName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getUserName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in PgCreateSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getUserNameOid()) {
                    return s
                }
            }
        }
    }
}
schema PGDeleteStatement extends SQLDeleteStatement {
    
}
impl PGDeleteStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGDeleteStatement {
        for (tmp in SQLDeleteStatement(db)) {
            for (x in PgDeleteStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGDeleteStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the alias of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGDeleteStatement.getAlias:String()`.
     * @return string
     */
    pub fn getAlias(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in PgDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getAlias()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is returning of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGDeleteStatement.isReturning:boolean()`.
     * @return int
     */
    pub fn isReturning(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgDeleteStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsReturning()) {
                        return s
                    }
                }
            }
        }
    }
}
schema PGDropSchemaStatement extends SQLStatementImpl {
    
}
impl PGDropSchemaStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGDropSchemaStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in PgDropSchemaStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGDropSchemaStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is cascade of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGDropSchemaStatement.isCascade:boolean()`.
     * @return int
     */
    pub fn isCascade(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgDropSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsCascade()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is if exists of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGDropSchemaStatement.isIfExists:boolean()`.
     * @return int
     */
    pub fn isIfExists(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgDropSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsIfExists()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is restrict of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGDropSchemaStatement.isRestrict:boolean()`.
     * @return int
     */
    pub fn isRestrict(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgDropSchemaStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsRestrict()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the schema name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGDropSchemaStatement.getSchemaName:SQLIdentifierExpr()`.
     * @return SQLIdentifierExpr
     */
    pub fn getSchemaName(self) -> SQLIdentifierExpr {
        for (s in SQLIdentifierExpr(__all_data__),
            x in PgDropSchemaStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getSchemaNameOid()) {
                    return s
                }
            }
        }
    }
}
schema PGFunctionTableSource extends SQLExprTableSource {
    
}
impl PGFunctionTableSource {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGFunctionTableSource {
        for (tmp in SQLExprTableSource(db)) {
            for (x in PgFunctionTableSourceDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGFunctionTableSource {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGFunctionTableSource.getParameters:List<SQLParameter>()`.
     * @return SQLParameter
     */
    pub fn getParameters(self) -> *SQLParameter {
        for (x in SQLParameter(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema PGInsertStatement extends SQLInsertStatement {
    
}
impl PGInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGInsertStatement {
        for (tmp in SQLInsertStatement(db)) {
            for (x in PgInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is default values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.isDefaultValues:boolean()`.
     * @return int
     */
    pub fn isDefaultValues(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDefaultValues()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is on conflict do nothing of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.isOnConflictDoNothing:boolean()`.
     * @return int
     */
    pub fn isOnConflictDoNothing(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnConflictDoNothing()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the on conflict constraint oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getOnConflictConstraint:SQLName()`.
     * @return SQLName
     */
    pub fn getOnConflictConstraint(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in PgInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnConflictConstraintOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on conflict update where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getOnConflictUpdateWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOnConflictUpdateWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnConflictUpdateWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the on conflict where oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getOnConflictWhere:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getOnConflictWhere(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOnConflictWhereOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the returning oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getReturning:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getReturning(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReturningOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getValues:ValuesClause()`.
     * @return string
     */
    pub fn getValues(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in PgInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValues()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the values list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getValuesList:List<ValuesClause>()`.
     * @return string
     */
    pub fn getValuesList(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in PgInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getValuesList()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the head hints direct of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getHeadHintsDirect:List<SQLCommentHint>()`.
     * @return SQLCommentHint
     */
    pub fn getHeadHintsDirect(self) -> *SQLCommentHint {
        for (x in SQLCommentHint(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the on conflict target of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getOnConflictTarget:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getOnConflictTarget(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the on conflict update set items of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGInsertStatement.getOnConflictUpdateSetItems:List<SQLUpdateSetItem>()`.
     * @return SQLUpdateSetItem
     */
    pub fn getOnConflictUpdateSetItems(self) -> *SQLUpdateSetItem {
        for (x in SQLUpdateSetItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema PGSelectQueryBlock extends SQLSelectQueryBlock {
    
}
impl PGSelectQueryBlock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGSelectQueryBlock {
        for (tmp in SQLSelectQueryBlock(db)) {
            for (x in PgSelectQueryBlockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGSelectQueryBlock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the fetch of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGSelectQueryBlock.getFetch:FetchClause()`.
     * @return string
     */
    pub fn getFetch(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in PgSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getFetch()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the for clause of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGSelectQueryBlock.getForClause:ForClause()`.
     * @return string
     */
    pub fn getForClause(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in PgSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getForClause()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into option of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGSelectQueryBlock.getIntoOption:IntoOption()`.
     * @return string
     */
    pub fn getIntoOption(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in PgSelectQueryBlockDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIntoOption()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the distinct on of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGSelectQueryBlock.getDistinctOn:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getDistinctOn(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema PGSelectStatement extends SQLSelectStatement {
    
}
impl PGSelectStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGSelectStatement {
        for (tmp in SQLSelectStatement(db)) {
            for (x in PgSelectStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGSelectStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema PGShowStatement extends SQLStatementImpl {
    
}
impl PGShowStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGShowStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in PgShowStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGShowStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGShowStatement.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in PgShowStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
}
schema PGStartTransactionStatement extends SQLStatementImpl {
    
}
impl PGStartTransactionStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGStartTransactionStatement {
        for (tmp in SQLStatementImpl(db)) {
            for (x in PgStartTransactionStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGStartTransactionStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
}
schema PGUpdateStatement extends SQLUpdateStatement {
    
}
impl PGUpdateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *PGUpdateStatement {
        for (tmp in SQLUpdateStatement(db)) {
            for (x in PgUpdateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield PGUpdateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is only of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGUpdateStatement.isOnly:boolean()`.
     * @return int
     */
    pub fn isOnly(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in PgUpdateStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsOnly()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLServerOutput extends SQLServerObjectImpl {
    
}
impl SQLServerOutput {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerOutput {
        for (tmp in SQLServerObjectImpl(db)) {
            for (x in SqlServerOutputDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerOutput {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the into oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerOutput.getInto:SQLExprTableSource()`.
     * @return SQLExprTableSource
     */
    pub fn getInto(self) -> SQLExprTableSource {
        for (s in SQLExprTableSource(__all_data__),
            x in SqlServerOutputDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getIntoOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the columns of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerOutput.getColumns:List<SQLExpr>()`.
     * @return SQLExpr
     */
    pub fn getColumns(self) -> *SQLExpr {
        for (x in SQLExpr(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
    /**
     * @brief gets the select list of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerOutput.getSelectList:List<SQLSelectItem>()`.
     * @return SQLSelectItem
     */
    pub fn getSelectList(self) -> *SQLSelectItem {
        for (x in SQLSelectItem(__all_data__)) {
            if (self.key_eq(x.getParent())) {
                yield x
            }
        }
    }
}
schema SQLServerSelectQueryBlock extends SQLSelectQueryBlock {
    
}
impl SQLServerSelectQueryBlock {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerSelectQueryBlock {
        for (tmp in SQLSelectQueryBlock(db)) {
            for (x in SqlServerSelectQueryBlockDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerSelectQueryBlock {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the top oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerSelectQueryBlock.getTop:SQLServerTop()`.
     * @return SQLServerTop
     */
    pub fn getTop(self) -> SQLServerTop {
        for (s in SQLServerTop(__all_data__),
            x in SqlServerSelectQueryBlockDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTopOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLServerTop extends SQLServerObjectImpl {
    
}
impl SQLServerTop {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerTop {
        for (tmp in SQLServerObjectImpl(db)) {
            for (x in SqlServerTopDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerTop {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the expr oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerTop.getExpr:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getExpr(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlServerTopDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getExprOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the is percent of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerTop.isPercent:boolean()`.
     * @return int
     */
    pub fn isPercent(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlServerTopDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsPercent()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is with ties of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerTop.isWithTies:boolean()`.
     * @return int
     */
    pub fn isWithTies(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlServerTopDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWithTies()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLServerObjectReferenceExpr extends SQLServerObjectImpl {
    
}
impl SQLServerObjectReferenceExpr {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerObjectReferenceExpr {
        for (tmp in SQLServerObjectImpl(db)) {
            for (x in SqlServerObjectReferenceExprDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerObjectReferenceExpr {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the database of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.expr.SQLServerObjectReferenceExpr.getDatabase:String()`.
     * @return string
     */
    pub fn getDatabase(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlServerObjectReferenceExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getDatabase()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the resolved column oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.expr.SQLServerObjectReferenceExpr.getResolvedColumn:SQLColumnDefinition()`.
     * @return SQLColumnDefinition
     */
    pub fn getResolvedColumn(self) -> SQLColumnDefinition {
        for (s in SQLColumnDefinition(__all_data__),
            x in SqlServerObjectReferenceExprDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getResolvedColumnOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the schema of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.expr.SQLServerObjectReferenceExpr.getSchema:String()`.
     * @return string
     */
    pub fn getSchema(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlServerObjectReferenceExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSchema()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the server of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.expr.SQLServerObjectReferenceExpr.getServer:String()`.
     * @return string
     */
    pub fn getServer(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlServerObjectReferenceExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getServer()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the simple name of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.expr.SQLServerObjectReferenceExpr.getSimpleName:String()`.
     * @return string
     */
    pub fn getSimpleName(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlServerObjectReferenceExprDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getSimpleName()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLServerExecStatement extends SQLServerStatementImpl {
    
}
impl SQLServerExecStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerExecStatement {
        for (tmp in SQLServerStatementImpl(db)) {
            for (x in SqlServerExecStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerExecStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the module name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerExecStatement.getModuleName:SQLName()`.
     * @return SQLName
     */
    pub fn getModuleName(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlServerExecStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getModuleNameOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the parameters of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerExecStatement.getParameters:List<SQLServerParameter>()`.
     * @return string
     */
    pub fn getParameters(self) -> *string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlServerExecStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getParameters()) {
                        yield s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the return status oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerExecStatement.getReturnStatus:SQLName()`.
     * @return SQLName
     */
    pub fn getReturnStatus(self) -> SQLName {
        for (s in SQLName(__all_data__),
            x in SqlServerExecStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getReturnStatusOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLServerInsertStatement extends SQLInsertStatement {
    
}
impl SQLServerInsertStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerInsertStatement {
        for (tmp in SQLInsertStatement(db)) {
            for (x in SqlServerInsertStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerInsertStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is default values of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerInsertStatement.isDefaultValues:boolean()`.
     * @return int
     */
    pub fn isDefaultValues(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlServerInsertStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsDefaultValues()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the output oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerInsertStatement.getOutput:SQLServerOutput()`.
     * @return SQLServerOutput
     */
    pub fn getOutput(self) -> SQLServerOutput {
        for (s in SQLServerOutput(__all_data__),
            x in SqlServerInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOutputOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the top oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerInsertStatement.getTop:SQLServerTop()`.
     * @return SQLServerTop
     */
    pub fn getTop(self) -> SQLServerTop {
        for (s in SQLServerTop(__all_data__),
            x in SqlServerInsertStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTopOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLServerRollbackStatement extends SQLRollbackStatement {
    
}
impl SQLServerRollbackStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerRollbackStatement {
        for (tmp in SQLRollbackStatement(db)) {
            for (x in SqlServerRollbackStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerRollbackStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the is work of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerRollbackStatement.isWork:boolean()`.
     * @return int
     */
    pub fn isWork(self) -> int {
        for (s in int::__undetermined_all__()) {
            for (x in SqlServerRollbackStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getIsWork()) {
                        return s
                    }
                }
            }
        }
    }
    /**
     * @brief gets the name oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerRollbackStatement.getName:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getName(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlServerRollbackStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getNameOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLServerSetTransactionIsolationLevelStatement extends SQLServerStatementImpl {
    
}
impl SQLServerSetTransactionIsolationLevelStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerSetTransactionIsolationLevelStatement {
        for (tmp in SQLServerStatementImpl(db)) {
            for (x in SqlServerSetTransactionIsolationLevelStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerSetTransactionIsolationLevelStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the level of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerSetTransactionIsolationLevelStatement.getLevel:String()`.
     * @return string
     */
    pub fn getLevel(self) -> string {
        for (s in string::__undetermined_all__()) {
            for (x in SqlServerSetTransactionIsolationLevelStatementDO(__all_data__)) {
                if (self.key_eq(x)) {
                    if (s = x.getLevel()) {
                        return s
                    }
                }
            }
        }
    }
}
schema SQLServerUpdateStatement extends SQLUpdateStatement {
    
}
impl SQLServerUpdateStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerUpdateStatement {
        for (tmp in SQLUpdateStatement(db)) {
            for (x in SqlServerUpdateStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerUpdateStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the output oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerUpdateStatement.getOutput:SQLServerOutput()`.
     * @return SQLServerOutput
     */
    pub fn getOutput(self) -> SQLServerOutput {
        for (s in SQLServerOutput(__all_data__),
            x in SqlServerUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getOutputOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the top oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerUpdateStatement.getTop:SQLServerTop()`.
     * @return SQLServerTop
     */
    pub fn getTop(self) -> SQLServerTop {
        for (s in SQLServerTop(__all_data__),
            x in SqlServerUpdateStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTopOid()) {
                    return s
                }
            }
        }
    }
}
schema SQLServerWaitForStatement extends SQLServerStatementImpl {
    
}
impl SQLServerWaitForStatement {
    @data_constraint
    @inline
    pub fn __all__(db: SqlDB) -> *SQLServerWaitForStatement {
        for (tmp in SQLServerStatementImpl(db)) {
            for (x in SqlServerWaitForStatementDO(db)) {
                if (tmp.key_eq(x)) {
                    yield SQLServerWaitForStatement {
                        oid_ : tmp.oid_,
                        parent_oid_ : tmp.parent_oid_,
                        location_oid_ : tmp.location_oid_,
                        node_type_ : tmp.node_type_,
                        index_in_parent_ : tmp.index_in_parent_,
                        after_comments_direct_ : tmp.after_comments_direct_,
                        before_comments_direct_ : tmp.before_comments_direct_,
                        db_type_ : tmp.db_type_,
                        printable_text : tmp.printable_text
                    }
                }
            }
        }
    }
    /**
     * @brief gets the delay oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerWaitForStatement.getDelay:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getDelay(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlServerWaitForStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getDelayOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the statement oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerWaitForStatement.getStatement:SQLStatement()`.
     * @return SQLStatement
     */
    pub fn getStatement(self) -> SQLStatement {
        for (s in SQLStatement(__all_data__),
            x in SqlServerWaitForStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getStatementOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the time oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerWaitForStatement.getTime:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTime(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlServerWaitForStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTimeOid()) {
                    return s
                }
            }
        }
    }
    /**
     * @brief gets the timeout oid of the class. It corresponds to this Druid's method: `com.alibaba.druid.sql.dialect.sqlserver.ast.stmt.SQLServerWaitForStatement.getTimeout:SQLExpr()`.
     * @return SQLExpr
     */
    pub fn getTimeout(self) -> SQLExpr {
        for (s in SQLExpr(__all_data__),
            x in SqlServerWaitForStatementDO(__all_data__)) {
            if (self.key_eq(x)) {
                if (s.oid_ = x.getTimeoutOid()) {
                    return s
                }
            }
        }
    }
}
