/*
 * This file is auto-generated by jinja template. Do not modify.
 */
#ifndef COREF_CFAMILY_SRC_EXTRACTOR_STORAGE_HPP
#define COREF_CFAMILY_SRC_EXTRACTOR_STORAGE_HPP

#include "Model/Models.hpp"
#include "ThirdParty/sqlite_orm/sqlite_orm.h"
#include <atomic>
#include <iostream>

namespace coref {

using namespace sqlite_orm;

// clang-format off
inline auto initStorage(const std::string &path) {
    return make_storage(
        path,

        {%- for table in table_list %}
        make_table(
            "{{ table.name | to_snake }}",
            {% for column in table.column_list -%}
            make_column("{{ column.name }}", &coref::{{ table.name | to_camel }}::{{ column.name | to_lower_camel }}
                {%- if column.is_pk -%}
                , primary_key()
                {%- endif -%}
            )
            {%- if not loop.last -%}
            ,
            {% endif %}
            {%- endfor %})
            {%- if not loop.last -%}
            ,
            {%- endif -%}
        {%- endfor %}
    );
}
// clang-format on

class Storage {
  public:
    using StorageType = decltype(initStorage(""));

    static Storage &getInstance() {
        static Storage instance;
        return instance;
    }

    /// initialize ORM
    /// \param sqliteDbPath
    inline void initialize(const std::string &sqliteDbPath = "") {
        if (!sqliteDbPath.empty())
            _sqliteDbPath = sqliteDbPath;

        _storage = std::make_unique<Storage::StorageType>(initStorage(_sqliteDbPath));
        _storage->sync_schema();
        _storage->pragma.synchronous(0); // PRAGMA synchronous = OFF
        _storage->pragma.journal_mode(journal_mode::MEMORY); // PRAGMA journal_mode = MEMORY
        _initialized = true;
    }

    /// Check if all the models are completely mapped
    /// \return
    inline bool isInitialised() const {
        return _initialized.load();
    }

    /// Get Sqlite ORM Object
    /// \return
    std::shared_ptr<StorageType> getStorage() {
        return _storage;
    }

    ~Storage() = default;

    Storage(const Storage &) = delete;

    Storage &operator=(const Storage &) = delete;

  private:
    Storage() = default;

    std::string _sqliteDbPath;
    std::atomic<bool> _initialized{false};
    std::shared_ptr<StorageType> _storage;
};

} // namespace coref

#endif // COREF_CFAMILY_SRC_EXTRACTOR_STORAGE_HPP
